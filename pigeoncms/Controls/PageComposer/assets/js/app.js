/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "../site/pigeon-corporate/controls/Pagecomposer/assets/js/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(1);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _classCallCheck2 = __webpack_require__(2);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _Config = __webpack_require__(3);
	
	var _Config2 = _interopRequireDefault(_Config);
	
	var _Emitter = __webpack_require__(4);
	
	var _Emitter2 = _interopRequireDefault(_Emitter);
	
	var _PageComposer = __webpack_require__(19);
	
	var _PageComposer2 = _interopRequireDefault(_PageComposer);
	
	var _Utils = __webpack_require__(103);
	
	var _Utils2 = _interopRequireDefault(_Utils);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	//require("babel-polyfill");
	
	var App = function () {
	    function App() {
	        (0, _classCallCheck3.default)(this, App);
	    }
	
	    App.prototype.init = function init(opts) {
	        this.pageComposer = new _PageComposer2.default(opts);
	        this.pageComposer.init();
	    };
	
	    App.prototype.getContent = function getContent() {
	        return this.pageComposer.getContent();
	    };
	
	    App.prototype.save = function save() {
	        return this.pageComposer.save();
	    };
	
	    return App;
	}();
	
	window.AQuest = window.AQuest || {};
	window.AQuest.PageComposer = new App();

/***/ },
/* 2 */
/***/ function(module, exports) {

	"use strict";
	
	exports.__esModule = true;
	
	exports.default = function (instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	};

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _classCallCheck2 = __webpack_require__(2);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _Emitter = __webpack_require__(4);
	
	var _Emitter2 = _interopRequireDefault(_Emitter);
	
	var _throttle = __webpack_require__(6);
	
	var _throttle2 = _interopRequireDefault(_throttle);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var Config = function () {
	        function Config() {
	                (0, _classCallCheck3.default)(this, Config);
	
	
	                this.mq = this.oldMq = '';
	
	                this.$html = document.getElementsByTagName('html')[0];
	
	                this.$document = document;
	
	                this.$body = document.body;
	
	                this.lang = this.$html.getAttribute('lang') || 'it';
	
	                this.windoInfo = {
	                        width: 1,
	                        height: 1
	                };
	
	                this.events = {
	                        PAGE_INIT: 'Emitter:init',
	                        WINDOW_RESIZE: 'window:resize',
	                        WINDOW_GET_INFO: 'window:hasGetInfo',
	                        RESIZE: 'resize',
	                        MQ_CHANGED: 'mq:changed',
	                        SCREEN_UPDATED: 'screen:updated',
	                        CLICK: 'click',
	                        IMAGES_LOADED: 'loader:images-loaded',
	                        LOADER_GONE: 'loader:gone',
	                        KEYUP: 'keyup',
	                        MOUSEOVER: 'mouseover',
	                        MOUSEENTER: 'mouseenter',
	                        MOUSELEAVE: 'mouseleave',
	                        SCROLL: 'scroll:adjusted',
	                        SCROLL_NATIVE: 'scroll',
	                        MOUSEWHEEL: /Firefox/i.test(navigator.userAgent) ? 'DOMMouseScroll' : 'mousewheel',
	                        CANPLAYTHROUGH: 'canplaythrough',
	                        NOTES_LOADED: 'notes::loaded'
	                };
	
	                this.classes = {
	                        ACTIVE: 'is-active',
	                        INACTVIE: 'is-inactive',
	                        IS_SHOWING_MODAL: 'is-modal-active',
	                        NO_SCROLL: 'no-scroll'
	                };
	
	                this.STYLE_URL_REGEXP = /url\(("|'|)([\/:\w-\.]+(?:\.png|\.jpg|\.webp|\.gif))\1\)/g;
	
	                this.handleWindowInfo();
	
	                this.getWindowInfo();
	
	                this.updateCurrentMq();
	
	                this.getMqInfo();
	        }
	
	        Config.prototype.handleWindowInfo = function handleWindowInfo() {
	                var _this = this;
	
	                this.getWindowInfo(false);
	
	                _Emitter2.default.on(this.events.WINDOW_RESIZE, function () {
	                        _this.getWindowInfo();
	                });
	
	                window.addEventListener(this.events.RESIZE, (0, _throttle2.default)(function () {
	
	                        if (!Modernizr.touchevents) {
	                                _Emitter2.default.emit(_this.events.WINDOW_RESIZE);
	                        }
	                }, 100));
	        };
	
	        Config.prototype.getWindowInfo = function getWindowInfo() {
	                var emit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
	
	
	                this.windoInfo.width = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
	
	                this.windoInfo.height = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;
	
	                if (emit) {
	                        _Emitter2.default.emit(this.events.WINDOW_GET_INFO);
	                }
	        };
	
	        Config.prototype.updateCurrentMq = function updateCurrentMq() {
	
	                this.oldMq = this.mq;
	                this.mq = window.getComputedStyle(document.body, '::after').content.replace(/['"]+/g, '');
	
	                if (this.mq !== this.oldMq) {
	                        _Emitter2.default.emit(this.events.MQ_CHANGED);
	                }
	        };
	
	        Config.prototype.getMqInfo = function getMqInfo() {
	                var _this2 = this;
	
	                var content = window.getComputedStyle(document.body, ':before').content,
	                    result = void 0;
	
	                var parseRegExp = /\{?\\?"([a-z0-9\-]+)\\?":([0-9]+)/g;
	
	                var _mqMin = function _mqMin(mq) {
	                        var keys = [];
	                        if (!_this2._mqMatrix) {
	                                return keys;
	                        }
	                        for (var _iterator = _this2._mqMatrix.keys(), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
	                                var _ref;
	
	                                if (_isArray) {
	                                        if (_i >= _iterator.length) break;
	                                        _ref = _iterator[_i++];
	                                } else {
	                                        _i = _iterator.next();
	                                        if (_i.done) break;
	                                        _ref = _i.value;
	                                }
	
	                                var key = _ref;
	
	                                keys.push(key);
	                        }
	                        return keys.indexOf(mq) !== -1 ? keys.slice(0, keys.indexOf(mq) + 1) : [];
	                };
	
	                this._mqMatrix = new Map();
	
	                while ((result = parseRegExp.exec(content)) !== null) {
	                        this._mqMatrix.set(result[1], parseInt(result[2], 10));
	                }
	
	                this.mqTo = function (mq) {
	                        return _mqMin(_this2.mq).indexOf(mq) !== -1;
	                };
	
	                this.mqUntil = function (mq) {
	                        return _mqMin(_this2.mq).indexOf(mq) === -1;
	                };
	
	                _Emitter2.default.on(this.events.WINDOW_RESIZE, function () {
	                        _this2.updateCurrentMq();
	                });
	        };
	
	        return Config;
	}();
	
	exports.default = new Config();

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _events = __webpack_require__(5);
	
	var _events2 = _interopRequireDefault(_events);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = new _events2.default().setMaxListeners(0);

/***/ },
/* 5 */
/***/ function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	function EventEmitter() {
	  this._events = this._events || {};
	  this._maxListeners = this._maxListeners || undefined;
	}
	module.exports = EventEmitter;
	
	// Backwards-compat with node 0.10.x
	EventEmitter.EventEmitter = EventEmitter;
	
	EventEmitter.prototype._events = undefined;
	EventEmitter.prototype._maxListeners = undefined;
	
	// By default EventEmitters will print a warning if more than 10 listeners are
	// added to it. This is a useful default which helps finding memory leaks.
	EventEmitter.defaultMaxListeners = 10;
	
	// Obviously not all Emitters should be limited to 10. This function allows
	// that to be increased. Set to zero for unlimited.
	EventEmitter.prototype.setMaxListeners = function(n) {
	  if (!isNumber(n) || n < 0 || isNaN(n))
	    throw TypeError('n must be a positive number');
	  this._maxListeners = n;
	  return this;
	};
	
	EventEmitter.prototype.emit = function(type) {
	  var er, handler, len, args, i, listeners;
	
	  if (!this._events)
	    this._events = {};
	
	  // If there is no 'error' event listener then throw.
	  if (type === 'error') {
	    if (!this._events.error ||
	        (isObject(this._events.error) && !this._events.error.length)) {
	      er = arguments[1];
	      if (er instanceof Error) {
	        throw er; // Unhandled 'error' event
	      } else {
	        // At least give some kind of context to the user
	        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
	        err.context = er;
	        throw err;
	      }
	    }
	  }
	
	  handler = this._events[type];
	
	  if (isUndefined(handler))
	    return false;
	
	  if (isFunction(handler)) {
	    switch (arguments.length) {
	      // fast cases
	      case 1:
	        handler.call(this);
	        break;
	      case 2:
	        handler.call(this, arguments[1]);
	        break;
	      case 3:
	        handler.call(this, arguments[1], arguments[2]);
	        break;
	      // slower
	      default:
	        args = Array.prototype.slice.call(arguments, 1);
	        handler.apply(this, args);
	    }
	  } else if (isObject(handler)) {
	    args = Array.prototype.slice.call(arguments, 1);
	    listeners = handler.slice();
	    len = listeners.length;
	    for (i = 0; i < len; i++)
	      listeners[i].apply(this, args);
	  }
	
	  return true;
	};
	
	EventEmitter.prototype.addListener = function(type, listener) {
	  var m;
	
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  if (!this._events)
	    this._events = {};
	
	  // To avoid recursion in the case that type === "newListener"! Before
	  // adding it to the listeners, first emit "newListener".
	  if (this._events.newListener)
	    this.emit('newListener', type,
	              isFunction(listener.listener) ?
	              listener.listener : listener);
	
	  if (!this._events[type])
	    // Optimize the case of one listener. Don't need the extra array object.
	    this._events[type] = listener;
	  else if (isObject(this._events[type]))
	    // If we've already got an array, just append.
	    this._events[type].push(listener);
	  else
	    // Adding the second element, need to change to array.
	    this._events[type] = [this._events[type], listener];
	
	  // Check for listener leak
	  if (isObject(this._events[type]) && !this._events[type].warned) {
	    if (!isUndefined(this._maxListeners)) {
	      m = this._maxListeners;
	    } else {
	      m = EventEmitter.defaultMaxListeners;
	    }
	
	    if (m && m > 0 && this._events[type].length > m) {
	      this._events[type].warned = true;
	      console.error('(node) warning: possible EventEmitter memory ' +
	                    'leak detected. %d listeners added. ' +
	                    'Use emitter.setMaxListeners() to increase limit.',
	                    this._events[type].length);
	      if (typeof console.trace === 'function') {
	        // not supported in IE 10
	        console.trace();
	      }
	    }
	  }
	
	  return this;
	};
	
	EventEmitter.prototype.on = EventEmitter.prototype.addListener;
	
	EventEmitter.prototype.once = function(type, listener) {
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  var fired = false;
	
	  function g() {
	    this.removeListener(type, g);
	
	    if (!fired) {
	      fired = true;
	      listener.apply(this, arguments);
	    }
	  }
	
	  g.listener = listener;
	  this.on(type, g);
	
	  return this;
	};
	
	// emits a 'removeListener' event iff the listener was removed
	EventEmitter.prototype.removeListener = function(type, listener) {
	  var list, position, length, i;
	
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  if (!this._events || !this._events[type])
	    return this;
	
	  list = this._events[type];
	  length = list.length;
	  position = -1;
	
	  if (list === listener ||
	      (isFunction(list.listener) && list.listener === listener)) {
	    delete this._events[type];
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	
	  } else if (isObject(list)) {
	    for (i = length; i-- > 0;) {
	      if (list[i] === listener ||
	          (list[i].listener && list[i].listener === listener)) {
	        position = i;
	        break;
	      }
	    }
	
	    if (position < 0)
	      return this;
	
	    if (list.length === 1) {
	      list.length = 0;
	      delete this._events[type];
	    } else {
	      list.splice(position, 1);
	    }
	
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	  }
	
	  return this;
	};
	
	EventEmitter.prototype.removeAllListeners = function(type) {
	  var key, listeners;
	
	  if (!this._events)
	    return this;
	
	  // not listening for removeListener, no need to emit
	  if (!this._events.removeListener) {
	    if (arguments.length === 0)
	      this._events = {};
	    else if (this._events[type])
	      delete this._events[type];
	    return this;
	  }
	
	  // emit removeListener for all listeners on all events
	  if (arguments.length === 0) {
	    for (key in this._events) {
	      if (key === 'removeListener') continue;
	      this.removeAllListeners(key);
	    }
	    this.removeAllListeners('removeListener');
	    this._events = {};
	    return this;
	  }
	
	  listeners = this._events[type];
	
	  if (isFunction(listeners)) {
	    this.removeListener(type, listeners);
	  } else if (listeners) {
	    // LIFO order
	    while (listeners.length)
	      this.removeListener(type, listeners[listeners.length - 1]);
	  }
	  delete this._events[type];
	
	  return this;
	};
	
	EventEmitter.prototype.listeners = function(type) {
	  var ret;
	  if (!this._events || !this._events[type])
	    ret = [];
	  else if (isFunction(this._events[type]))
	    ret = [this._events[type]];
	  else
	    ret = this._events[type].slice();
	  return ret;
	};
	
	EventEmitter.prototype.listenerCount = function(type) {
	  if (this._events) {
	    var evlistener = this._events[type];
	
	    if (isFunction(evlistener))
	      return 1;
	    else if (evlistener)
	      return evlistener.length;
	  }
	  return 0;
	};
	
	EventEmitter.listenerCount = function(emitter, type) {
	  return emitter.listenerCount(type);
	};
	
	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	
	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	
	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	
	function isUndefined(arg) {
	  return arg === void 0;
	}


/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	var debounce = __webpack_require__(7),
	    isObject = __webpack_require__(8);
	
	/** Error message constants. */
	var FUNC_ERROR_TEXT = 'Expected a function';
	
	/**
	 * Creates a throttled function that only invokes `func` at most once per
	 * every `wait` milliseconds. The throttled function comes with a `cancel`
	 * method to cancel delayed `func` invocations and a `flush` method to
	 * immediately invoke them. Provide `options` to indicate whether `func`
	 * should be invoked on the leading and/or trailing edge of the `wait`
	 * timeout. The `func` is invoked with the last arguments provided to the
	 * throttled function. Subsequent calls to the throttled function return the
	 * result of the last `func` invocation.
	 *
	 * **Note:** If `leading` and `trailing` options are `true`, `func` is
	 * invoked on the trailing edge of the timeout only if the throttled function
	 * is invoked more than once during the `wait` timeout.
	 *
	 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
	 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
	 *
	 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
	 * for details over the differences between `_.throttle` and `_.debounce`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Function
	 * @param {Function} func The function to throttle.
	 * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
	 * @param {Object} [options={}] The options object.
	 * @param {boolean} [options.leading=true]
	 *  Specify invoking on the leading edge of the timeout.
	 * @param {boolean} [options.trailing=true]
	 *  Specify invoking on the trailing edge of the timeout.
	 * @returns {Function} Returns the new throttled function.
	 * @example
	 *
	 * // Avoid excessively updating the position while scrolling.
	 * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
	 *
	 * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
	 * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
	 * jQuery(element).on('click', throttled);
	 *
	 * // Cancel the trailing throttled invocation.
	 * jQuery(window).on('popstate', throttled.cancel);
	 */
	function throttle(func, wait, options) {
	  var leading = true,
	      trailing = true;
	
	  if (typeof func != 'function') {
	    throw new TypeError(FUNC_ERROR_TEXT);
	  }
	  if (isObject(options)) {
	    leading = 'leading' in options ? !!options.leading : leading;
	    trailing = 'trailing' in options ? !!options.trailing : trailing;
	  }
	  return debounce(func, wait, {
	    'leading': leading,
	    'maxWait': wait,
	    'trailing': trailing
	  });
	}
	
	module.exports = throttle;


/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(8),
	    now = __webpack_require__(9),
	    toNumber = __webpack_require__(12);
	
	/** Error message constants. */
	var FUNC_ERROR_TEXT = 'Expected a function';
	
	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMax = Math.max,
	    nativeMin = Math.min;
	
	/**
	 * Creates a debounced function that delays invoking `func` until after `wait`
	 * milliseconds have elapsed since the last time the debounced function was
	 * invoked. The debounced function comes with a `cancel` method to cancel
	 * delayed `func` invocations and a `flush` method to immediately invoke them.
	 * Provide `options` to indicate whether `func` should be invoked on the
	 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
	 * with the last arguments provided to the debounced function. Subsequent
	 * calls to the debounced function return the result of the last `func`
	 * invocation.
	 *
	 * **Note:** If `leading` and `trailing` options are `true`, `func` is
	 * invoked on the trailing edge of the timeout only if the debounced function
	 * is invoked more than once during the `wait` timeout.
	 *
	 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
	 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
	 *
	 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
	 * for details over the differences between `_.debounce` and `_.throttle`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Function
	 * @param {Function} func The function to debounce.
	 * @param {number} [wait=0] The number of milliseconds to delay.
	 * @param {Object} [options={}] The options object.
	 * @param {boolean} [options.leading=false]
	 *  Specify invoking on the leading edge of the timeout.
	 * @param {number} [options.maxWait]
	 *  The maximum time `func` is allowed to be delayed before it's invoked.
	 * @param {boolean} [options.trailing=true]
	 *  Specify invoking on the trailing edge of the timeout.
	 * @returns {Function} Returns the new debounced function.
	 * @example
	 *
	 * // Avoid costly calculations while the window size is in flux.
	 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
	 *
	 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
	 * jQuery(element).on('click', _.debounce(sendMail, 300, {
	 *   'leading': true,
	 *   'trailing': false
	 * }));
	 *
	 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
	 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
	 * var source = new EventSource('/stream');
	 * jQuery(source).on('message', debounced);
	 *
	 * // Cancel the trailing debounced invocation.
	 * jQuery(window).on('popstate', debounced.cancel);
	 */
	function debounce(func, wait, options) {
	  var lastArgs,
	      lastThis,
	      maxWait,
	      result,
	      timerId,
	      lastCallTime,
	      lastInvokeTime = 0,
	      leading = false,
	      maxing = false,
	      trailing = true;
	
	  if (typeof func != 'function') {
	    throw new TypeError(FUNC_ERROR_TEXT);
	  }
	  wait = toNumber(wait) || 0;
	  if (isObject(options)) {
	    leading = !!options.leading;
	    maxing = 'maxWait' in options;
	    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
	    trailing = 'trailing' in options ? !!options.trailing : trailing;
	  }
	
	  function invokeFunc(time) {
	    var args = lastArgs,
	        thisArg = lastThis;
	
	    lastArgs = lastThis = undefined;
	    lastInvokeTime = time;
	    result = func.apply(thisArg, args);
	    return result;
	  }
	
	  function leadingEdge(time) {
	    // Reset any `maxWait` timer.
	    lastInvokeTime = time;
	    // Start the timer for the trailing edge.
	    timerId = setTimeout(timerExpired, wait);
	    // Invoke the leading edge.
	    return leading ? invokeFunc(time) : result;
	  }
	
	  function remainingWait(time) {
	    var timeSinceLastCall = time - lastCallTime,
	        timeSinceLastInvoke = time - lastInvokeTime,
	        result = wait - timeSinceLastCall;
	
	    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
	  }
	
	  function shouldInvoke(time) {
	    var timeSinceLastCall = time - lastCallTime,
	        timeSinceLastInvoke = time - lastInvokeTime;
	
	    // Either this is the first call, activity has stopped and we're at the
	    // trailing edge, the system time has gone backwards and we're treating
	    // it as the trailing edge, or we've hit the `maxWait` limit.
	    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
	      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
	  }
	
	  function timerExpired() {
	    var time = now();
	    if (shouldInvoke(time)) {
	      return trailingEdge(time);
	    }
	    // Restart the timer.
	    timerId = setTimeout(timerExpired, remainingWait(time));
	  }
	
	  function trailingEdge(time) {
	    timerId = undefined;
	
	    // Only invoke if we have `lastArgs` which means `func` has been
	    // debounced at least once.
	    if (trailing && lastArgs) {
	      return invokeFunc(time);
	    }
	    lastArgs = lastThis = undefined;
	    return result;
	  }
	
	  function cancel() {
	    if (timerId !== undefined) {
	      clearTimeout(timerId);
	    }
	    lastInvokeTime = 0;
	    lastArgs = lastCallTime = lastThis = timerId = undefined;
	  }
	
	  function flush() {
	    return timerId === undefined ? result : trailingEdge(now());
	  }
	
	  function debounced() {
	    var time = now(),
	        isInvoking = shouldInvoke(time);
	
	    lastArgs = arguments;
	    lastThis = this;
	    lastCallTime = time;
	
	    if (isInvoking) {
	      if (timerId === undefined) {
	        return leadingEdge(lastCallTime);
	      }
	      if (maxing) {
	        // Handle invocations in a tight loop.
	        timerId = setTimeout(timerExpired, wait);
	        return invokeFunc(lastCallTime);
	      }
	    }
	    if (timerId === undefined) {
	      timerId = setTimeout(timerExpired, wait);
	    }
	    return result;
	  }
	  debounced.cancel = cancel;
	  debounced.flush = flush;
	  return debounced;
	}
	
	module.exports = debounce;


/***/ },
/* 8 */
/***/ function(module, exports) {

	/**
	 * Checks if `value` is the
	 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(_.noop);
	 * // => true
	 *
	 * _.isObject(null);
	 * // => false
	 */
	function isObject(value) {
	  var type = typeof value;
	  return value != null && (type == 'object' || type == 'function');
	}
	
	module.exports = isObject;


/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	var root = __webpack_require__(10);
	
	/**
	 * Gets the timestamp of the number of milliseconds that have elapsed since
	 * the Unix epoch (1 January 1970 00:00:00 UTC).
	 *
	 * @static
	 * @memberOf _
	 * @since 2.4.0
	 * @category Date
	 * @returns {number} Returns the timestamp.
	 * @example
	 *
	 * _.defer(function(stamp) {
	 *   console.log(_.now() - stamp);
	 * }, _.now());
	 * // => Logs the number of milliseconds it took for the deferred invocation.
	 */
	var now = function() {
	  return root.Date.now();
	};
	
	module.exports = now;


/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	var freeGlobal = __webpack_require__(11);
	
	/** Detect free variable `self`. */
	var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
	
	/** Used as a reference to the global object. */
	var root = freeGlobal || freeSelf || Function('return this')();
	
	module.exports = root;


/***/ },
/* 11 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {/** Detect free variable `global` from Node.js. */
	var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
	
	module.exports = freeGlobal;
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(8),
	    isSymbol = __webpack_require__(13);
	
	/** Used as references for various `Number` constants. */
	var NAN = 0 / 0;
	
	/** Used to match leading and trailing whitespace. */
	var reTrim = /^\s+|\s+$/g;
	
	/** Used to detect bad signed hexadecimal string values. */
	var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
	
	/** Used to detect binary string values. */
	var reIsBinary = /^0b[01]+$/i;
	
	/** Used to detect octal string values. */
	var reIsOctal = /^0o[0-7]+$/i;
	
	/** Built-in method references without a dependency on `root`. */
	var freeParseInt = parseInt;
	
	/**
	 * Converts `value` to a number.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to process.
	 * @returns {number} Returns the number.
	 * @example
	 *
	 * _.toNumber(3.2);
	 * // => 3.2
	 *
	 * _.toNumber(Number.MIN_VALUE);
	 * // => 5e-324
	 *
	 * _.toNumber(Infinity);
	 * // => Infinity
	 *
	 * _.toNumber('3.2');
	 * // => 3.2
	 */
	function toNumber(value) {
	  if (typeof value == 'number') {
	    return value;
	  }
	  if (isSymbol(value)) {
	    return NAN;
	  }
	  if (isObject(value)) {
	    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
	    value = isObject(other) ? (other + '') : other;
	  }
	  if (typeof value != 'string') {
	    return value === 0 ? value : +value;
	  }
	  value = value.replace(reTrim, '');
	  var isBinary = reIsBinary.test(value);
	  return (isBinary || reIsOctal.test(value))
	    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
	    : (reIsBadHex.test(value) ? NAN : +value);
	}
	
	module.exports = toNumber;


/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	var baseGetTag = __webpack_require__(14),
	    isObjectLike = __webpack_require__(18);
	
	/** `Object#toString` result references. */
	var symbolTag = '[object Symbol]';
	
	/**
	 * Checks if `value` is classified as a `Symbol` primitive or object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
	 * @example
	 *
	 * _.isSymbol(Symbol.iterator);
	 * // => true
	 *
	 * _.isSymbol('abc');
	 * // => false
	 */
	function isSymbol(value) {
	  return typeof value == 'symbol' ||
	    (isObjectLike(value) && baseGetTag(value) == symbolTag);
	}
	
	module.exports = isSymbol;


/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	var Symbol = __webpack_require__(15),
	    getRawTag = __webpack_require__(16),
	    objectToString = __webpack_require__(17);
	
	/** `Object#toString` result references. */
	var nullTag = '[object Null]',
	    undefinedTag = '[object Undefined]';
	
	/** Built-in value references. */
	var symToStringTag = Symbol ? Symbol.toStringTag : undefined;
	
	/**
	 * The base implementation of `getTag` without fallbacks for buggy environments.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	function baseGetTag(value) {
	  if (value == null) {
	    return value === undefined ? undefinedTag : nullTag;
	  }
	  value = Object(value);
	  return (symToStringTag && symToStringTag in value)
	    ? getRawTag(value)
	    : objectToString(value);
	}
	
	module.exports = baseGetTag;


/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	var root = __webpack_require__(10);
	
	/** Built-in value references. */
	var Symbol = root.Symbol;
	
	module.exports = Symbol;


/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	var Symbol = __webpack_require__(15);
	
	/** Used for built-in method references. */
	var objectProto = Object.prototype;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;
	
	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString = objectProto.toString;
	
	/** Built-in value references. */
	var symToStringTag = Symbol ? Symbol.toStringTag : undefined;
	
	/**
	 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the raw `toStringTag`.
	 */
	function getRawTag(value) {
	  var isOwn = hasOwnProperty.call(value, symToStringTag),
	      tag = value[symToStringTag];
	
	  try {
	    value[symToStringTag] = undefined;
	    var unmasked = true;
	  } catch (e) {}
	
	  var result = nativeObjectToString.call(value);
	  if (unmasked) {
	    if (isOwn) {
	      value[symToStringTag] = tag;
	    } else {
	      delete value[symToStringTag];
	    }
	  }
	  return result;
	}
	
	module.exports = getRawTag;


/***/ },
/* 17 */
/***/ function(module, exports) {

	/** Used for built-in method references. */
	var objectProto = Object.prototype;
	
	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString = objectProto.toString;
	
	/**
	 * Converts `value` to a string using `Object.prototype.toString`.
	 *
	 * @private
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 */
	function objectToString(value) {
	  return nativeObjectToString.call(value);
	}
	
	module.exports = objectToString;


/***/ },
/* 18 */
/***/ function(module, exports) {

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return value != null && typeof value == 'object';
	}
	
	module.exports = isObjectLike;


/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _classCallCheck2 = __webpack_require__(2);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(20);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(89);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _Component2 = __webpack_require__(97);
	
	var _Component3 = _interopRequireDefault(_Component2);
	
	var _Utils = __webpack_require__(103);
	
	var _Utils2 = _interopRequireDefault(_Utils);
	
	var _RenderFactory = __webpack_require__(193);
	
	var _RenderFactory2 = _interopRequireDefault(_RenderFactory);
	
	var _dragula = __webpack_require__(242);
	
	var _dragula2 = _interopRequireDefault(_dragula);
	
	var _lodash = __webpack_require__(198);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _classie = __webpack_require__(99);
	
	var _classie2 = _interopRequireDefault(_classie);
	
	var _cookiesJs = __webpack_require__(251);
	
	var _cookiesJs2 = _interopRequireDefault(_cookiesJs);
	
	var _base = __webpack_require__(104);
	
	var _base2 = _interopRequireDefault(_base);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var PageComposer = function (_Component) {
	    (0, _inherits3.default)(PageComposer, _Component);
	
	    function PageComposer(opts) {
	        (0, _classCallCheck3.default)(this, PageComposer);
	
	        var _this = (0, _possibleConstructorReturn3.default)(this, _Component.call(this, null, opts));
	
	        _this.blocks = Array();
	
	        _this.blockAdded = _this.blockAdded.bind(_this);
	        _this.getContent = _this.getContent.bind(_this);
	        _this.onDelete = _this.onDelete.bind(_this);
	        _this.save = _this.save.bind(_this);
	        _this.onChildChanged = _this.onChildChanged.bind(_this);
	        return _this;
	    }
	
	    PageComposer.prototype.getDefaultOptions = function getDefaultOptions() {
	        return {
	            sources: [
	            //"cookie:pagecomposer",
	            "element:input[name=aq_pagecomposer_value]"],
	            targets: [
	            //"cookie:pagecomposer",
	            "element:input[name=aq_pagecomposer_value]"],
	            labels: {
	                delete: "Delete",
	                deleteTitle: "Confirm delete",
	                deleteMessage: "Do you want to delete the block ?",
	                confirm: "Confirm",
	                cancel: "Cancel"
	            },
	            languageSelector: "#cmbLanguages",
	            endpoints: {
	                getPreview: 'getPreview',
	                upload: 'upload',
	                delete: 'delete'
	            }
	        };
	    };
	
	    PageComposer.prototype.init = function init() {
	        var _this2 = this;
	
	        this.wrapper = document.getElementById('aq-composer-wrapper');
	        if (!this.wrapper) return;
	
	        this.composerContent = this.wrapper.querySelectorAll(".composer-content")[0];
	        this.composerToolbar = this.wrapper.querySelectorAll(".composer-toolbar")[0];
	
	        this.load();
	
	        this.saveBtn = document.getElementById('saveBtn');
	        if (this.saveBtn) {
	            this.saveBtn.addEventListener("click", this.save);
	        }
	
	        this.renderExisting();
	
	        this.bindDeleteBlock();
	
	        var languageSelectorEl = this.getLanguageSelectorElement();
	        if (languageSelectorEl) {
	            languageSelectorEl.addEventListener("change", function () {
	                _this2.setCurrentLanguage(languageSelectorEl.value);
	            });
	        }
	
	        (0, _dragula2.default)([this.composerToolbar, this.composerContent], {
	            copySortSource: false,
	            copy: function copy(el, source) {
	                return source === _this2.composerToolbar;
	            },
	            accepts: function accepts(el, target) {
	                return target === _this2.composerContent;
	            },
	            moves: function moves(el, container, handle) {
	                return _classie2.default.has(handle, "task-move");
	            }
	        }).on("drop", this.blockAdded);
	    };
	
	    PageComposer.prototype.bindDeleteBlock = function bindDeleteBlock() {
	        var _this3 = this;
	
	        this.composerContent.querySelectorAll(".task-delete").forEach(function (el) {
	
	            if (_Utils2.default.Data(el, "aq_pagecomposerclickbinded") === "1") return;
	
	            if (!el.parentNode.classList.contains("block-task")) return;
	
	            el.addEventListener("click", function (e) {
	                _this3.onDelete(e.currentTarget);
	            });
	
	            _Utils2.default.Data(el, "aq_pagecomposerclickbinded", "1");
	        });
	    };
	
	    PageComposer.prototype.onDelete = function onDelete(el) {
	        var _this4 = this;
	
	        var blockEl = _Utils2.default.FindAncestorByClass(el, "block-item");
	        var uid = _Utils2.default.Data(blockEl, "pagecomposeruid");
	
	        _Utils2.default.AlertWarning(this.settings.labels.deleteTitle, this.settings.labels.deleteMessage, true).then(function () {
	            if (uid && _this4.blocks[uid]) {
	                var block = _this4.blocks[uid];
	                block.delete().then(function () {
	                    delete _this4.blocks[uid];
	                    blockEl.parentNode.removeChild(blockEl);
	                    _this4.onChildChanged();
	                }).catch(function () {
	                    _Utils2.default.AlertError();
	                });
	            }
	        });
	    };
	
	    PageComposer.prototype.renderExisting = function renderExisting() {
	        this.composerContent.querySelectorAll(".block-item").forEach(function (block) {
	            this.renderBlock(block);
	        }, this);
	    };
	
	    PageComposer.prototype.getSourceValue = function getSourceValue(source) {
	        var sourcePath = _lodash2.default.split(source, ":");
	        if (sourcePath[0] && sourcePath[1]) {
	            switch (sourcePath[0]) {
	                case "cookie":
	                    return _cookiesJs2.default.get(sourcePath[1]);
	                case "element":
	                    var valueEl = document.querySelector(sourcePath[1]);
	                    if (valueEl) return valueEl.value;
	            }
	        }
	    };
	
	    PageComposer.prototype.setTargetValue = function setTargetValue(target, value) {
	        var targetPath = _lodash2.default.split(target, ":");
	        if (targetPath[0] && targetPath[1]) {
	            switch (targetPath[0]) {
	                case "cookie":
	                    _cookiesJs2.default.set(targetPath[1], value);
	                case "element":
	                    var valueEl = document.querySelector(targetPath[1]);
	                    if (valueEl) valueEl.value = value;
	            }
	        }
	    };
	
	    PageComposer.prototype.load = function load() {
	
	        var loaded = false;
	        this.settings.sources.forEach(function (source) {
	            if (loaded) return;
	
	            var savedContent = this.getSourceValue(source);
	            if (savedContent) {
	                var savedData = _Utils2.default.Base64ToObj(savedContent);
	                loaded = this.loadData(savedData);
	            }
	        }, this);
	
	        return loaded;
	    };
	
	    PageComposer.prototype.loadData = function loadData(data) {
	
	        if (data.blocks && Array.isArray(data.blocks)) {
	            data.blocks.forEach(function (block) {
	                var blockEl = document.createElement("div");
	                _classie2.default.add(blockEl, "block-item");
	                _Utils2.default.Data(blockEl, "pagecomposerrender", block.type);
	                _Utils2.default.Data(blockEl, "pagecomposerblockrendered", 0);
	                _Utils2.default.Data(blockEl, "pagecomposeredit", 1);
	                blockEl.style.display = "none";
	                blockEl.innerText = _Utils2.default.ObjToBase64(block.data);
	                this.composerContent.appendChild(blockEl);
	            }, this);
	            return true;
	        }
	        return false;
	    };
	
	    PageComposer.prototype.save = function save() {
	        console.log(JSON.stringify(this.getContent()));
	        var state = _Utils2.default.ObjToBase64(this.getContent());
	        this.settings.targets.forEach(function (target) {
	            this.setTargetValue(target, state);
	        }, this);
	    };
	
	    PageComposer.prototype.blockAdded = function blockAdded(el, target, source, sibling) {
	        if (target !== this.composerContent) return false;
	
	        this.renderBlock(el);
	        this.bindDeleteBlock();
	        this.onChildChanged();
	    };
	
	    PageComposer.prototype.onChildChanged = function onChildChanged() {
	        this.save();
	    };
	
	    PageComposer.prototype.renderBlock = function renderBlock(el) {
	        var renderClass = _Utils2.default.Data(el, "pagecomposerrender");
	        var alreadyRendered = _Utils2.default.Data(el, "pagecomposerblockrendered");
	        if (renderClass && renderClass.trim().length > 0 && alreadyRendered != 1) {
	            this.removePlaceHolder();
	            var render = _RenderFactory2.default.create(renderClass, this.getSettingsForChild());
	            render.init(el);
	            this.blocks[render.id()] = render;
	        }
	    };
	
	    PageComposer.prototype.getSettingsForChild = function getSettingsForChild() {
	        return {
	            changeCallback: this.onChildChanged,
	            languages: this.getLanguages(),
	            currentLang: this.getCurrentLanguage(),
	            endpoints: this.settings.endpoints
	        };
	    };
	
	    PageComposer.prototype.getLanguageSelectorElement = function getLanguageSelectorElement() {
	        return this.settings.languageSelector.substring(0, 1) === "#" ? document.getElementById(this.settings.languageSelector.substring(1)) : _Component.prototype.find.call(this, document, this.settings.languageSelector);
	    };
	
	    PageComposer.prototype.getLanguages = function getLanguages() {
	
	        var result = {};
	
	        Array.from(this.getLanguageSelectorElement().querySelectorAll("option")).forEach(function (element) {
	            result[element.value] = element.innerText;
	        }, this);
	
	        return result;
	    };
	
	    PageComposer.prototype.getCurrentLanguage = function getCurrentLanguage() {
	        return this.getLanguageSelectorElement().value;
	    };
	
	    PageComposer.prototype.setCurrentLanguage = function setCurrentLanguage(lang) {
	        for (var key in this.blocks) {
	            var block = this.blocks[key];
	
	            if (block.setCurrentLanguage && typeof block.setCurrentLanguage === "function") {
	                block.setCurrentLanguage(lang);
	            }
	        }
	    };
	
	    PageComposer.prototype.removePlaceHolder = function removePlaceHolder() {
	        var placeHolderEl = this.composerContent.querySelectorAll(".composer-title");
	        if (placeHolderEl && placeHolderEl.length > 0) placeHolderEl[0].parentNode.removeChild(placeHolderEl[0]);
	    };
	
	    PageComposer.prototype.getContent = function getContent() {
	        var result = Array();
	        var blocks = this.composerContent.querySelectorAll(".block-item");
	        blocks.forEach(function (block) {
	            var uid = _Utils2.default.Data(block, "pagecomposeruid");
	            if (uid && this.blocks[uid]) {
	                result.push({
	                    "type": this.blocks[uid].constructor.name.replace("Render", ""),
	                    "data": this.blocks[uid].getValue()
	                });
	            }
	        }, this);
	
	        return {
	            blocks: result
	        };
	    };
	
	    return PageComposer;
	}(_Component3.default);
	
	exports.default = PageComposer;

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _typeof2 = __webpack_require__(21);
	
	var _typeof3 = _interopRequireDefault(_typeof2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function (self, call) {
	  if (!self) {
	    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	  }
	
	  return call && ((typeof call === "undefined" ? "undefined" : (0, _typeof3.default)(call)) === "object" || typeof call === "function") ? call : self;
	};

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _iterator = __webpack_require__(22);
	
	var _iterator2 = _interopRequireDefault(_iterator);
	
	var _symbol = __webpack_require__(73);
	
	var _symbol2 = _interopRequireDefault(_symbol);
	
	var _typeof = typeof _symbol2.default === "function" && typeof _iterator2.default === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default ? "symbol" : typeof obj; };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = typeof _symbol2.default === "function" && _typeof(_iterator2.default) === "symbol" ? function (obj) {
	  return typeof obj === "undefined" ? "undefined" : _typeof(obj);
	} : function (obj) {
	  return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof(obj);
	};

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(23), __esModule: true };

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(24);
	__webpack_require__(68);
	module.exports = __webpack_require__(72).f('iterator');

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $at  = __webpack_require__(25)(true);
	
	// 21.1.3.27 String.prototype[@@iterator]()
	__webpack_require__(28)(String, 'String', function(iterated){
	  this._t = String(iterated); // target
	  this._i = 0;                // next index
	// 21.1.5.2.1 %StringIteratorPrototype%.next()
	}, function(){
	  var O     = this._t
	    , index = this._i
	    , point;
	  if(index >= O.length)return {value: undefined, done: true};
	  point = $at(O, index);
	  this._i += point.length;
	  return {value: point, done: false};
	});

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	var toInteger = __webpack_require__(26)
	  , defined   = __webpack_require__(27);
	// true  -> String#at
	// false -> String#codePointAt
	module.exports = function(TO_STRING){
	  return function(that, pos){
	    var s = String(defined(that))
	      , i = toInteger(pos)
	      , l = s.length
	      , a, b;
	    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;
	    a = s.charCodeAt(i);
	    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
	      ? TO_STRING ? s.charAt(i) : a
	      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
	  };
	};

/***/ },
/* 26 */
/***/ function(module, exports) {

	// 7.1.4 ToInteger
	var ceil  = Math.ceil
	  , floor = Math.floor;
	module.exports = function(it){
	  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
	};

/***/ },
/* 27 */
/***/ function(module, exports) {

	// 7.2.1 RequireObjectCoercible(argument)
	module.exports = function(it){
	  if(it == undefined)throw TypeError("Can't call method on  " + it);
	  return it;
	};

/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var LIBRARY        = __webpack_require__(29)
	  , $export        = __webpack_require__(30)
	  , redefine       = __webpack_require__(45)
	  , hide           = __webpack_require__(35)
	  , has            = __webpack_require__(46)
	  , Iterators      = __webpack_require__(47)
	  , $iterCreate    = __webpack_require__(48)
	  , setToStringTag = __webpack_require__(64)
	  , getPrototypeOf = __webpack_require__(66)
	  , ITERATOR       = __webpack_require__(65)('iterator')
	  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`
	  , FF_ITERATOR    = '@@iterator'
	  , KEYS           = 'keys'
	  , VALUES         = 'values';
	
	var returnThis = function(){ return this; };
	
	module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){
	  $iterCreate(Constructor, NAME, next);
	  var getMethod = function(kind){
	    if(!BUGGY && kind in proto)return proto[kind];
	    switch(kind){
	      case KEYS: return function keys(){ return new Constructor(this, kind); };
	      case VALUES: return function values(){ return new Constructor(this, kind); };
	    } return function entries(){ return new Constructor(this, kind); };
	  };
	  var TAG        = NAME + ' Iterator'
	    , DEF_VALUES = DEFAULT == VALUES
	    , VALUES_BUG = false
	    , proto      = Base.prototype
	    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]
	    , $default   = $native || getMethod(DEFAULT)
	    , $entries   = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined
	    , $anyNative = NAME == 'Array' ? proto.entries || $native : $native
	    , methods, key, IteratorPrototype;
	  // Fix native
	  if($anyNative){
	    IteratorPrototype = getPrototypeOf($anyNative.call(new Base));
	    if(IteratorPrototype !== Object.prototype){
	      // Set @@toStringTag to native iterators
	      setToStringTag(IteratorPrototype, TAG, true);
	      // fix for some old engines
	      if(!LIBRARY && !has(IteratorPrototype, ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);
	    }
	  }
	  // fix Array#{values, @@iterator}.name in V8 / FF
	  if(DEF_VALUES && $native && $native.name !== VALUES){
	    VALUES_BUG = true;
	    $default = function values(){ return $native.call(this); };
	  }
	  // Define iterator
	  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){
	    hide(proto, ITERATOR, $default);
	  }
	  // Plug for library
	  Iterators[NAME] = $default;
	  Iterators[TAG]  = returnThis;
	  if(DEFAULT){
	    methods = {
	      values:  DEF_VALUES ? $default : getMethod(VALUES),
	      keys:    IS_SET     ? $default : getMethod(KEYS),
	      entries: $entries
	    };
	    if(FORCED)for(key in methods){
	      if(!(key in proto))redefine(proto, key, methods[key]);
	    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
	  }
	  return methods;
	};

/***/ },
/* 29 */
/***/ function(module, exports) {

	module.exports = true;

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	var global    = __webpack_require__(31)
	  , core      = __webpack_require__(32)
	  , ctx       = __webpack_require__(33)
	  , hide      = __webpack_require__(35)
	  , PROTOTYPE = 'prototype';
	
	var $export = function(type, name, source){
	  var IS_FORCED = type & $export.F
	    , IS_GLOBAL = type & $export.G
	    , IS_STATIC = type & $export.S
	    , IS_PROTO  = type & $export.P
	    , IS_BIND   = type & $export.B
	    , IS_WRAP   = type & $export.W
	    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
	    , expProto  = exports[PROTOTYPE]
	    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]
	    , key, own, out;
	  if(IS_GLOBAL)source = name;
	  for(key in source){
	    // contains in native
	    own = !IS_FORCED && target && target[key] !== undefined;
	    if(own && key in exports)continue;
	    // export native or passed
	    out = own ? target[key] : source[key];
	    // prevent global pollution for namespaces
	    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
	    // bind timers to global for call from export context
	    : IS_BIND && own ? ctx(out, global)
	    // wrap global constructors for prevent change them in library
	    : IS_WRAP && target[key] == out ? (function(C){
	      var F = function(a, b, c){
	        if(this instanceof C){
	          switch(arguments.length){
	            case 0: return new C;
	            case 1: return new C(a);
	            case 2: return new C(a, b);
	          } return new C(a, b, c);
	        } return C.apply(this, arguments);
	      };
	      F[PROTOTYPE] = C[PROTOTYPE];
	      return F;
	    // make static versions for prototype methods
	    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
	    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
	    if(IS_PROTO){
	      (exports.virtual || (exports.virtual = {}))[key] = out;
	      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
	      if(type & $export.R && expProto && !expProto[key])hide(expProto, key, out);
	    }
	  }
	};
	// type bitmap
	$export.F = 1;   // forced
	$export.G = 2;   // global
	$export.S = 4;   // static
	$export.P = 8;   // proto
	$export.B = 16;  // bind
	$export.W = 32;  // wrap
	$export.U = 64;  // safe
	$export.R = 128; // real proto method for `library` 
	module.exports = $export;

/***/ },
/* 31 */
/***/ function(module, exports) {

	// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
	var global = module.exports = typeof window != 'undefined' && window.Math == Math
	  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
	if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef

/***/ },
/* 32 */
/***/ function(module, exports) {

	var core = module.exports = {version: '2.4.0'};
	if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	// optional / simple context binding
	var aFunction = __webpack_require__(34);
	module.exports = function(fn, that, length){
	  aFunction(fn);
	  if(that === undefined)return fn;
	  switch(length){
	    case 1: return function(a){
	      return fn.call(that, a);
	    };
	    case 2: return function(a, b){
	      return fn.call(that, a, b);
	    };
	    case 3: return function(a, b, c){
	      return fn.call(that, a, b, c);
	    };
	  }
	  return function(/* ...args */){
	    return fn.apply(that, arguments);
	  };
	};

/***/ },
/* 34 */
/***/ function(module, exports) {

	module.exports = function(it){
	  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
	  return it;
	};

/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	var dP         = __webpack_require__(36)
	  , createDesc = __webpack_require__(44);
	module.exports = __webpack_require__(40) ? function(object, key, value){
	  return dP.f(object, key, createDesc(1, value));
	} : function(object, key, value){
	  object[key] = value;
	  return object;
	};

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	var anObject       = __webpack_require__(37)
	  , IE8_DOM_DEFINE = __webpack_require__(39)
	  , toPrimitive    = __webpack_require__(43)
	  , dP             = Object.defineProperty;
	
	exports.f = __webpack_require__(40) ? Object.defineProperty : function defineProperty(O, P, Attributes){
	  anObject(O);
	  P = toPrimitive(P, true);
	  anObject(Attributes);
	  if(IE8_DOM_DEFINE)try {
	    return dP(O, P, Attributes);
	  } catch(e){ /* empty */ }
	  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');
	  if('value' in Attributes)O[P] = Attributes.value;
	  return O;
	};

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(38);
	module.exports = function(it){
	  if(!isObject(it))throw TypeError(it + ' is not an object!');
	  return it;
	};

/***/ },
/* 38 */
/***/ function(module, exports) {

	module.exports = function(it){
	  return typeof it === 'object' ? it !== null : typeof it === 'function';
	};

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = !__webpack_require__(40) && !__webpack_require__(41)(function(){
	  return Object.defineProperty(__webpack_require__(42)('div'), 'a', {get: function(){ return 7; }}).a != 7;
	});

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	// Thank's IE8 for his funny defineProperty
	module.exports = !__webpack_require__(41)(function(){
	  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;
	});

/***/ },
/* 41 */
/***/ function(module, exports) {

	module.exports = function(exec){
	  try {
	    return !!exec();
	  } catch(e){
	    return true;
	  }
	};

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(38)
	  , document = __webpack_require__(31).document
	  // in old IE typeof document.createElement is 'object'
	  , is = isObject(document) && isObject(document.createElement);
	module.exports = function(it){
	  return is ? document.createElement(it) : {};
	};

/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.1 ToPrimitive(input [, PreferredType])
	var isObject = __webpack_require__(38);
	// instead of the ES6 spec version, we didn't implement @@toPrimitive case
	// and the second argument - flag - preferred type is a string
	module.exports = function(it, S){
	  if(!isObject(it))return it;
	  var fn, val;
	  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
	  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;
	  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
	  throw TypeError("Can't convert object to primitive value");
	};

/***/ },
/* 44 */
/***/ function(module, exports) {

	module.exports = function(bitmap, value){
	  return {
	    enumerable  : !(bitmap & 1),
	    configurable: !(bitmap & 2),
	    writable    : !(bitmap & 4),
	    value       : value
	  };
	};

/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(35);

/***/ },
/* 46 */
/***/ function(module, exports) {

	var hasOwnProperty = {}.hasOwnProperty;
	module.exports = function(it, key){
	  return hasOwnProperty.call(it, key);
	};

/***/ },
/* 47 */
/***/ function(module, exports) {

	module.exports = {};

/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var create         = __webpack_require__(49)
	  , descriptor     = __webpack_require__(44)
	  , setToStringTag = __webpack_require__(64)
	  , IteratorPrototype = {};
	
	// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
	__webpack_require__(35)(IteratorPrototype, __webpack_require__(65)('iterator'), function(){ return this; });
	
	module.exports = function(Constructor, NAME, next){
	  Constructor.prototype = create(IteratorPrototype, {next: descriptor(1, next)});
	  setToStringTag(Constructor, NAME + ' Iterator');
	};

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
	var anObject    = __webpack_require__(37)
	  , dPs         = __webpack_require__(50)
	  , enumBugKeys = __webpack_require__(62)
	  , IE_PROTO    = __webpack_require__(59)('IE_PROTO')
	  , Empty       = function(){ /* empty */ }
	  , PROTOTYPE   = 'prototype';
	
	// Create object with fake `null` prototype: use iframe Object with cleared prototype
	var createDict = function(){
	  // Thrash, waste and sodomy: IE GC bug
	  var iframe = __webpack_require__(42)('iframe')
	    , i      = enumBugKeys.length
	    , lt     = '<'
	    , gt     = '>'
	    , iframeDocument;
	  iframe.style.display = 'none';
	  __webpack_require__(63).appendChild(iframe);
	  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
	  // createDict = iframe.contentWindow.Object;
	  // html.removeChild(iframe);
	  iframeDocument = iframe.contentWindow.document;
	  iframeDocument.open();
	  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
	  iframeDocument.close();
	  createDict = iframeDocument.F;
	  while(i--)delete createDict[PROTOTYPE][enumBugKeys[i]];
	  return createDict();
	};
	
	module.exports = Object.create || function create(O, Properties){
	  var result;
	  if(O !== null){
	    Empty[PROTOTYPE] = anObject(O);
	    result = new Empty;
	    Empty[PROTOTYPE] = null;
	    // add "__proto__" for Object.getPrototypeOf polyfill
	    result[IE_PROTO] = O;
	  } else result = createDict();
	  return Properties === undefined ? result : dPs(result, Properties);
	};


/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	var dP       = __webpack_require__(36)
	  , anObject = __webpack_require__(37)
	  , getKeys  = __webpack_require__(51);
	
	module.exports = __webpack_require__(40) ? Object.defineProperties : function defineProperties(O, Properties){
	  anObject(O);
	  var keys   = getKeys(Properties)
	    , length = keys.length
	    , i = 0
	    , P;
	  while(length > i)dP.f(O, P = keys[i++], Properties[P]);
	  return O;
	};

/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.14 / 15.2.3.14 Object.keys(O)
	var $keys       = __webpack_require__(52)
	  , enumBugKeys = __webpack_require__(62);
	
	module.exports = Object.keys || function keys(O){
	  return $keys(O, enumBugKeys);
	};

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	var has          = __webpack_require__(46)
	  , toIObject    = __webpack_require__(53)
	  , arrayIndexOf = __webpack_require__(56)(false)
	  , IE_PROTO     = __webpack_require__(59)('IE_PROTO');
	
	module.exports = function(object, names){
	  var O      = toIObject(object)
	    , i      = 0
	    , result = []
	    , key;
	  for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);
	  // Don't enum bug & hidden keys
	  while(names.length > i)if(has(O, key = names[i++])){
	    ~arrayIndexOf(result, key) || result.push(key);
	  }
	  return result;
	};

/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	// to indexed object, toObject with fallback for non-array-like ES3 strings
	var IObject = __webpack_require__(54)
	  , defined = __webpack_require__(27);
	module.exports = function(it){
	  return IObject(defined(it));
	};

/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	// fallback for non-array-like ES3 and non-enumerable old V8 strings
	var cof = __webpack_require__(55);
	module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){
	  return cof(it) == 'String' ? it.split('') : Object(it);
	};

/***/ },
/* 55 */
/***/ function(module, exports) {

	var toString = {}.toString;
	
	module.exports = function(it){
	  return toString.call(it).slice(8, -1);
	};

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	// false -> Array#indexOf
	// true  -> Array#includes
	var toIObject = __webpack_require__(53)
	  , toLength  = __webpack_require__(57)
	  , toIndex   = __webpack_require__(58);
	module.exports = function(IS_INCLUDES){
	  return function($this, el, fromIndex){
	    var O      = toIObject($this)
	      , length = toLength(O.length)
	      , index  = toIndex(fromIndex, length)
	      , value;
	    // Array#includes uses SameValueZero equality algorithm
	    if(IS_INCLUDES && el != el)while(length > index){
	      value = O[index++];
	      if(value != value)return true;
	    // Array#toIndex ignores holes, Array#includes - not
	    } else for(;length > index; index++)if(IS_INCLUDES || index in O){
	      if(O[index] === el)return IS_INCLUDES || index || 0;
	    } return !IS_INCLUDES && -1;
	  };
	};

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.15 ToLength
	var toInteger = __webpack_require__(26)
	  , min       = Math.min;
	module.exports = function(it){
	  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
	};

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	var toInteger = __webpack_require__(26)
	  , max       = Math.max
	  , min       = Math.min;
	module.exports = function(index, length){
	  index = toInteger(index);
	  return index < 0 ? max(index + length, 0) : min(index, length);
	};

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	var shared = __webpack_require__(60)('keys')
	  , uid    = __webpack_require__(61);
	module.exports = function(key){
	  return shared[key] || (shared[key] = uid(key));
	};

/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	var global = __webpack_require__(31)
	  , SHARED = '__core-js_shared__'
	  , store  = global[SHARED] || (global[SHARED] = {});
	module.exports = function(key){
	  return store[key] || (store[key] = {});
	};

/***/ },
/* 61 */
/***/ function(module, exports) {

	var id = 0
	  , px = Math.random();
	module.exports = function(key){
	  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
	};

/***/ },
/* 62 */
/***/ function(module, exports) {

	// IE 8- don't enum bug keys
	module.exports = (
	  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
	).split(',');

/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(31).document && document.documentElement;

/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	var def = __webpack_require__(36).f
	  , has = __webpack_require__(46)
	  , TAG = __webpack_require__(65)('toStringTag');
	
	module.exports = function(it, tag, stat){
	  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});
	};

/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	var store      = __webpack_require__(60)('wks')
	  , uid        = __webpack_require__(61)
	  , Symbol     = __webpack_require__(31).Symbol
	  , USE_SYMBOL = typeof Symbol == 'function';
	
	var $exports = module.exports = function(name){
	  return store[name] || (store[name] =
	    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
	};
	
	$exports.store = store;

/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
	var has         = __webpack_require__(46)
	  , toObject    = __webpack_require__(67)
	  , IE_PROTO    = __webpack_require__(59)('IE_PROTO')
	  , ObjectProto = Object.prototype;
	
	module.exports = Object.getPrototypeOf || function(O){
	  O = toObject(O);
	  if(has(O, IE_PROTO))return O[IE_PROTO];
	  if(typeof O.constructor == 'function' && O instanceof O.constructor){
	    return O.constructor.prototype;
	  } return O instanceof Object ? ObjectProto : null;
	};

/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.13 ToObject(argument)
	var defined = __webpack_require__(27);
	module.exports = function(it){
	  return Object(defined(it));
	};

/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(69);
	var global        = __webpack_require__(31)
	  , hide          = __webpack_require__(35)
	  , Iterators     = __webpack_require__(47)
	  , TO_STRING_TAG = __webpack_require__(65)('toStringTag');
	
	for(var collections = ['NodeList', 'DOMTokenList', 'MediaList', 'StyleSheetList', 'CSSRuleList'], i = 0; i < 5; i++){
	  var NAME       = collections[i]
	    , Collection = global[NAME]
	    , proto      = Collection && Collection.prototype;
	  if(proto && !proto[TO_STRING_TAG])hide(proto, TO_STRING_TAG, NAME);
	  Iterators[NAME] = Iterators.Array;
	}

/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var addToUnscopables = __webpack_require__(70)
	  , step             = __webpack_require__(71)
	  , Iterators        = __webpack_require__(47)
	  , toIObject        = __webpack_require__(53);
	
	// 22.1.3.4 Array.prototype.entries()
	// 22.1.3.13 Array.prototype.keys()
	// 22.1.3.29 Array.prototype.values()
	// 22.1.3.30 Array.prototype[@@iterator]()
	module.exports = __webpack_require__(28)(Array, 'Array', function(iterated, kind){
	  this._t = toIObject(iterated); // target
	  this._i = 0;                   // next index
	  this._k = kind;                // kind
	// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
	}, function(){
	  var O     = this._t
	    , kind  = this._k
	    , index = this._i++;
	  if(!O || index >= O.length){
	    this._t = undefined;
	    return step(1);
	  }
	  if(kind == 'keys'  )return step(0, index);
	  if(kind == 'values')return step(0, O[index]);
	  return step(0, [index, O[index]]);
	}, 'values');
	
	// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
	Iterators.Arguments = Iterators.Array;
	
	addToUnscopables('keys');
	addToUnscopables('values');
	addToUnscopables('entries');

/***/ },
/* 70 */
/***/ function(module, exports) {

	module.exports = function(){ /* empty */ };

/***/ },
/* 71 */
/***/ function(module, exports) {

	module.exports = function(done, value){
	  return {value: value, done: !!done};
	};

/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

	exports.f = __webpack_require__(65);

/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(74), __esModule: true };

/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(75);
	__webpack_require__(86);
	__webpack_require__(87);
	__webpack_require__(88);
	module.exports = __webpack_require__(32).Symbol;

/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// ECMAScript 6 symbols shim
	var global         = __webpack_require__(31)
	  , has            = __webpack_require__(46)
	  , DESCRIPTORS    = __webpack_require__(40)
	  , $export        = __webpack_require__(30)
	  , redefine       = __webpack_require__(45)
	  , META           = __webpack_require__(76).KEY
	  , $fails         = __webpack_require__(41)
	  , shared         = __webpack_require__(60)
	  , setToStringTag = __webpack_require__(64)
	  , uid            = __webpack_require__(61)
	  , wks            = __webpack_require__(65)
	  , wksExt         = __webpack_require__(72)
	  , wksDefine      = __webpack_require__(77)
	  , keyOf          = __webpack_require__(78)
	  , enumKeys       = __webpack_require__(79)
	  , isArray        = __webpack_require__(82)
	  , anObject       = __webpack_require__(37)
	  , toIObject      = __webpack_require__(53)
	  , toPrimitive    = __webpack_require__(43)
	  , createDesc     = __webpack_require__(44)
	  , _create        = __webpack_require__(49)
	  , gOPNExt        = __webpack_require__(83)
	  , $GOPD          = __webpack_require__(85)
	  , $DP            = __webpack_require__(36)
	  , $keys          = __webpack_require__(51)
	  , gOPD           = $GOPD.f
	  , dP             = $DP.f
	  , gOPN           = gOPNExt.f
	  , $Symbol        = global.Symbol
	  , $JSON          = global.JSON
	  , _stringify     = $JSON && $JSON.stringify
	  , PROTOTYPE      = 'prototype'
	  , HIDDEN         = wks('_hidden')
	  , TO_PRIMITIVE   = wks('toPrimitive')
	  , isEnum         = {}.propertyIsEnumerable
	  , SymbolRegistry = shared('symbol-registry')
	  , AllSymbols     = shared('symbols')
	  , OPSymbols      = shared('op-symbols')
	  , ObjectProto    = Object[PROTOTYPE]
	  , USE_NATIVE     = typeof $Symbol == 'function'
	  , QObject        = global.QObject;
	// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
	var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;
	
	// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
	var setSymbolDesc = DESCRIPTORS && $fails(function(){
	  return _create(dP({}, 'a', {
	    get: function(){ return dP(this, 'a', {value: 7}).a; }
	  })).a != 7;
	}) ? function(it, key, D){
	  var protoDesc = gOPD(ObjectProto, key);
	  if(protoDesc)delete ObjectProto[key];
	  dP(it, key, D);
	  if(protoDesc && it !== ObjectProto)dP(ObjectProto, key, protoDesc);
	} : dP;
	
	var wrap = function(tag){
	  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
	  sym._k = tag;
	  return sym;
	};
	
	var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function(it){
	  return typeof it == 'symbol';
	} : function(it){
	  return it instanceof $Symbol;
	};
	
	var $defineProperty = function defineProperty(it, key, D){
	  if(it === ObjectProto)$defineProperty(OPSymbols, key, D);
	  anObject(it);
	  key = toPrimitive(key, true);
	  anObject(D);
	  if(has(AllSymbols, key)){
	    if(!D.enumerable){
	      if(!has(it, HIDDEN))dP(it, HIDDEN, createDesc(1, {}));
	      it[HIDDEN][key] = true;
	    } else {
	      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;
	      D = _create(D, {enumerable: createDesc(0, false)});
	    } return setSymbolDesc(it, key, D);
	  } return dP(it, key, D);
	};
	var $defineProperties = function defineProperties(it, P){
	  anObject(it);
	  var keys = enumKeys(P = toIObject(P))
	    , i    = 0
	    , l = keys.length
	    , key;
	  while(l > i)$defineProperty(it, key = keys[i++], P[key]);
	  return it;
	};
	var $create = function create(it, P){
	  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
	};
	var $propertyIsEnumerable = function propertyIsEnumerable(key){
	  var E = isEnum.call(this, key = toPrimitive(key, true));
	  if(this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return false;
	  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
	};
	var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){
	  it  = toIObject(it);
	  key = toPrimitive(key, true);
	  if(it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return;
	  var D = gOPD(it, key);
	  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;
	  return D;
	};
	var $getOwnPropertyNames = function getOwnPropertyNames(it){
	  var names  = gOPN(toIObject(it))
	    , result = []
	    , i      = 0
	    , key;
	  while(names.length > i){
	    if(!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META)result.push(key);
	  } return result;
	};
	var $getOwnPropertySymbols = function getOwnPropertySymbols(it){
	  var IS_OP  = it === ObjectProto
	    , names  = gOPN(IS_OP ? OPSymbols : toIObject(it))
	    , result = []
	    , i      = 0
	    , key;
	  while(names.length > i){
	    if(has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true))result.push(AllSymbols[key]);
	  } return result;
	};
	
	// 19.4.1.1 Symbol([description])
	if(!USE_NATIVE){
	  $Symbol = function Symbol(){
	    if(this instanceof $Symbol)throw TypeError('Symbol is not a constructor!');
	    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
	    var $set = function(value){
	      if(this === ObjectProto)$set.call(OPSymbols, value);
	      if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;
	      setSymbolDesc(this, tag, createDesc(1, value));
	    };
	    if(DESCRIPTORS && setter)setSymbolDesc(ObjectProto, tag, {configurable: true, set: $set});
	    return wrap(tag);
	  };
	  redefine($Symbol[PROTOTYPE], 'toString', function toString(){
	    return this._k;
	  });
	
	  $GOPD.f = $getOwnPropertyDescriptor;
	  $DP.f   = $defineProperty;
	  __webpack_require__(84).f = gOPNExt.f = $getOwnPropertyNames;
	  __webpack_require__(81).f  = $propertyIsEnumerable;
	  __webpack_require__(80).f = $getOwnPropertySymbols;
	
	  if(DESCRIPTORS && !__webpack_require__(29)){
	    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
	  }
	
	  wksExt.f = function(name){
	    return wrap(wks(name));
	  }
	}
	
	$export($export.G + $export.W + $export.F * !USE_NATIVE, {Symbol: $Symbol});
	
	for(var symbols = (
	  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
	  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
	).split(','), i = 0; symbols.length > i; )wks(symbols[i++]);
	
	for(var symbols = $keys(wks.store), i = 0; symbols.length > i; )wksDefine(symbols[i++]);
	
	$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
	  // 19.4.2.1 Symbol.for(key)
	  'for': function(key){
	    return has(SymbolRegistry, key += '')
	      ? SymbolRegistry[key]
	      : SymbolRegistry[key] = $Symbol(key);
	  },
	  // 19.4.2.5 Symbol.keyFor(sym)
	  keyFor: function keyFor(key){
	    if(isSymbol(key))return keyOf(SymbolRegistry, key);
	    throw TypeError(key + ' is not a symbol!');
	  },
	  useSetter: function(){ setter = true; },
	  useSimple: function(){ setter = false; }
	});
	
	$export($export.S + $export.F * !USE_NATIVE, 'Object', {
	  // 19.1.2.2 Object.create(O [, Properties])
	  create: $create,
	  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
	  defineProperty: $defineProperty,
	  // 19.1.2.3 Object.defineProperties(O, Properties)
	  defineProperties: $defineProperties,
	  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
	  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
	  // 19.1.2.7 Object.getOwnPropertyNames(O)
	  getOwnPropertyNames: $getOwnPropertyNames,
	  // 19.1.2.8 Object.getOwnPropertySymbols(O)
	  getOwnPropertySymbols: $getOwnPropertySymbols
	});
	
	// 24.3.2 JSON.stringify(value [, replacer [, space]])
	$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function(){
	  var S = $Symbol();
	  // MS Edge converts symbol values to JSON as {}
	  // WebKit converts symbol values to JSON as null
	  // V8 throws on boxed symbols
	  return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';
	})), 'JSON', {
	  stringify: function stringify(it){
	    if(it === undefined || isSymbol(it))return; // IE8 returns string on undefined
	    var args = [it]
	      , i    = 1
	      , replacer, $replacer;
	    while(arguments.length > i)args.push(arguments[i++]);
	    replacer = args[1];
	    if(typeof replacer == 'function')$replacer = replacer;
	    if($replacer || !isArray(replacer))replacer = function(key, value){
	      if($replacer)value = $replacer.call(this, key, value);
	      if(!isSymbol(value))return value;
	    };
	    args[1] = replacer;
	    return _stringify.apply($JSON, args);
	  }
	});
	
	// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
	$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(35)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
	// 19.4.3.5 Symbol.prototype[@@toStringTag]
	setToStringTag($Symbol, 'Symbol');
	// 20.2.1.9 Math[@@toStringTag]
	setToStringTag(Math, 'Math', true);
	// 24.3.3 JSON[@@toStringTag]
	setToStringTag(global.JSON, 'JSON', true);

/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	var META     = __webpack_require__(61)('meta')
	  , isObject = __webpack_require__(38)
	  , has      = __webpack_require__(46)
	  , setDesc  = __webpack_require__(36).f
	  , id       = 0;
	var isExtensible = Object.isExtensible || function(){
	  return true;
	};
	var FREEZE = !__webpack_require__(41)(function(){
	  return isExtensible(Object.preventExtensions({}));
	});
	var setMeta = function(it){
	  setDesc(it, META, {value: {
	    i: 'O' + ++id, // object ID
	    w: {}          // weak collections IDs
	  }});
	};
	var fastKey = function(it, create){
	  // return primitive with prefix
	  if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
	  if(!has(it, META)){
	    // can't set metadata to uncaught frozen object
	    if(!isExtensible(it))return 'F';
	    // not necessary to add metadata
	    if(!create)return 'E';
	    // add missing metadata
	    setMeta(it);
	  // return object ID
	  } return it[META].i;
	};
	var getWeak = function(it, create){
	  if(!has(it, META)){
	    // can't set metadata to uncaught frozen object
	    if(!isExtensible(it))return true;
	    // not necessary to add metadata
	    if(!create)return false;
	    // add missing metadata
	    setMeta(it);
	  // return hash weak collections IDs
	  } return it[META].w;
	};
	// add metadata on freeze-family methods calling
	var onFreeze = function(it){
	  if(FREEZE && meta.NEED && isExtensible(it) && !has(it, META))setMeta(it);
	  return it;
	};
	var meta = module.exports = {
	  KEY:      META,
	  NEED:     false,
	  fastKey:  fastKey,
	  getWeak:  getWeak,
	  onFreeze: onFreeze
	};

/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	var global         = __webpack_require__(31)
	  , core           = __webpack_require__(32)
	  , LIBRARY        = __webpack_require__(29)
	  , wksExt         = __webpack_require__(72)
	  , defineProperty = __webpack_require__(36).f;
	module.exports = function(name){
	  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
	  if(name.charAt(0) != '_' && !(name in $Symbol))defineProperty($Symbol, name, {value: wksExt.f(name)});
	};

/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	var getKeys   = __webpack_require__(51)
	  , toIObject = __webpack_require__(53);
	module.exports = function(object, el){
	  var O      = toIObject(object)
	    , keys   = getKeys(O)
	    , length = keys.length
	    , index  = 0
	    , key;
	  while(length > index)if(O[key = keys[index++]] === el)return key;
	};

/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	// all enumerable object keys, includes symbols
	var getKeys = __webpack_require__(51)
	  , gOPS    = __webpack_require__(80)
	  , pIE     = __webpack_require__(81);
	module.exports = function(it){
	  var result     = getKeys(it)
	    , getSymbols = gOPS.f;
	  if(getSymbols){
	    var symbols = getSymbols(it)
	      , isEnum  = pIE.f
	      , i       = 0
	      , key;
	    while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))result.push(key);
	  } return result;
	};

/***/ },
/* 80 */
/***/ function(module, exports) {

	exports.f = Object.getOwnPropertySymbols;

/***/ },
/* 81 */
/***/ function(module, exports) {

	exports.f = {}.propertyIsEnumerable;

/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

	// 7.2.2 IsArray(argument)
	var cof = __webpack_require__(55);
	module.exports = Array.isArray || function isArray(arg){
	  return cof(arg) == 'Array';
	};

/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

	// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
	var toIObject = __webpack_require__(53)
	  , gOPN      = __webpack_require__(84).f
	  , toString  = {}.toString;
	
	var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
	  ? Object.getOwnPropertyNames(window) : [];
	
	var getWindowNames = function(it){
	  try {
	    return gOPN(it);
	  } catch(e){
	    return windowNames.slice();
	  }
	};
	
	module.exports.f = function getOwnPropertyNames(it){
	  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
	};


/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
	var $keys      = __webpack_require__(52)
	  , hiddenKeys = __webpack_require__(62).concat('length', 'prototype');
	
	exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O){
	  return $keys(O, hiddenKeys);
	};

/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	var pIE            = __webpack_require__(81)
	  , createDesc     = __webpack_require__(44)
	  , toIObject      = __webpack_require__(53)
	  , toPrimitive    = __webpack_require__(43)
	  , has            = __webpack_require__(46)
	  , IE8_DOM_DEFINE = __webpack_require__(39)
	  , gOPD           = Object.getOwnPropertyDescriptor;
	
	exports.f = __webpack_require__(40) ? gOPD : function getOwnPropertyDescriptor(O, P){
	  O = toIObject(O);
	  P = toPrimitive(P, true);
	  if(IE8_DOM_DEFINE)try {
	    return gOPD(O, P);
	  } catch(e){ /* empty */ }
	  if(has(O, P))return createDesc(!pIE.f.call(O, P), O[P]);
	};

/***/ },
/* 86 */
/***/ function(module, exports) {



/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(77)('asyncIterator');

/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(77)('observable');

/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _setPrototypeOf = __webpack_require__(90);
	
	var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);
	
	var _create = __webpack_require__(94);
	
	var _create2 = _interopRequireDefault(_create);
	
	var _typeof2 = __webpack_require__(21);
	
	var _typeof3 = _interopRequireDefault(_typeof2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function (subClass, superClass) {
	  if (typeof superClass !== "function" && superClass !== null) {
	    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : (0, _typeof3.default)(superClass)));
	  }
	
	  subClass.prototype = (0, _create2.default)(superClass && superClass.prototype, {
	    constructor: {
	      value: subClass,
	      enumerable: false,
	      writable: true,
	      configurable: true
	    }
	  });
	  if (superClass) _setPrototypeOf2.default ? (0, _setPrototypeOf2.default)(subClass, superClass) : subClass.__proto__ = superClass;
	};

/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(91), __esModule: true };

/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(92);
	module.exports = __webpack_require__(32).Object.setPrototypeOf;

/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.3.19 Object.setPrototypeOf(O, proto)
	var $export = __webpack_require__(30);
	$export($export.S, 'Object', {setPrototypeOf: __webpack_require__(93).set});

/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	// Works with __proto__ only. Old v8 can't work with null proto objects.
	/* eslint-disable no-proto */
	var isObject = __webpack_require__(38)
	  , anObject = __webpack_require__(37);
	var check = function(O, proto){
	  anObject(O);
	  if(!isObject(proto) && proto !== null)throw TypeError(proto + ": can't set as prototype!");
	};
	module.exports = {
	  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
	    function(test, buggy, set){
	      try {
	        set = __webpack_require__(33)(Function.call, __webpack_require__(85).f(Object.prototype, '__proto__').set, 2);
	        set(test, []);
	        buggy = !(test instanceof Array);
	      } catch(e){ buggy = true; }
	      return function setPrototypeOf(O, proto){
	        check(O, proto);
	        if(buggy)O.__proto__ = proto;
	        else set(O, proto);
	        return O;
	      };
	    }({}, false) : undefined),
	  check: check
	};

/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(95), __esModule: true };

/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(96);
	var $Object = __webpack_require__(32).Object;
	module.exports = function create(P, D){
	  return $Object.create(P, D);
	};

/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(30)
	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
	$export($export.S, 'Object', {create: __webpack_require__(49)});

/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _classCallCheck2 = __webpack_require__(2);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _guid = __webpack_require__(98);
	
	var _guid2 = _interopRequireDefault(_guid);
	
	var _classie = __webpack_require__(99);
	
	var _classie2 = _interopRequireDefault(_classie);
	
	var _Utils = __webpack_require__(103);
	
	var _Utils2 = _interopRequireDefault(_Utils);
	
	var _merge = __webpack_require__(106);
	
	var _merge2 = _interopRequireDefault(_merge);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var Component = function () {
	    function Component(element) {
	        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	        (0, _classCallCheck3.default)(this, Component);
	
	        this.element = typeof element === 'string' ? { container: document.querySelector(element) } : { container: element };
	
	        this.settings = (0, _merge2.default)({}, this.getDefaultOptions(), options);
	        this.events = {};
	        this.state = new Map();
	        this.listeners = new Map();
	
	        this._id = _guid2.default.create().toString().replace(/\-/ig, "0");
	        this.id = this.id.bind(this);
	    }
	
	    Component.prototype.id = function id() {
	        return this._id;
	    };
	
	    Component.prototype.query = function query(selector) {
	        return Array.from(this.element.container.querySelectorAll(selector));
	    };
	
	    Component.prototype.queryClass = function queryClass(selector) {
	        return Array.from(this.element.container.getElementsByClassName(selector));
	    };
	
	    Component.prototype.getDefaultOptions = function getDefaultOptions() {
	        return {};
	    };
	
	    Component.prototype.setInitialState = function setInitialState() {
	        return this.state;
	    };
	
	    Component.prototype.getState = function getState() {
	        var key = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;
	
	        return typeof key === 'undefined' ? this.state : this.state.get(key);
	    };
	
	    Component.prototype.setState = function setState(key, newValue) {
	        var oldValue = this.state.get(key);
	        if (oldValue !== newValue) {
	            this.state.set(key, newValue);
	        }
	    };
	
	    Component.prototype.getListeners = function getListeners() {
	        return this.listeners;
	    };
	
	    Component.prototype.setListener = function setListener(key, context, value) {
	
	        var scope = typeof context === 'string' ? document.querySelectorAll(context) : context;
	        var addListener = function addListener(key, scope, value) {
	            if (scope.hasOwnProperty(length)) {
	                for (var i = scope.length; i--;) {
	                    scope[i].addEventListener(key, value, false);
	                }
	            } else {
	                scope.addEventListener(key, value, false);
	            }
	        };
	
	        if (this.listeners.has(scope)) {
	            var oldMap = this.listeners.get(scope);
	            if (oldMap.has(key)) {
	                var oldFunctions = oldMap.get(key);
	                if (oldFunctions.indexOf(value) === -1) {
	                    oldFunctions.push(value);
	                    addListener(key, scope, value);
	                }
	            } else {
	                var newItem = new Map();
	                newItem.set(key, [value]);
	                this.listeners.set(scope, newItem);
	                addListener(key, scope, value);
	            }
	        } else {
	            var _newItem = new Map();
	            _newItem.set(key, [value]);
	            this.listeners.set(scope, _newItem);
	            addListener(key, scope, value);
	        }
	
	        return this.listeners;
	    };
	
	    Component.prototype.data = function data(key, value) {
	        if (value !== undefined) {
	            _Utils2.default.Data(key, value);
	        } else {
	            return _Utils2.default.Data(key);
	        }
	    };
	
	    Component.prototype.getSizeForQueryString = function getSizeForQueryString(el, defaultHeight) {
	        if (el.offsetHeight == 0) return "height=" + defaultHeight;else return "height=" + el.offsetHeight + "&width=" + el.offsetWidth;
	    };
	
	    Component.prototype.find = function find(el, selector) {
	        var nodes = el.querySelectorAll(selector);
	        return nodes.length <= 0 ? null : nodes[0];
	    };
	
	    return Component;
	}();
	
	exports.default = Component;

/***/ },
/* 98 */
/***/ function(module, exports) {

	(function () {
	  var validator = new RegExp("^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$", "i");
	
	  function gen(count) {
	    var out = "";
	    for (var i=0; i<count; i++) {
	      out += (((1+Math.random())*0x10000)|0).toString(16).substring(1);
	    }
	    return out;
	  }
	
	  function Guid(guid) {
	    if (!guid) throw new TypeError("Invalid argument; `value` has no value.");
	      
	    this.value = Guid.EMPTY;
	    
	    if (guid && guid instanceof Guid) {
	      this.value = guid.toString();
	
	    } else if (guid && Object.prototype.toString.call(guid) === "[object String]" && Guid.isGuid(guid)) {
	      this.value = guid;
	    }
	    
	    this.equals = function(other) {
	      // Comparing string `value` against provided `guid` will auto-call
	      // toString on `guid` for comparison
	      return Guid.isGuid(other) && this.value == other;
	    };
	
	    this.isEmpty = function() {
	      return this.value === Guid.EMPTY;
	    };
	    
	    this.toString = function() {
	      return this.value;
	    };
	    
	    this.toJSON = function() {
	      return this.value;
	    };
	  };
	
	  Guid.EMPTY = "00000000-0000-0000-0000-000000000000";
	
	  Guid.isGuid = function(value) {
	    return value && (value instanceof Guid || validator.test(value.toString()));
	  };
	
	  Guid.create = function() {
	    return new Guid([gen(2), gen(1), gen(1), gen(1), gen(3)].join("-"));
	  };
	
	  Guid.raw = function() {
	    return [gen(2), gen(1), gen(1), gen(1), gen(3)].join("-");
	  };
	
	  if(typeof module != 'undefined' && module.exports) {
	    module.exports = Guid;
	  }
	  else if (typeof window != 'undefined') {
	    window.Guid = Guid;
	  }
	})();


/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * classie
	 * http://github.amexpub.com/modules/classie
	 *
	 * Copyright (c) 2013 AmexPub. All rights reserved.
	 */
	
	module.exports = __webpack_require__(100);


/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module) {/*!
	 * classie - class helper functions
	 * from bonzo https://github.com/ded/bonzo
	 * 
	 * classie.has( elem, 'my-class' ) -> true/false
	 * classie.add( elem, 'my-new-class' )
	 * classie.remove( elem, 'my-unwanted-class' )
	 * classie.toggle( elem, 'my-class' )
	 */
	
	/*jshint browser: true, strict: true, undef: true */
	/*global define: false */
	'use strict';
	
	// class helper functions from bonzo https://github.com/ded/bonzo
	var classList = __webpack_require__(102),
	    classie;
	
	function classReg(className) {
	    return new RegExp("(^|\\s+)" + className + "(\\s+|$)");
	}
	
	function noop() {}
	
	function isArr(classes) {
	    if (Array.isArray(classes)) {
	        return true;
	    } else if (Object.prototype.toString.call(classes) === '[object Array]') {
	        return true;
	    } else {
	        return false;
	    }
	}
	
	function removeMultiple() {
	    var c = arguments[1],
	        elem = arguments[0];
	    c.forEach(function(value) {
	        if (classie.has(elem, value)) {
	            noop();
	        }
	        classie.removeClass(elem, value);
	    });
	}
	
	
	function addMultiple() {
	    var c = arguments[1],
	        elem = arguments[0];
	    c.forEach(function(value) {
	        if (classie.has(elem, value)) {
	            noop();
	        }
	        classie.addClass(elem, value);
	    });
	}
	
	function hasClass(elem, c) {
	    return elem.classList.contains(c);
	}
	
	function addClass(elem, c) {
	    if (isArr(c)) {
	        addMultiple.apply(this, arguments);
	    } else {
	        elem.classList.add(c);
	    }
	}
	
	function removeClass(elem, c) {
	    if (isArr(c)) {
	        removeMultiple.apply(this, arguments);
	    } else {
	        elem.classList.remove(c);
	    }
	}
	
	function toggleClass(elem, c) {
	    var fn = hasClass(elem, c) ? removeClass : addClass;
	    fn(elem, c);
	}
	
	var classie = {
	    // full names
	    hasClass: hasClass,
	    addClass: addClass,
	    removeClass: removeClass,
	    toggleClass: toggleClass,
	    // short names
	    has: hasClass,
	    add: addClass,
	    remove: removeClass,
	    toggle: toggleClass
	};
	
	// transport
	
	if (typeof module === "object" && module && typeof module.exports === "object") {
	    // commonjs / browserify
	    module.exports = classie;
	} else {
	    // AMD
	    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (classie), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(101)(module)))

/***/ },
/* 101 */
/***/ function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 102 */
/***/ function(module, exports) {

	/* 
	 * classList.js: Cross-browser full element.classList implementation.
	 * 2014-07-23
	 *
	 * By Eli Grey, http://eligrey.com
	 * Public Domain.
	 * NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.
	 */
	
	/*global self, document, DOMException, DOMTokenList */
	
	/*! @source http://purl.eligrey.com/github/classList.js/blob/master/classList.js*/
	
	if ("document" in self) {
	
	    // Full polyfill for browsers with no classList support
	    if (!("classList" in document.createElement("_")) || document.createElementNS && !("classList" in document.createElementNS("http://www.w3.org/2000/svg", "g"))) {
	
	        (function(view) {
	
	            "use strict";
	
	            if (!('Element' in view)) {
	                return;
	            }
	
	            var classListProp = "classList",
	                protoProp = "prototype",
	                elemCtrProto = view.Element[protoProp],
	                objCtr = Object,
	                strTrim = String[protoProp].trim || function() {
	                    return this.replace(/^\s+|\s+$/g, "");
	                }, arrIndexOf = Array[protoProp].indexOf || function(item) {
	                    var
	                    i = 0,
	                        len = this.length;
	                    for (; i < len; i++) {
	                        if (i in this && this[i] === item) {
	                            return i;
	                        }
	                    }
	                    return -1;
	                },
	                // Vendors: please allow content code to instantiate DOMExceptions
	                DOMEx = function(type, message) {
	                    this.name = type;
	                    this.code = DOMException[type];
	                    this.message = message;
	                }, checkTokenAndGetIndex = function(classList, token) {
	                    if (token === "") {
	                        throw new DOMEx(
	                            "SYNTAX_ERR", "An invalid or illegal string was specified");
	                    }
	                    if (/\s/.test(token)) {
	                        throw new DOMEx(
	                            "INVALID_CHARACTER_ERR", "String contains an invalid character");
	                    }
	                    return arrIndexOf.call(classList, token);
	                }, ClassList = function(elem) {
	                    var
	                    trimmedClasses = strTrim.call(elem.getAttribute("class") || ""),
	                        classes = trimmedClasses ? trimmedClasses.split(/\s+/) : [],
	                        i = 0,
	                        len = classes.length;
	                    for (; i < len; i++) {
	                        this.push(classes[i]);
	                    }
	                    this._updateClassName = function() {
	                        elem.setAttribute("class", this.toString());
	                    };
	                }, classListProto = ClassList[protoProp] = [],
	                classListGetter = function() {
	                    return new ClassList(this);
	                };
	            // Most DOMException implementations don't allow calling DOMException's toString()
	            // on non-DOMExceptions. Error's toString() is sufficient here.
	            DOMEx[protoProp] = Error[protoProp];
	            classListProto.item = function(i) {
	                return this[i] || null;
	            };
	            classListProto.contains = function(token) {
	                token += "";
	                return checkTokenAndGetIndex(this, token) !== -1;
	            };
	            classListProto.add = function() {
	                var
	                tokens = arguments,
	                    i = 0,
	                    l = tokens.length,
	                    token, updated = false;
	                do {
	                    token = tokens[i] + "";
	                    if (checkTokenAndGetIndex(this, token) === -1) {
	                        this.push(token);
	                        updated = true;
	                    }
	                }
	                while (++i < l);
	
	                if (updated) {
	                    this._updateClassName();
	                }
	            };
	            classListProto.remove = function() {
	                var
	                tokens = arguments,
	                    i = 0,
	                    l = tokens.length,
	                    token, updated = false,
	                    index;
	                do {
	                    token = tokens[i] + "";
	                    index = checkTokenAndGetIndex(this, token);
	                    while (index !== -1) {
	                        this.splice(index, 1);
	                        updated = true;
	                        index = checkTokenAndGetIndex(this, token);
	                    }
	                }
	                while (++i < l);
	
	                if (updated) {
	                    this._updateClassName();
	                }
	            };
	            classListProto.toggle = function(token, force) {
	                token += "";
	
	                var
	                result = this.contains(token),
	                    method = result ?
	                        force !== true && "remove" :
	                        force !== false && "add";
	
	                if (method) {
	                    this[method](token);
	                }
	
	                if (force === true || force === false) {
	                    return force;
	                } else {
	                    return !result;
	                }
	            };
	            classListProto.toString = function() {
	                return this.join(" ");
	            };
	
	            if (objCtr.defineProperty) {
	                var classListPropDesc = {
	                    get: classListGetter,
	                    enumerable: true,
	                    configurable: true
	                };
	                try {
	                    objCtr.defineProperty(elemCtrProto, classListProp, classListPropDesc);
	                } catch (ex) { // IE 8 doesn't support enumerable:true
	                    if (ex.number === -0x7FF5EC54) {
	                        classListPropDesc.enumerable = false;
	                        objCtr.defineProperty(elemCtrProto, classListProp, classListPropDesc);
	                    }
	                }
	            } else if (objCtr[protoProp].__defineGetter__) {
	                elemCtrProto.__defineGetter__(classListProp, classListGetter);
	            }
	
	        }(self));
	
	    } else {
	        // There is full or partial native classList support, so just check if we need
	        // to normalize the add/remove and toggle APIs.
	
	        (function() {
	            "use strict";
	
	            var testElement = document.createElement("_");
	
	            testElement.classList.add("c1", "c2");
	
	            // Polyfill for IE 10/11 and Firefox <26, where classList.add and
	            // classList.remove exist but support only one argument at a time.
	            if (!testElement.classList.contains("c2")) {
	                var createMethod = function(method) {
	                    var original = DOMTokenList.prototype[method];
	
	                    DOMTokenList.prototype[method] = function(token) {
	                        var i, len = arguments.length;
	
	                        for (i = 0; i < len; i++) {
	                            token = arguments[i];
	                            original.call(this, token);
	                        }
	                    };
	                };
	                createMethod('add');
	                createMethod('remove');
	            }
	
	            testElement.classList.toggle("c3", false);
	
	            // Polyfill for IE 10 and Firefox <24, where classList.toggle does not
	            // support the second argument.
	            if (testElement.classList.contains("c3")) {
	                var _toggle = DOMTokenList.prototype.toggle;
	
	                DOMTokenList.prototype.toggle = function(token, force) {
	                    if (1 in arguments && !this.contains(token) === !force) {
	                        return force;
	                    } else {
	                        return _toggle.call(this, token);
	                    }
	                };
	
	            }
	
	            testElement = null;
	        }());
	    }
	
	}


/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _classCallCheck2 = __webpack_require__(2);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _guid = __webpack_require__(98);
	
	var _guid2 = _interopRequireDefault(_guid);
	
	var _base = __webpack_require__(104);
	
	var _base2 = _interopRequireDefault(_base);
	
	var _sweetalert = __webpack_require__(105);
	
	var _sweetalert2 = _interopRequireDefault(_sweetalert);
	
	var _merge = __webpack_require__(106);
	
	var _merge2 = _interopRequireDefault(_merge);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var Utils = function () {
	    function Utils() {
	        (0, _classCallCheck3.default)(this, Utils);
	    }
	
	    Utils.GetDefaultOptions = function GetDefaultOptions() {
	        return {
	            alerts: {
	                showCancelButton: false,
	                confirmLabel: "Ok",
	                cancelLabel: "Cancel",
	                genericError: "An error occurred."
	            }
	        };
	    };
	
	    Utils.GetSettings = function GetSettings() {
	        if (!Utils.Settings) Utils.Settings = (0, _merge2.default)({}, Utils.GetDefaultOptions());
	        return Utils.Settings;
	    };
	
	    Utils.SetSettings = function SetSettings(options) {
	        return Utils.Settings = (0, _merge2.default)({}, Utils.GetDefaultOptions(), options);
	    };
	
	    //http://stackoverflow.com/questions/10716986/swap-2-html-elements-and-preserve-event-listeners-on-them
	
	
	    Utils.SwapElements = function SwapElements(obj1, obj2) {
	        // save the location of obj2
	        var parent2 = obj2.parentNode;
	        var next2 = obj2.nextSibling;
	
	        // special case for obj1 is the next sibling of obj2
	        if (next2 === obj1) {
	            // just put obj1 before obj2
	            parent2.insertBefore(obj1, obj2);
	        } else {
	            // insert obj2 right before obj1
	            obj1.parentNode.insertBefore(obj2, obj1);
	
	            // now insert obj1 where obj2 was
	            if (next2) {
	                // if there was an element after obj2, then insert obj1 right before that
	                parent2.insertBefore(obj1, next2);
	            } else {
	                // otherwise, just append as last child
	                parent2.appendChild(obj1);
	            }
	        }
	    };
	
	    Utils.ReplaceClass = function ReplaceClass(el, from, to) {
	        if (el.classList.contains(from)) {
	            el.classList.remove(from);
	            el.classList.add(to);
	        }
	    };
	
	    Utils.InvertUnsemanticGridPrefixSuffix = function InvertUnsemanticGridPrefixSuffix(obj) {
	        var tmpClass = "tmp_" + this.Uid() + "_class";
	        for (var i = 5; i < 100; i += 5) {
	            this.ReplaceClass(obj, "prefix-" + i, tmpClass + "-" + i);
	            this.ReplaceClass(obj, "suffix-" + i, "prefix-" + i);
	            this.ReplaceClass(obj, tmpClass + "-" + i, "suffix-" + i);
	        }
	    };
	
	    Utils.FadeSwapElements = function FadeSwapElements(obj1, obj2) {
	        var _this = this;
	
	        obj1.classList.add("fade-transition");
	        obj2.classList.add("fade-transition");
	
	        obj1.style.opacity = 0;
	        obj2.style.opacity = 0;
	
	        setTimeout(function () {
	
	            _this.InvertUnsemanticGridPrefixSuffix(obj1);
	            _this.InvertUnsemanticGridPrefixSuffix(obj2);
	
	            _this.SwapElements(obj1, obj2);
	
	            obj1.style.opacity = 1;
	            obj2.style.opacity = 1;
	
	            setTimeout(function () {
	                obj1.classList.remove("fade-transition");
	                obj2.classList.remove("fade-transition");
	            }, 400);
	        }, 400);
	    };
	
	    Utils.Data = function Data(el, key, value) {
	        if (value !== undefined) {
	            el.dataset[key] = value;
	        } else {
	            return el.dataset[key];
	        }
	    };
	
	    Utils.Uid = function Uid() {
	        return _guid2.default.create().toString();
	    };
	
	    Utils.EscapeTags = function EscapeTags(str) {
	        return String(str).replace(/&/g, '&amp;').replace(/"/g, '&quot;').replace(/'/g, '&#39;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
	    };
	
	    Utils.ObjToBase64 = function ObjToBase64(obj) {
	        return _base2.default.encode(JSON.stringify(obj));
	    };
	
	    Utils.Base64ToObj = function Base64ToObj(str) {
	        var defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	
	        try {
	            return JSON.parse(_base2.default.decode(str));
	        } catch (exc) {
	            return defaultValue;
	        }
	    };
	
	    Utils.FindAncestorByClass = function FindAncestorByClass(el, cls) {
	        while ((el = el.parentElement) && !el.classList.contains(cls)) {}
	        return el;
	    };
	
	    Utils.NoLang = function NoLang() {
	        return "no-lang";
	    };
	
	    Utils.AlertError = function AlertError(title, message, showCancel, confirmLabel, cancelLabel) {
	        return this.Alert("error", title || Utils.GetSettings().alerts.genericError, message, showCancel, confirmLabel, cancelLabel);
	    };
	
	    Utils.AlertWarning = function AlertWarning(title, message, showCancel, confirmLabel, cancelLabel) {
	        return this.Alert("warning", title, message, showCancel, confirmLabel, cancelLabel);
	    };
	
	    Utils.AlertInfo = function AlertInfo(title, message, showCancel, confirmLabel, cancelLabel) {
	        return this.Alert("info", title, message, showCancel, confirmLabel, cancelLabel);
	    };
	
	    Utils.Alert = function Alert(type, title, message, showCancel, confirmLabel, cancelLabel) {
	        return (0, _sweetalert2.default)({
	            title: title,
	            text: message || "",
	            type: type,
	            showCancelButton: showCancel || Utils.GetSettings().alerts.showCancelButton,
	            confirmButtonText: confirmLabel || Utils.GetSettings().alerts.confirmLabel,
	            cancelButtonText: cancelLabel || Utils.GetSettings().alerts.cancelLabel
	        });
	    };
	
	    return Utils;
	}();
	
	exports.default = Utils;

/***/ },
/* 104 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {/*! http://mths.be/base64 v0.1.0 by @mathias | MIT license */
	;(function(root) {
	
		// Detect free variables `exports`.
		var freeExports = typeof exports == 'object' && exports;
	
		// Detect free variable `module`.
		var freeModule = typeof module == 'object' && module &&
			module.exports == freeExports && module;
	
		// Detect free variable `global`, from Node.js or Browserified code, and use
		// it as `root`.
		var freeGlobal = typeof global == 'object' && global;
		if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
			root = freeGlobal;
		}
	
		/*--------------------------------------------------------------------------*/
	
		var InvalidCharacterError = function(message) {
			this.message = message;
		};
		InvalidCharacterError.prototype = new Error;
		InvalidCharacterError.prototype.name = 'InvalidCharacterError';
	
		var error = function(message) {
			// Note: the error messages used throughout this file match those used by
			// the native `atob`/`btoa` implementation in Chromium.
			throw new InvalidCharacterError(message);
		};
	
		var TABLE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
		// http://whatwg.org/html/common-microsyntaxes.html#space-character
		var REGEX_SPACE_CHARACTERS = /[\t\n\f\r ]/g;
	
		// `decode` is designed to be fully compatible with `atob` as described in the
		// HTML Standard. http://whatwg.org/html/webappapis.html#dom-windowbase64-atob
		// The optimized base64-decoding algorithm used is based on @atks excellent
		// implementation. https://gist.github.com/atk/1020396
		var decode = function(input) {
			input = String(input)
				.replace(REGEX_SPACE_CHARACTERS, '');
			var length = input.length;
			if (length % 4 == 0) {
				input = input.replace(/==?$/, '');
				length = input.length;
			}
			if (
				length % 4 == 1 ||
				// http://whatwg.org/C#alphanumeric-ascii-characters
				/[^+a-zA-Z0-9/]/.test(input)
			) {
				error(
					'Invalid character: the string to be decoded is not correctly encoded.'
				);
			}
			var bitCounter = 0;
			var bitStorage;
			var buffer;
			var output = '';
			var position = -1;
			while (++position < length) {
				buffer = TABLE.indexOf(input.charAt(position));
				bitStorage = bitCounter % 4 ? bitStorage * 64 + buffer : buffer;
				// Unless this is the first of a group of 4 characters
				if (bitCounter++ % 4) {
					// convert the first 8 bits to a single ASCII character.
					output += String.fromCharCode(
						0xFF & bitStorage >> (-2 * bitCounter & 6)
					);
				}
			}
			return output;
		};
	
		// `encode` is designed to be fully compatible with `btoa` as described in the
		// HTML Standard: http://whatwg.org/html/webappapis.html#dom-windowbase64-btoa
		var encode = function(input) {
			input = String(input);
			if (/[^\0-\xFF]/.test(input)) {
				// Note: no need to special-case astral symbols here, as surrogates are
				// matched, and the input is supposed to only contain ASCII anyway.
				error(
					'The string to be encoded contains characters outside of the ' +
					'Latin1 range.'
				);
			}
			var padding = input.length % 3;
			var output = '';
			var position = -1;
			var a;
			var b;
			var c;
			var d;
			var buffer;
			// Make sure any padding is handled outside of the loop.
			var length = input.length - padding;
	
			while (++position < length) {
				// Read three bytes, i.e. 24 bits.
				a = input.charCodeAt(position) << 16;
				b = input.charCodeAt(++position) << 8;
				c = input.charCodeAt(++position);
				buffer = a + b + c;
				// Turn the 24 bits into four chunks of 6 bits each, and append the
				// matching character for each of them to the output.
				output += (
					TABLE.charAt(buffer >> 18 & 0x3F) +
					TABLE.charAt(buffer >> 12 & 0x3F) +
					TABLE.charAt(buffer >> 6 & 0x3F) +
					TABLE.charAt(buffer & 0x3F)
				);
			}
	
			if (padding == 2) {
				a = input.charCodeAt(position) << 8;
				b = input.charCodeAt(++position);
				buffer = a + b;
				output += (
					TABLE.charAt(buffer >> 10) +
					TABLE.charAt((buffer >> 4) & 0x3F) +
					TABLE.charAt((buffer << 2) & 0x3F) +
					'='
				);
			} else if (padding == 1) {
				buffer = input.charCodeAt(position);
				output += (
					TABLE.charAt(buffer >> 2) +
					TABLE.charAt((buffer << 4) & 0x3F) +
					'=='
				);
			}
	
			return output;
		};
	
		var base64 = {
			'encode': encode,
			'decode': decode,
			'version': '0.1.0'
		};
	
		// Some AMD build optimizers, like r.js, check for specific condition patterns
		// like the following:
		if (
			true
		) {
			!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
				return base64;
			}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		}	else if (freeExports && !freeExports.nodeType) {
			if (freeModule) { // in Node.js or RingoJS v0.8.0+
				freeModule.exports = base64;
			} else { // in Narwhal or RingoJS v0.7.0-
				for (var key in base64) {
					base64.hasOwnProperty(key) && (freeExports[key] = base64[key]);
				}
			}
		} else { // in Rhino or a web browser
			root.base64 = base64;
		}
	
	}(this));
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(101)(module), (function() { return this; }())))

/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * sweetalert2 v6.2.0
	 * Released under the MIT License.
	 */
	(function (global, factory) {
	   true ? module.exports = factory() :
	  typeof define === 'function' && define.amd ? define(factory) :
	  (global.Sweetalert2 = factory());
	}(this, (function () { 'use strict';
	
	var swalPrefix = 'swal2-';
	
	var prefix = function prefix(items) {
	  var result = {};
	  for (var i in items) {
	    result[items[i]] = swalPrefix + items[i];
	  }
	  return result;
	};
	
	var swalClasses = prefix(['container', 'in', 'iosfix', 'modal', 'overlay', 'fade', 'show', 'hide', 'noanimation', 'close', 'title', 'content', 'spacer', 'confirm', 'cancel', 'icon', 'image', 'input', 'file', 'range', 'select', 'radio', 'checkbox', 'textarea', 'inputerror', 'validationerror', 'progresssteps', 'activeprogressstep', 'progresscircle', 'progressline', 'loading', 'styled']);
	
	var iconTypes = prefix(['success', 'warning', 'info', 'question', 'error']);
	
	var defaultParams = {
	  title: '',
	  text: '',
	  html: '',
	  type: null,
	  customClass: '',
	  animation: true,
	  allowOutsideClick: true,
	  allowEscapeKey: true,
	  showConfirmButton: true,
	  showCancelButton: false,
	  preConfirm: null,
	  confirmButtonText: 'OK',
	  confirmButtonColor: '#3085d6',
	  confirmButtonClass: null,
	  cancelButtonText: 'Cancel',
	  cancelButtonColor: '#aaa',
	  cancelButtonClass: null,
	  buttonsStyling: true,
	  reverseButtons: false,
	  focusCancel: false,
	  showCloseButton: false,
	  showLoaderOnConfirm: false,
	  imageUrl: null,
	  imageWidth: null,
	  imageHeight: null,
	  imageClass: null,
	  timer: null,
	  width: 500,
	  padding: 20,
	  background: '#fff',
	  input: null,
	  inputPlaceholder: '',
	  inputValue: '',
	  inputOptions: {},
	  inputAutoTrim: true,
	  inputClass: null,
	  inputAttributes: {},
	  inputValidator: null,
	  progressSteps: [],
	  currentProgressStep: null,
	  progressStepsDistance: '40px',
	  onOpen: null,
	  onClose: null
	};
	
	var sweetHTML = ('\n  <div class="' + swalClasses.modal + '" style="display: none" tabIndex="-1">\n    <ul class="' + swalClasses.progresssteps + '"></ul>\n    <div class="' + swalClasses.icon + ' ' + iconTypes.error + '">\n      <span class="x-mark"><span class="line left"></span><span class="line right"></span></span>\n    </div>\n    <div class="' + swalClasses.icon + ' ' + iconTypes.question + '">?</div>\n    <div class="' + swalClasses.icon + ' ' + iconTypes.warning + '">!</div>\n    <div class="' + swalClasses.icon + ' ' + iconTypes.info + '">i</div>\n    <div class="' + swalClasses.icon + ' ' + iconTypes.success + '">\n      <span class="line tip"></span> <span class="line long"></span>\n      <div class="placeholder"></div> <div class="fix"></div>\n    </div>\n    <img class="' + swalClasses.image + '">\n    <h2 class="' + swalClasses.title + '"></h2>\n    <div class="' + swalClasses.content + '"></div>\n    <input class="' + swalClasses.input + '">\n    <input type="file" class="' + swalClasses.file + '">\n    <div class="' + swalClasses.range + '">\n      <output></output>\n      <input type="range">\n    </div>\n    <select class="' + swalClasses.select + '"></select>\n    <div class="' + swalClasses.radio + '"></div>\n    <label for="' + swalClasses.checkbox + '" class="' + swalClasses.checkbox + '">\n      <input type="checkbox">\n    </label>\n    <textarea class="' + swalClasses.textarea + '"></textarea>\n    <div class="' + swalClasses.validationerror + '"></div>\n    <hr class="' + swalClasses.spacer + '">\n    <button type="button" class="' + swalClasses.confirm + '">OK</button>\n    <button type="button" class="' + swalClasses.cancel + '">Cancel</button>\n    <span class="' + swalClasses.close + '">&times;</span>\n  </div>\n').replace(/(^|\n)\s*/g, '');
	
	var sweetContainer = void 0;
	
	var existingSweetContainers = document.getElementsByClassName(swalClasses.container);
	
	if (existingSweetContainers.length) {
	  sweetContainer = existingSweetContainers[0];
	} else {
	  sweetContainer = document.createElement('div');
	  sweetContainer.className = swalClasses.container;
	  sweetContainer.innerHTML = sweetHTML;
	}
	
	/*
	 * Set hover, active and focus-states for buttons (source: http://www.sitepoint.com/javascript-generate-lighter-darker-color)
	 */
	var colorLuminance = function colorLuminance(hex, lum) {
	  // Validate hex string
	  hex = String(hex).replace(/[^0-9a-f]/gi, '');
	  if (hex.length < 6) {
	    hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
	  }
	  lum = lum || 0;
	
	  // Convert to decimal and change luminosity
	  var rgb = '#';
	  for (var i = 0; i < 3; i++) {
	    var c = parseInt(hex.substr(i * 2, 2), 16);
	    c = Math.round(Math.min(Math.max(0, c + c * lum), 255)).toString(16);
	    rgb += ('00' + c).substr(c.length);
	  }
	
	  return rgb;
	};
	
	/* global MouseEvent */
	
	// Remember state in cases where opening and handling a modal will fiddle with it.
	var states = {
	  previousWindowKeyDown: null,
	  previousActiveElement: null,
	  previousBodyPadding: null
	};
	
	/*
	 * Add modal + overlay to DOM
	 */
	var init = function init() {
	  if (typeof document === 'undefined') {
	    console.error('SweetAlert2 requires document to initialize');
	    return;
	  } else if (document.getElementsByClassName(swalClasses.container).length) {
	    return;
	  }
	
	  document.body.appendChild(sweetContainer);
	
	  var modal = getModal();
	  var input = getChildByClass(modal, swalClasses.input);
	  var file = getChildByClass(modal, swalClasses.file);
	  var range = modal.querySelector('.' + swalClasses.range + ' input');
	  var rangeOutput = modal.querySelector('.' + swalClasses.range + ' output');
	  var select = getChildByClass(modal, swalClasses.select);
	  var checkbox = modal.querySelector('.' + swalClasses.checkbox + ' input');
	  var textarea = getChildByClass(modal, swalClasses.textarea);
	
	  input.oninput = function () {
	    sweetAlert.resetValidationError();
	  };
	
	  input.onkeydown = function (event) {
	    setTimeout(function () {
	      if (event.keyCode === 13) {
	        event.stopPropagation();
	        sweetAlert.clickConfirm();
	      }
	    }, 0);
	  };
	
	  file.onchange = function () {
	    sweetAlert.resetValidationError();
	  };
	
	  range.oninput = function () {
	    sweetAlert.resetValidationError();
	    rangeOutput.value = range.value;
	  };
	
	  range.onchange = function () {
	    sweetAlert.resetValidationError();
	    range.previousSibling.value = range.value;
	  };
	
	  select.onchange = function () {
	    sweetAlert.resetValidationError();
	  };
	
	  checkbox.onchange = function () {
	    sweetAlert.resetValidationError();
	  };
	
	  textarea.oninput = function () {
	    sweetAlert.resetValidationError();
	  };
	
	  return modal;
	};
	
	/*
	 * Manipulate DOM
	 */
	var elementByClass = function elementByClass(className) {
	  return sweetContainer.querySelector('.' + className);
	};
	
	var getModal = function getModal() {
	  return document.body.querySelector('.' + swalClasses.modal) || init();
	};
	
	var getIcons = function getIcons() {
	  var modal = getModal();
	  return modal.querySelectorAll('.' + swalClasses.icon);
	};
	
	var getTitle = function getTitle() {
	  return elementByClass(swalClasses.title);
	};
	
	var getContent = function getContent() {
	  return elementByClass(swalClasses.content);
	};
	
	var getImage = function getImage() {
	  return elementByClass(swalClasses.image);
	};
	
	var getSpacer = function getSpacer() {
	  return elementByClass(swalClasses.spacer);
	};
	
	var getProgressSteps = function getProgressSteps() {
	  return elementByClass(swalClasses.progresssteps);
	};
	
	var getValidationError = function getValidationError() {
	  return elementByClass(swalClasses.validationerror);
	};
	
	var getConfirmButton = function getConfirmButton() {
	  return elementByClass(swalClasses.confirm);
	};
	
	var getCancelButton = function getCancelButton() {
	  return elementByClass(swalClasses.cancel);
	};
	
	var getCloseButton = function getCloseButton() {
	  return elementByClass(swalClasses.close);
	};
	
	var getFocusableElements = function getFocusableElements(focusCancel) {
	  var buttons = [getConfirmButton(), getCancelButton()];
	  if (focusCancel) {
	    buttons.reverse();
	  }
	  return buttons.concat(Array.prototype.slice.call(getModal().querySelectorAll('button:not([class^=' + swalPrefix + ']), input:not([type=hidden]), textarea, select')));
	};
	
	var hasClass = function hasClass(elem, className) {
	  if (elem.classList) {
	    return elem.classList.contains(className);
	  }
	  return false;
	};
	
	var focusInput = function focusInput(input) {
	  input.focus();
	
	  // place cursor at end of text in text input
	  if (input.type !== 'file') {
	    // http://stackoverflow.com/a/2345915/1331425
	    var val = input.value;
	    input.value = '';
	    input.value = val;
	  }
	};
	
	var addClass = function addClass(elem, className) {
	  if (!elem || !className) {
	    return;
	  }
	  var classes = className.split(/\s+/).filter(Boolean);
	  classes.forEach(function (className) {
	    elem.classList.add(className);
	  });
	};
	
	var removeClass = function removeClass(elem, className) {
	  if (!elem || !className) {
	    return;
	  }
	  var classes = className.split(/\s+/).filter(Boolean);
	  classes.forEach(function (className) {
	    elem.classList.remove(className);
	  });
	};
	
	var getChildByClass = function getChildByClass(elem, className) {
	  for (var i = 0; i < elem.childNodes.length; i++) {
	    if (hasClass(elem.childNodes[i], className)) {
	      return elem.childNodes[i];
	    }
	  }
	};
	
	var show = function show(elem, display) {
	  if (!display) {
	    display = 'block';
	  }
	  elem.style.opacity = '';
	  elem.style.display = display;
	};
	
	var hide = function hide(elem) {
	  elem.style.opacity = '';
	  elem.style.display = 'none';
	};
	
	var empty = function empty(elem) {
	  while (elem.firstChild) {
	    elem.removeChild(elem.firstChild);
	  }
	};
	
	// borrowed from jqeury $(elem).is(':visible') implementation
	var isVisible = function isVisible(elem) {
	  return elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length;
	};
	
	var removeStyleProperty = function removeStyleProperty(elem, property) {
	  if (elem.style.removeProperty) {
	    elem.style.removeProperty(property);
	  } else {
	    elem.style.removeAttribute(property);
	  }
	};
	
	
	
	
	
	
	
	var fireClick = function fireClick(node) {
	  // Taken from http://www.nonobtrusive.com/2011/11/29/programatically-fire-crossbrowser-click-event-with-javascript/
	  // Then fixed for today's Chrome browser.
	  if (typeof MouseEvent === 'function') {
	    // Up-to-date approach
	    var mevt = new MouseEvent('click', {
	      view: window,
	      bubbles: false,
	      cancelable: true
	    });
	    node.dispatchEvent(mevt);
	  } else if (document.createEvent) {
	    // Fallback
	    var evt = document.createEvent('MouseEvents');
	    evt.initEvent('click', false, false);
	    node.dispatchEvent(evt);
	  } else if (document.createEventObject) {
	    node.fireEvent('onclick');
	  } else if (typeof node.onclick === 'function') {
	    node.onclick();
	  }
	};
	
	var animationEndEvent = function () {
	  var testEl = document.createElement('div');
	  var transEndEventNames = {
	    'WebkitAnimation': 'webkitAnimationEnd',
	    'OAnimation': 'oAnimationEnd oanimationend',
	    'msAnimation': 'MSAnimationEnd',
	    'animation': 'animationend'
	  };
	  for (var i in transEndEventNames) {
	    if (transEndEventNames.hasOwnProperty(i) && testEl.style[i] !== undefined) {
	      return transEndEventNames[i];
	    }
	  }
	
	  return false;
	}();
	
	// Reset the page to its previous state
	var resetPrevState = function resetPrevState() {
	  var modal = getModal();
	  window.onkeydown = states.previousWindowKeyDown;
	  if (states.previousActiveElement && states.previousActiveElement.focus) {
	    states.previousActiveElement.focus();
	  }
	  clearTimeout(modal.timeout);
	};
	
	// Measure width of scrollbar
	// https://github.com/twbs/bootstrap/blob/master/js/modal.js#L279-L286
	var measureScrollbar = function measureScrollbar() {
	  var scrollDiv = document.createElement('div');
	  scrollDiv.style.width = '50px';
	  scrollDiv.style.height = '50px';
	  scrollDiv.style.overflow = 'scroll';
	  document.body.appendChild(scrollDiv);
	  var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
	  document.body.removeChild(scrollDiv);
	  return scrollbarWidth;
	};
	
	// JavaScript Debounce Function
	// Simplivied version of https://davidwalsh.name/javascript-debounce-function
	var debounce = function debounce(func, wait) {
	  var timeout = void 0;
	  return function () {
	    var later = function later() {
	      timeout = null;
	      func();
	    };
	    clearTimeout(timeout);
	    timeout = setTimeout(later, wait);
	  };
	};
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
	  return typeof obj;
	} : function (obj) {
	  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
	};
	
	
	
	
	
	var asyncGenerator = function () {
	  function AwaitValue(value) {
	    this.value = value;
	  }
	
	  function AsyncGenerator(gen) {
	    var front, back;
	
	    function send(key, arg) {
	      return new Promise(function (resolve, reject) {
	        var request = {
	          key: key,
	          arg: arg,
	          resolve: resolve,
	          reject: reject,
	          next: null
	        };
	
	        if (back) {
	          back = back.next = request;
	        } else {
	          front = back = request;
	          resume(key, arg);
	        }
	      });
	    }
	
	    function resume(key, arg) {
	      try {
	        var result = gen[key](arg);
	        var value = result.value;
	
	        if (value instanceof AwaitValue) {
	          Promise.resolve(value.value).then(function (arg) {
	            resume("next", arg);
	          }, function (arg) {
	            resume("throw", arg);
	          });
	        } else {
	          settle(result.done ? "return" : "normal", result.value);
	        }
	      } catch (err) {
	        settle("throw", err);
	      }
	    }
	
	    function settle(type, value) {
	      switch (type) {
	        case "return":
	          front.resolve({
	            value: value,
	            done: true
	          });
	          break;
	
	        case "throw":
	          front.reject(value);
	          break;
	
	        default:
	          front.resolve({
	            value: value,
	            done: false
	          });
	          break;
	      }
	
	      front = front.next;
	
	      if (front) {
	        resume(front.key, front.arg);
	      } else {
	        back = null;
	      }
	    }
	
	    this._invoke = send;
	
	    if (typeof gen.return !== "function") {
	      this.return = undefined;
	    }
	  }
	
	  if (typeof Symbol === "function" && Symbol.asyncIterator) {
	    AsyncGenerator.prototype[Symbol.asyncIterator] = function () {
	      return this;
	    };
	  }
	
	  AsyncGenerator.prototype.next = function (arg) {
	    return this._invoke("next", arg);
	  };
	
	  AsyncGenerator.prototype.throw = function (arg) {
	    return this._invoke("throw", arg);
	  };
	
	  AsyncGenerator.prototype.return = function (arg) {
	    return this._invoke("return", arg);
	  };
	
	  return {
	    wrap: function (fn) {
	      return function () {
	        return new AsyncGenerator(fn.apply(this, arguments));
	      };
	    },
	    await: function (value) {
	      return new AwaitValue(value);
	    }
	  };
	}();
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];
	
	    for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }
	
	  return target;
	};
	
	var get = function get(object, property, receiver) {
	  if (object === null) object = Function.prototype;
	  var desc = Object.getOwnPropertyDescriptor(object, property);
	
	  if (desc === undefined) {
	    var parent = Object.getPrototypeOf(object);
	
	    if (parent === null) {
	      return undefined;
	    } else {
	      return get(parent, property, receiver);
	    }
	  } else if ("value" in desc) {
	    return desc.value;
	  } else {
	    var getter = desc.get;
	
	    if (getter === undefined) {
	      return undefined;
	    }
	
	    return getter.call(receiver);
	  }
	};
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	var set = function set(object, property, value, receiver) {
	  var desc = Object.getOwnPropertyDescriptor(object, property);
	
	  if (desc === undefined) {
	    var parent = Object.getPrototypeOf(object);
	
	    if (parent !== null) {
	      set(parent, property, value, receiver);
	    }
	  } else if ("value" in desc && desc.writable) {
	    desc.value = value;
	  } else {
	    var setter = desc.set;
	
	    if (setter !== undefined) {
	      setter.call(receiver, value);
	    }
	  }
	
	  return value;
	};
	
	var modalParams = _extends({}, defaultParams);
	var queue = [];
	var swal2Observer = void 0;
	
	/*
	 * Set type, text and actions on modal
	 */
	var setParameters = function setParameters(params) {
	  var modal = getModal();
	
	  for (var param in params) {
	    if (!defaultParams.hasOwnProperty(param) && param !== 'extraParams') {
	      console.warn('SweetAlert2: Unknown parameter "' + param + '"');
	    }
	  }
	
	  // set modal width and margin-left
	  modal.style.width = typeof params.width === 'number' ? params.width + 'px' : params.width;
	
	  modal.style.padding = params.padding + 'px';
	  modal.style.background = params.background;
	
	  var title = getTitle();
	  var content = getContent();
	  var confirmButton = getConfirmButton();
	  var cancelButton = getCancelButton();
	  var closeButton = getCloseButton();
	
	  // Title
	  title.innerHTML = params.title.split('\n').join('<br>');
	
	  // Content
	  if (params.text || params.html) {
	    if (_typeof(params.html) === 'object') {
	      content.innerHTML = '';
	      if (0 in params.html) {
	        for (var i = 0; i in params.html; i++) {
	          content.appendChild(params.html[i].cloneNode(true));
	        }
	      } else {
	        content.appendChild(params.html.cloneNode(true));
	      }
	    } else if (params.html) {
	      content.innerHTML = params.html;
	    } else if (params.text) {
	      content.innerHTML = ('' + params.text).split('\n').join('<br>');
	    }
	    show(content);
	  } else {
	    hide(content);
	  }
	
	  // Close button
	  if (params.showCloseButton) {
	    show(closeButton);
	  } else {
	    hide(closeButton);
	  }
	
	  // Custom Class
	  modal.className = swalClasses.modal;
	  if (params.customClass) {
	    addClass(modal, params.customClass);
	  }
	
	  // Progress steps
	  var progressStepsContainer = getProgressSteps();
	  var currentProgressStep = parseInt(params.currentProgressStep === null ? sweetAlert.getQueueStep() : params.currentProgressStep, 10);
	  if (params.progressSteps.length) {
	    show(progressStepsContainer);
	    empty(progressStepsContainer);
	    if (currentProgressStep >= params.progressSteps.length) {
	      console.warn('SweetAlert2: Invalid currentProgressStep parameter, it should be less than progressSteps.length ' + '(currentProgressStep like JS arrays starts from 0)');
	    }
	    params.progressSteps.forEach(function (step, index) {
	      var circle = document.createElement('li');
	      addClass(circle, swalClasses.progresscircle);
	      circle.innerHTML = step;
	      if (index === currentProgressStep) {
	        addClass(circle, swalClasses.activeprogressstep);
	      }
	      progressStepsContainer.appendChild(circle);
	      if (index !== params.progressSteps.length - 1) {
	        var line = document.createElement('li');
	        addClass(line, swalClasses.progressline);
	        line.style.width = params.progressStepsDistance;
	        progressStepsContainer.appendChild(line);
	      }
	    });
	  } else {
	    hide(progressStepsContainer);
	  }
	
	  // Icon
	  var icons = getIcons();
	  for (var _i = 0; _i < icons.length; _i++) {
	    hide(icons[_i]);
	  }
	  if (params.type) {
	    var validType = false;
	    for (var iconType in iconTypes) {
	      if (params.type === iconType) {
	        validType = true;
	        break;
	      }
	    }
	    if (!validType) {
	      console.error('SweetAlert2: Unknown alert type: ' + params.type);
	      return false;
	    }
	    var icon = modal.querySelector('.' + swalClasses.icon + '.' + iconTypes[params.type]);
	    show(icon);
	
	    // Animate icon
	    switch (params.type) {
	      case 'success':
	        addClass(icon, 'animate');
	        addClass(icon.querySelector('.tip'), 'animate-success-tip');
	        addClass(icon.querySelector('.long'), 'animate-success-long');
	        break;
	      case 'error':
	        addClass(icon, 'animate-error-icon');
	        addClass(icon.querySelector('.x-mark'), 'animate-x-mark');
	        break;
	      case 'warning':
	        addClass(icon, 'pulse-warning');
	        break;
	      default:
	        break;
	    }
	  }
	
	  // Custom image
	  var image = getImage();
	  if (params.imageUrl) {
	    image.setAttribute('src', params.imageUrl);
	    show(image);
	
	    if (params.imageWidth) {
	      image.setAttribute('width', params.imageWidth);
	    } else {
	      image.removeAttribute('width');
	    }
	
	    if (params.imageHeight) {
	      image.setAttribute('height', params.imageHeight);
	    } else {
	      image.removeAttribute('height');
	    }
	
	    image.className = swalClasses.image;
	    if (params.imageClass) {
	      addClass(image, params.imageClass);
	    }
	  } else {
	    hide(image);
	  }
	
	  // Cancel button
	  if (params.showCancelButton) {
	    cancelButton.style.display = 'inline-block';
	  } else {
	    hide(cancelButton);
	  }
	
	  // Confirm button
	  if (params.showConfirmButton) {
	    removeStyleProperty(confirmButton, 'display');
	  } else {
	    hide(confirmButton);
	  }
	
	  // Buttons spacer
	  var spacer = getSpacer();
	  if (!params.showConfirmButton && !params.showCancelButton) {
	    hide(spacer);
	  } else {
	    show(spacer);
	  }
	
	  // Edit text on cancel and confirm buttons
	  confirmButton.innerHTML = params.confirmButtonText;
	  cancelButton.innerHTML = params.cancelButtonText;
	
	  // Set buttons to selected background colors
	  if (params.buttonsStyling) {
	    confirmButton.style.backgroundColor = params.confirmButtonColor;
	    cancelButton.style.backgroundColor = params.cancelButtonColor;
	  }
	
	  // Add buttons custom classes
	  confirmButton.className = swalClasses.confirm;
	  addClass(confirmButton, params.confirmButtonClass);
	  cancelButton.className = swalClasses.cancel;
	  addClass(cancelButton, params.cancelButtonClass);
	
	  // Buttons styling
	  if (params.buttonsStyling) {
	    addClass(confirmButton, swalClasses.styled);
	    addClass(cancelButton, swalClasses.styled);
	  } else {
	    removeClass(confirmButton, swalClasses.styled);
	    removeClass(cancelButton, swalClasses.styled);
	
	    confirmButton.style.backgroundColor = confirmButton.style.borderLeftColor = confirmButton.style.borderRightColor = '';
	    cancelButton.style.backgroundColor = cancelButton.style.borderLeftColor = cancelButton.style.borderRightColor = '';
	  }
	
	  // CSS animation
	  if (params.animation === true) {
	    removeClass(modal, swalClasses.noanimation);
	  } else {
	    addClass(modal, swalClasses.noanimation);
	  }
	};
	
	/*
	 * Animations
	 */
	var openModal = function openModal(animation, onComplete) {
	  var modal = getModal();
	  if (animation) {
	    addClass(modal, swalClasses.show);
	    addClass(sweetContainer, swalClasses.fade);
	    removeClass(modal, swalClasses.hide);
	  } else {
	    removeClass(modal, swalClasses.fade);
	  }
	  show(modal);
	
	  // scrolling is 'hidden' until animation is done, after that 'auto'
	  sweetContainer.style.overflowY = 'hidden';
	  if (animationEndEvent && !hasClass(modal, swalClasses.noanimation)) {
	    modal.addEventListener(animationEndEvent, function swalCloseEventFinished() {
	      modal.removeEventListener(animationEndEvent, swalCloseEventFinished);
	      sweetContainer.style.overflowY = 'auto';
	    });
	  } else {
	    sweetContainer.style.overflowY = 'auto';
	  }
	
	  addClass(sweetContainer, swalClasses.in);
	  addClass(document.body, swalClasses.in);
	  fixScrollbar();
	  iOSfix();
	  states.previousActiveElement = document.activeElement;
	  if (onComplete !== null && typeof onComplete === 'function') {
	    onComplete(modal);
	  }
	};
	
	var fixScrollbar = function fixScrollbar() {
	  // for queues, do not do this more than once
	  if (states.previousBodyPadding !== null) {
	    return;
	  }
	  // if the body has overflow
	  if (document.body.scrollHeight > window.innerHeight) {
	    // add padding so the content doesn't shift after removal of scrollbar
	    states.previousBodyPadding = document.body.style.paddingRight;
	    document.body.style.paddingRight = measureScrollbar() + 'px';
	  }
	};
	
	var undoScrollbar = function undoScrollbar() {
	  if (states.previousBodyPadding !== null) {
	    document.body.style.paddingRight = states.previousBodyPadding;
	    states.previousBodyPadding = null;
	  }
	};
	
	// Fix iOS scrolling http://stackoverflow.com/q/39626302/1331425
	var iOSfix = function iOSfix() {
	  var iOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
	  if (iOS && !hasClass(document.body, swalClasses.iosfix)) {
	    var offset = document.body.scrollTop;
	    document.body.style.top = offset * -1 + 'px';
	    addClass(document.body, swalClasses.iosfix);
	  }
	};
	
	var undoIOSfix = function undoIOSfix() {
	  if (hasClass(document.body, swalClasses.iosfix)) {
	    var offset = parseInt(document.body.style.top, 10);
	    removeClass(document.body, swalClasses.iosfix);
	    document.body.style.top = '';
	    document.body.scrollTop = offset * -1;
	  }
	};
	
	var modalDependant = function modalDependant() {
	  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	    args[_key] = arguments[_key];
	  }
	
	  if (args[0] === undefined) {
	    console.error('SweetAlert2 expects at least 1 attribute!');
	    return false;
	  }
	
	  var params = _extends({}, modalParams);
	
	  switch (_typeof(args[0])) {
	    case 'string':
	      params.title = args[0];
	      params.text = args[1];
	      params.type = args[2];
	
	      break;
	
	    case 'object':
	      _extends(params, args[0]);
	      params.extraParams = args[0].extraParams;
	
	      if (params.input === 'email' && params.inputValidator === null) {
	        params.inputValidator = function (email) {
	          return new Promise(function (resolve, reject) {
	            var emailRegex = /^[a-zA-Z0-9._-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,6}$/;
	            if (emailRegex.test(email)) {
	              resolve();
	            } else {
	              reject('Invalid email address');
	            }
	          });
	        };
	      }
	      break;
	
	    default:
	      console.error('SweetAlert2: Unexpected type of argument! Expected "string" or "object", got ' + _typeof(args[0]));
	      return false;
	  }
	
	  setParameters(params);
	
	  var modal = getModal();
	
	  return new Promise(function (resolve, reject) {
	    // Close on timer
	    if (params.timer) {
	      modal.timeout = setTimeout(function () {
	        sweetAlert.closeModal(params.onClose);
	        reject('timer');
	      }, params.timer);
	    }
	
	    // Get input element by specified type or, if type isn't specified, by params.input
	    var getInput = function getInput(inputType) {
	      inputType = inputType || params.input;
	      switch (inputType) {
	        case 'select':
	        case 'textarea':
	        case 'file':
	          return getChildByClass(modal, swalClasses[inputType]);
	        case 'checkbox':
	          return modal.querySelector('.' + swalClasses.checkbox + ' input');
	        case 'radio':
	          return modal.querySelector('.' + swalClasses.radio + ' input:checked') || modal.querySelector('.' + swalClasses.radio + ' input:first-child');
	        case 'range':
	          return modal.querySelector('.' + swalClasses.range + ' input');
	        default:
	          return getChildByClass(modal, swalClasses.input);
	      }
	    };
	
	    // Get the value of the modal input
	    var getInputValue = function getInputValue() {
	      var input = getInput();
	      if (!input) {
	        return null;
	      }
	      switch (params.input) {
	        case 'checkbox':
	          return input.checked ? 1 : 0;
	        case 'radio':
	          return input.checked ? input.value : null;
	        case 'file':
	          return input.files.length ? input.files[0] : null;
	        default:
	          return params.inputAutoTrim ? input.value.trim() : input.value;
	      }
	    };
	
	    // input autofocus
	    if (params.input) {
	      setTimeout(function () {
	        var input = getInput();
	        if (input) {
	          focusInput(input);
	        }
	      }, 0);
	    }
	
	    var confirm = function confirm(value) {
	      if (params.showLoaderOnConfirm) {
	        sweetAlert.showLoading();
	      }
	
	      if (params.preConfirm) {
	        params.preConfirm(value, params.extraParams).then(function (preConfirmValue) {
	          sweetAlert.closeModal(params.onClose);
	          resolve(preConfirmValue || value);
	        }, function (error) {
	          sweetAlert.hideLoading();
	          if (error) {
	            sweetAlert.showValidationError(error);
	          }
	        });
	      } else {
	        sweetAlert.closeModal(params.onClose);
	        resolve(value);
	      }
	    };
	
	    // Mouse interactions
	    var onButtonEvent = function onButtonEvent(event) {
	      var e = event || window.event;
	      var target = e.target || e.srcElement;
	      var confirmButton = getConfirmButton();
	      var cancelButton = getCancelButton();
	      var targetedConfirm = confirmButton === target || confirmButton.contains(target);
	      var targetedCancel = cancelButton === target || cancelButton.contains(target);
	
	      switch (e.type) {
	        case 'mouseover':
	        case 'mouseup':
	          if (params.buttonsStyling) {
	            if (targetedConfirm) {
	              confirmButton.style.backgroundColor = colorLuminance(params.confirmButtonColor, -0.1);
	            } else if (targetedCancel) {
	              cancelButton.style.backgroundColor = colorLuminance(params.cancelButtonColor, -0.1);
	            }
	          }
	          break;
	        case 'mouseout':
	          if (params.buttonsStyling) {
	            if (targetedConfirm) {
	              confirmButton.style.backgroundColor = params.confirmButtonColor;
	            } else if (targetedCancel) {
	              cancelButton.style.backgroundColor = params.cancelButtonColor;
	            }
	          }
	          break;
	        case 'mousedown':
	          if (params.buttonsStyling) {
	            if (targetedConfirm) {
	              confirmButton.style.backgroundColor = colorLuminance(params.confirmButtonColor, -0.2);
	            } else if (targetedCancel) {
	              cancelButton.style.backgroundColor = colorLuminance(params.cancelButtonColor, -0.2);
	            }
	          }
	          break;
	        case 'click':
	          // Clicked 'confirm'
	          if (targetedConfirm && sweetAlert.isVisible()) {
	            if (params.input) {
	              (function () {
	                var inputValue = getInputValue();
	
	                if (params.inputValidator) {
	                  sweetAlert.disableInput();
	                  params.inputValidator(inputValue, params.extraParams).then(function () {
	                    sweetAlert.enableInput();
	                    confirm(inputValue);
	                  }, function (error) {
	                    sweetAlert.enableInput();
	                    if (error) {
	                      sweetAlert.showValidationError(error);
	                    }
	                  });
	                } else {
	                  confirm(inputValue);
	                }
	              })();
	            } else {
	              confirm(true);
	            }
	
	            // Clicked 'cancel'
	          } else if (targetedCancel && sweetAlert.isVisible()) {
	            sweetAlert.closeModal(params.onClose);
	            reject('cancel');
	          }
	          break;
	        default:
	      }
	    };
	
	    var buttons = modal.querySelectorAll('button');
	    for (var i = 0; i < buttons.length; i++) {
	      buttons[i].onclick = onButtonEvent;
	      buttons[i].onmouseover = onButtonEvent;
	      buttons[i].onmouseout = onButtonEvent;
	      buttons[i].onmousedown = onButtonEvent;
	    }
	
	    // Closing modal by close button
	    getCloseButton().onclick = function () {
	      sweetAlert.closeModal(params.onClose);
	      reject('close');
	    };
	
	    // Closing modal by overlay click
	    sweetContainer.onclick = function (e) {
	      if (e.target !== sweetContainer) {
	        return;
	      }
	      if (params.allowOutsideClick) {
	        sweetAlert.closeModal(params.onClose);
	        reject('overlay');
	      }
	    };
	
	    var confirmButton = getConfirmButton();
	    var cancelButton = getCancelButton();
	
	    // Reverse buttons if neede d
	    if (params.reverseButtons) {
	      confirmButton.parentNode.insertBefore(cancelButton, confirmButton);
	    } else {
	      confirmButton.parentNode.insertBefore(confirmButton, cancelButton);
	    }
	
	    // Focus handling
	    var setFocus = function setFocus(index, increment) {
	      var focusableElements = getFocusableElements(params.focusCancel);
	      // search for visible elements and select the next possible match
	      for (var _i2 = 0; _i2 < focusableElements.length; _i2++) {
	        index = index + increment;
	
	        // rollover to first item
	        if (index === focusableElements.length) {
	          index = 0;
	
	          // go to last item
	        } else if (index === -1) {
	          index = focusableElements.length - 1;
	        }
	
	        // determine if element is visible
	        var el = focusableElements[index];
	        if (isVisible(el)) {
	          return el.focus();
	        }
	      }
	    };
	
	    var handleKeyDown = function handleKeyDown(event) {
	      var e = event || window.event;
	      var keyCode = e.keyCode || e.which;
	
	      if ([9, 13, 32, 27].indexOf(keyCode) === -1) {
	        // Don't do work on keys we don't care about.
	        return;
	      }
	
	      var targetElement = e.target || e.srcElement;
	
	      var focusableElements = getFocusableElements(params.focusCancel);
	      var btnIndex = -1; // Find the button - note, this is a nodelist, not an array.
	      for (var _i3 = 0; _i3 < focusableElements.length; _i3++) {
	        if (targetElement === focusableElements[_i3]) {
	          btnIndex = _i3;
	          break;
	        }
	      }
	
	      // TAB
	      if (keyCode === 9) {
	        if (!e.shiftKey) {
	          // Cycle to the next button
	          setFocus(btnIndex, 1);
	        } else {
	          // Cycle to the prev button
	          setFocus(btnIndex, -1);
	        }
	        e.stopPropagation();
	        e.preventDefault();
	
	        // ENTER/SPACE
	      } else {
	        if (keyCode === 13 || keyCode === 32) {
	          if (btnIndex === -1) {
	            // ENTER/SPACE clicked outside of a button.
	            if (params.focusCancel) {
	              fireClick(cancelButton, e);
	            } else {
	              fireClick(confirmButton, e);
	            }
	          }
	        } else if (keyCode === 27 && params.allowEscapeKey === true) {
	          sweetAlert.closeModal(params.onClose);
	          reject('esc');
	        }
	      }
	    };
	
	    states.previousWindowKeyDown = window.onkeydown;
	    window.onkeydown = handleKeyDown;
	
	    // Loading state
	    if (params.buttonsStyling) {
	      confirmButton.style.borderLeftColor = params.confirmButtonColor;
	      confirmButton.style.borderRightColor = params.confirmButtonColor;
	    }
	
	    /**
	     * Show spinner instead of Confirm button and disable Cancel button
	     */
	    sweetAlert.showLoading = sweetAlert.enableLoading = function () {
	      show(getSpacer());
	      show(confirmButton, 'inline-block');
	      addClass(confirmButton, swalClasses.loading);
	      addClass(modal, swalClasses.loading);
	      confirmButton.disabled = true;
	      cancelButton.disabled = true;
	    };
	
	    /**
	     * Show spinner instead of Confirm button and disable Cancel button
	     */
	    sweetAlert.hideLoading = sweetAlert.disableLoading = function () {
	      if (!params.showConfirmButton) {
	        hide(confirmButton);
	        if (!params.showCancelButton) {
	          hide(getSpacer());
	        }
	      }
	      removeClass(confirmButton, swalClasses.loading);
	      removeClass(modal, swalClasses.loading);
	      confirmButton.disabled = false;
	      cancelButton.disabled = false;
	    };
	
	    sweetAlert.enableButtons = function () {
	      confirmButton.disabled = false;
	      cancelButton.disabled = false;
	    };
	
	    sweetAlert.disableButtons = function () {
	      confirmButton.disabled = true;
	      cancelButton.disabled = true;
	    };
	
	    sweetAlert.enableConfirmButton = function () {
	      confirmButton.disabled = false;
	    };
	
	    sweetAlert.disableConfirmButton = function () {
	      confirmButton.disabled = true;
	    };
	
	    sweetAlert.enableInput = function () {
	      var input = getInput();
	      if (!input) {
	        return false;
	      }
	      if (input.type === 'radio') {
	        var radiosContainer = input.parentNode.parentNode;
	        var radios = radiosContainer.querySelectorAll('input');
	        for (var _i4 = 0; _i4 < radios.length; _i4++) {
	          radios[_i4].disabled = false;
	        }
	      } else {
	        input.disabled = false;
	      }
	    };
	
	    sweetAlert.disableInput = function () {
	      var input = getInput();
	      if (!input) {
	        return false;
	      }
	      if (input && input.type === 'radio') {
	        var radiosContainer = input.parentNode.parentNode;
	        var radios = radiosContainer.querySelectorAll('input');
	        for (var _i5 = 0; _i5 < radios.length; _i5++) {
	          radios[_i5].disabled = true;
	        }
	      } else {
	        input.disabled = true;
	      }
	    };
	
	    // Set modal min-height to disable scrolling inside the modal
	    sweetAlert.recalculateHeight = debounce(function () {
	      var modal = getModal();
	      var prevState = modal.style.display;
	      modal.style.minHeight = '';
	      show(modal);
	      modal.style.minHeight = modal.scrollHeight + 1 + 'px';
	      modal.style.display = prevState;
	    }, 50);
	
	    // Show block with validation error
	    sweetAlert.showValidationError = function (error) {
	      var validationError = getValidationError();
	      validationError.innerHTML = error;
	      show(validationError);
	
	      var input = getInput();
	      focusInput(input);
	      addClass(input, swalClasses.inputerror);
	    };
	
	    // Hide block with validation error
	    sweetAlert.resetValidationError = function () {
	      var validationError = getValidationError();
	      hide(validationError);
	      sweetAlert.recalculateHeight();
	
	      var input = getInput();
	      if (input) {
	        removeClass(input, swalClasses.inputerror);
	      }
	    };
	
	    sweetAlert.getProgressSteps = function () {
	      return params.progressSteps;
	    };
	
	    sweetAlert.setProgressSteps = function (progressSteps) {
	      params.progressSteps = progressSteps;
	      setParameters(params);
	    };
	
	    sweetAlert.showProgressSteps = function () {
	      show(getProgressSteps());
	    };
	
	    sweetAlert.hideProgressSteps = function () {
	      hide(getProgressSteps());
	    };
	
	    sweetAlert.enableButtons();
	    sweetAlert.hideLoading();
	    sweetAlert.resetValidationError();
	
	    // inputs
	    var inputTypes = ['input', 'file', 'range', 'select', 'radio', 'checkbox', 'textarea'];
	    var input = void 0;
	    for (var _i6 = 0; _i6 < inputTypes.length; _i6++) {
	      var inputClass = swalClasses[inputTypes[_i6]];
	      var inputContainer = getChildByClass(modal, inputClass);
	      input = getInput(inputTypes[_i6]);
	
	      // set attributes
	      if (input) {
	        for (var j in input.attributes) {
	          if (input.attributes.hasOwnProperty(j)) {
	            var attrName = input.attributes[j].name;
	            if (attrName !== 'type' && attrName !== 'value') {
	              input.removeAttribute(attrName);
	            }
	          }
	        }
	        for (var attr in params.inputAttributes) {
	          input.setAttribute(attr, params.inputAttributes[attr]);
	        }
	      }
	
	      // set class
	      inputContainer.className = inputClass;
	      if (params.inputClass) {
	        addClass(inputContainer, params.inputClass);
	      }
	
	      hide(inputContainer);
	    }
	
	    var populateInputOptions = void 0;
	
	    (function () {
	      switch (params.input) {
	        case 'text':
	        case 'email':
	        case 'password':
	        case 'number':
	        case 'tel':
	          input = getChildByClass(modal, swalClasses.input);
	          input.value = params.inputValue;
	          input.placeholder = params.inputPlaceholder;
	          input.type = params.input;
	          show(input);
	          break;
	        case 'file':
	          input = getChildByClass(modal, swalClasses.file);
	          input.placeholder = params.inputPlaceholder;
	          input.type = params.input;
	          show(input);
	          break;
	        case 'range':
	          var range = getChildByClass(modal, swalClasses.range);
	          var rangeInput = range.querySelector('input');
	          var rangeOutput = range.querySelector('output');
	          rangeInput.value = params.inputValue;
	          rangeInput.type = params.input;
	          rangeOutput.value = params.inputValue;
	          show(range);
	          break;
	        case 'select':
	          var select = getChildByClass(modal, swalClasses.select);
	          select.innerHTML = '';
	          if (params.inputPlaceholder) {
	            var placeholder = document.createElement('option');
	            placeholder.innerHTML = params.inputPlaceholder;
	            placeholder.value = '';
	            placeholder.disabled = true;
	            placeholder.selected = true;
	            select.appendChild(placeholder);
	          }
	          populateInputOptions = function populateInputOptions(inputOptions) {
	            for (var optionValue in inputOptions) {
	              var option = document.createElement('option');
	              option.value = optionValue;
	              option.innerHTML = inputOptions[optionValue];
	              if (params.inputValue === optionValue) {
	                option.selected = true;
	              }
	              select.appendChild(option);
	            }
	            show(select);
	            select.focus();
	          };
	          break;
	        case 'radio':
	          var radio = getChildByClass(modal, swalClasses.radio);
	          radio.innerHTML = '';
	          populateInputOptions = function populateInputOptions(inputOptions) {
	            for (var radioValue in inputOptions) {
	              var id = 1;
	              var radioInput = document.createElement('input');
	              var radioLabel = document.createElement('label');
	              var radioLabelSpan = document.createElement('span');
	              radioInput.type = 'radio';
	              radioInput.name = swalClasses.radio;
	              radioInput.value = radioValue;
	              radioInput.id = swalClasses.radio + '-' + id++;
	              if (params.inputValue === radioValue) {
	                radioInput.checked = true;
	              }
	              radioLabelSpan.innerHTML = inputOptions[radioValue];
	              radioLabel.appendChild(radioInput);
	              radioLabel.appendChild(radioLabelSpan);
	              radioLabel.for = radioInput.id;
	              radio.appendChild(radioLabel);
	            }
	            show(radio);
	            var radios = radio.querySelectorAll('input');
	            if (radios.length) {
	              radios[0].focus();
	            }
	          };
	          break;
	        case 'checkbox':
	          var checkbox = getChildByClass(modal, swalClasses.checkbox);
	          var checkboxInput = getInput('checkbox');
	          checkboxInput.type = 'checkbox';
	          checkboxInput.value = 1;
	          checkboxInput.id = swalClasses.checkbox;
	          checkboxInput.checked = Boolean(params.inputValue);
	          var label = checkbox.getElementsByTagName('span');
	          if (label.length) {
	            checkbox.removeChild(label[0]);
	          }
	          label = document.createElement('span');
	          label.innerHTML = params.inputPlaceholder;
	          checkbox.appendChild(label);
	          show(checkbox);
	          break;
	        case 'textarea':
	          var textarea = getChildByClass(modal, swalClasses.textarea);
	          textarea.value = params.inputValue;
	          textarea.placeholder = params.inputPlaceholder;
	          show(textarea);
	          break;
	        case null:
	          break;
	        default:
	          console.error('SweetAlert2: Unexpected type of input! Expected "text", "email", "password", "select", "checkbox", "textarea" or "file", got "' + params.input + '"');
	          break;
	      }
	    })();
	
	    if (params.input === 'select' || params.input === 'radio') {
	      if (params.inputOptions instanceof Promise) {
	        sweetAlert.showLoading();
	        params.inputOptions.then(function (inputOptions) {
	          sweetAlert.hideLoading();
	          populateInputOptions(inputOptions);
	        });
	      } else if (_typeof(params.inputOptions) === 'object') {
	        populateInputOptions(params.inputOptions);
	      } else {
	        console.error('SweetAlert2: Unexpected type of inputOptions! Expected object or Promise, got ' + _typeof(params.inputOptions));
	      }
	    }
	
	    openModal(params.animation, params.onOpen);
	
	    // Focus the first element (input or button)
	    setFocus(-1, 1);
	
	    // fix scroll
	    sweetContainer.scrollTop = 0;
	
	    // Observe changes inside the modal and adjust height
	    if (typeof MutationObserver !== 'undefined' && !swal2Observer) {
	      swal2Observer = new MutationObserver(sweetAlert.recalculateHeight);
	      swal2Observer.observe(modal, { childList: true, characterData: true, subtree: true });
	    }
	  });
	};
	
	// SweetAlert entry point
	var sweetAlert = function sweetAlert() {
	  for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
	    args[_key2] = arguments[_key2];
	  }
	
	  if (sweetAlert.isVisible()) {
	    sweetAlert.close();
	  }
	
	  return modalDependant.apply(undefined, args);
	};
	
	/*
	 * Global function to determine if swal2 modal is visible
	 */
	sweetAlert.isVisible = function () {
	  var modal = getModal();
	  return isVisible(modal);
	};
	
	/*
	 * Global function for chaining sweetAlert modals
	 */
	sweetAlert.queue = function (steps) {
	  queue = steps;
	  var modal = getModal();
	  var resetQueue = function resetQueue() {
	    queue = [];
	    modal.removeAttribute('data-queue-step');
	  };
	  var queueResult = [];
	  return new Promise(function (resolve, reject) {
	    (function step(i, callback) {
	      if (i < queue.length) {
	        modal.setAttribute('data-queue-step', i);
	
	        sweetAlert(queue[i]).then(function (result) {
	          queueResult.push(result);
	          step(i + 1, callback);
	        }, function (dismiss) {
	          resetQueue();
	          reject(dismiss);
	        });
	      } else {
	        resetQueue();
	        resolve(queueResult);
	      }
	    })(0);
	  });
	};
	
	/*
	 * Global function for getting the index of current modal in queue
	 */
	sweetAlert.getQueueStep = function () {
	  return getModal().getAttribute('data-queue-step');
	};
	
	/*
	 * Global function for inserting a modal to the queue
	 */
	sweetAlert.insertQueueStep = function (step, index) {
	  if (index && index < queue.length) {
	    return queue.splice(index, 0, step);
	  }
	  return queue.push(step);
	};
	
	/*
	 * Global function for deleting a modal from the queue
	 */
	sweetAlert.deleteQueueStep = function (index) {
	  if (typeof queue[index] !== 'undefined') {
	    queue.splice(index, 1);
	  }
	};
	
	/*
	 * Global function to close sweetAlert
	 */
	sweetAlert.close = sweetAlert.closeModal = function (onComplete) {
	  var modal = getModal();
	  removeClass(modal, swalClasses.show);
	  addClass(modal, swalClasses.hide);
	
	  // Reset icon animations
	  var successIcon = modal.querySelector('.' + swalClasses.icon + '.' + iconTypes.success);
	  removeClass(successIcon, 'animate');
	  removeClass(successIcon.querySelector('.tip'), 'animate-success-tip');
	  removeClass(successIcon.querySelector('.long'), 'animate-success-long');
	
	  var errorIcon = modal.querySelector('.' + swalClasses.icon + '.' + iconTypes.error);
	  removeClass(errorIcon, 'animate-error-icon');
	  removeClass(errorIcon.querySelector('.x-mark'), 'animate-x-mark');
	
	  var warningIcon = modal.querySelector('.' + swalClasses.icon + '.' + iconTypes.warning);
	  removeClass(warningIcon, 'pulse-warning');
	
	  resetPrevState();
	
	  var hideModalAndResetState = function hideModalAndResetState() {
	    hide(modal);
	    modal.style.minHeight = '';
	    removeClass(sweetContainer, swalClasses.in);
	    removeClass(document.body, swalClasses.in);
	    undoScrollbar();
	    undoIOSfix();
	  };
	
	  // If animation is supported, animate
	  if (animationEndEvent && !hasClass(modal, swalClasses.noanimation)) {
	    modal.addEventListener(animationEndEvent, function swalCloseEventFinished() {
	      modal.removeEventListener(animationEndEvent, swalCloseEventFinished);
	      if (hasClass(modal, swalClasses.hide)) {
	        hideModalAndResetState();
	      }
	    });
	  } else {
	    // Otherwise, hide immediately
	    hideModalAndResetState();
	  }
	  if (onComplete !== null && typeof onComplete === 'function') {
	    onComplete(modal);
	  }
	};
	
	/*
	 * Global function to click 'Confirm' button
	 */
	sweetAlert.clickConfirm = function () {
	  return getConfirmButton().click();
	};
	
	/*
	 * Global function to click 'Cancel' button
	 */
	sweetAlert.clickCancel = function () {
	  return getCancelButton().click();
	};
	
	/**
	 * Set default params for each popup
	 * @param {Object} userParams
	 */
	sweetAlert.setDefaults = function (userParams) {
	  if (!userParams || (typeof userParams === 'undefined' ? 'undefined' : _typeof(userParams)) !== 'object') {
	    return console.error('SweetAlert2: the argument for setDefaults() is required and has to be a object');
	  }
	
	  for (var param in userParams) {
	    if (!defaultParams.hasOwnProperty(param) && param !== 'extraParams') {
	      console.warn('SweetAlert2: Unknown parameter "' + param + '"');
	      delete userParams[param];
	    }
	  }
	
	  _extends(modalParams, userParams);
	};
	
	/**
	 * Reset default params for each popup
	 */
	sweetAlert.resetDefaults = function () {
	  modalParams = _extends({}, defaultParams);
	};
	
	sweetAlert.noop = function () {};
	
	sweetAlert.version = '6.2.0';
	
	return sweetAlert;
	
	})));
	if (window.Sweetalert2) window.sweetAlert = window.swal = window.Sweetalert2;


/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

	var baseMerge = __webpack_require__(107),
	    createAssigner = __webpack_require__(183);
	
	/**
	 * This method is like `_.assign` except that it recursively merges own and
	 * inherited enumerable string keyed properties of source objects into the
	 * destination object. Source properties that resolve to `undefined` are
	 * skipped if a destination value exists. Array and plain object properties
	 * are merged recursively. Other objects and value types are overridden by
	 * assignment. Source objects are applied from left to right. Subsequent
	 * sources overwrite property assignments of previous sources.
	 *
	 * **Note:** This method mutates `object`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.5.0
	 * @category Object
	 * @param {Object} object The destination object.
	 * @param {...Object} [sources] The source objects.
	 * @returns {Object} Returns `object`.
	 * @example
	 *
	 * var object = {
	 *   'a': [{ 'b': 2 }, { 'd': 4 }]
	 * };
	 *
	 * var other = {
	 *   'a': [{ 'c': 3 }, { 'e': 5 }]
	 * };
	 *
	 * _.merge(object, other);
	 * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
	 */
	var merge = createAssigner(function(object, source, srcIndex) {
	  baseMerge(object, source, srcIndex);
	});
	
	module.exports = merge;


/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

	var Stack = __webpack_require__(108),
	    assignMergeValue = __webpack_require__(145),
	    baseFor = __webpack_require__(148),
	    baseMergeDeep = __webpack_require__(150),
	    isObject = __webpack_require__(8),
	    keysIn = __webpack_require__(177);
	
	/**
	 * The base implementation of `_.merge` without support for multiple sources.
	 *
	 * @private
	 * @param {Object} object The destination object.
	 * @param {Object} source The source object.
	 * @param {number} srcIndex The index of `source`.
	 * @param {Function} [customizer] The function to customize merged values.
	 * @param {Object} [stack] Tracks traversed source values and their merged
	 *  counterparts.
	 */
	function baseMerge(object, source, srcIndex, customizer, stack) {
	  if (object === source) {
	    return;
	  }
	  baseFor(source, function(srcValue, key) {
	    if (isObject(srcValue)) {
	      stack || (stack = new Stack);
	      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
	    }
	    else {
	      var newValue = customizer
	        ? customizer(object[key], srcValue, (key + ''), object, source, stack)
	        : undefined;
	
	      if (newValue === undefined) {
	        newValue = srcValue;
	      }
	      assignMergeValue(object, key, newValue);
	    }
	  }, keysIn);
	}
	
	module.exports = baseMerge;


/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	var ListCache = __webpack_require__(109),
	    stackClear = __webpack_require__(117),
	    stackDelete = __webpack_require__(118),
	    stackGet = __webpack_require__(119),
	    stackHas = __webpack_require__(120),
	    stackSet = __webpack_require__(121);
	
	/**
	 * Creates a stack cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Stack(entries) {
	  var data = this.__data__ = new ListCache(entries);
	  this.size = data.size;
	}
	
	// Add methods to `Stack`.
	Stack.prototype.clear = stackClear;
	Stack.prototype['delete'] = stackDelete;
	Stack.prototype.get = stackGet;
	Stack.prototype.has = stackHas;
	Stack.prototype.set = stackSet;
	
	module.exports = Stack;


/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

	var listCacheClear = __webpack_require__(110),
	    listCacheDelete = __webpack_require__(111),
	    listCacheGet = __webpack_require__(114),
	    listCacheHas = __webpack_require__(115),
	    listCacheSet = __webpack_require__(116);
	
	/**
	 * Creates an list cache object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function ListCache(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;
	
	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}
	
	// Add methods to `ListCache`.
	ListCache.prototype.clear = listCacheClear;
	ListCache.prototype['delete'] = listCacheDelete;
	ListCache.prototype.get = listCacheGet;
	ListCache.prototype.has = listCacheHas;
	ListCache.prototype.set = listCacheSet;
	
	module.exports = ListCache;


/***/ },
/* 110 */
/***/ function(module, exports) {

	/**
	 * Removes all key-value entries from the list cache.
	 *
	 * @private
	 * @name clear
	 * @memberOf ListCache
	 */
	function listCacheClear() {
	  this.__data__ = [];
	  this.size = 0;
	}
	
	module.exports = listCacheClear;


/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

	var assocIndexOf = __webpack_require__(112);
	
	/** Used for built-in method references. */
	var arrayProto = Array.prototype;
	
	/** Built-in value references. */
	var splice = arrayProto.splice;
	
	/**
	 * Removes `key` and its value from the list cache.
	 *
	 * @private
	 * @name delete
	 * @memberOf ListCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function listCacheDelete(key) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);
	
	  if (index < 0) {
	    return false;
	  }
	  var lastIndex = data.length - 1;
	  if (index == lastIndex) {
	    data.pop();
	  } else {
	    splice.call(data, index, 1);
	  }
	  --this.size;
	  return true;
	}
	
	module.exports = listCacheDelete;


/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	var eq = __webpack_require__(113);
	
	/**
	 * Gets the index at which the `key` is found in `array` of key-value pairs.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} key The key to search for.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function assocIndexOf(array, key) {
	  var length = array.length;
	  while (length--) {
	    if (eq(array[length][0], key)) {
	      return length;
	    }
	  }
	  return -1;
	}
	
	module.exports = assocIndexOf;


/***/ },
/* 113 */
/***/ function(module, exports) {

	/**
	 * Performs a
	 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * comparison between two values to determine if they are equivalent.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 * var other = { 'a': 1 };
	 *
	 * _.eq(object, object);
	 * // => true
	 *
	 * _.eq(object, other);
	 * // => false
	 *
	 * _.eq('a', 'a');
	 * // => true
	 *
	 * _.eq('a', Object('a'));
	 * // => false
	 *
	 * _.eq(NaN, NaN);
	 * // => true
	 */
	function eq(value, other) {
	  return value === other || (value !== value && other !== other);
	}
	
	module.exports = eq;


/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

	var assocIndexOf = __webpack_require__(112);
	
	/**
	 * Gets the list cache value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf ListCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function listCacheGet(key) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);
	
	  return index < 0 ? undefined : data[index][1];
	}
	
	module.exports = listCacheGet;


/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

	var assocIndexOf = __webpack_require__(112);
	
	/**
	 * Checks if a list cache value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf ListCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function listCacheHas(key) {
	  return assocIndexOf(this.__data__, key) > -1;
	}
	
	module.exports = listCacheHas;


/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	var assocIndexOf = __webpack_require__(112);
	
	/**
	 * Sets the list cache `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf ListCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the list cache instance.
	 */
	function listCacheSet(key, value) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);
	
	  if (index < 0) {
	    ++this.size;
	    data.push([key, value]);
	  } else {
	    data[index][1] = value;
	  }
	  return this;
	}
	
	module.exports = listCacheSet;


/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

	var ListCache = __webpack_require__(109);
	
	/**
	 * Removes all key-value entries from the stack.
	 *
	 * @private
	 * @name clear
	 * @memberOf Stack
	 */
	function stackClear() {
	  this.__data__ = new ListCache;
	  this.size = 0;
	}
	
	module.exports = stackClear;


/***/ },
/* 118 */
/***/ function(module, exports) {

	/**
	 * Removes `key` and its value from the stack.
	 *
	 * @private
	 * @name delete
	 * @memberOf Stack
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function stackDelete(key) {
	  var data = this.__data__,
	      result = data['delete'](key);
	
	  this.size = data.size;
	  return result;
	}
	
	module.exports = stackDelete;


/***/ },
/* 119 */
/***/ function(module, exports) {

	/**
	 * Gets the stack value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Stack
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function stackGet(key) {
	  return this.__data__.get(key);
	}
	
	module.exports = stackGet;


/***/ },
/* 120 */
/***/ function(module, exports) {

	/**
	 * Checks if a stack value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Stack
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function stackHas(key) {
	  return this.__data__.has(key);
	}
	
	module.exports = stackHas;


/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

	var ListCache = __webpack_require__(109),
	    Map = __webpack_require__(122),
	    MapCache = __webpack_require__(130);
	
	/** Used as the size to enable large array optimizations. */
	var LARGE_ARRAY_SIZE = 200;
	
	/**
	 * Sets the stack `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Stack
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the stack cache instance.
	 */
	function stackSet(key, value) {
	  var data = this.__data__;
	  if (data instanceof ListCache) {
	    var pairs = data.__data__;
	    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
	      pairs.push([key, value]);
	      this.size = ++data.size;
	      return this;
	    }
	    data = this.__data__ = new MapCache(pairs);
	  }
	  data.set(key, value);
	  this.size = data.size;
	  return this;
	}
	
	module.exports = stackSet;


/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

	var getNative = __webpack_require__(123),
	    root = __webpack_require__(10);
	
	/* Built-in method references that are verified to be native. */
	var Map = getNative(root, 'Map');
	
	module.exports = Map;


/***/ },
/* 123 */
/***/ function(module, exports, __webpack_require__) {

	var baseIsNative = __webpack_require__(124),
	    getValue = __webpack_require__(129);
	
	/**
	 * Gets the native function at `key` of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the method to get.
	 * @returns {*} Returns the function if it's native, else `undefined`.
	 */
	function getNative(object, key) {
	  var value = getValue(object, key);
	  return baseIsNative(value) ? value : undefined;
	}
	
	module.exports = getNative;


/***/ },
/* 124 */
/***/ function(module, exports, __webpack_require__) {

	var isFunction = __webpack_require__(125),
	    isMasked = __webpack_require__(126),
	    isObject = __webpack_require__(8),
	    toSource = __webpack_require__(128);
	
	/**
	 * Used to match `RegExp`
	 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
	 */
	var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
	
	/** Used to detect host constructors (Safari). */
	var reIsHostCtor = /^\[object .+?Constructor\]$/;
	
	/** Used for built-in method references. */
	var funcProto = Function.prototype,
	    objectProto = Object.prototype;
	
	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;
	
	/** Used to detect if a method is native. */
	var reIsNative = RegExp('^' +
	  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
	  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	);
	
	/**
	 * The base implementation of `_.isNative` without bad shim checks.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a native function,
	 *  else `false`.
	 */
	function baseIsNative(value) {
	  if (!isObject(value) || isMasked(value)) {
	    return false;
	  }
	  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
	  return pattern.test(toSource(value));
	}
	
	module.exports = baseIsNative;


/***/ },
/* 125 */
/***/ function(module, exports, __webpack_require__) {

	var baseGetTag = __webpack_require__(14),
	    isObject = __webpack_require__(8);
	
	/** `Object#toString` result references. */
	var asyncTag = '[object AsyncFunction]',
	    funcTag = '[object Function]',
	    genTag = '[object GeneratorFunction]',
	    proxyTag = '[object Proxy]';
	
	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction(value) {
	  if (!isObject(value)) {
	    return false;
	  }
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in Safari 9 which returns 'object' for typed arrays and other constructors.
	  var tag = baseGetTag(value);
	  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
	}
	
	module.exports = isFunction;


/***/ },
/* 126 */
/***/ function(module, exports, __webpack_require__) {

	var coreJsData = __webpack_require__(127);
	
	/** Used to detect methods masquerading as native. */
	var maskSrcKey = (function() {
	  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
	  return uid ? ('Symbol(src)_1.' + uid) : '';
	}());
	
	/**
	 * Checks if `func` has its source masked.
	 *
	 * @private
	 * @param {Function} func The function to check.
	 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
	 */
	function isMasked(func) {
	  return !!maskSrcKey && (maskSrcKey in func);
	}
	
	module.exports = isMasked;


/***/ },
/* 127 */
/***/ function(module, exports, __webpack_require__) {

	var root = __webpack_require__(10);
	
	/** Used to detect overreaching core-js shims. */
	var coreJsData = root['__core-js_shared__'];
	
	module.exports = coreJsData;


/***/ },
/* 128 */
/***/ function(module, exports) {

	/** Used for built-in method references. */
	var funcProto = Function.prototype;
	
	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;
	
	/**
	 * Converts `func` to its source code.
	 *
	 * @private
	 * @param {Function} func The function to convert.
	 * @returns {string} Returns the source code.
	 */
	function toSource(func) {
	  if (func != null) {
	    try {
	      return funcToString.call(func);
	    } catch (e) {}
	    try {
	      return (func + '');
	    } catch (e) {}
	  }
	  return '';
	}
	
	module.exports = toSource;


/***/ },
/* 129 */
/***/ function(module, exports) {

	/**
	 * Gets the value at `key` of `object`.
	 *
	 * @private
	 * @param {Object} [object] The object to query.
	 * @param {string} key The key of the property to get.
	 * @returns {*} Returns the property value.
	 */
	function getValue(object, key) {
	  return object == null ? undefined : object[key];
	}
	
	module.exports = getValue;


/***/ },
/* 130 */
/***/ function(module, exports, __webpack_require__) {

	var mapCacheClear = __webpack_require__(131),
	    mapCacheDelete = __webpack_require__(139),
	    mapCacheGet = __webpack_require__(142),
	    mapCacheHas = __webpack_require__(143),
	    mapCacheSet = __webpack_require__(144);
	
	/**
	 * Creates a map cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function MapCache(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;
	
	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}
	
	// Add methods to `MapCache`.
	MapCache.prototype.clear = mapCacheClear;
	MapCache.prototype['delete'] = mapCacheDelete;
	MapCache.prototype.get = mapCacheGet;
	MapCache.prototype.has = mapCacheHas;
	MapCache.prototype.set = mapCacheSet;
	
	module.exports = MapCache;


/***/ },
/* 131 */
/***/ function(module, exports, __webpack_require__) {

	var Hash = __webpack_require__(132),
	    ListCache = __webpack_require__(109),
	    Map = __webpack_require__(122);
	
	/**
	 * Removes all key-value entries from the map.
	 *
	 * @private
	 * @name clear
	 * @memberOf MapCache
	 */
	function mapCacheClear() {
	  this.size = 0;
	  this.__data__ = {
	    'hash': new Hash,
	    'map': new (Map || ListCache),
	    'string': new Hash
	  };
	}
	
	module.exports = mapCacheClear;


/***/ },
/* 132 */
/***/ function(module, exports, __webpack_require__) {

	var hashClear = __webpack_require__(133),
	    hashDelete = __webpack_require__(135),
	    hashGet = __webpack_require__(136),
	    hashHas = __webpack_require__(137),
	    hashSet = __webpack_require__(138);
	
	/**
	 * Creates a hash object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Hash(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;
	
	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}
	
	// Add methods to `Hash`.
	Hash.prototype.clear = hashClear;
	Hash.prototype['delete'] = hashDelete;
	Hash.prototype.get = hashGet;
	Hash.prototype.has = hashHas;
	Hash.prototype.set = hashSet;
	
	module.exports = Hash;


/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

	var nativeCreate = __webpack_require__(134);
	
	/**
	 * Removes all key-value entries from the hash.
	 *
	 * @private
	 * @name clear
	 * @memberOf Hash
	 */
	function hashClear() {
	  this.__data__ = nativeCreate ? nativeCreate(null) : {};
	  this.size = 0;
	}
	
	module.exports = hashClear;


/***/ },
/* 134 */
/***/ function(module, exports, __webpack_require__) {

	var getNative = __webpack_require__(123);
	
	/* Built-in method references that are verified to be native. */
	var nativeCreate = getNative(Object, 'create');
	
	module.exports = nativeCreate;


/***/ },
/* 135 */
/***/ function(module, exports) {

	/**
	 * Removes `key` and its value from the hash.
	 *
	 * @private
	 * @name delete
	 * @memberOf Hash
	 * @param {Object} hash The hash to modify.
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function hashDelete(key) {
	  var result = this.has(key) && delete this.__data__[key];
	  this.size -= result ? 1 : 0;
	  return result;
	}
	
	module.exports = hashDelete;


/***/ },
/* 136 */
/***/ function(module, exports, __webpack_require__) {

	var nativeCreate = __webpack_require__(134);
	
	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED = '__lodash_hash_undefined__';
	
	/** Used for built-in method references. */
	var objectProto = Object.prototype;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;
	
	/**
	 * Gets the hash value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Hash
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function hashGet(key) {
	  var data = this.__data__;
	  if (nativeCreate) {
	    var result = data[key];
	    return result === HASH_UNDEFINED ? undefined : result;
	  }
	  return hasOwnProperty.call(data, key) ? data[key] : undefined;
	}
	
	module.exports = hashGet;


/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

	var nativeCreate = __webpack_require__(134);
	
	/** Used for built-in method references. */
	var objectProto = Object.prototype;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;
	
	/**
	 * Checks if a hash value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Hash
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function hashHas(key) {
	  var data = this.__data__;
	  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
	}
	
	module.exports = hashHas;


/***/ },
/* 138 */
/***/ function(module, exports, __webpack_require__) {

	var nativeCreate = __webpack_require__(134);
	
	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED = '__lodash_hash_undefined__';
	
	/**
	 * Sets the hash `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Hash
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the hash instance.
	 */
	function hashSet(key, value) {
	  var data = this.__data__;
	  this.size += this.has(key) ? 0 : 1;
	  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
	  return this;
	}
	
	module.exports = hashSet;


/***/ },
/* 139 */
/***/ function(module, exports, __webpack_require__) {

	var getMapData = __webpack_require__(140);
	
	/**
	 * Removes `key` and its value from the map.
	 *
	 * @private
	 * @name delete
	 * @memberOf MapCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function mapCacheDelete(key) {
	  var result = getMapData(this, key)['delete'](key);
	  this.size -= result ? 1 : 0;
	  return result;
	}
	
	module.exports = mapCacheDelete;


/***/ },
/* 140 */
/***/ function(module, exports, __webpack_require__) {

	var isKeyable = __webpack_require__(141);
	
	/**
	 * Gets the data for `map`.
	 *
	 * @private
	 * @param {Object} map The map to query.
	 * @param {string} key The reference key.
	 * @returns {*} Returns the map data.
	 */
	function getMapData(map, key) {
	  var data = map.__data__;
	  return isKeyable(key)
	    ? data[typeof key == 'string' ? 'string' : 'hash']
	    : data.map;
	}
	
	module.exports = getMapData;


/***/ },
/* 141 */
/***/ function(module, exports) {

	/**
	 * Checks if `value` is suitable for use as unique object key.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
	 */
	function isKeyable(value) {
	  var type = typeof value;
	  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
	    ? (value !== '__proto__')
	    : (value === null);
	}
	
	module.exports = isKeyable;


/***/ },
/* 142 */
/***/ function(module, exports, __webpack_require__) {

	var getMapData = __webpack_require__(140);
	
	/**
	 * Gets the map value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf MapCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function mapCacheGet(key) {
	  return getMapData(this, key).get(key);
	}
	
	module.exports = mapCacheGet;


/***/ },
/* 143 */
/***/ function(module, exports, __webpack_require__) {

	var getMapData = __webpack_require__(140);
	
	/**
	 * Checks if a map value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf MapCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function mapCacheHas(key) {
	  return getMapData(this, key).has(key);
	}
	
	module.exports = mapCacheHas;


/***/ },
/* 144 */
/***/ function(module, exports, __webpack_require__) {

	var getMapData = __webpack_require__(140);
	
	/**
	 * Sets the map `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf MapCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the map cache instance.
	 */
	function mapCacheSet(key, value) {
	  var data = getMapData(this, key),
	      size = data.size;
	
	  data.set(key, value);
	  this.size += data.size == size ? 0 : 1;
	  return this;
	}
	
	module.exports = mapCacheSet;


/***/ },
/* 145 */
/***/ function(module, exports, __webpack_require__) {

	var baseAssignValue = __webpack_require__(146),
	    eq = __webpack_require__(113);
	
	/**
	 * This function is like `assignValue` except that it doesn't assign
	 * `undefined` values.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {string} key The key of the property to assign.
	 * @param {*} value The value to assign.
	 */
	function assignMergeValue(object, key, value) {
	  if ((value !== undefined && !eq(object[key], value)) ||
	      (value === undefined && !(key in object))) {
	    baseAssignValue(object, key, value);
	  }
	}
	
	module.exports = assignMergeValue;


/***/ },
/* 146 */
/***/ function(module, exports, __webpack_require__) {

	var defineProperty = __webpack_require__(147);
	
	/**
	 * The base implementation of `assignValue` and `assignMergeValue` without
	 * value checks.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {string} key The key of the property to assign.
	 * @param {*} value The value to assign.
	 */
	function baseAssignValue(object, key, value) {
	  if (key == '__proto__' && defineProperty) {
	    defineProperty(object, key, {
	      'configurable': true,
	      'enumerable': true,
	      'value': value,
	      'writable': true
	    });
	  } else {
	    object[key] = value;
	  }
	}
	
	module.exports = baseAssignValue;


/***/ },
/* 147 */
/***/ function(module, exports, __webpack_require__) {

	var getNative = __webpack_require__(123);
	
	var defineProperty = (function() {
	  try {
	    var func = getNative(Object, 'defineProperty');
	    func({}, '', {});
	    return func;
	  } catch (e) {}
	}());
	
	module.exports = defineProperty;


/***/ },
/* 148 */
/***/ function(module, exports, __webpack_require__) {

	var createBaseFor = __webpack_require__(149);
	
	/**
	 * The base implementation of `baseForOwn` which iterates over `object`
	 * properties returned by `keysFunc` and invokes `iteratee` for each property.
	 * Iteratee functions may exit iteration early by explicitly returning `false`.
	 *
	 * @private
	 * @param {Object} object The object to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @param {Function} keysFunc The function to get the keys of `object`.
	 * @returns {Object} Returns `object`.
	 */
	var baseFor = createBaseFor();
	
	module.exports = baseFor;


/***/ },
/* 149 */
/***/ function(module, exports) {

	/**
	 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
	 *
	 * @private
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {Function} Returns the new base function.
	 */
	function createBaseFor(fromRight) {
	  return function(object, iteratee, keysFunc) {
	    var index = -1,
	        iterable = Object(object),
	        props = keysFunc(object),
	        length = props.length;
	
	    while (length--) {
	      var key = props[fromRight ? length : ++index];
	      if (iteratee(iterable[key], key, iterable) === false) {
	        break;
	      }
	    }
	    return object;
	  };
	}
	
	module.exports = createBaseFor;


/***/ },
/* 150 */
/***/ function(module, exports, __webpack_require__) {

	var assignMergeValue = __webpack_require__(145),
	    cloneBuffer = __webpack_require__(151),
	    cloneTypedArray = __webpack_require__(152),
	    copyArray = __webpack_require__(155),
	    initCloneObject = __webpack_require__(156),
	    isArguments = __webpack_require__(161),
	    isArray = __webpack_require__(163),
	    isArrayLikeObject = __webpack_require__(164),
	    isBuffer = __webpack_require__(167),
	    isFunction = __webpack_require__(125),
	    isObject = __webpack_require__(8),
	    isPlainObject = __webpack_require__(169),
	    isTypedArray = __webpack_require__(170),
	    toPlainObject = __webpack_require__(174);
	
	/**
	 * A specialized version of `baseMerge` for arrays and objects which performs
	 * deep merges and tracks traversed objects enabling objects with circular
	 * references to be merged.
	 *
	 * @private
	 * @param {Object} object The destination object.
	 * @param {Object} source The source object.
	 * @param {string} key The key of the value to merge.
	 * @param {number} srcIndex The index of `source`.
	 * @param {Function} mergeFunc The function to merge values.
	 * @param {Function} [customizer] The function to customize assigned values.
	 * @param {Object} [stack] Tracks traversed source values and their merged
	 *  counterparts.
	 */
	function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
	  var objValue = object[key],
	      srcValue = source[key],
	      stacked = stack.get(srcValue);
	
	  if (stacked) {
	    assignMergeValue(object, key, stacked);
	    return;
	  }
	  var newValue = customizer
	    ? customizer(objValue, srcValue, (key + ''), object, source, stack)
	    : undefined;
	
	  var isCommon = newValue === undefined;
	
	  if (isCommon) {
	    var isArr = isArray(srcValue),
	        isBuff = !isArr && isBuffer(srcValue),
	        isTyped = !isArr && !isBuff && isTypedArray(srcValue);
	
	    newValue = srcValue;
	    if (isArr || isBuff || isTyped) {
	      if (isArray(objValue)) {
	        newValue = objValue;
	      }
	      else if (isArrayLikeObject(objValue)) {
	        newValue = copyArray(objValue);
	      }
	      else if (isBuff) {
	        isCommon = false;
	        newValue = cloneBuffer(srcValue, true);
	      }
	      else if (isTyped) {
	        isCommon = false;
	        newValue = cloneTypedArray(srcValue, true);
	      }
	      else {
	        newValue = [];
	      }
	    }
	    else if (isPlainObject(srcValue) || isArguments(srcValue)) {
	      newValue = objValue;
	      if (isArguments(objValue)) {
	        newValue = toPlainObject(objValue);
	      }
	      else if (!isObject(objValue) || (srcIndex && isFunction(objValue))) {
	        newValue = initCloneObject(srcValue);
	      }
	    }
	    else {
	      isCommon = false;
	    }
	  }
	  if (isCommon) {
	    // Recursively merge objects and arrays (susceptible to call stack limits).
	    stack.set(srcValue, newValue);
	    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
	    stack['delete'](srcValue);
	  }
	  assignMergeValue(object, key, newValue);
	}
	
	module.exports = baseMergeDeep;


/***/ },
/* 151 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {var root = __webpack_require__(10);
	
	/** Detect free variable `exports`. */
	var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
	
	/** Detect free variable `module`. */
	var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
	
	/** Detect the popular CommonJS extension `module.exports`. */
	var moduleExports = freeModule && freeModule.exports === freeExports;
	
	/** Built-in value references. */
	var Buffer = moduleExports ? root.Buffer : undefined,
	    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;
	
	/**
	 * Creates a clone of  `buffer`.
	 *
	 * @private
	 * @param {Buffer} buffer The buffer to clone.
	 * @param {boolean} [isDeep] Specify a deep clone.
	 * @returns {Buffer} Returns the cloned buffer.
	 */
	function cloneBuffer(buffer, isDeep) {
	  if (isDeep) {
	    return buffer.slice();
	  }
	  var length = buffer.length,
	      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
	
	  buffer.copy(result);
	  return result;
	}
	
	module.exports = cloneBuffer;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(101)(module)))

/***/ },
/* 152 */
/***/ function(module, exports, __webpack_require__) {

	var cloneArrayBuffer = __webpack_require__(153);
	
	/**
	 * Creates a clone of `typedArray`.
	 *
	 * @private
	 * @param {Object} typedArray The typed array to clone.
	 * @param {boolean} [isDeep] Specify a deep clone.
	 * @returns {Object} Returns the cloned typed array.
	 */
	function cloneTypedArray(typedArray, isDeep) {
	  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
	  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
	}
	
	module.exports = cloneTypedArray;


/***/ },
/* 153 */
/***/ function(module, exports, __webpack_require__) {

	var Uint8Array = __webpack_require__(154);
	
	/**
	 * Creates a clone of `arrayBuffer`.
	 *
	 * @private
	 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
	 * @returns {ArrayBuffer} Returns the cloned array buffer.
	 */
	function cloneArrayBuffer(arrayBuffer) {
	  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
	  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
	  return result;
	}
	
	module.exports = cloneArrayBuffer;


/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

	var root = __webpack_require__(10);
	
	/** Built-in value references. */
	var Uint8Array = root.Uint8Array;
	
	module.exports = Uint8Array;


/***/ },
/* 155 */
/***/ function(module, exports) {

	/**
	 * Copies the values of `source` to `array`.
	 *
	 * @private
	 * @param {Array} source The array to copy values from.
	 * @param {Array} [array=[]] The array to copy values to.
	 * @returns {Array} Returns `array`.
	 */
	function copyArray(source, array) {
	  var index = -1,
	      length = source.length;
	
	  array || (array = Array(length));
	  while (++index < length) {
	    array[index] = source[index];
	  }
	  return array;
	}
	
	module.exports = copyArray;


/***/ },
/* 156 */
/***/ function(module, exports, __webpack_require__) {

	var baseCreate = __webpack_require__(157),
	    getPrototype = __webpack_require__(158),
	    isPrototype = __webpack_require__(160);
	
	/**
	 * Initializes an object clone.
	 *
	 * @private
	 * @param {Object} object The object to clone.
	 * @returns {Object} Returns the initialized clone.
	 */
	function initCloneObject(object) {
	  return (typeof object.constructor == 'function' && !isPrototype(object))
	    ? baseCreate(getPrototype(object))
	    : {};
	}
	
	module.exports = initCloneObject;


/***/ },
/* 157 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(8);
	
	/** Built-in value references. */
	var objectCreate = Object.create;
	
	/**
	 * The base implementation of `_.create` without support for assigning
	 * properties to the created object.
	 *
	 * @private
	 * @param {Object} proto The object to inherit from.
	 * @returns {Object} Returns the new object.
	 */
	var baseCreate = (function() {
	  function object() {}
	  return function(proto) {
	    if (!isObject(proto)) {
	      return {};
	    }
	    if (objectCreate) {
	      return objectCreate(proto);
	    }
	    object.prototype = proto;
	    var result = new object;
	    object.prototype = undefined;
	    return result;
	  };
	}());
	
	module.exports = baseCreate;


/***/ },
/* 158 */
/***/ function(module, exports, __webpack_require__) {

	var overArg = __webpack_require__(159);
	
	/** Built-in value references. */
	var getPrototype = overArg(Object.getPrototypeOf, Object);
	
	module.exports = getPrototype;


/***/ },
/* 159 */
/***/ function(module, exports) {

	/**
	 * Creates a unary function that invokes `func` with its argument transformed.
	 *
	 * @private
	 * @param {Function} func The function to wrap.
	 * @param {Function} transform The argument transform.
	 * @returns {Function} Returns the new function.
	 */
	function overArg(func, transform) {
	  return function(arg) {
	    return func(transform(arg));
	  };
	}
	
	module.exports = overArg;


/***/ },
/* 160 */
/***/ function(module, exports) {

	/** Used for built-in method references. */
	var objectProto = Object.prototype;
	
	/**
	 * Checks if `value` is likely a prototype object.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
	 */
	function isPrototype(value) {
	  var Ctor = value && value.constructor,
	      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;
	
	  return value === proto;
	}
	
	module.exports = isPrototype;


/***/ },
/* 161 */
/***/ function(module, exports, __webpack_require__) {

	var baseIsArguments = __webpack_require__(162),
	    isObjectLike = __webpack_require__(18);
	
	/** Used for built-in method references. */
	var objectProto = Object.prototype;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;
	
	/** Built-in value references. */
	var propertyIsEnumerable = objectProto.propertyIsEnumerable;
	
	/**
	 * Checks if `value` is likely an `arguments` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArguments(function() { return arguments; }());
	 * // => true
	 *
	 * _.isArguments([1, 2, 3]);
	 * // => false
	 */
	var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
	  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
	    !propertyIsEnumerable.call(value, 'callee');
	};
	
	module.exports = isArguments;


/***/ },
/* 162 */
/***/ function(module, exports, __webpack_require__) {

	var baseGetTag = __webpack_require__(14),
	    isObjectLike = __webpack_require__(18);
	
	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]';
	
	/**
	 * The base implementation of `_.isArguments`.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 */
	function baseIsArguments(value) {
	  return isObjectLike(value) && baseGetTag(value) == argsTag;
	}
	
	module.exports = baseIsArguments;


/***/ },
/* 163 */
/***/ function(module, exports) {

	/**
	 * Checks if `value` is classified as an `Array` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
	 * @example
	 *
	 * _.isArray([1, 2, 3]);
	 * // => true
	 *
	 * _.isArray(document.body.children);
	 * // => false
	 *
	 * _.isArray('abc');
	 * // => false
	 *
	 * _.isArray(_.noop);
	 * // => false
	 */
	var isArray = Array.isArray;
	
	module.exports = isArray;


/***/ },
/* 164 */
/***/ function(module, exports, __webpack_require__) {

	var isArrayLike = __webpack_require__(165),
	    isObjectLike = __webpack_require__(18);
	
	/**
	 * This method is like `_.isArrayLike` except that it also checks if `value`
	 * is an object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array-like object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArrayLikeObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLikeObject(document.body.children);
	 * // => true
	 *
	 * _.isArrayLikeObject('abc');
	 * // => false
	 *
	 * _.isArrayLikeObject(_.noop);
	 * // => false
	 */
	function isArrayLikeObject(value) {
	  return isObjectLike(value) && isArrayLike(value);
	}
	
	module.exports = isArrayLikeObject;


/***/ },
/* 165 */
/***/ function(module, exports, __webpack_require__) {

	var isFunction = __webpack_require__(125),
	    isLength = __webpack_require__(166);
	
	/**
	 * Checks if `value` is array-like. A value is considered array-like if it's
	 * not a function and has a `value.length` that's an integer greater than or
	 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	 * @example
	 *
	 * _.isArrayLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLike(document.body.children);
	 * // => true
	 *
	 * _.isArrayLike('abc');
	 * // => true
	 *
	 * _.isArrayLike(_.noop);
	 * // => false
	 */
	function isArrayLike(value) {
	  return value != null && isLength(value.length) && !isFunction(value);
	}
	
	module.exports = isArrayLike;


/***/ },
/* 166 */
/***/ function(module, exports) {

	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER = 9007199254740991;
	
	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This method is loosely based on
	 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 * @example
	 *
	 * _.isLength(3);
	 * // => true
	 *
	 * _.isLength(Number.MIN_VALUE);
	 * // => false
	 *
	 * _.isLength(Infinity);
	 * // => false
	 *
	 * _.isLength('3');
	 * // => false
	 */
	function isLength(value) {
	  return typeof value == 'number' &&
	    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	}
	
	module.exports = isLength;


/***/ },
/* 167 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {var root = __webpack_require__(10),
	    stubFalse = __webpack_require__(168);
	
	/** Detect free variable `exports`. */
	var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
	
	/** Detect free variable `module`. */
	var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
	
	/** Detect the popular CommonJS extension `module.exports`. */
	var moduleExports = freeModule && freeModule.exports === freeExports;
	
	/** Built-in value references. */
	var Buffer = moduleExports ? root.Buffer : undefined;
	
	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;
	
	/**
	 * Checks if `value` is a buffer.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.3.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
	 * @example
	 *
	 * _.isBuffer(new Buffer(2));
	 * // => true
	 *
	 * _.isBuffer(new Uint8Array(2));
	 * // => false
	 */
	var isBuffer = nativeIsBuffer || stubFalse;
	
	module.exports = isBuffer;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(101)(module)))

/***/ },
/* 168 */
/***/ function(module, exports) {

	/**
	 * This method returns `false`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.13.0
	 * @category Util
	 * @returns {boolean} Returns `false`.
	 * @example
	 *
	 * _.times(2, _.stubFalse);
	 * // => [false, false]
	 */
	function stubFalse() {
	  return false;
	}
	
	module.exports = stubFalse;


/***/ },
/* 169 */
/***/ function(module, exports, __webpack_require__) {

	var baseGetTag = __webpack_require__(14),
	    getPrototype = __webpack_require__(158),
	    isObjectLike = __webpack_require__(18);
	
	/** `Object#toString` result references. */
	var objectTag = '[object Object]';
	
	/** Used for built-in method references. */
	var funcProto = Function.prototype,
	    objectProto = Object.prototype;
	
	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;
	
	/** Used to infer the `Object` constructor. */
	var objectCtorString = funcToString.call(Object);
	
	/**
	 * Checks if `value` is a plain object, that is, an object created by the
	 * `Object` constructor or one with a `[[Prototype]]` of `null`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.8.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 * }
	 *
	 * _.isPlainObject(new Foo);
	 * // => false
	 *
	 * _.isPlainObject([1, 2, 3]);
	 * // => false
	 *
	 * _.isPlainObject({ 'x': 0, 'y': 0 });
	 * // => true
	 *
	 * _.isPlainObject(Object.create(null));
	 * // => true
	 */
	function isPlainObject(value) {
	  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
	    return false;
	  }
	  var proto = getPrototype(value);
	  if (proto === null) {
	    return true;
	  }
	  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
	  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
	    funcToString.call(Ctor) == objectCtorString;
	}
	
	module.exports = isPlainObject;


/***/ },
/* 170 */
/***/ function(module, exports, __webpack_require__) {

	var baseIsTypedArray = __webpack_require__(171),
	    baseUnary = __webpack_require__(172),
	    nodeUtil = __webpack_require__(173);
	
	/* Node.js helper references. */
	var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
	
	/**
	 * Checks if `value` is classified as a typed array.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 * @example
	 *
	 * _.isTypedArray(new Uint8Array);
	 * // => true
	 *
	 * _.isTypedArray([]);
	 * // => false
	 */
	var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
	
	module.exports = isTypedArray;


/***/ },
/* 171 */
/***/ function(module, exports, __webpack_require__) {

	var baseGetTag = __webpack_require__(14),
	    isLength = __webpack_require__(166),
	    isObjectLike = __webpack_require__(18);
	
	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]',
	    arrayTag = '[object Array]',
	    boolTag = '[object Boolean]',
	    dateTag = '[object Date]',
	    errorTag = '[object Error]',
	    funcTag = '[object Function]',
	    mapTag = '[object Map]',
	    numberTag = '[object Number]',
	    objectTag = '[object Object]',
	    regexpTag = '[object RegExp]',
	    setTag = '[object Set]',
	    stringTag = '[object String]',
	    weakMapTag = '[object WeakMap]';
	
	var arrayBufferTag = '[object ArrayBuffer]',
	    dataViewTag = '[object DataView]',
	    float32Tag = '[object Float32Array]',
	    float64Tag = '[object Float64Array]',
	    int8Tag = '[object Int8Array]',
	    int16Tag = '[object Int16Array]',
	    int32Tag = '[object Int32Array]',
	    uint8Tag = '[object Uint8Array]',
	    uint8ClampedTag = '[object Uint8ClampedArray]',
	    uint16Tag = '[object Uint16Array]',
	    uint32Tag = '[object Uint32Array]';
	
	/** Used to identify `toStringTag` values of typed arrays. */
	var typedArrayTags = {};
	typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
	typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
	typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
	typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
	typedArrayTags[uint32Tag] = true;
	typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
	typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
	typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
	typedArrayTags[errorTag] = typedArrayTags[funcTag] =
	typedArrayTags[mapTag] = typedArrayTags[numberTag] =
	typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
	typedArrayTags[setTag] = typedArrayTags[stringTag] =
	typedArrayTags[weakMapTag] = false;
	
	/**
	 * The base implementation of `_.isTypedArray` without Node.js optimizations.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 */
	function baseIsTypedArray(value) {
	  return isObjectLike(value) &&
	    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
	}
	
	module.exports = baseIsTypedArray;


/***/ },
/* 172 */
/***/ function(module, exports) {

	/**
	 * The base implementation of `_.unary` without support for storing metadata.
	 *
	 * @private
	 * @param {Function} func The function to cap arguments for.
	 * @returns {Function} Returns the new capped function.
	 */
	function baseUnary(func) {
	  return function(value) {
	    return func(value);
	  };
	}
	
	module.exports = baseUnary;


/***/ },
/* 173 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {var freeGlobal = __webpack_require__(11);
	
	/** Detect free variable `exports`. */
	var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
	
	/** Detect free variable `module`. */
	var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
	
	/** Detect the popular CommonJS extension `module.exports`. */
	var moduleExports = freeModule && freeModule.exports === freeExports;
	
	/** Detect free variable `process` from Node.js. */
	var freeProcess = moduleExports && freeGlobal.process;
	
	/** Used to access faster Node.js helpers. */
	var nodeUtil = (function() {
	  try {
	    return freeProcess && freeProcess.binding && freeProcess.binding('util');
	  } catch (e) {}
	}());
	
	module.exports = nodeUtil;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(101)(module)))

/***/ },
/* 174 */
/***/ function(module, exports, __webpack_require__) {

	var copyObject = __webpack_require__(175),
	    keysIn = __webpack_require__(177);
	
	/**
	 * Converts `value` to a plain object flattening inherited enumerable string
	 * keyed properties of `value` to own properties of the plain object.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Lang
	 * @param {*} value The value to convert.
	 * @returns {Object} Returns the converted plain object.
	 * @example
	 *
	 * function Foo() {
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.assign({ 'a': 1 }, new Foo);
	 * // => { 'a': 1, 'b': 2 }
	 *
	 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
	 * // => { 'a': 1, 'b': 2, 'c': 3 }
	 */
	function toPlainObject(value) {
	  return copyObject(value, keysIn(value));
	}
	
	module.exports = toPlainObject;


/***/ },
/* 175 */
/***/ function(module, exports, __webpack_require__) {

	var assignValue = __webpack_require__(176),
	    baseAssignValue = __webpack_require__(146);
	
	/**
	 * Copies properties of `source` to `object`.
	 *
	 * @private
	 * @param {Object} source The object to copy properties from.
	 * @param {Array} props The property identifiers to copy.
	 * @param {Object} [object={}] The object to copy properties to.
	 * @param {Function} [customizer] The function to customize copied values.
	 * @returns {Object} Returns `object`.
	 */
	function copyObject(source, props, object, customizer) {
	  var isNew = !object;
	  object || (object = {});
	
	  var index = -1,
	      length = props.length;
	
	  while (++index < length) {
	    var key = props[index];
	
	    var newValue = customizer
	      ? customizer(object[key], source[key], key, object, source)
	      : undefined;
	
	    if (newValue === undefined) {
	      newValue = source[key];
	    }
	    if (isNew) {
	      baseAssignValue(object, key, newValue);
	    } else {
	      assignValue(object, key, newValue);
	    }
	  }
	  return object;
	}
	
	module.exports = copyObject;


/***/ },
/* 176 */
/***/ function(module, exports, __webpack_require__) {

	var baseAssignValue = __webpack_require__(146),
	    eq = __webpack_require__(113);
	
	/** Used for built-in method references. */
	var objectProto = Object.prototype;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;
	
	/**
	 * Assigns `value` to `key` of `object` if the existing value is not equivalent
	 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * for equality comparisons.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {string} key The key of the property to assign.
	 * @param {*} value The value to assign.
	 */
	function assignValue(object, key, value) {
	  var objValue = object[key];
	  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
	      (value === undefined && !(key in object))) {
	    baseAssignValue(object, key, value);
	  }
	}
	
	module.exports = assignValue;


/***/ },
/* 177 */
/***/ function(module, exports, __webpack_require__) {

	var arrayLikeKeys = __webpack_require__(178),
	    baseKeysIn = __webpack_require__(181),
	    isArrayLike = __webpack_require__(165);
	
	/**
	 * Creates an array of the own and inherited enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keysIn(new Foo);
	 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
	 */
	function keysIn(object) {
	  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
	}
	
	module.exports = keysIn;


/***/ },
/* 178 */
/***/ function(module, exports, __webpack_require__) {

	var baseTimes = __webpack_require__(179),
	    isArguments = __webpack_require__(161),
	    isArray = __webpack_require__(163),
	    isBuffer = __webpack_require__(167),
	    isIndex = __webpack_require__(180),
	    isTypedArray = __webpack_require__(170);
	
	/** Used for built-in method references. */
	var objectProto = Object.prototype;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;
	
	/**
	 * Creates an array of the enumerable property names of the array-like `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @param {boolean} inherited Specify returning inherited property names.
	 * @returns {Array} Returns the array of property names.
	 */
	function arrayLikeKeys(value, inherited) {
	  var isArr = isArray(value),
	      isArg = !isArr && isArguments(value),
	      isBuff = !isArr && !isArg && isBuffer(value),
	      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
	      skipIndexes = isArr || isArg || isBuff || isType,
	      result = skipIndexes ? baseTimes(value.length, String) : [],
	      length = result.length;
	
	  for (var key in value) {
	    if ((inherited || hasOwnProperty.call(value, key)) &&
	        !(skipIndexes && (
	           // Safari 9 has enumerable `arguments.length` in strict mode.
	           key == 'length' ||
	           // Node.js 0.10 has enumerable non-index properties on buffers.
	           (isBuff && (key == 'offset' || key == 'parent')) ||
	           // PhantomJS 2 has enumerable non-index properties on typed arrays.
	           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
	           // Skip index properties.
	           isIndex(key, length)
	        ))) {
	      result.push(key);
	    }
	  }
	  return result;
	}
	
	module.exports = arrayLikeKeys;


/***/ },
/* 179 */
/***/ function(module, exports) {

	/**
	 * The base implementation of `_.times` without support for iteratee shorthands
	 * or max array length checks.
	 *
	 * @private
	 * @param {number} n The number of times to invoke `iteratee`.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the array of results.
	 */
	function baseTimes(n, iteratee) {
	  var index = -1,
	      result = Array(n);
	
	  while (++index < n) {
	    result[index] = iteratee(index);
	  }
	  return result;
	}
	
	module.exports = baseTimes;


/***/ },
/* 180 */
/***/ function(module, exports) {

	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER = 9007199254740991;
	
	/** Used to detect unsigned integer values. */
	var reIsUint = /^(?:0|[1-9]\d*)$/;
	
	/**
	 * Checks if `value` is a valid array-like index.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	 */
	function isIndex(value, length) {
	  length = length == null ? MAX_SAFE_INTEGER : length;
	  return !!length &&
	    (typeof value == 'number' || reIsUint.test(value)) &&
	    (value > -1 && value % 1 == 0 && value < length);
	}
	
	module.exports = isIndex;


/***/ },
/* 181 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(8),
	    isPrototype = __webpack_require__(160),
	    nativeKeysIn = __webpack_require__(182);
	
	/** Used for built-in method references. */
	var objectProto = Object.prototype;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;
	
	/**
	 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function baseKeysIn(object) {
	  if (!isObject(object)) {
	    return nativeKeysIn(object);
	  }
	  var isProto = isPrototype(object),
	      result = [];
	
	  for (var key in object) {
	    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
	      result.push(key);
	    }
	  }
	  return result;
	}
	
	module.exports = baseKeysIn;


/***/ },
/* 182 */
/***/ function(module, exports) {

	/**
	 * This function is like
	 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	 * except that it includes inherited enumerable properties.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function nativeKeysIn(object) {
	  var result = [];
	  if (object != null) {
	    for (var key in Object(object)) {
	      result.push(key);
	    }
	  }
	  return result;
	}
	
	module.exports = nativeKeysIn;


/***/ },
/* 183 */
/***/ function(module, exports, __webpack_require__) {

	var baseRest = __webpack_require__(184),
	    isIterateeCall = __webpack_require__(192);
	
	/**
	 * Creates a function like `_.assign`.
	 *
	 * @private
	 * @param {Function} assigner The function to assign values.
	 * @returns {Function} Returns the new assigner function.
	 */
	function createAssigner(assigner) {
	  return baseRest(function(object, sources) {
	    var index = -1,
	        length = sources.length,
	        customizer = length > 1 ? sources[length - 1] : undefined,
	        guard = length > 2 ? sources[2] : undefined;
	
	    customizer = (assigner.length > 3 && typeof customizer == 'function')
	      ? (length--, customizer)
	      : undefined;
	
	    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
	      customizer = length < 3 ? undefined : customizer;
	      length = 1;
	    }
	    object = Object(object);
	    while (++index < length) {
	      var source = sources[index];
	      if (source) {
	        assigner(object, source, index, customizer);
	      }
	    }
	    return object;
	  });
	}
	
	module.exports = createAssigner;


/***/ },
/* 184 */
/***/ function(module, exports, __webpack_require__) {

	var identity = __webpack_require__(185),
	    overRest = __webpack_require__(186),
	    setToString = __webpack_require__(188);
	
	/**
	 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
	 *
	 * @private
	 * @param {Function} func The function to apply a rest parameter to.
	 * @param {number} [start=func.length-1] The start position of the rest parameter.
	 * @returns {Function} Returns the new function.
	 */
	function baseRest(func, start) {
	  return setToString(overRest(func, start, identity), func + '');
	}
	
	module.exports = baseRest;


/***/ },
/* 185 */
/***/ function(module, exports) {

	/**
	 * This method returns the first argument it receives.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Util
	 * @param {*} value Any value.
	 * @returns {*} Returns `value`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 *
	 * console.log(_.identity(object) === object);
	 * // => true
	 */
	function identity(value) {
	  return value;
	}
	
	module.exports = identity;


/***/ },
/* 186 */
/***/ function(module, exports, __webpack_require__) {

	var apply = __webpack_require__(187);
	
	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMax = Math.max;
	
	/**
	 * A specialized version of `baseRest` which transforms the rest array.
	 *
	 * @private
	 * @param {Function} func The function to apply a rest parameter to.
	 * @param {number} [start=func.length-1] The start position of the rest parameter.
	 * @param {Function} transform The rest array transform.
	 * @returns {Function} Returns the new function.
	 */
	function overRest(func, start, transform) {
	  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
	  return function() {
	    var args = arguments,
	        index = -1,
	        length = nativeMax(args.length - start, 0),
	        array = Array(length);
	
	    while (++index < length) {
	      array[index] = args[start + index];
	    }
	    index = -1;
	    var otherArgs = Array(start + 1);
	    while (++index < start) {
	      otherArgs[index] = args[index];
	    }
	    otherArgs[start] = transform(array);
	    return apply(func, this, otherArgs);
	  };
	}
	
	module.exports = overRest;


/***/ },
/* 187 */
/***/ function(module, exports) {

	/**
	 * A faster alternative to `Function#apply`, this function invokes `func`
	 * with the `this` binding of `thisArg` and the arguments of `args`.
	 *
	 * @private
	 * @param {Function} func The function to invoke.
	 * @param {*} thisArg The `this` binding of `func`.
	 * @param {Array} args The arguments to invoke `func` with.
	 * @returns {*} Returns the result of `func`.
	 */
	function apply(func, thisArg, args) {
	  switch (args.length) {
	    case 0: return func.call(thisArg);
	    case 1: return func.call(thisArg, args[0]);
	    case 2: return func.call(thisArg, args[0], args[1]);
	    case 3: return func.call(thisArg, args[0], args[1], args[2]);
	  }
	  return func.apply(thisArg, args);
	}
	
	module.exports = apply;


/***/ },
/* 188 */
/***/ function(module, exports, __webpack_require__) {

	var baseSetToString = __webpack_require__(189),
	    shortOut = __webpack_require__(191);
	
	/**
	 * Sets the `toString` method of `func` to return `string`.
	 *
	 * @private
	 * @param {Function} func The function to modify.
	 * @param {Function} string The `toString` result.
	 * @returns {Function} Returns `func`.
	 */
	var setToString = shortOut(baseSetToString);
	
	module.exports = setToString;


/***/ },
/* 189 */
/***/ function(module, exports, __webpack_require__) {

	var constant = __webpack_require__(190),
	    defineProperty = __webpack_require__(147),
	    identity = __webpack_require__(185);
	
	/**
	 * The base implementation of `setToString` without support for hot loop shorting.
	 *
	 * @private
	 * @param {Function} func The function to modify.
	 * @param {Function} string The `toString` result.
	 * @returns {Function} Returns `func`.
	 */
	var baseSetToString = !defineProperty ? identity : function(func, string) {
	  return defineProperty(func, 'toString', {
	    'configurable': true,
	    'enumerable': false,
	    'value': constant(string),
	    'writable': true
	  });
	};
	
	module.exports = baseSetToString;


/***/ },
/* 190 */
/***/ function(module, exports) {

	/**
	 * Creates a function that returns `value`.
	 *
	 * @static
	 * @memberOf _
	 * @since 2.4.0
	 * @category Util
	 * @param {*} value The value to return from the new function.
	 * @returns {Function} Returns the new constant function.
	 * @example
	 *
	 * var objects = _.times(2, _.constant({ 'a': 1 }));
	 *
	 * console.log(objects);
	 * // => [{ 'a': 1 }, { 'a': 1 }]
	 *
	 * console.log(objects[0] === objects[1]);
	 * // => true
	 */
	function constant(value) {
	  return function() {
	    return value;
	  };
	}
	
	module.exports = constant;


/***/ },
/* 191 */
/***/ function(module, exports) {

	/** Used to detect hot functions by number of calls within a span of milliseconds. */
	var HOT_COUNT = 800,
	    HOT_SPAN = 16;
	
	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeNow = Date.now;
	
	/**
	 * Creates a function that'll short out and invoke `identity` instead
	 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
	 * milliseconds.
	 *
	 * @private
	 * @param {Function} func The function to restrict.
	 * @returns {Function} Returns the new shortable function.
	 */
	function shortOut(func) {
	  var count = 0,
	      lastCalled = 0;
	
	  return function() {
	    var stamp = nativeNow(),
	        remaining = HOT_SPAN - (stamp - lastCalled);
	
	    lastCalled = stamp;
	    if (remaining > 0) {
	      if (++count >= HOT_COUNT) {
	        return arguments[0];
	      }
	    } else {
	      count = 0;
	    }
	    return func.apply(undefined, arguments);
	  };
	}
	
	module.exports = shortOut;


/***/ },
/* 192 */
/***/ function(module, exports, __webpack_require__) {

	var eq = __webpack_require__(113),
	    isArrayLike = __webpack_require__(165),
	    isIndex = __webpack_require__(180),
	    isObject = __webpack_require__(8);
	
	/**
	 * Checks if the given arguments are from an iteratee call.
	 *
	 * @private
	 * @param {*} value The potential iteratee value argument.
	 * @param {*} index The potential iteratee index or key argument.
	 * @param {*} object The potential iteratee object argument.
	 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
	 *  else `false`.
	 */
	function isIterateeCall(value, index, object) {
	  if (!isObject(object)) {
	    return false;
	  }
	  var type = typeof index;
	  if (type == 'number'
	        ? (isArrayLike(object) && isIndex(index, object.length))
	        : (type == 'string' && index in object)
	      ) {
	    return eq(object[index], value);
	  }
	  return false;
	}
	
	module.exports = isIterateeCall;


/***/ },
/* 193 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _classCallCheck2 = __webpack_require__(2);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _ = __webpack_require__(194);
	
	var Render = _interopRequireWildcard(_);
	
	var _Utils = __webpack_require__(103);
	
	var _Utils2 = _interopRequireDefault(_Utils);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var RenderFactory = function () {
	    function RenderFactory() {
	        (0, _classCallCheck3.default)(this, RenderFactory);
	    }
	
	    RenderFactory.create = function create(className, opts) {
	        return new Render[className](opts, _Utils2.default.Uid());
	    };
	
	    return RenderFactory;
	}();
	
	exports.default = RenderFactory;

/***/ },
/* 194 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _HeaderRender = __webpack_require__(195);
	
	Object.defineProperty(exports, "Header", {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_HeaderRender).default;
	  }
	});
	
	var _ImageTextRender = __webpack_require__(240);
	
	Object.defineProperty(exports, "ImageText", {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_ImageTextRender).default;
	  }
	});
	
	var _ImageRender = __webpack_require__(241);
	
	Object.defineProperty(exports, "Image", {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_ImageRender).default;
	  }
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ },
/* 195 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _classCallCheck2 = __webpack_require__(2);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(20);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(89);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _BaseRender2 = __webpack_require__(196);
	
	var _BaseRender3 = _interopRequireDefault(_BaseRender2);
	
	var _fields = __webpack_require__(199);
	
	var Fields = _interopRequireWildcard(_fields);
	
	var _lodash = __webpack_require__(198);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	// HeaderBlockItem
	var HeaderRender = function (_BaseRender) {
	    (0, _inherits3.default)(HeaderRender, _BaseRender);
	
	    function HeaderRender(opts) {
	        (0, _classCallCheck3.default)(this, HeaderRender);
	        return (0, _possibleConstructorReturn3.default)(this, _BaseRender.call(this, opts));
	    }
	
	    HeaderRender.prototype.createFields = function createFields() {
	        /* Image field */
	        var imageField = new Fields.ImageField(_BaseRender.prototype.getSettingsForChild.call(this, false));
	
	        /* Title field */
	        var titleField = new Fields.RichTextField(_BaseRender.prototype.getSettingsForChild.call(this, true));
	
	        /* Abstract field */
	        var abstractField = new Fields.RichTextField(_BaseRender.prototype.getSettingsForChild.call(this, true, {
	            showCode: true
	        }));
	
	        /* Title style field */
	        var titleStyleField = new Fields.SelectField(_BaseRender.prototype.getSettingsForChild.call(this, false, {
	            "values": {
	                "normal": "Normale",
	                "gradient": "Gradiente arancione"
	            }
	        }));
	
	        _BaseRender.prototype.appendField.call(this, "image", imageField, "Immagine");
	        _BaseRender.prototype.appendField.call(this, "title", titleField, "Title");
	        _BaseRender.prototype.appendField.call(this, "titleStyle", titleStyleField, "Title style");
	        _BaseRender.prototype.appendField.call(this, "abstract", abstractField, "Abstract");
	    };
	
	    HeaderRender.prototype.delete = function _delete() {
	        return _BaseRender.prototype.getField.call(this, "image").delete();
	    };
	
	    return HeaderRender;
	}(_BaseRender3.default);
	
	exports.default = HeaderRender;

/***/ },
/* 196 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _classCallCheck2 = __webpack_require__(2);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(20);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(89);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _Component2 = __webpack_require__(97);
	
	var _Component3 = _interopRequireDefault(_Component2);
	
	var _Utils = __webpack_require__(103);
	
	var _Utils2 = _interopRequireDefault(_Utils);
	
	var _classie = __webpack_require__(99);
	
	var _classie2 = _interopRequireDefault(_classie);
	
	var _BaseField = __webpack_require__(197);
	
	var _BaseField2 = _interopRequireDefault(_BaseField);
	
	var _base = __webpack_require__(104);
	
	var _base2 = _interopRequireDefault(_base);
	
	var _lodash = __webpack_require__(198);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var BaseRender = function (_Component) {
	    (0, _inherits3.default)(BaseRender, _Component);
	
	    function BaseRender(opts) {
	        (0, _classCallCheck3.default)(this, BaseRender);
	
	        var _this = (0, _possibleConstructorReturn3.default)(this, _Component.call(this, null, opts));
	
	        _this.fields = Array();
	        _this.onChildChanged = _this.onChildChanged.bind(_this);
	        return _this;
	    }
	
	    BaseRender.prototype.onChildChanged = function onChildChanged() {};
	
	    BaseRender.prototype.init = function init(el) {
	
	        this.createContainer();
	
	        this.createFields();
	
	        var blockData = {};
	
	        if (_Utils2.default.Data(el, "pagecomposeredit") == 1) {
	            blockData = JSON.parse(_base2.default.decode(el.innerText.trim()));
	        }
	
	        el.replaceWith(this.containerEl);
	
	        for (var field in this.fields) {
	            var currentField = this.fields[field];
	            if (currentField) {
	                if (typeof currentField.init === "function") {
	                    currentField.init();
	                }
	
	                var fieldName = currentField.getFieldName();
	                if (blockData.hasOwnProperty(fieldName) && typeof currentField.setValue === "function") {
	                    currentField.setValue(blockData[fieldName]);
	                }
	            }
	        }
	
	        _Utils2.default.Data(this.containerEl, "pagecomposerblockrendered", 1);
	    };
	
	    BaseRender.prototype.getDefaultOptions = function getDefaultOptions() {
	        return {
	            changeCallback: this.onChildChanged
	        };
	    };
	
	    BaseRender.prototype.getSettingsForChild = function getSettingsForChild(isLocalized) {
	        var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	
	
	        var result = _lodash2.default.merge(opts, {
	            changeCallback: this.settings.changeCallback,
	            endpoints: this.settings.endpoints
	        });
	
	        if (isLocalized) {
	            result.languages = this.settings.languages;
	            result.currentLang = this.settings.currentLang;
	        }
	
	        return result;
	    };
	
	    BaseRender.prototype.createFields = function createFields() {};
	
	    BaseRender.prototype.wrapField = function wrapField(el, label) {
	        var wrapperEl = document.createElement("div");
	        _classie2.default.add(wrapperEl, "field-wrapper");
	
	        var labelContainerEl = document.createElement("div");
	        _classie2.default.add(labelContainerEl, "field-label-container");
	
	        var labelEl = document.createElement("span");
	        labelEl.innerText = label;
	
	        labelContainerEl.appendChild(labelEl);
	
	        wrapperEl.appendChild(labelContainerEl);
	
	        if (Array.isArray(el)) {
	            el.forEach(function (child) {
	                wrapperEl.appendChild(child);
	            }, this);
	        } else {
	            wrapperEl.appendChild(el);
	        }
	
	        return wrapperEl;
	    };
	
	    BaseRender.prototype.createContainer = function createContainer() {
	        var containerEl = document.createElement("div");
	
	        _classie2.default.add(containerEl, "render-container");
	        _classie2.default.add(containerEl, "block-item");
	        _classie2.default.add(containerEl, _lodash2.default.snakeCase(this.constructor.name).replace("_", "-"));
	
	        _Utils2.default.Data(containerEl, "pagecomposeruid", this.id());
	
	        var taskHtml = '\
	            <div class="block-task u-text--right">\
	                <span class="block-task-icon task-move"></span>\
	                <span class="block-task-icon task-delete"></span>\
	            </div>';
	
	        containerEl.appendChild(_Component.prototype.find.call(this, new DOMParser().parseFromString(taskHtml, "text/html"), ".block-task"));
	
	        var separatorEl = document.createElement("hr");
	
	        containerEl.appendChild(separatorEl);
	
	        this.containerEl = containerEl;
	    };
	
	    BaseRender.prototype.addField = function addField(id, field) {
	        if (field && field instanceof _BaseField2.default) {
	            field.setFieldName(id);
	            this.fields[id] = field;
	            return true;
	        }
	        return false;
	    };
	
	    BaseRender.prototype.getField = function getField(id) {
	        if (this.fields && this.fields[id]) {
	            return this.fields[id];
	        }
	        return null;
	    };
	
	    BaseRender.prototype.appendField = function appendField(id, field, label) {
	        if (this.addField(id, field)) {
	            this.addToLayout(this.wrapField(field.build(), label));
	        }
	    };
	
	    BaseRender.prototype.addToLayout = function addToLayout(el) {
	        var separatorEl = this.getSeparator();
	        this.containerEl.insertBefore(el, separatorEl);
	    };
	
	    BaseRender.prototype.getSeparator = function getSeparator() {
	        return this.containerEl.querySelectorAll("hr")[0];
	    };
	
	    BaseRender.prototype.getValue = function getValue() {
	        var obj = {};
	        for (var key in this.fields) {
	            var field = this.fields[key];
	            if (field.getValue && typeof field.getValue === "function") {
	                obj[key] = field.getValue();
	            }
	        }
	        return obj;
	    };
	
	    BaseRender.prototype.setCurrentLanguage = function setCurrentLanguage(lang) {
	        for (var key in this.fields) {
	            var field = this.fields[key];
	            if (field.setCurrentLanguage && typeof field.setCurrentLanguage === "function") {
	                field.setCurrentLanguage(lang);
	            }
	        }
	    };
	
	    return BaseRender;
	}(_Component3.default);
	
	exports.default = BaseRender;

/***/ },
/* 197 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _classCallCheck2 = __webpack_require__(2);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(20);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(89);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _Component2 = __webpack_require__(97);
	
	var _Component3 = _interopRequireDefault(_Component2);
	
	var _Utils = __webpack_require__(103);
	
	var _Utils2 = _interopRequireDefault(_Utils);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var BaseField = function (_Component) {
	    (0, _inherits3.default)(BaseField, _Component);
	
	    function BaseField(opts) {
	        (0, _classCallCheck3.default)(this, BaseField);
	
	        var _this = (0, _possibleConstructorReturn3.default)(this, _Component.call(this, null, opts));
	
	        _this.fieldName = "";
	        _this.components = new Map();
	        return _this;
	    }
	
	    BaseField.prototype.init = function init() {};
	
	    BaseField.prototype.build = function build() {
	        if (this.settings.languages) {
	            var localizedFieldContainer = document.createElement("div");
	            localizedFieldContainer.classList.add("translation-container");
	            for (var lang in this.settings.languages) {
	                var localizedFieldEl = this.createLocalizedField(lang);
	                if (localizedFieldEl) {
	                    this.addComponent(lang, localizedFieldEl);
	                    localizedFieldContainer.appendChild(localizedFieldEl);
	                    if (lang !== this.settings.currentLang) localizedFieldEl.style.display = 'none';
	                }
	            }
	            return localizedFieldContainer;
	        } else {
	            var _localizedFieldEl = this.createLocalizedField(_Utils2.default.NoLang());
	            if (_localizedFieldEl) {
	                this.addComponent(_Utils2.default.NoLang(), _localizedFieldEl);
	                return _localizedFieldEl;
	            }
	            return null;
	        }
	    };
	
	    BaseField.prototype.createLocalizedField = function createLocalizedField(lang) {
	        throw "Unimplemented 'createLocalizedField' in " + this.constructor.name;
	    };
	
	    BaseField.prototype.getDefaultOptions = function getDefaultOptions() {
	        return {
	            changeCallback: null,
	            languages: null,
	            currentLang: null
	        };
	    };
	
	    BaseField.prototype.getComponents = function getComponents() {
	        return this.components;
	    };
	
	    BaseField.prototype.setCurrentLang = function setCurrentLang(lang) {};
	
	    BaseField.prototype.addComponent = function addComponent(lang, el) {
	        var _this2 = this;
	
	        if (el && lang) {
	            this.components.set(lang, el);
	            el.addEventListener("change", function () {
	                _this2.signalChange();
	            });
	        }
	    };
	
	    BaseField.prototype.signalChange = function signalChange() {
	        if (this.settings.changeCallback && typeof this.settings.changeCallback === 'function') this.settings.changeCallback();
	    };
	
	    BaseField.prototype.getValueFromLocalizedField = function getValueFromLocalizedField(el, lang) {
	        return el ? el.value : null;
	    };
	
	    BaseField.prototype.setValueToLocalizedField = function setValueToLocalizedField(el, value, lang) {
	        if (el) el.value = value;
	    };
	
	    BaseField.prototype.getValue = function getValue() {
	        if (this.components.size <= 0) return null;
	
	        if (this.components.size === 1 && this.components.keys().next().value === _Utils2.default.NoLang()) return this.getValueFromLocalizedField(this.components.get(_Utils2.default.NoLang()), _Utils2.default.NoLang());
	
	        var result = {};
	        for (var _iterator = this.components, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
	            var _ref;
	
	            if (_isArray) {
	                if (_i >= _iterator.length) break;
	                _ref = _iterator[_i++];
	            } else {
	                _i = _iterator.next();
	                if (_i.done) break;
	                _ref = _i.value;
	            }
	
	            var _ref2 = _ref,
	                lang = _ref2[0],
	                el = _ref2[1];
	
	            result[lang] = this.getValueFromLocalizedField(el, lang);
	        }return result;
	    };
	
	    BaseField.prototype.setValue = function setValue(value) {
	        if (this.components.size <= 0) return null;
	
	        if (this.components.size === 1 && this.components.keys().next().value === _Utils2.default.NoLang()) return this.setValueToLocalizedField(this.components.get(_Utils2.default.NoLang()), value, _Utils2.default.NoLang());
	
	        for (var _iterator2 = this.components, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
	            var _ref3;
	
	            if (_isArray2) {
	                if (_i2 >= _iterator2.length) break;
	                _ref3 = _iterator2[_i2++];
	            } else {
	                _i2 = _iterator2.next();
	                if (_i2.done) break;
	                _ref3 = _i2.value;
	            }
	
	            var _ref4 = _ref3,
	                lang = _ref4[0],
	                el = _ref4[1];
	
	            if (value[lang]) this.setValueToLocalizedField(el, value[lang], lang);
	        }
	    };
	
	    BaseField.prototype.getFieldName = function getFieldName() {
	        return this.fieldName;
	    };
	
	    BaseField.prototype.setFieldName = function setFieldName(value) {
	        this.fieldName = value;
	    };
	
	    BaseField.prototype.setCurrentLanguage = function setCurrentLanguage(currentLanguage) {
	        for (var _iterator3 = this.getComponents(), _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
	            var _ref5;
	
	            if (_isArray3) {
	                if (_i3 >= _iterator3.length) break;
	                _ref5 = _iterator3[_i3++];
	            } else {
	                _i3 = _iterator3.next();
	                if (_i3.done) break;
	                _ref5 = _i3.value;
	            }
	
	            var _ref6 = _ref5,
	                lang = _ref6[0],
	                el = _ref6[1];
	
	            if (_Utils2.default.NoLang() === lang || lang === currentLanguage) el.style.display = "block";else el.style.display = "none";
	        }
	    };
	
	    return BaseField;
	}(_Component3.default);
	
	exports.default = BaseField;

/***/ },
/* 198 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(global, module) {/**
	 * @license
	 * Lodash <https://lodash.com/>
	 * Copyright JS Foundation and other contributors <https://js.foundation/>
	 * Released under MIT license <https://lodash.com/license>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 */
	;(function() {
	
	  /** Used as a safe reference for `undefined` in pre-ES5 environments. */
	  var undefined;
	
	  /** Used as the semantic version number. */
	  var VERSION = '4.17.2';
	
	  /** Used as the size to enable large array optimizations. */
	  var LARGE_ARRAY_SIZE = 200;
	
	  /** Error message constants. */
	  var CORE_ERROR_TEXT = 'Unsupported core-js use. Try https://npms.io/search?q=ponyfill.',
	      FUNC_ERROR_TEXT = 'Expected a function';
	
	  /** Used to stand-in for `undefined` hash values. */
	  var HASH_UNDEFINED = '__lodash_hash_undefined__';
	
	  /** Used as the maximum memoize cache size. */
	  var MAX_MEMOIZE_SIZE = 500;
	
	  /** Used as the internal argument placeholder. */
	  var PLACEHOLDER = '__lodash_placeholder__';
	
	  /** Used to compose bitmasks for cloning. */
	  var CLONE_DEEP_FLAG = 1,
	      CLONE_FLAT_FLAG = 2,
	      CLONE_SYMBOLS_FLAG = 4;
	
	  /** Used to compose bitmasks for value comparisons. */
	  var COMPARE_PARTIAL_FLAG = 1,
	      COMPARE_UNORDERED_FLAG = 2;
	
	  /** Used to compose bitmasks for function metadata. */
	  var WRAP_BIND_FLAG = 1,
	      WRAP_BIND_KEY_FLAG = 2,
	      WRAP_CURRY_BOUND_FLAG = 4,
	      WRAP_CURRY_FLAG = 8,
	      WRAP_CURRY_RIGHT_FLAG = 16,
	      WRAP_PARTIAL_FLAG = 32,
	      WRAP_PARTIAL_RIGHT_FLAG = 64,
	      WRAP_ARY_FLAG = 128,
	      WRAP_REARG_FLAG = 256,
	      WRAP_FLIP_FLAG = 512;
	
	  /** Used as default options for `_.truncate`. */
	  var DEFAULT_TRUNC_LENGTH = 30,
	      DEFAULT_TRUNC_OMISSION = '...';
	
	  /** Used to detect hot functions by number of calls within a span of milliseconds. */
	  var HOT_COUNT = 800,
	      HOT_SPAN = 16;
	
	  /** Used to indicate the type of lazy iteratees. */
	  var LAZY_FILTER_FLAG = 1,
	      LAZY_MAP_FLAG = 2,
	      LAZY_WHILE_FLAG = 3;
	
	  /** Used as references for various `Number` constants. */
	  var INFINITY = 1 / 0,
	      MAX_SAFE_INTEGER = 9007199254740991,
	      MAX_INTEGER = 1.7976931348623157e+308,
	      NAN = 0 / 0;
	
	  /** Used as references for the maximum length and index of an array. */
	  var MAX_ARRAY_LENGTH = 4294967295,
	      MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
	      HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
	
	  /** Used to associate wrap methods with their bit flags. */
	  var wrapFlags = [
	    ['ary', WRAP_ARY_FLAG],
	    ['bind', WRAP_BIND_FLAG],
	    ['bindKey', WRAP_BIND_KEY_FLAG],
	    ['curry', WRAP_CURRY_FLAG],
	    ['curryRight', WRAP_CURRY_RIGHT_FLAG],
	    ['flip', WRAP_FLIP_FLAG],
	    ['partial', WRAP_PARTIAL_FLAG],
	    ['partialRight', WRAP_PARTIAL_RIGHT_FLAG],
	    ['rearg', WRAP_REARG_FLAG]
	  ];
	
	  /** `Object#toString` result references. */
	  var argsTag = '[object Arguments]',
	      arrayTag = '[object Array]',
	      asyncTag = '[object AsyncFunction]',
	      boolTag = '[object Boolean]',
	      dateTag = '[object Date]',
	      domExcTag = '[object DOMException]',
	      errorTag = '[object Error]',
	      funcTag = '[object Function]',
	      genTag = '[object GeneratorFunction]',
	      mapTag = '[object Map]',
	      numberTag = '[object Number]',
	      nullTag = '[object Null]',
	      objectTag = '[object Object]',
	      promiseTag = '[object Promise]',
	      proxyTag = '[object Proxy]',
	      regexpTag = '[object RegExp]',
	      setTag = '[object Set]',
	      stringTag = '[object String]',
	      symbolTag = '[object Symbol]',
	      undefinedTag = '[object Undefined]',
	      weakMapTag = '[object WeakMap]',
	      weakSetTag = '[object WeakSet]';
	
	  var arrayBufferTag = '[object ArrayBuffer]',
	      dataViewTag = '[object DataView]',
	      float32Tag = '[object Float32Array]',
	      float64Tag = '[object Float64Array]',
	      int8Tag = '[object Int8Array]',
	      int16Tag = '[object Int16Array]',
	      int32Tag = '[object Int32Array]',
	      uint8Tag = '[object Uint8Array]',
	      uint8ClampedTag = '[object Uint8ClampedArray]',
	      uint16Tag = '[object Uint16Array]',
	      uint32Tag = '[object Uint32Array]';
	
	  /** Used to match empty string literals in compiled template source. */
	  var reEmptyStringLeading = /\b__p \+= '';/g,
	      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
	      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
	
	  /** Used to match HTML entities and HTML characters. */
	  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g,
	      reUnescapedHtml = /[&<>"']/g,
	      reHasEscapedHtml = RegExp(reEscapedHtml.source),
	      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
	
	  /** Used to match template delimiters. */
	  var reEscape = /<%-([\s\S]+?)%>/g,
	      reEvaluate = /<%([\s\S]+?)%>/g,
	      reInterpolate = /<%=([\s\S]+?)%>/g;
	
	  /** Used to match property names within property paths. */
	  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
	      reIsPlainProp = /^\w*$/,
	      reLeadingDot = /^\./,
	      rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
	
	  /**
	   * Used to match `RegExp`
	   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
	   */
	  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
	      reHasRegExpChar = RegExp(reRegExpChar.source);
	
	  /** Used to match leading and trailing whitespace. */
	  var reTrim = /^\s+|\s+$/g,
	      reTrimStart = /^\s+/,
	      reTrimEnd = /\s+$/;
	
	  /** Used to match wrap detail comments. */
	  var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
	      reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/,
	      reSplitDetails = /,? & /;
	
	  /** Used to match words composed of alphanumeric characters. */
	  var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
	
	  /** Used to match backslashes in property paths. */
	  var reEscapeChar = /\\(\\)?/g;
	
	  /**
	   * Used to match
	   * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
	   */
	  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
	
	  /** Used to match `RegExp` flags from their coerced string values. */
	  var reFlags = /\w*$/;
	
	  /** Used to detect bad signed hexadecimal string values. */
	  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
	
	  /** Used to detect binary string values. */
	  var reIsBinary = /^0b[01]+$/i;
	
	  /** Used to detect host constructors (Safari). */
	  var reIsHostCtor = /^\[object .+?Constructor\]$/;
	
	  /** Used to detect octal string values. */
	  var reIsOctal = /^0o[0-7]+$/i;
	
	  /** Used to detect unsigned integer values. */
	  var reIsUint = /^(?:0|[1-9]\d*)$/;
	
	  /** Used to match Latin Unicode letters (excluding mathematical operators). */
	  var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
	
	  /** Used to ensure capturing order of template delimiters. */
	  var reNoMatch = /($^)/;
	
	  /** Used to match unescaped characters in compiled string literals. */
	  var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
	
	  /** Used to compose unicode character classes. */
	  var rsAstralRange = '\\ud800-\\udfff',
	      rsComboMarksRange = '\\u0300-\\u036f',
	      reComboHalfMarksRange = '\\ufe20-\\ufe2f',
	      rsComboSymbolsRange = '\\u20d0-\\u20ff',
	      rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
	      rsDingbatRange = '\\u2700-\\u27bf',
	      rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
	      rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
	      rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
	      rsPunctuationRange = '\\u2000-\\u206f',
	      rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
	      rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
	      rsVarRange = '\\ufe0e\\ufe0f',
	      rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
	
	  /** Used to compose unicode capture groups. */
	  var rsApos = "['\u2019]",
	      rsAstral = '[' + rsAstralRange + ']',
	      rsBreak = '[' + rsBreakRange + ']',
	      rsCombo = '[' + rsComboRange + ']',
	      rsDigits = '\\d+',
	      rsDingbat = '[' + rsDingbatRange + ']',
	      rsLower = '[' + rsLowerRange + ']',
	      rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
	      rsFitz = '\\ud83c[\\udffb-\\udfff]',
	      rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
	      rsNonAstral = '[^' + rsAstralRange + ']',
	      rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
	      rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
	      rsUpper = '[' + rsUpperRange + ']',
	      rsZWJ = '\\u200d';
	
	  /** Used to compose unicode regexes. */
	  var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',
	      rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',
	      rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',
	      rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',
	      reOptMod = rsModifier + '?',
	      rsOptVar = '[' + rsVarRange + ']?',
	      rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
	      rsOrdLower = '\\d*(?:(?:1st|2nd|3rd|(?![123])\\dth)\\b)',
	      rsOrdUpper = '\\d*(?:(?:1ST|2ND|3RD|(?![123])\\dTH)\\b)',
	      rsSeq = rsOptVar + reOptMod + rsOptJoin,
	      rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq,
	      rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';
	
	  /** Used to match apostrophes. */
	  var reApos = RegExp(rsApos, 'g');
	
	  /**
	   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
	   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
	   */
	  var reComboMark = RegExp(rsCombo, 'g');
	
	  /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
	  var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');
	
	  /** Used to match complex or compound words. */
	  var reUnicodeWord = RegExp([
	    rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
	    rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',
	    rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,
	    rsUpper + '+' + rsOptContrUpper,
	    rsOrdUpper,
	    rsOrdLower,
	    rsDigits,
	    rsEmoji
	  ].join('|'), 'g');
	
	  /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
	  var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');
	
	  /** Used to detect strings that need a more robust regexp to match words. */
	  var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
	
	  /** Used to assign default `context` object properties. */
	  var contextProps = [
	    'Array', 'Buffer', 'DataView', 'Date', 'Error', 'Float32Array', 'Float64Array',
	    'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Map', 'Math', 'Object',
	    'Promise', 'RegExp', 'Set', 'String', 'Symbol', 'TypeError', 'Uint8Array',
	    'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap',
	    '_', 'clearTimeout', 'isFinite', 'parseInt', 'setTimeout'
	  ];
	
	  /** Used to make template sourceURLs easier to identify. */
	  var templateCounter = -1;
	
	  /** Used to identify `toStringTag` values of typed arrays. */
	  var typedArrayTags = {};
	  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
	  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
	  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
	  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
	  typedArrayTags[uint32Tag] = true;
	  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
	  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
	  typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
	  typedArrayTags[errorTag] = typedArrayTags[funcTag] =
	  typedArrayTags[mapTag] = typedArrayTags[numberTag] =
	  typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
	  typedArrayTags[setTag] = typedArrayTags[stringTag] =
	  typedArrayTags[weakMapTag] = false;
	
	  /** Used to identify `toStringTag` values supported by `_.clone`. */
	  var cloneableTags = {};
	  cloneableTags[argsTag] = cloneableTags[arrayTag] =
	  cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
	  cloneableTags[boolTag] = cloneableTags[dateTag] =
	  cloneableTags[float32Tag] = cloneableTags[float64Tag] =
	  cloneableTags[int8Tag] = cloneableTags[int16Tag] =
	  cloneableTags[int32Tag] = cloneableTags[mapTag] =
	  cloneableTags[numberTag] = cloneableTags[objectTag] =
	  cloneableTags[regexpTag] = cloneableTags[setTag] =
	  cloneableTags[stringTag] = cloneableTags[symbolTag] =
	  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
	  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
	  cloneableTags[errorTag] = cloneableTags[funcTag] =
	  cloneableTags[weakMapTag] = false;
	
	  /** Used to map Latin Unicode letters to basic Latin letters. */
	  var deburredLetters = {
	    // Latin-1 Supplement block.
	    '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
	    '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
	    '\xc7': 'C',  '\xe7': 'c',
	    '\xd0': 'D',  '\xf0': 'd',
	    '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
	    '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
	    '\xcc': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
	    '\xec': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
	    '\xd1': 'N',  '\xf1': 'n',
	    '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
	    '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
	    '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
	    '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
	    '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
	    '\xc6': 'Ae', '\xe6': 'ae',
	    '\xde': 'Th', '\xfe': 'th',
	    '\xdf': 'ss',
	    // Latin Extended-A block.
	    '\u0100': 'A',  '\u0102': 'A', '\u0104': 'A',
	    '\u0101': 'a',  '\u0103': 'a', '\u0105': 'a',
	    '\u0106': 'C',  '\u0108': 'C', '\u010a': 'C', '\u010c': 'C',
	    '\u0107': 'c',  '\u0109': 'c', '\u010b': 'c', '\u010d': 'c',
	    '\u010e': 'D',  '\u0110': 'D', '\u010f': 'd', '\u0111': 'd',
	    '\u0112': 'E',  '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E',
	    '\u0113': 'e',  '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e',
	    '\u011c': 'G',  '\u011e': 'G', '\u0120': 'G', '\u0122': 'G',
	    '\u011d': 'g',  '\u011f': 'g', '\u0121': 'g', '\u0123': 'g',
	    '\u0124': 'H',  '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
	    '\u0128': 'I',  '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I',
	    '\u0129': 'i',  '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i',
	    '\u0134': 'J',  '\u0135': 'j',
	    '\u0136': 'K',  '\u0137': 'k', '\u0138': 'k',
	    '\u0139': 'L',  '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L',
	    '\u013a': 'l',  '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l',
	    '\u0143': 'N',  '\u0145': 'N', '\u0147': 'N', '\u014a': 'N',
	    '\u0144': 'n',  '\u0146': 'n', '\u0148': 'n', '\u014b': 'n',
	    '\u014c': 'O',  '\u014e': 'O', '\u0150': 'O',
	    '\u014d': 'o',  '\u014f': 'o', '\u0151': 'o',
	    '\u0154': 'R',  '\u0156': 'R', '\u0158': 'R',
	    '\u0155': 'r',  '\u0157': 'r', '\u0159': 'r',
	    '\u015a': 'S',  '\u015c': 'S', '\u015e': 'S', '\u0160': 'S',
	    '\u015b': 's',  '\u015d': 's', '\u015f': 's', '\u0161': 's',
	    '\u0162': 'T',  '\u0164': 'T', '\u0166': 'T',
	    '\u0163': 't',  '\u0165': 't', '\u0167': 't',
	    '\u0168': 'U',  '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U',
	    '\u0169': 'u',  '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u',
	    '\u0174': 'W',  '\u0175': 'w',
	    '\u0176': 'Y',  '\u0177': 'y', '\u0178': 'Y',
	    '\u0179': 'Z',  '\u017b': 'Z', '\u017d': 'Z',
	    '\u017a': 'z',  '\u017c': 'z', '\u017e': 'z',
	    '\u0132': 'IJ', '\u0133': 'ij',
	    '\u0152': 'Oe', '\u0153': 'oe',
	    '\u0149': "'n", '\u017f': 's'
	  };
	
	  /** Used to map characters to HTML entities. */
	  var htmlEscapes = {
	    '&': '&amp;',
	    '<': '&lt;',
	    '>': '&gt;',
	    '"': '&quot;',
	    "'": '&#39;'
	  };
	
	  /** Used to map HTML entities to characters. */
	  var htmlUnescapes = {
	    '&amp;': '&',
	    '&lt;': '<',
	    '&gt;': '>',
	    '&quot;': '"',
	    '&#39;': "'"
	  };
	
	  /** Used to escape characters for inclusion in compiled string literals. */
	  var stringEscapes = {
	    '\\': '\\',
	    "'": "'",
	    '\n': 'n',
	    '\r': 'r',
	    '\u2028': 'u2028',
	    '\u2029': 'u2029'
	  };
	
	  /** Built-in method references without a dependency on `root`. */
	  var freeParseFloat = parseFloat,
	      freeParseInt = parseInt;
	
	  /** Detect free variable `global` from Node.js. */
	  var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
	
	  /** Detect free variable `self`. */
	  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
	
	  /** Used as a reference to the global object. */
	  var root = freeGlobal || freeSelf || Function('return this')();
	
	  /** Detect free variable `exports`. */
	  var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
	
	  /** Detect free variable `module`. */
	  var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
	
	  /** Detect the popular CommonJS extension `module.exports`. */
	  var moduleExports = freeModule && freeModule.exports === freeExports;
	
	  /** Detect free variable `process` from Node.js. */
	  var freeProcess = moduleExports && freeGlobal.process;
	
	  /** Used to access faster Node.js helpers. */
	  var nodeUtil = (function() {
	    try {
	      return freeProcess && freeProcess.binding && freeProcess.binding('util');
	    } catch (e) {}
	  }());
	
	  /* Node.js helper references. */
	  var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer,
	      nodeIsDate = nodeUtil && nodeUtil.isDate,
	      nodeIsMap = nodeUtil && nodeUtil.isMap,
	      nodeIsRegExp = nodeUtil && nodeUtil.isRegExp,
	      nodeIsSet = nodeUtil && nodeUtil.isSet,
	      nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
	
	  /*--------------------------------------------------------------------------*/
	
	  /**
	   * Adds the key-value `pair` to `map`.
	   *
	   * @private
	   * @param {Object} map The map to modify.
	   * @param {Array} pair The key-value pair to add.
	   * @returns {Object} Returns `map`.
	   */
	  function addMapEntry(map, pair) {
	    // Don't return `map.set` because it's not chainable in IE 11.
	    map.set(pair[0], pair[1]);
	    return map;
	  }
	
	  /**
	   * Adds `value` to `set`.
	   *
	   * @private
	   * @param {Object} set The set to modify.
	   * @param {*} value The value to add.
	   * @returns {Object} Returns `set`.
	   */
	  function addSetEntry(set, value) {
	    // Don't return `set.add` because it's not chainable in IE 11.
	    set.add(value);
	    return set;
	  }
	
	  /**
	   * A faster alternative to `Function#apply`, this function invokes `func`
	   * with the `this` binding of `thisArg` and the arguments of `args`.
	   *
	   * @private
	   * @param {Function} func The function to invoke.
	   * @param {*} thisArg The `this` binding of `func`.
	   * @param {Array} args The arguments to invoke `func` with.
	   * @returns {*} Returns the result of `func`.
	   */
	  function apply(func, thisArg, args) {
	    switch (args.length) {
	      case 0: return func.call(thisArg);
	      case 1: return func.call(thisArg, args[0]);
	      case 2: return func.call(thisArg, args[0], args[1]);
	      case 3: return func.call(thisArg, args[0], args[1], args[2]);
	    }
	    return func.apply(thisArg, args);
	  }
	
	  /**
	   * A specialized version of `baseAggregator` for arrays.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} setter The function to set `accumulator` values.
	   * @param {Function} iteratee The iteratee to transform keys.
	   * @param {Object} accumulator The initial aggregated object.
	   * @returns {Function} Returns `accumulator`.
	   */
	  function arrayAggregator(array, setter, iteratee, accumulator) {
	    var index = -1,
	        length = array == null ? 0 : array.length;
	
	    while (++index < length) {
	      var value = array[index];
	      setter(accumulator, value, iteratee(value), array);
	    }
	    return accumulator;
	  }
	
	  /**
	   * A specialized version of `_.forEach` for arrays without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @returns {Array} Returns `array`.
	   */
	  function arrayEach(array, iteratee) {
	    var index = -1,
	        length = array == null ? 0 : array.length;
	
	    while (++index < length) {
	      if (iteratee(array[index], index, array) === false) {
	        break;
	      }
	    }
	    return array;
	  }
	
	  /**
	   * A specialized version of `_.forEachRight` for arrays without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @returns {Array} Returns `array`.
	   */
	  function arrayEachRight(array, iteratee) {
	    var length = array == null ? 0 : array.length;
	
	    while (length--) {
	      if (iteratee(array[length], length, array) === false) {
	        break;
	      }
	    }
	    return array;
	  }
	
	  /**
	   * A specialized version of `_.every` for arrays without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} predicate The function invoked per iteration.
	   * @returns {boolean} Returns `true` if all elements pass the predicate check,
	   *  else `false`.
	   */
	  function arrayEvery(array, predicate) {
	    var index = -1,
	        length = array == null ? 0 : array.length;
	
	    while (++index < length) {
	      if (!predicate(array[index], index, array)) {
	        return false;
	      }
	    }
	    return true;
	  }
	
	  /**
	   * A specialized version of `_.filter` for arrays without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} predicate The function invoked per iteration.
	   * @returns {Array} Returns the new filtered array.
	   */
	  function arrayFilter(array, predicate) {
	    var index = -1,
	        length = array == null ? 0 : array.length,
	        resIndex = 0,
	        result = [];
	
	    while (++index < length) {
	      var value = array[index];
	      if (predicate(value, index, array)) {
	        result[resIndex++] = value;
	      }
	    }
	    return result;
	  }
	
	  /**
	   * A specialized version of `_.includes` for arrays without support for
	   * specifying an index to search from.
	   *
	   * @private
	   * @param {Array} [array] The array to inspect.
	   * @param {*} target The value to search for.
	   * @returns {boolean} Returns `true` if `target` is found, else `false`.
	   */
	  function arrayIncludes(array, value) {
	    var length = array == null ? 0 : array.length;
	    return !!length && baseIndexOf(array, value, 0) > -1;
	  }
	
	  /**
	   * This function is like `arrayIncludes` except that it accepts a comparator.
	   *
	   * @private
	   * @param {Array} [array] The array to inspect.
	   * @param {*} target The value to search for.
	   * @param {Function} comparator The comparator invoked per element.
	   * @returns {boolean} Returns `true` if `target` is found, else `false`.
	   */
	  function arrayIncludesWith(array, value, comparator) {
	    var index = -1,
	        length = array == null ? 0 : array.length;
	
	    while (++index < length) {
	      if (comparator(value, array[index])) {
	        return true;
	      }
	    }
	    return false;
	  }
	
	  /**
	   * A specialized version of `_.map` for arrays without support for iteratee
	   * shorthands.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @returns {Array} Returns the new mapped array.
	   */
	  function arrayMap(array, iteratee) {
	    var index = -1,
	        length = array == null ? 0 : array.length,
	        result = Array(length);
	
	    while (++index < length) {
	      result[index] = iteratee(array[index], index, array);
	    }
	    return result;
	  }
	
	  /**
	   * Appends the elements of `values` to `array`.
	   *
	   * @private
	   * @param {Array} array The array to modify.
	   * @param {Array} values The values to append.
	   * @returns {Array} Returns `array`.
	   */
	  function arrayPush(array, values) {
	    var index = -1,
	        length = values.length,
	        offset = array.length;
	
	    while (++index < length) {
	      array[offset + index] = values[index];
	    }
	    return array;
	  }
	
	  /**
	   * A specialized version of `_.reduce` for arrays without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @param {*} [accumulator] The initial value.
	   * @param {boolean} [initAccum] Specify using the first element of `array` as
	   *  the initial value.
	   * @returns {*} Returns the accumulated value.
	   */
	  function arrayReduce(array, iteratee, accumulator, initAccum) {
	    var index = -1,
	        length = array == null ? 0 : array.length;
	
	    if (initAccum && length) {
	      accumulator = array[++index];
	    }
	    while (++index < length) {
	      accumulator = iteratee(accumulator, array[index], index, array);
	    }
	    return accumulator;
	  }
	
	  /**
	   * A specialized version of `_.reduceRight` for arrays without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @param {*} [accumulator] The initial value.
	   * @param {boolean} [initAccum] Specify using the last element of `array` as
	   *  the initial value.
	   * @returns {*} Returns the accumulated value.
	   */
	  function arrayReduceRight(array, iteratee, accumulator, initAccum) {
	    var length = array == null ? 0 : array.length;
	    if (initAccum && length) {
	      accumulator = array[--length];
	    }
	    while (length--) {
	      accumulator = iteratee(accumulator, array[length], length, array);
	    }
	    return accumulator;
	  }
	
	  /**
	   * A specialized version of `_.some` for arrays without support for iteratee
	   * shorthands.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} predicate The function invoked per iteration.
	   * @returns {boolean} Returns `true` if any element passes the predicate check,
	   *  else `false`.
	   */
	  function arraySome(array, predicate) {
	    var index = -1,
	        length = array == null ? 0 : array.length;
	
	    while (++index < length) {
	      if (predicate(array[index], index, array)) {
	        return true;
	      }
	    }
	    return false;
	  }
	
	  /**
	   * Gets the size of an ASCII `string`.
	   *
	   * @private
	   * @param {string} string The string inspect.
	   * @returns {number} Returns the string size.
	   */
	  var asciiSize = baseProperty('length');
	
	  /**
	   * Converts an ASCII `string` to an array.
	   *
	   * @private
	   * @param {string} string The string to convert.
	   * @returns {Array} Returns the converted array.
	   */
	  function asciiToArray(string) {
	    return string.split('');
	  }
	
	  /**
	   * Splits an ASCII `string` into an array of its words.
	   *
	   * @private
	   * @param {string} The string to inspect.
	   * @returns {Array} Returns the words of `string`.
	   */
	  function asciiWords(string) {
	    return string.match(reAsciiWord) || [];
	  }
	
	  /**
	   * The base implementation of methods like `_.findKey` and `_.findLastKey`,
	   * without support for iteratee shorthands, which iterates over `collection`
	   * using `eachFunc`.
	   *
	   * @private
	   * @param {Array|Object} collection The collection to inspect.
	   * @param {Function} predicate The function invoked per iteration.
	   * @param {Function} eachFunc The function to iterate over `collection`.
	   * @returns {*} Returns the found element or its key, else `undefined`.
	   */
	  function baseFindKey(collection, predicate, eachFunc) {
	    var result;
	    eachFunc(collection, function(value, key, collection) {
	      if (predicate(value, key, collection)) {
	        result = key;
	        return false;
	      }
	    });
	    return result;
	  }
	
	  /**
	   * The base implementation of `_.findIndex` and `_.findLastIndex` without
	   * support for iteratee shorthands.
	   *
	   * @private
	   * @param {Array} array The array to inspect.
	   * @param {Function} predicate The function invoked per iteration.
	   * @param {number} fromIndex The index to search from.
	   * @param {boolean} [fromRight] Specify iterating from right to left.
	   * @returns {number} Returns the index of the matched value, else `-1`.
	   */
	  function baseFindIndex(array, predicate, fromIndex, fromRight) {
	    var length = array.length,
	        index = fromIndex + (fromRight ? 1 : -1);
	
	    while ((fromRight ? index-- : ++index < length)) {
	      if (predicate(array[index], index, array)) {
	        return index;
	      }
	    }
	    return -1;
	  }
	
	  /**
	   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
	   *
	   * @private
	   * @param {Array} array The array to inspect.
	   * @param {*} value The value to search for.
	   * @param {number} fromIndex The index to search from.
	   * @returns {number} Returns the index of the matched value, else `-1`.
	   */
	  function baseIndexOf(array, value, fromIndex) {
	    return value === value
	      ? strictIndexOf(array, value, fromIndex)
	      : baseFindIndex(array, baseIsNaN, fromIndex);
	  }
	
	  /**
	   * This function is like `baseIndexOf` except that it accepts a comparator.
	   *
	   * @private
	   * @param {Array} array The array to inspect.
	   * @param {*} value The value to search for.
	   * @param {number} fromIndex The index to search from.
	   * @param {Function} comparator The comparator invoked per element.
	   * @returns {number} Returns the index of the matched value, else `-1`.
	   */
	  function baseIndexOfWith(array, value, fromIndex, comparator) {
	    var index = fromIndex - 1,
	        length = array.length;
	
	    while (++index < length) {
	      if (comparator(array[index], value)) {
	        return index;
	      }
	    }
	    return -1;
	  }
	
	  /**
	   * The base implementation of `_.isNaN` without support for number objects.
	   *
	   * @private
	   * @param {*} value The value to check.
	   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
	   */
	  function baseIsNaN(value) {
	    return value !== value;
	  }
	
	  /**
	   * The base implementation of `_.mean` and `_.meanBy` without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} array The array to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @returns {number} Returns the mean.
	   */
	  function baseMean(array, iteratee) {
	    var length = array == null ? 0 : array.length;
	    return length ? (baseSum(array, iteratee) / length) : NAN;
	  }
	
	  /**
	   * The base implementation of `_.property` without support for deep paths.
	   *
	   * @private
	   * @param {string} key The key of the property to get.
	   * @returns {Function} Returns the new accessor function.
	   */
	  function baseProperty(key) {
	    return function(object) {
	      return object == null ? undefined : object[key];
	    };
	  }
	
	  /**
	   * The base implementation of `_.propertyOf` without support for deep paths.
	   *
	   * @private
	   * @param {Object} object The object to query.
	   * @returns {Function} Returns the new accessor function.
	   */
	  function basePropertyOf(object) {
	    return function(key) {
	      return object == null ? undefined : object[key];
	    };
	  }
	
	  /**
	   * The base implementation of `_.reduce` and `_.reduceRight`, without support
	   * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
	   *
	   * @private
	   * @param {Array|Object} collection The collection to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @param {*} accumulator The initial value.
	   * @param {boolean} initAccum Specify using the first or last element of
	   *  `collection` as the initial value.
	   * @param {Function} eachFunc The function to iterate over `collection`.
	   * @returns {*} Returns the accumulated value.
	   */
	  function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
	    eachFunc(collection, function(value, index, collection) {
	      accumulator = initAccum
	        ? (initAccum = false, value)
	        : iteratee(accumulator, value, index, collection);
	    });
	    return accumulator;
	  }
	
	  /**
	   * The base implementation of `_.sortBy` which uses `comparer` to define the
	   * sort order of `array` and replaces criteria objects with their corresponding
	   * values.
	   *
	   * @private
	   * @param {Array} array The array to sort.
	   * @param {Function} comparer The function to define sort order.
	   * @returns {Array} Returns `array`.
	   */
	  function baseSortBy(array, comparer) {
	    var length = array.length;
	
	    array.sort(comparer);
	    while (length--) {
	      array[length] = array[length].value;
	    }
	    return array;
	  }
	
	  /**
	   * The base implementation of `_.sum` and `_.sumBy` without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} array The array to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @returns {number} Returns the sum.
	   */
	  function baseSum(array, iteratee) {
	    var result,
	        index = -1,
	        length = array.length;
	
	    while (++index < length) {
	      var current = iteratee(array[index]);
	      if (current !== undefined) {
	        result = result === undefined ? current : (result + current);
	      }
	    }
	    return result;
	  }
	
	  /**
	   * The base implementation of `_.times` without support for iteratee shorthands
	   * or max array length checks.
	   *
	   * @private
	   * @param {number} n The number of times to invoke `iteratee`.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @returns {Array} Returns the array of results.
	   */
	  function baseTimes(n, iteratee) {
	    var index = -1,
	        result = Array(n);
	
	    while (++index < n) {
	      result[index] = iteratee(index);
	    }
	    return result;
	  }
	
	  /**
	   * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
	   * of key-value pairs for `object` corresponding to the property names of `props`.
	   *
	   * @private
	   * @param {Object} object The object to query.
	   * @param {Array} props The property names to get values for.
	   * @returns {Object} Returns the key-value pairs.
	   */
	  function baseToPairs(object, props) {
	    return arrayMap(props, function(key) {
	      return [key, object[key]];
	    });
	  }
	
	  /**
	   * The base implementation of `_.unary` without support for storing metadata.
	   *
	   * @private
	   * @param {Function} func The function to cap arguments for.
	   * @returns {Function} Returns the new capped function.
	   */
	  function baseUnary(func) {
	    return function(value) {
	      return func(value);
	    };
	  }
	
	  /**
	   * The base implementation of `_.values` and `_.valuesIn` which creates an
	   * array of `object` property values corresponding to the property names
	   * of `props`.
	   *
	   * @private
	   * @param {Object} object The object to query.
	   * @param {Array} props The property names to get values for.
	   * @returns {Object} Returns the array of property values.
	   */
	  function baseValues(object, props) {
	    return arrayMap(props, function(key) {
	      return object[key];
	    });
	  }
	
	  /**
	   * Checks if a `cache` value for `key` exists.
	   *
	   * @private
	   * @param {Object} cache The cache to query.
	   * @param {string} key The key of the entry to check.
	   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	   */
	  function cacheHas(cache, key) {
	    return cache.has(key);
	  }
	
	  /**
	   * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
	   * that is not found in the character symbols.
	   *
	   * @private
	   * @param {Array} strSymbols The string symbols to inspect.
	   * @param {Array} chrSymbols The character symbols to find.
	   * @returns {number} Returns the index of the first unmatched string symbol.
	   */
	  function charsStartIndex(strSymbols, chrSymbols) {
	    var index = -1,
	        length = strSymbols.length;
	
	    while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
	    return index;
	  }
	
	  /**
	   * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
	   * that is not found in the character symbols.
	   *
	   * @private
	   * @param {Array} strSymbols The string symbols to inspect.
	   * @param {Array} chrSymbols The character symbols to find.
	   * @returns {number} Returns the index of the last unmatched string symbol.
	   */
	  function charsEndIndex(strSymbols, chrSymbols) {
	    var index = strSymbols.length;
	
	    while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
	    return index;
	  }
	
	  /**
	   * Gets the number of `placeholder` occurrences in `array`.
	   *
	   * @private
	   * @param {Array} array The array to inspect.
	   * @param {*} placeholder The placeholder to search for.
	   * @returns {number} Returns the placeholder count.
	   */
	  function countHolders(array, placeholder) {
	    var length = array.length,
	        result = 0;
	
	    while (length--) {
	      if (array[length] === placeholder) {
	        ++result;
	      }
	    }
	    return result;
	  }
	
	  /**
	   * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
	   * letters to basic Latin letters.
	   *
	   * @private
	   * @param {string} letter The matched letter to deburr.
	   * @returns {string} Returns the deburred letter.
	   */
	  var deburrLetter = basePropertyOf(deburredLetters);
	
	  /**
	   * Used by `_.escape` to convert characters to HTML entities.
	   *
	   * @private
	   * @param {string} chr The matched character to escape.
	   * @returns {string} Returns the escaped character.
	   */
	  var escapeHtmlChar = basePropertyOf(htmlEscapes);
	
	  /**
	   * Used by `_.template` to escape characters for inclusion in compiled string literals.
	   *
	   * @private
	   * @param {string} chr The matched character to escape.
	   * @returns {string} Returns the escaped character.
	   */
	  function escapeStringChar(chr) {
	    return '\\' + stringEscapes[chr];
	  }
	
	  /**
	   * Gets the value at `key` of `object`.
	   *
	   * @private
	   * @param {Object} [object] The object to query.
	   * @param {string} key The key of the property to get.
	   * @returns {*} Returns the property value.
	   */
	  function getValue(object, key) {
	    return object == null ? undefined : object[key];
	  }
	
	  /**
	   * Checks if `string` contains Unicode symbols.
	   *
	   * @private
	   * @param {string} string The string to inspect.
	   * @returns {boolean} Returns `true` if a symbol is found, else `false`.
	   */
	  function hasUnicode(string) {
	    return reHasUnicode.test(string);
	  }
	
	  /**
	   * Checks if `string` contains a word composed of Unicode symbols.
	   *
	   * @private
	   * @param {string} string The string to inspect.
	   * @returns {boolean} Returns `true` if a word is found, else `false`.
	   */
	  function hasUnicodeWord(string) {
	    return reHasUnicodeWord.test(string);
	  }
	
	  /**
	   * Converts `iterator` to an array.
	   *
	   * @private
	   * @param {Object} iterator The iterator to convert.
	   * @returns {Array} Returns the converted array.
	   */
	  function iteratorToArray(iterator) {
	    var data,
	        result = [];
	
	    while (!(data = iterator.next()).done) {
	      result.push(data.value);
	    }
	    return result;
	  }
	
	  /**
	   * Converts `map` to its key-value pairs.
	   *
	   * @private
	   * @param {Object} map The map to convert.
	   * @returns {Array} Returns the key-value pairs.
	   */
	  function mapToArray(map) {
	    var index = -1,
	        result = Array(map.size);
	
	    map.forEach(function(value, key) {
	      result[++index] = [key, value];
	    });
	    return result;
	  }
	
	  /**
	   * Creates a unary function that invokes `func` with its argument transformed.
	   *
	   * @private
	   * @param {Function} func The function to wrap.
	   * @param {Function} transform The argument transform.
	   * @returns {Function} Returns the new function.
	   */
	  function overArg(func, transform) {
	    return function(arg) {
	      return func(transform(arg));
	    };
	  }
	
	  /**
	   * Replaces all `placeholder` elements in `array` with an internal placeholder
	   * and returns an array of their indexes.
	   *
	   * @private
	   * @param {Array} array The array to modify.
	   * @param {*} placeholder The placeholder to replace.
	   * @returns {Array} Returns the new array of placeholder indexes.
	   */
	  function replaceHolders(array, placeholder) {
	    var index = -1,
	        length = array.length,
	        resIndex = 0,
	        result = [];
	
	    while (++index < length) {
	      var value = array[index];
	      if (value === placeholder || value === PLACEHOLDER) {
	        array[index] = PLACEHOLDER;
	        result[resIndex++] = index;
	      }
	    }
	    return result;
	  }
	
	  /**
	   * Converts `set` to an array of its values.
	   *
	   * @private
	   * @param {Object} set The set to convert.
	   * @returns {Array} Returns the values.
	   */
	  function setToArray(set) {
	    var index = -1,
	        result = Array(set.size);
	
	    set.forEach(function(value) {
	      result[++index] = value;
	    });
	    return result;
	  }
	
	  /**
	   * Converts `set` to its value-value pairs.
	   *
	   * @private
	   * @param {Object} set The set to convert.
	   * @returns {Array} Returns the value-value pairs.
	   */
	  function setToPairs(set) {
	    var index = -1,
	        result = Array(set.size);
	
	    set.forEach(function(value) {
	      result[++index] = [value, value];
	    });
	    return result;
	  }
	
	  /**
	   * A specialized version of `_.indexOf` which performs strict equality
	   * comparisons of values, i.e. `===`.
	   *
	   * @private
	   * @param {Array} array The array to inspect.
	   * @param {*} value The value to search for.
	   * @param {number} fromIndex The index to search from.
	   * @returns {number} Returns the index of the matched value, else `-1`.
	   */
	  function strictIndexOf(array, value, fromIndex) {
	    var index = fromIndex - 1,
	        length = array.length;
	
	    while (++index < length) {
	      if (array[index] === value) {
	        return index;
	      }
	    }
	    return -1;
	  }
	
	  /**
	   * A specialized version of `_.lastIndexOf` which performs strict equality
	   * comparisons of values, i.e. `===`.
	   *
	   * @private
	   * @param {Array} array The array to inspect.
	   * @param {*} value The value to search for.
	   * @param {number} fromIndex The index to search from.
	   * @returns {number} Returns the index of the matched value, else `-1`.
	   */
	  function strictLastIndexOf(array, value, fromIndex) {
	    var index = fromIndex + 1;
	    while (index--) {
	      if (array[index] === value) {
	        return index;
	      }
	    }
	    return index;
	  }
	
	  /**
	   * Gets the number of symbols in `string`.
	   *
	   * @private
	   * @param {string} string The string to inspect.
	   * @returns {number} Returns the string size.
	   */
	  function stringSize(string) {
	    return hasUnicode(string)
	      ? unicodeSize(string)
	      : asciiSize(string);
	  }
	
	  /**
	   * Converts `string` to an array.
	   *
	   * @private
	   * @param {string} string The string to convert.
	   * @returns {Array} Returns the converted array.
	   */
	  function stringToArray(string) {
	    return hasUnicode(string)
	      ? unicodeToArray(string)
	      : asciiToArray(string);
	  }
	
	  /**
	   * Used by `_.unescape` to convert HTML entities to characters.
	   *
	   * @private
	   * @param {string} chr The matched character to unescape.
	   * @returns {string} Returns the unescaped character.
	   */
	  var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
	
	  /**
	   * Gets the size of a Unicode `string`.
	   *
	   * @private
	   * @param {string} string The string inspect.
	   * @returns {number} Returns the string size.
	   */
	  function unicodeSize(string) {
	    var result = reUnicode.lastIndex = 0;
	    while (reUnicode.test(string)) {
	      ++result;
	    }
	    return result;
	  }
	
	  /**
	   * Converts a Unicode `string` to an array.
	   *
	   * @private
	   * @param {string} string The string to convert.
	   * @returns {Array} Returns the converted array.
	   */
	  function unicodeToArray(string) {
	    return string.match(reUnicode) || [];
	  }
	
	  /**
	   * Splits a Unicode `string` into an array of its words.
	   *
	   * @private
	   * @param {string} The string to inspect.
	   * @returns {Array} Returns the words of `string`.
	   */
	  function unicodeWords(string) {
	    return string.match(reUnicodeWord) || [];
	  }
	
	  /*--------------------------------------------------------------------------*/
	
	  /**
	   * Create a new pristine `lodash` function using the `context` object.
	   *
	   * @static
	   * @memberOf _
	   * @since 1.1.0
	   * @category Util
	   * @param {Object} [context=root] The context object.
	   * @returns {Function} Returns a new `lodash` function.
	   * @example
	   *
	   * _.mixin({ 'foo': _.constant('foo') });
	   *
	   * var lodash = _.runInContext();
	   * lodash.mixin({ 'bar': lodash.constant('bar') });
	   *
	   * _.isFunction(_.foo);
	   * // => true
	   * _.isFunction(_.bar);
	   * // => false
	   *
	   * lodash.isFunction(lodash.foo);
	   * // => false
	   * lodash.isFunction(lodash.bar);
	   * // => true
	   *
	   * // Create a suped-up `defer` in Node.js.
	   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
	   */
	  var runInContext = (function runInContext(context) {
	    context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));
	
	    /** Built-in constructor references. */
	    var Array = context.Array,
	        Date = context.Date,
	        Error = context.Error,
	        Function = context.Function,
	        Math = context.Math,
	        Object = context.Object,
	        RegExp = context.RegExp,
	        String = context.String,
	        TypeError = context.TypeError;
	
	    /** Used for built-in method references. */
	    var arrayProto = Array.prototype,
	        funcProto = Function.prototype,
	        objectProto = Object.prototype;
	
	    /** Used to detect overreaching core-js shims. */
	    var coreJsData = context['__core-js_shared__'];
	
	    /** Used to resolve the decompiled source of functions. */
	    var funcToString = funcProto.toString;
	
	    /** Used to check objects for own properties. */
	    var hasOwnProperty = objectProto.hasOwnProperty;
	
	    /** Used to generate unique IDs. */
	    var idCounter = 0;
	
	    /** Used to detect methods masquerading as native. */
	    var maskSrcKey = (function() {
	      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
	      return uid ? ('Symbol(src)_1.' + uid) : '';
	    }());
	
	    /**
	     * Used to resolve the
	     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	     * of values.
	     */
	    var nativeObjectToString = objectProto.toString;
	
	    /** Used to infer the `Object` constructor. */
	    var objectCtorString = funcToString.call(Object);
	
	    /** Used to restore the original `_` reference in `_.noConflict`. */
	    var oldDash = root._;
	
	    /** Used to detect if a method is native. */
	    var reIsNative = RegExp('^' +
	      funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
	      .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	    );
	
	    /** Built-in value references. */
	    var Buffer = moduleExports ? context.Buffer : undefined,
	        Symbol = context.Symbol,
	        Uint8Array = context.Uint8Array,
	        allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,
	        getPrototype = overArg(Object.getPrototypeOf, Object),
	        objectCreate = Object.create,
	        propertyIsEnumerable = objectProto.propertyIsEnumerable,
	        splice = arrayProto.splice,
	        spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined,
	        symIterator = Symbol ? Symbol.iterator : undefined,
	        symToStringTag = Symbol ? Symbol.toStringTag : undefined;
	
	    var defineProperty = (function() {
	      try {
	        var func = getNative(Object, 'defineProperty');
	        func({}, '', {});
	        return func;
	      } catch (e) {}
	    }());
	
	    /** Mocked built-ins. */
	    var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout,
	        ctxNow = Date && Date.now !== root.Date.now && Date.now,
	        ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
	
	    /* Built-in method references for those with the same name as other `lodash` methods. */
	    var nativeCeil = Math.ceil,
	        nativeFloor = Math.floor,
	        nativeGetSymbols = Object.getOwnPropertySymbols,
	        nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
	        nativeIsFinite = context.isFinite,
	        nativeJoin = arrayProto.join,
	        nativeKeys = overArg(Object.keys, Object),
	        nativeMax = Math.max,
	        nativeMin = Math.min,
	        nativeNow = Date.now,
	        nativeParseInt = context.parseInt,
	        nativeRandom = Math.random,
	        nativeReverse = arrayProto.reverse;
	
	    /* Built-in method references that are verified to be native. */
	    var DataView = getNative(context, 'DataView'),
	        Map = getNative(context, 'Map'),
	        Promise = getNative(context, 'Promise'),
	        Set = getNative(context, 'Set'),
	        WeakMap = getNative(context, 'WeakMap'),
	        nativeCreate = getNative(Object, 'create');
	
	    /** Used to store function metadata. */
	    var metaMap = WeakMap && new WeakMap;
	
	    /** Used to lookup unminified function names. */
	    var realNames = {};
	
	    /** Used to detect maps, sets, and weakmaps. */
	    var dataViewCtorString = toSource(DataView),
	        mapCtorString = toSource(Map),
	        promiseCtorString = toSource(Promise),
	        setCtorString = toSource(Set),
	        weakMapCtorString = toSource(WeakMap);
	
	    /** Used to convert symbols to primitives and strings. */
	    var symbolProto = Symbol ? Symbol.prototype : undefined,
	        symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,
	        symbolToString = symbolProto ? symbolProto.toString : undefined;
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * Creates a `lodash` object which wraps `value` to enable implicit method
	     * chain sequences. Methods that operate on and return arrays, collections,
	     * and functions can be chained together. Methods that retrieve a single value
	     * or may return a primitive value will automatically end the chain sequence
	     * and return the unwrapped value. Otherwise, the value must be unwrapped
	     * with `_#value`.
	     *
	     * Explicit chain sequences, which must be unwrapped with `_#value`, may be
	     * enabled using `_.chain`.
	     *
	     * The execution of chained methods is lazy, that is, it's deferred until
	     * `_#value` is implicitly or explicitly called.
	     *
	     * Lazy evaluation allows several methods to support shortcut fusion.
	     * Shortcut fusion is an optimization to merge iteratee calls; this avoids
	     * the creation of intermediate arrays and can greatly reduce the number of
	     * iteratee executions. Sections of a chain sequence qualify for shortcut
	     * fusion if the section is applied to an array of at least `200` elements
	     * and any iteratees accept only one argument. The heuristic for whether a
	     * section qualifies for shortcut fusion is subject to change.
	     *
	     * Chaining is supported in custom builds as long as the `_#value` method is
	     * directly or indirectly included in the build.
	     *
	     * In addition to lodash methods, wrappers have `Array` and `String` methods.
	     *
	     * The wrapper `Array` methods are:
	     * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
	     *
	     * The wrapper `String` methods are:
	     * `replace` and `split`
	     *
	     * The wrapper methods that support shortcut fusion are:
	     * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
	     * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
	     * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
	     *
	     * The chainable wrapper methods are:
	     * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
	     * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
	     * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
	     * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
	     * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
	     * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
	     * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
	     * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
	     * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
	     * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
	     * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
	     * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
	     * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
	     * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
	     * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
	     * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
	     * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
	     * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
	     * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
	     * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
	     * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
	     * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
	     * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
	     * `zipObject`, `zipObjectDeep`, and `zipWith`
	     *
	     * The wrapper methods that are **not** chainable by default are:
	     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
	     * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
	     * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
	     * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
	     * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
	     * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
	     * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
	     * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
	     * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
	     * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
	     * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
	     * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
	     * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
	     * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
	     * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
	     * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
	     * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
	     * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
	     * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
	     * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
	     * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
	     * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
	     * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
	     * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
	     * `upperFirst`, `value`, and `words`
	     *
	     * @name _
	     * @constructor
	     * @category Seq
	     * @param {*} value The value to wrap in a `lodash` instance.
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * function square(n) {
	     *   return n * n;
	     * }
	     *
	     * var wrapped = _([1, 2, 3]);
	     *
	     * // Returns an unwrapped value.
	     * wrapped.reduce(_.add);
	     * // => 6
	     *
	     * // Returns a wrapped value.
	     * var squares = wrapped.map(square);
	     *
	     * _.isArray(squares);
	     * // => false
	     *
	     * _.isArray(squares.value());
	     * // => true
	     */
	    function lodash(value) {
	      if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
	        if (value instanceof LodashWrapper) {
	          return value;
	        }
	        if (hasOwnProperty.call(value, '__wrapped__')) {
	          return wrapperClone(value);
	        }
	      }
	      return new LodashWrapper(value);
	    }
	
	    /**
	     * The base implementation of `_.create` without support for assigning
	     * properties to the created object.
	     *
	     * @private
	     * @param {Object} proto The object to inherit from.
	     * @returns {Object} Returns the new object.
	     */
	    var baseCreate = (function() {
	      function object() {}
	      return function(proto) {
	        if (!isObject(proto)) {
	          return {};
	        }
	        if (objectCreate) {
	          return objectCreate(proto);
	        }
	        object.prototype = proto;
	        var result = new object;
	        object.prototype = undefined;
	        return result;
	      };
	    }());
	
	    /**
	     * The function whose prototype chain sequence wrappers inherit from.
	     *
	     * @private
	     */
	    function baseLodash() {
	      // No operation performed.
	    }
	
	    /**
	     * The base constructor for creating `lodash` wrapper objects.
	     *
	     * @private
	     * @param {*} value The value to wrap.
	     * @param {boolean} [chainAll] Enable explicit method chain sequences.
	     */
	    function LodashWrapper(value, chainAll) {
	      this.__wrapped__ = value;
	      this.__actions__ = [];
	      this.__chain__ = !!chainAll;
	      this.__index__ = 0;
	      this.__values__ = undefined;
	    }
	
	    /**
	     * By default, the template delimiters used by lodash are like those in
	     * embedded Ruby (ERB). Change the following template settings to use
	     * alternative delimiters.
	     *
	     * @static
	     * @memberOf _
	     * @type {Object}
	     */
	    lodash.templateSettings = {
	
	      /**
	       * Used to detect `data` property values to be HTML-escaped.
	       *
	       * @memberOf _.templateSettings
	       * @type {RegExp}
	       */
	      'escape': reEscape,
	
	      /**
	       * Used to detect code to be evaluated.
	       *
	       * @memberOf _.templateSettings
	       * @type {RegExp}
	       */
	      'evaluate': reEvaluate,
	
	      /**
	       * Used to detect `data` property values to inject.
	       *
	       * @memberOf _.templateSettings
	       * @type {RegExp}
	       */
	      'interpolate': reInterpolate,
	
	      /**
	       * Used to reference the data object in the template text.
	       *
	       * @memberOf _.templateSettings
	       * @type {string}
	       */
	      'variable': '',
	
	      /**
	       * Used to import variables into the compiled template.
	       *
	       * @memberOf _.templateSettings
	       * @type {Object}
	       */
	      'imports': {
	
	        /**
	         * A reference to the `lodash` function.
	         *
	         * @memberOf _.templateSettings.imports
	         * @type {Function}
	         */
	        '_': lodash
	      }
	    };
	
	    // Ensure wrappers are instances of `baseLodash`.
	    lodash.prototype = baseLodash.prototype;
	    lodash.prototype.constructor = lodash;
	
	    LodashWrapper.prototype = baseCreate(baseLodash.prototype);
	    LodashWrapper.prototype.constructor = LodashWrapper;
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
	     *
	     * @private
	     * @constructor
	     * @param {*} value The value to wrap.
	     */
	    function LazyWrapper(value) {
	      this.__wrapped__ = value;
	      this.__actions__ = [];
	      this.__dir__ = 1;
	      this.__filtered__ = false;
	      this.__iteratees__ = [];
	      this.__takeCount__ = MAX_ARRAY_LENGTH;
	      this.__views__ = [];
	    }
	
	    /**
	     * Creates a clone of the lazy wrapper object.
	     *
	     * @private
	     * @name clone
	     * @memberOf LazyWrapper
	     * @returns {Object} Returns the cloned `LazyWrapper` object.
	     */
	    function lazyClone() {
	      var result = new LazyWrapper(this.__wrapped__);
	      result.__actions__ = copyArray(this.__actions__);
	      result.__dir__ = this.__dir__;
	      result.__filtered__ = this.__filtered__;
	      result.__iteratees__ = copyArray(this.__iteratees__);
	      result.__takeCount__ = this.__takeCount__;
	      result.__views__ = copyArray(this.__views__);
	      return result;
	    }
	
	    /**
	     * Reverses the direction of lazy iteration.
	     *
	     * @private
	     * @name reverse
	     * @memberOf LazyWrapper
	     * @returns {Object} Returns the new reversed `LazyWrapper` object.
	     */
	    function lazyReverse() {
	      if (this.__filtered__) {
	        var result = new LazyWrapper(this);
	        result.__dir__ = -1;
	        result.__filtered__ = true;
	      } else {
	        result = this.clone();
	        result.__dir__ *= -1;
	      }
	      return result;
	    }
	
	    /**
	     * Extracts the unwrapped value from its lazy wrapper.
	     *
	     * @private
	     * @name value
	     * @memberOf LazyWrapper
	     * @returns {*} Returns the unwrapped value.
	     */
	    function lazyValue() {
	      var array = this.__wrapped__.value(),
	          dir = this.__dir__,
	          isArr = isArray(array),
	          isRight = dir < 0,
	          arrLength = isArr ? array.length : 0,
	          view = getView(0, arrLength, this.__views__),
	          start = view.start,
	          end = view.end,
	          length = end - start,
	          index = isRight ? end : (start - 1),
	          iteratees = this.__iteratees__,
	          iterLength = iteratees.length,
	          resIndex = 0,
	          takeCount = nativeMin(length, this.__takeCount__);
	
	      if (!isArr || arrLength < LARGE_ARRAY_SIZE ||
	          (arrLength == length && takeCount == length)) {
	        return baseWrapperValue(array, this.__actions__);
	      }
	      var result = [];
	
	      outer:
	      while (length-- && resIndex < takeCount) {
	        index += dir;
	
	        var iterIndex = -1,
	            value = array[index];
	
	        while (++iterIndex < iterLength) {
	          var data = iteratees[iterIndex],
	              iteratee = data.iteratee,
	              type = data.type,
	              computed = iteratee(value);
	
	          if (type == LAZY_MAP_FLAG) {
	            value = computed;
	          } else if (!computed) {
	            if (type == LAZY_FILTER_FLAG) {
	              continue outer;
	            } else {
	              break outer;
	            }
	          }
	        }
	        result[resIndex++] = value;
	      }
	      return result;
	    }
	
	    // Ensure `LazyWrapper` is an instance of `baseLodash`.
	    LazyWrapper.prototype = baseCreate(baseLodash.prototype);
	    LazyWrapper.prototype.constructor = LazyWrapper;
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * Creates a hash object.
	     *
	     * @private
	     * @constructor
	     * @param {Array} [entries] The key-value pairs to cache.
	     */
	    function Hash(entries) {
	      var index = -1,
	          length = entries == null ? 0 : entries.length;
	
	      this.clear();
	      while (++index < length) {
	        var entry = entries[index];
	        this.set(entry[0], entry[1]);
	      }
	    }
	
	    /**
	     * Removes all key-value entries from the hash.
	     *
	     * @private
	     * @name clear
	     * @memberOf Hash
	     */
	    function hashClear() {
	      this.__data__ = nativeCreate ? nativeCreate(null) : {};
	      this.size = 0;
	    }
	
	    /**
	     * Removes `key` and its value from the hash.
	     *
	     * @private
	     * @name delete
	     * @memberOf Hash
	     * @param {Object} hash The hash to modify.
	     * @param {string} key The key of the value to remove.
	     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	     */
	    function hashDelete(key) {
	      var result = this.has(key) && delete this.__data__[key];
	      this.size -= result ? 1 : 0;
	      return result;
	    }
	
	    /**
	     * Gets the hash value for `key`.
	     *
	     * @private
	     * @name get
	     * @memberOf Hash
	     * @param {string} key The key of the value to get.
	     * @returns {*} Returns the entry value.
	     */
	    function hashGet(key) {
	      var data = this.__data__;
	      if (nativeCreate) {
	        var result = data[key];
	        return result === HASH_UNDEFINED ? undefined : result;
	      }
	      return hasOwnProperty.call(data, key) ? data[key] : undefined;
	    }
	
	    /**
	     * Checks if a hash value for `key` exists.
	     *
	     * @private
	     * @name has
	     * @memberOf Hash
	     * @param {string} key The key of the entry to check.
	     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	     */
	    function hashHas(key) {
	      var data = this.__data__;
	      return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
	    }
	
	    /**
	     * Sets the hash `key` to `value`.
	     *
	     * @private
	     * @name set
	     * @memberOf Hash
	     * @param {string} key The key of the value to set.
	     * @param {*} value The value to set.
	     * @returns {Object} Returns the hash instance.
	     */
	    function hashSet(key, value) {
	      var data = this.__data__;
	      this.size += this.has(key) ? 0 : 1;
	      data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
	      return this;
	    }
	
	    // Add methods to `Hash`.
	    Hash.prototype.clear = hashClear;
	    Hash.prototype['delete'] = hashDelete;
	    Hash.prototype.get = hashGet;
	    Hash.prototype.has = hashHas;
	    Hash.prototype.set = hashSet;
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * Creates an list cache object.
	     *
	     * @private
	     * @constructor
	     * @param {Array} [entries] The key-value pairs to cache.
	     */
	    function ListCache(entries) {
	      var index = -1,
	          length = entries == null ? 0 : entries.length;
	
	      this.clear();
	      while (++index < length) {
	        var entry = entries[index];
	        this.set(entry[0], entry[1]);
	      }
	    }
	
	    /**
	     * Removes all key-value entries from the list cache.
	     *
	     * @private
	     * @name clear
	     * @memberOf ListCache
	     */
	    function listCacheClear() {
	      this.__data__ = [];
	      this.size = 0;
	    }
	
	    /**
	     * Removes `key` and its value from the list cache.
	     *
	     * @private
	     * @name delete
	     * @memberOf ListCache
	     * @param {string} key The key of the value to remove.
	     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	     */
	    function listCacheDelete(key) {
	      var data = this.__data__,
	          index = assocIndexOf(data, key);
	
	      if (index < 0) {
	        return false;
	      }
	      var lastIndex = data.length - 1;
	      if (index == lastIndex) {
	        data.pop();
	      } else {
	        splice.call(data, index, 1);
	      }
	      --this.size;
	      return true;
	    }
	
	    /**
	     * Gets the list cache value for `key`.
	     *
	     * @private
	     * @name get
	     * @memberOf ListCache
	     * @param {string} key The key of the value to get.
	     * @returns {*} Returns the entry value.
	     */
	    function listCacheGet(key) {
	      var data = this.__data__,
	          index = assocIndexOf(data, key);
	
	      return index < 0 ? undefined : data[index][1];
	    }
	
	    /**
	     * Checks if a list cache value for `key` exists.
	     *
	     * @private
	     * @name has
	     * @memberOf ListCache
	     * @param {string} key The key of the entry to check.
	     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	     */
	    function listCacheHas(key) {
	      return assocIndexOf(this.__data__, key) > -1;
	    }
	
	    /**
	     * Sets the list cache `key` to `value`.
	     *
	     * @private
	     * @name set
	     * @memberOf ListCache
	     * @param {string} key The key of the value to set.
	     * @param {*} value The value to set.
	     * @returns {Object} Returns the list cache instance.
	     */
	    function listCacheSet(key, value) {
	      var data = this.__data__,
	          index = assocIndexOf(data, key);
	
	      if (index < 0) {
	        ++this.size;
	        data.push([key, value]);
	      } else {
	        data[index][1] = value;
	      }
	      return this;
	    }
	
	    // Add methods to `ListCache`.
	    ListCache.prototype.clear = listCacheClear;
	    ListCache.prototype['delete'] = listCacheDelete;
	    ListCache.prototype.get = listCacheGet;
	    ListCache.prototype.has = listCacheHas;
	    ListCache.prototype.set = listCacheSet;
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * Creates a map cache object to store key-value pairs.
	     *
	     * @private
	     * @constructor
	     * @param {Array} [entries] The key-value pairs to cache.
	     */
	    function MapCache(entries) {
	      var index = -1,
	          length = entries == null ? 0 : entries.length;
	
	      this.clear();
	      while (++index < length) {
	        var entry = entries[index];
	        this.set(entry[0], entry[1]);
	      }
	    }
	
	    /**
	     * Removes all key-value entries from the map.
	     *
	     * @private
	     * @name clear
	     * @memberOf MapCache
	     */
	    function mapCacheClear() {
	      this.size = 0;
	      this.__data__ = {
	        'hash': new Hash,
	        'map': new (Map || ListCache),
	        'string': new Hash
	      };
	    }
	
	    /**
	     * Removes `key` and its value from the map.
	     *
	     * @private
	     * @name delete
	     * @memberOf MapCache
	     * @param {string} key The key of the value to remove.
	     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	     */
	    function mapCacheDelete(key) {
	      var result = getMapData(this, key)['delete'](key);
	      this.size -= result ? 1 : 0;
	      return result;
	    }
	
	    /**
	     * Gets the map value for `key`.
	     *
	     * @private
	     * @name get
	     * @memberOf MapCache
	     * @param {string} key The key of the value to get.
	     * @returns {*} Returns the entry value.
	     */
	    function mapCacheGet(key) {
	      return getMapData(this, key).get(key);
	    }
	
	    /**
	     * Checks if a map value for `key` exists.
	     *
	     * @private
	     * @name has
	     * @memberOf MapCache
	     * @param {string} key The key of the entry to check.
	     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	     */
	    function mapCacheHas(key) {
	      return getMapData(this, key).has(key);
	    }
	
	    /**
	     * Sets the map `key` to `value`.
	     *
	     * @private
	     * @name set
	     * @memberOf MapCache
	     * @param {string} key The key of the value to set.
	     * @param {*} value The value to set.
	     * @returns {Object} Returns the map cache instance.
	     */
	    function mapCacheSet(key, value) {
	      var data = getMapData(this, key),
	          size = data.size;
	
	      data.set(key, value);
	      this.size += data.size == size ? 0 : 1;
	      return this;
	    }
	
	    // Add methods to `MapCache`.
	    MapCache.prototype.clear = mapCacheClear;
	    MapCache.prototype['delete'] = mapCacheDelete;
	    MapCache.prototype.get = mapCacheGet;
	    MapCache.prototype.has = mapCacheHas;
	    MapCache.prototype.set = mapCacheSet;
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     *
	     * Creates an array cache object to store unique values.
	     *
	     * @private
	     * @constructor
	     * @param {Array} [values] The values to cache.
	     */
	    function SetCache(values) {
	      var index = -1,
	          length = values == null ? 0 : values.length;
	
	      this.__data__ = new MapCache;
	      while (++index < length) {
	        this.add(values[index]);
	      }
	    }
	
	    /**
	     * Adds `value` to the array cache.
	     *
	     * @private
	     * @name add
	     * @memberOf SetCache
	     * @alias push
	     * @param {*} value The value to cache.
	     * @returns {Object} Returns the cache instance.
	     */
	    function setCacheAdd(value) {
	      this.__data__.set(value, HASH_UNDEFINED);
	      return this;
	    }
	
	    /**
	     * Checks if `value` is in the array cache.
	     *
	     * @private
	     * @name has
	     * @memberOf SetCache
	     * @param {*} value The value to search for.
	     * @returns {number} Returns `true` if `value` is found, else `false`.
	     */
	    function setCacheHas(value) {
	      return this.__data__.has(value);
	    }
	
	    // Add methods to `SetCache`.
	    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
	    SetCache.prototype.has = setCacheHas;
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * Creates a stack cache object to store key-value pairs.
	     *
	     * @private
	     * @constructor
	     * @param {Array} [entries] The key-value pairs to cache.
	     */
	    function Stack(entries) {
	      var data = this.__data__ = new ListCache(entries);
	      this.size = data.size;
	    }
	
	    /**
	     * Removes all key-value entries from the stack.
	     *
	     * @private
	     * @name clear
	     * @memberOf Stack
	     */
	    function stackClear() {
	      this.__data__ = new ListCache;
	      this.size = 0;
	    }
	
	    /**
	     * Removes `key` and its value from the stack.
	     *
	     * @private
	     * @name delete
	     * @memberOf Stack
	     * @param {string} key The key of the value to remove.
	     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	     */
	    function stackDelete(key) {
	      var data = this.__data__,
	          result = data['delete'](key);
	
	      this.size = data.size;
	      return result;
	    }
	
	    /**
	     * Gets the stack value for `key`.
	     *
	     * @private
	     * @name get
	     * @memberOf Stack
	     * @param {string} key The key of the value to get.
	     * @returns {*} Returns the entry value.
	     */
	    function stackGet(key) {
	      return this.__data__.get(key);
	    }
	
	    /**
	     * Checks if a stack value for `key` exists.
	     *
	     * @private
	     * @name has
	     * @memberOf Stack
	     * @param {string} key The key of the entry to check.
	     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	     */
	    function stackHas(key) {
	      return this.__data__.has(key);
	    }
	
	    /**
	     * Sets the stack `key` to `value`.
	     *
	     * @private
	     * @name set
	     * @memberOf Stack
	     * @param {string} key The key of the value to set.
	     * @param {*} value The value to set.
	     * @returns {Object} Returns the stack cache instance.
	     */
	    function stackSet(key, value) {
	      var data = this.__data__;
	      if (data instanceof ListCache) {
	        var pairs = data.__data__;
	        if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
	          pairs.push([key, value]);
	          this.size = ++data.size;
	          return this;
	        }
	        data = this.__data__ = new MapCache(pairs);
	      }
	      data.set(key, value);
	      this.size = data.size;
	      return this;
	    }
	
	    // Add methods to `Stack`.
	    Stack.prototype.clear = stackClear;
	    Stack.prototype['delete'] = stackDelete;
	    Stack.prototype.get = stackGet;
	    Stack.prototype.has = stackHas;
	    Stack.prototype.set = stackSet;
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * Creates an array of the enumerable property names of the array-like `value`.
	     *
	     * @private
	     * @param {*} value The value to query.
	     * @param {boolean} inherited Specify returning inherited property names.
	     * @returns {Array} Returns the array of property names.
	     */
	    function arrayLikeKeys(value, inherited) {
	      var isArr = isArray(value),
	          isArg = !isArr && isArguments(value),
	          isBuff = !isArr && !isArg && isBuffer(value),
	          isType = !isArr && !isArg && !isBuff && isTypedArray(value),
	          skipIndexes = isArr || isArg || isBuff || isType,
	          result = skipIndexes ? baseTimes(value.length, String) : [],
	          length = result.length;
	
	      for (var key in value) {
	        if ((inherited || hasOwnProperty.call(value, key)) &&
	            !(skipIndexes && (
	               // Safari 9 has enumerable `arguments.length` in strict mode.
	               key == 'length' ||
	               // Node.js 0.10 has enumerable non-index properties on buffers.
	               (isBuff && (key == 'offset' || key == 'parent')) ||
	               // PhantomJS 2 has enumerable non-index properties on typed arrays.
	               (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
	               // Skip index properties.
	               isIndex(key, length)
	            ))) {
	          result.push(key);
	        }
	      }
	      return result;
	    }
	
	    /**
	     * A specialized version of `_.sample` for arrays.
	     *
	     * @private
	     * @param {Array} array The array to sample.
	     * @returns {*} Returns the random element.
	     */
	    function arraySample(array) {
	      var length = array.length;
	      return length ? array[baseRandom(0, length - 1)] : undefined;
	    }
	
	    /**
	     * A specialized version of `_.sampleSize` for arrays.
	     *
	     * @private
	     * @param {Array} array The array to sample.
	     * @param {number} n The number of elements to sample.
	     * @returns {Array} Returns the random elements.
	     */
	    function arraySampleSize(array, n) {
	      return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
	    }
	
	    /**
	     * A specialized version of `_.shuffle` for arrays.
	     *
	     * @private
	     * @param {Array} array The array to shuffle.
	     * @returns {Array} Returns the new shuffled array.
	     */
	    function arrayShuffle(array) {
	      return shuffleSelf(copyArray(array));
	    }
	
	    /**
	     * Used by `_.defaults` to customize its `_.assignIn` use.
	     *
	     * @private
	     * @param {*} objValue The destination value.
	     * @param {*} srcValue The source value.
	     * @param {string} key The key of the property to assign.
	     * @param {Object} object The parent object of `objValue`.
	     * @returns {*} Returns the value to assign.
	     */
	    function assignInDefaults(objValue, srcValue, key, object) {
	      if (objValue === undefined ||
	          (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {
	        return srcValue;
	      }
	      return objValue;
	    }
	
	    /**
	     * This function is like `assignValue` except that it doesn't assign
	     * `undefined` values.
	     *
	     * @private
	     * @param {Object} object The object to modify.
	     * @param {string} key The key of the property to assign.
	     * @param {*} value The value to assign.
	     */
	    function assignMergeValue(object, key, value) {
	      if ((value !== undefined && !eq(object[key], value)) ||
	          (value === undefined && !(key in object))) {
	        baseAssignValue(object, key, value);
	      }
	    }
	
	    /**
	     * Assigns `value` to `key` of `object` if the existing value is not equivalent
	     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * for equality comparisons.
	     *
	     * @private
	     * @param {Object} object The object to modify.
	     * @param {string} key The key of the property to assign.
	     * @param {*} value The value to assign.
	     */
	    function assignValue(object, key, value) {
	      var objValue = object[key];
	      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
	          (value === undefined && !(key in object))) {
	        baseAssignValue(object, key, value);
	      }
	    }
	
	    /**
	     * Gets the index at which the `key` is found in `array` of key-value pairs.
	     *
	     * @private
	     * @param {Array} array The array to inspect.
	     * @param {*} key The key to search for.
	     * @returns {number} Returns the index of the matched value, else `-1`.
	     */
	    function assocIndexOf(array, key) {
	      var length = array.length;
	      while (length--) {
	        if (eq(array[length][0], key)) {
	          return length;
	        }
	      }
	      return -1;
	    }
	
	    /**
	     * Aggregates elements of `collection` on `accumulator` with keys transformed
	     * by `iteratee` and values set by `setter`.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} setter The function to set `accumulator` values.
	     * @param {Function} iteratee The iteratee to transform keys.
	     * @param {Object} accumulator The initial aggregated object.
	     * @returns {Function} Returns `accumulator`.
	     */
	    function baseAggregator(collection, setter, iteratee, accumulator) {
	      baseEach(collection, function(value, key, collection) {
	        setter(accumulator, value, iteratee(value), collection);
	      });
	      return accumulator;
	    }
	
	    /**
	     * The base implementation of `_.assign` without support for multiple sources
	     * or `customizer` functions.
	     *
	     * @private
	     * @param {Object} object The destination object.
	     * @param {Object} source The source object.
	     * @returns {Object} Returns `object`.
	     */
	    function baseAssign(object, source) {
	      return object && copyObject(source, keys(source), object);
	    }
	
	    /**
	     * The base implementation of `_.assignIn` without support for multiple sources
	     * or `customizer` functions.
	     *
	     * @private
	     * @param {Object} object The destination object.
	     * @param {Object} source The source object.
	     * @returns {Object} Returns `object`.
	     */
	    function baseAssignIn(object, source) {
	      return object && copyObject(source, keysIn(source), object);
	    }
	
	    /**
	     * The base implementation of `assignValue` and `assignMergeValue` without
	     * value checks.
	     *
	     * @private
	     * @param {Object} object The object to modify.
	     * @param {string} key The key of the property to assign.
	     * @param {*} value The value to assign.
	     */
	    function baseAssignValue(object, key, value) {
	      if (key == '__proto__' && defineProperty) {
	        defineProperty(object, key, {
	          'configurable': true,
	          'enumerable': true,
	          'value': value,
	          'writable': true
	        });
	      } else {
	        object[key] = value;
	      }
	    }
	
	    /**
	     * The base implementation of `_.at` without support for individual paths.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {string[]} paths The property paths to pick.
	     * @returns {Array} Returns the picked elements.
	     */
	    function baseAt(object, paths) {
	      var index = -1,
	          length = paths.length,
	          result = Array(length),
	          skip = object == null;
	
	      while (++index < length) {
	        result[index] = skip ? undefined : get(object, paths[index]);
	      }
	      return result;
	    }
	
	    /**
	     * The base implementation of `_.clamp` which doesn't coerce arguments.
	     *
	     * @private
	     * @param {number} number The number to clamp.
	     * @param {number} [lower] The lower bound.
	     * @param {number} upper The upper bound.
	     * @returns {number} Returns the clamped number.
	     */
	    function baseClamp(number, lower, upper) {
	      if (number === number) {
	        if (upper !== undefined) {
	          number = number <= upper ? number : upper;
	        }
	        if (lower !== undefined) {
	          number = number >= lower ? number : lower;
	        }
	      }
	      return number;
	    }
	
	    /**
	     * The base implementation of `_.clone` and `_.cloneDeep` which tracks
	     * traversed objects.
	     *
	     * @private
	     * @param {*} value The value to clone.
	     * @param {boolean} bitmask The bitmask flags.
	     *  1 - Deep clone
	     *  2 - Flatten inherited properties
	     *  4 - Clone symbols
	     * @param {Function} [customizer] The function to customize cloning.
	     * @param {string} [key] The key of `value`.
	     * @param {Object} [object] The parent object of `value`.
	     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
	     * @returns {*} Returns the cloned value.
	     */
	    function baseClone(value, bitmask, customizer, key, object, stack) {
	      var result,
	          isDeep = bitmask & CLONE_DEEP_FLAG,
	          isFlat = bitmask & CLONE_FLAT_FLAG,
	          isFull = bitmask & CLONE_SYMBOLS_FLAG;
	
	      if (customizer) {
	        result = object ? customizer(value, key, object, stack) : customizer(value);
	      }
	      if (result !== undefined) {
	        return result;
	      }
	      if (!isObject(value)) {
	        return value;
	      }
	      var isArr = isArray(value);
	      if (isArr) {
	        result = initCloneArray(value);
	        if (!isDeep) {
	          return copyArray(value, result);
	        }
	      } else {
	        var tag = getTag(value),
	            isFunc = tag == funcTag || tag == genTag;
	
	        if (isBuffer(value)) {
	          return cloneBuffer(value, isDeep);
	        }
	        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
	          result = (isFlat || isFunc) ? {} : initCloneObject(value);
	          if (!isDeep) {
	            return isFlat
	              ? copySymbolsIn(value, baseAssignIn(result, value))
	              : copySymbols(value, baseAssign(result, value));
	          }
	        } else {
	          if (!cloneableTags[tag]) {
	            return object ? value : {};
	          }
	          result = initCloneByTag(value, tag, baseClone, isDeep);
	        }
	      }
	      // Check for circular references and return its corresponding clone.
	      stack || (stack = new Stack);
	      var stacked = stack.get(value);
	      if (stacked) {
	        return stacked;
	      }
	      stack.set(value, result);
	
	      var keysFunc = isFull
	        ? (isFlat ? getAllKeysIn : getAllKeys)
	        : (isFlat ? keysIn : keys);
	
	      var props = isArr ? undefined : keysFunc(value);
	      arrayEach(props || value, function(subValue, key) {
	        if (props) {
	          key = subValue;
	          subValue = value[key];
	        }
	        // Recursively populate clone (susceptible to call stack limits).
	        assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
	      });
	      return result;
	    }
	
	    /**
	     * The base implementation of `_.conforms` which doesn't clone `source`.
	     *
	     * @private
	     * @param {Object} source The object of property predicates to conform to.
	     * @returns {Function} Returns the new spec function.
	     */
	    function baseConforms(source) {
	      var props = keys(source);
	      return function(object) {
	        return baseConformsTo(object, source, props);
	      };
	    }
	
	    /**
	     * The base implementation of `_.conformsTo` which accepts `props` to check.
	     *
	     * @private
	     * @param {Object} object The object to inspect.
	     * @param {Object} source The object of property predicates to conform to.
	     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
	     */
	    function baseConformsTo(object, source, props) {
	      var length = props.length;
	      if (object == null) {
	        return !length;
	      }
	      object = Object(object);
	      while (length--) {
	        var key = props[length],
	            predicate = source[key],
	            value = object[key];
	
	        if ((value === undefined && !(key in object)) || !predicate(value)) {
	          return false;
	        }
	      }
	      return true;
	    }
	
	    /**
	     * The base implementation of `_.delay` and `_.defer` which accepts `args`
	     * to provide to `func`.
	     *
	     * @private
	     * @param {Function} func The function to delay.
	     * @param {number} wait The number of milliseconds to delay invocation.
	     * @param {Array} args The arguments to provide to `func`.
	     * @returns {number|Object} Returns the timer id or timeout object.
	     */
	    function baseDelay(func, wait, args) {
	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      return setTimeout(function() { func.apply(undefined, args); }, wait);
	    }
	
	    /**
	     * The base implementation of methods like `_.difference` without support
	     * for excluding multiple arrays or iteratee shorthands.
	     *
	     * @private
	     * @param {Array} array The array to inspect.
	     * @param {Array} values The values to exclude.
	     * @param {Function} [iteratee] The iteratee invoked per element.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new array of filtered values.
	     */
	    function baseDifference(array, values, iteratee, comparator) {
	      var index = -1,
	          includes = arrayIncludes,
	          isCommon = true,
	          length = array.length,
	          result = [],
	          valuesLength = values.length;
	
	      if (!length) {
	        return result;
	      }
	      if (iteratee) {
	        values = arrayMap(values, baseUnary(iteratee));
	      }
	      if (comparator) {
	        includes = arrayIncludesWith;
	        isCommon = false;
	      }
	      else if (values.length >= LARGE_ARRAY_SIZE) {
	        includes = cacheHas;
	        isCommon = false;
	        values = new SetCache(values);
	      }
	      outer:
	      while (++index < length) {
	        var value = array[index],
	            computed = iteratee == null ? value : iteratee(value);
	
	        value = (comparator || value !== 0) ? value : 0;
	        if (isCommon && computed === computed) {
	          var valuesIndex = valuesLength;
	          while (valuesIndex--) {
	            if (values[valuesIndex] === computed) {
	              continue outer;
	            }
	          }
	          result.push(value);
	        }
	        else if (!includes(values, computed, comparator)) {
	          result.push(value);
	        }
	      }
	      return result;
	    }
	
	    /**
	     * The base implementation of `_.forEach` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Array|Object} Returns `collection`.
	     */
	    var baseEach = createBaseEach(baseForOwn);
	
	    /**
	     * The base implementation of `_.forEachRight` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Array|Object} Returns `collection`.
	     */
	    var baseEachRight = createBaseEach(baseForOwnRight, true);
	
	    /**
	     * The base implementation of `_.every` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} predicate The function invoked per iteration.
	     * @returns {boolean} Returns `true` if all elements pass the predicate check,
	     *  else `false`
	     */
	    function baseEvery(collection, predicate) {
	      var result = true;
	      baseEach(collection, function(value, index, collection) {
	        result = !!predicate(value, index, collection);
	        return result;
	      });
	      return result;
	    }
	
	    /**
	     * The base implementation of methods like `_.max` and `_.min` which accepts a
	     * `comparator` to determine the extremum value.
	     *
	     * @private
	     * @param {Array} array The array to iterate over.
	     * @param {Function} iteratee The iteratee invoked per iteration.
	     * @param {Function} comparator The comparator used to compare values.
	     * @returns {*} Returns the extremum value.
	     */
	    function baseExtremum(array, iteratee, comparator) {
	      var index = -1,
	          length = array.length;
	
	      while (++index < length) {
	        var value = array[index],
	            current = iteratee(value);
	
	        if (current != null && (computed === undefined
	              ? (current === current && !isSymbol(current))
	              : comparator(current, computed)
	            )) {
	          var computed = current,
	              result = value;
	        }
	      }
	      return result;
	    }
	
	    /**
	     * The base implementation of `_.fill` without an iteratee call guard.
	     *
	     * @private
	     * @param {Array} array The array to fill.
	     * @param {*} value The value to fill `array` with.
	     * @param {number} [start=0] The start position.
	     * @param {number} [end=array.length] The end position.
	     * @returns {Array} Returns `array`.
	     */
	    function baseFill(array, value, start, end) {
	      var length = array.length;
	
	      start = toInteger(start);
	      if (start < 0) {
	        start = -start > length ? 0 : (length + start);
	      }
	      end = (end === undefined || end > length) ? length : toInteger(end);
	      if (end < 0) {
	        end += length;
	      }
	      end = start > end ? 0 : toLength(end);
	      while (start < end) {
	        array[start++] = value;
	      }
	      return array;
	    }
	
	    /**
	     * The base implementation of `_.filter` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} predicate The function invoked per iteration.
	     * @returns {Array} Returns the new filtered array.
	     */
	    function baseFilter(collection, predicate) {
	      var result = [];
	      baseEach(collection, function(value, index, collection) {
	        if (predicate(value, index, collection)) {
	          result.push(value);
	        }
	      });
	      return result;
	    }
	
	    /**
	     * The base implementation of `_.flatten` with support for restricting flattening.
	     *
	     * @private
	     * @param {Array} array The array to flatten.
	     * @param {number} depth The maximum recursion depth.
	     * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
	     * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
	     * @param {Array} [result=[]] The initial result value.
	     * @returns {Array} Returns the new flattened array.
	     */
	    function baseFlatten(array, depth, predicate, isStrict, result) {
	      var index = -1,
	          length = array.length;
	
	      predicate || (predicate = isFlattenable);
	      result || (result = []);
	
	      while (++index < length) {
	        var value = array[index];
	        if (depth > 0 && predicate(value)) {
	          if (depth > 1) {
	            // Recursively flatten arrays (susceptible to call stack limits).
	            baseFlatten(value, depth - 1, predicate, isStrict, result);
	          } else {
	            arrayPush(result, value);
	          }
	        } else if (!isStrict) {
	          result[result.length] = value;
	        }
	      }
	      return result;
	    }
	
	    /**
	     * The base implementation of `baseForOwn` which iterates over `object`
	     * properties returned by `keysFunc` and invokes `iteratee` for each property.
	     * Iteratee functions may exit iteration early by explicitly returning `false`.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @param {Function} keysFunc The function to get the keys of `object`.
	     * @returns {Object} Returns `object`.
	     */
	    var baseFor = createBaseFor();
	
	    /**
	     * This function is like `baseFor` except that it iterates over properties
	     * in the opposite order.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @param {Function} keysFunc The function to get the keys of `object`.
	     * @returns {Object} Returns `object`.
	     */
	    var baseForRight = createBaseFor(true);
	
	    /**
	     * The base implementation of `_.forOwn` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     */
	    function baseForOwn(object, iteratee) {
	      return object && baseFor(object, iteratee, keys);
	    }
	
	    /**
	     * The base implementation of `_.forOwnRight` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     */
	    function baseForOwnRight(object, iteratee) {
	      return object && baseForRight(object, iteratee, keys);
	    }
	
	    /**
	     * The base implementation of `_.functions` which creates an array of
	     * `object` function property names filtered from `props`.
	     *
	     * @private
	     * @param {Object} object The object to inspect.
	     * @param {Array} props The property names to filter.
	     * @returns {Array} Returns the function names.
	     */
	    function baseFunctions(object, props) {
	      return arrayFilter(props, function(key) {
	        return isFunction(object[key]);
	      });
	    }
	
	    /**
	     * The base implementation of `_.get` without support for default values.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path of the property to get.
	     * @returns {*} Returns the resolved value.
	     */
	    function baseGet(object, path) {
	      path = castPath(path, object);
	
	      var index = 0,
	          length = path.length;
	
	      while (object != null && index < length) {
	        object = object[toKey(path[index++])];
	      }
	      return (index && index == length) ? object : undefined;
	    }
	
	    /**
	     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
	     * `keysFunc` and `symbolsFunc` to get the enumerable property names and
	     * symbols of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {Function} keysFunc The function to get the keys of `object`.
	     * @param {Function} symbolsFunc The function to get the symbols of `object`.
	     * @returns {Array} Returns the array of property names and symbols.
	     */
	    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
	      var result = keysFunc(object);
	      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
	    }
	
	    /**
	     * The base implementation of `getTag` without fallbacks for buggy environments.
	     *
	     * @private
	     * @param {*} value The value to query.
	     * @returns {string} Returns the `toStringTag`.
	     */
	    function baseGetTag(value) {
	      if (value == null) {
	        return value === undefined ? undefinedTag : nullTag;
	      }
	      value = Object(value);
	      return (symToStringTag && symToStringTag in value)
	        ? getRawTag(value)
	        : objectToString(value);
	    }
	
	    /**
	     * The base implementation of `_.gt` which doesn't coerce arguments.
	     *
	     * @private
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if `value` is greater than `other`,
	     *  else `false`.
	     */
	    function baseGt(value, other) {
	      return value > other;
	    }
	
	    /**
	     * The base implementation of `_.has` without support for deep paths.
	     *
	     * @private
	     * @param {Object} [object] The object to query.
	     * @param {Array|string} key The key to check.
	     * @returns {boolean} Returns `true` if `key` exists, else `false`.
	     */
	    function baseHas(object, key) {
	      return object != null && hasOwnProperty.call(object, key);
	    }
	
	    /**
	     * The base implementation of `_.hasIn` without support for deep paths.
	     *
	     * @private
	     * @param {Object} [object] The object to query.
	     * @param {Array|string} key The key to check.
	     * @returns {boolean} Returns `true` if `key` exists, else `false`.
	     */
	    function baseHasIn(object, key) {
	      return object != null && key in Object(object);
	    }
	
	    /**
	     * The base implementation of `_.inRange` which doesn't coerce arguments.
	     *
	     * @private
	     * @param {number} number The number to check.
	     * @param {number} start The start of the range.
	     * @param {number} end The end of the range.
	     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
	     */
	    function baseInRange(number, start, end) {
	      return number >= nativeMin(start, end) && number < nativeMax(start, end);
	    }
	
	    /**
	     * The base implementation of methods like `_.intersection`, without support
	     * for iteratee shorthands, that accepts an array of arrays to inspect.
	     *
	     * @private
	     * @param {Array} arrays The arrays to inspect.
	     * @param {Function} [iteratee] The iteratee invoked per element.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new array of shared values.
	     */
	    function baseIntersection(arrays, iteratee, comparator) {
	      var includes = comparator ? arrayIncludesWith : arrayIncludes,
	          length = arrays[0].length,
	          othLength = arrays.length,
	          othIndex = othLength,
	          caches = Array(othLength),
	          maxLength = Infinity,
	          result = [];
	
	      while (othIndex--) {
	        var array = arrays[othIndex];
	        if (othIndex && iteratee) {
	          array = arrayMap(array, baseUnary(iteratee));
	        }
	        maxLength = nativeMin(array.length, maxLength);
	        caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120))
	          ? new SetCache(othIndex && array)
	          : undefined;
	      }
	      array = arrays[0];
	
	      var index = -1,
	          seen = caches[0];
	
	      outer:
	      while (++index < length && result.length < maxLength) {
	        var value = array[index],
	            computed = iteratee ? iteratee(value) : value;
	
	        value = (comparator || value !== 0) ? value : 0;
	        if (!(seen
	              ? cacheHas(seen, computed)
	              : includes(result, computed, comparator)
	            )) {
	          othIndex = othLength;
	          while (--othIndex) {
	            var cache = caches[othIndex];
	            if (!(cache
	                  ? cacheHas(cache, computed)
	                  : includes(arrays[othIndex], computed, comparator))
	                ) {
	              continue outer;
	            }
	          }
	          if (seen) {
	            seen.push(computed);
	          }
	          result.push(value);
	        }
	      }
	      return result;
	    }
	
	    /**
	     * The base implementation of `_.invert` and `_.invertBy` which inverts
	     * `object` with values transformed by `iteratee` and set by `setter`.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} setter The function to set `accumulator` values.
	     * @param {Function} iteratee The iteratee to transform values.
	     * @param {Object} accumulator The initial inverted object.
	     * @returns {Function} Returns `accumulator`.
	     */
	    function baseInverter(object, setter, iteratee, accumulator) {
	      baseForOwn(object, function(value, key, object) {
	        setter(accumulator, iteratee(value), key, object);
	      });
	      return accumulator;
	    }
	
	    /**
	     * The base implementation of `_.invoke` without support for individual
	     * method arguments.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path of the method to invoke.
	     * @param {Array} args The arguments to invoke the method with.
	     * @returns {*} Returns the result of the invoked method.
	     */
	    function baseInvoke(object, path, args) {
	      path = castPath(path, object);
	      object = parent(object, path);
	      var func = object == null ? object : object[toKey(last(path))];
	      return func == null ? undefined : apply(func, object, args);
	    }
	
	    /**
	     * The base implementation of `_.isArguments`.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	     */
	    function baseIsArguments(value) {
	      return isObjectLike(value) && baseGetTag(value) == argsTag;
	    }
	
	    /**
	     * The base implementation of `_.isArrayBuffer` without Node.js optimizations.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
	     */
	    function baseIsArrayBuffer(value) {
	      return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
	    }
	
	    /**
	     * The base implementation of `_.isDate` without Node.js optimizations.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
	     */
	    function baseIsDate(value) {
	      return isObjectLike(value) && baseGetTag(value) == dateTag;
	    }
	
	    /**
	     * The base implementation of `_.isEqual` which supports partial comparisons
	     * and tracks traversed objects.
	     *
	     * @private
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @param {boolean} bitmask The bitmask flags.
	     *  1 - Unordered comparison
	     *  2 - Partial comparison
	     * @param {Function} [customizer] The function to customize comparisons.
	     * @param {Object} [stack] Tracks traversed `value` and `other` objects.
	     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	     */
	    function baseIsEqual(value, other, bitmask, customizer, stack) {
	      if (value === other) {
	        return true;
	      }
	      if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {
	        return value !== value && other !== other;
	      }
	      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
	    }
	
	    /**
	     * A specialized version of `baseIsEqual` for arrays and objects which performs
	     * deep comparisons and tracks traversed objects enabling objects with circular
	     * references to be compared.
	     *
	     * @private
	     * @param {Object} object The object to compare.
	     * @param {Object} other The other object to compare.
	     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	     * @param {Function} customizer The function to customize comparisons.
	     * @param {Function} equalFunc The function to determine equivalents of values.
	     * @param {Object} [stack] Tracks traversed `object` and `other` objects.
	     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	     */
	    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
	      var objIsArr = isArray(object),
	          othIsArr = isArray(other),
	          objTag = arrayTag,
	          othTag = arrayTag;
	
	      if (!objIsArr) {
	        objTag = getTag(object);
	        objTag = objTag == argsTag ? objectTag : objTag;
	      }
	      if (!othIsArr) {
	        othTag = getTag(other);
	        othTag = othTag == argsTag ? objectTag : othTag;
	      }
	      var objIsObj = objTag == objectTag,
	          othIsObj = othTag == objectTag,
	          isSameTag = objTag == othTag;
	
	      if (isSameTag && isBuffer(object)) {
	        if (!isBuffer(other)) {
	          return false;
	        }
	        objIsArr = true;
	        objIsObj = false;
	      }
	      if (isSameTag && !objIsObj) {
	        stack || (stack = new Stack);
	        return (objIsArr || isTypedArray(object))
	          ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
	          : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
	      }
	      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
	        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
	            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');
	
	        if (objIsWrapped || othIsWrapped) {
	          var objUnwrapped = objIsWrapped ? object.value() : object,
	              othUnwrapped = othIsWrapped ? other.value() : other;
	
	          stack || (stack = new Stack);
	          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
	        }
	      }
	      if (!isSameTag) {
	        return false;
	      }
	      stack || (stack = new Stack);
	      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
	    }
	
	    /**
	     * The base implementation of `_.isMap` without Node.js optimizations.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
	     */
	    function baseIsMap(value) {
	      return isObjectLike(value) && getTag(value) == mapTag;
	    }
	
	    /**
	     * The base implementation of `_.isMatch` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Object} object The object to inspect.
	     * @param {Object} source The object of property values to match.
	     * @param {Array} matchData The property names, values, and compare flags to match.
	     * @param {Function} [customizer] The function to customize comparisons.
	     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
	     */
	    function baseIsMatch(object, source, matchData, customizer) {
	      var index = matchData.length,
	          length = index,
	          noCustomizer = !customizer;
	
	      if (object == null) {
	        return !length;
	      }
	      object = Object(object);
	      while (index--) {
	        var data = matchData[index];
	        if ((noCustomizer && data[2])
	              ? data[1] !== object[data[0]]
	              : !(data[0] in object)
	            ) {
	          return false;
	        }
	      }
	      while (++index < length) {
	        data = matchData[index];
	        var key = data[0],
	            objValue = object[key],
	            srcValue = data[1];
	
	        if (noCustomizer && data[2]) {
	          if (objValue === undefined && !(key in object)) {
	            return false;
	          }
	        } else {
	          var stack = new Stack;
	          if (customizer) {
	            var result = customizer(objValue, srcValue, key, object, source, stack);
	          }
	          if (!(result === undefined
	                ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
	                : result
	              )) {
	            return false;
	          }
	        }
	      }
	      return true;
	    }
	
	    /**
	     * The base implementation of `_.isNative` without bad shim checks.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a native function,
	     *  else `false`.
	     */
	    function baseIsNative(value) {
	      if (!isObject(value) || isMasked(value)) {
	        return false;
	      }
	      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
	      return pattern.test(toSource(value));
	    }
	
	    /**
	     * The base implementation of `_.isRegExp` without Node.js optimizations.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
	     */
	    function baseIsRegExp(value) {
	      return isObjectLike(value) && baseGetTag(value) == regexpTag;
	    }
	
	    /**
	     * The base implementation of `_.isSet` without Node.js optimizations.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
	     */
	    function baseIsSet(value) {
	      return isObjectLike(value) && getTag(value) == setTag;
	    }
	
	    /**
	     * The base implementation of `_.isTypedArray` without Node.js optimizations.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	     */
	    function baseIsTypedArray(value) {
	      return isObjectLike(value) &&
	        isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
	    }
	
	    /**
	     * The base implementation of `_.iteratee`.
	     *
	     * @private
	     * @param {*} [value=_.identity] The value to convert to an iteratee.
	     * @returns {Function} Returns the iteratee.
	     */
	    function baseIteratee(value) {
	      // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
	      // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
	      if (typeof value == 'function') {
	        return value;
	      }
	      if (value == null) {
	        return identity;
	      }
	      if (typeof value == 'object') {
	        return isArray(value)
	          ? baseMatchesProperty(value[0], value[1])
	          : baseMatches(value);
	      }
	      return property(value);
	    }
	
	    /**
	     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names.
	     */
	    function baseKeys(object) {
	      if (!isPrototype(object)) {
	        return nativeKeys(object);
	      }
	      var result = [];
	      for (var key in Object(object)) {
	        if (hasOwnProperty.call(object, key) && key != 'constructor') {
	          result.push(key);
	        }
	      }
	      return result;
	    }
	
	    /**
	     * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names.
	     */
	    function baseKeysIn(object) {
	      if (!isObject(object)) {
	        return nativeKeysIn(object);
	      }
	      var isProto = isPrototype(object),
	          result = [];
	
	      for (var key in object) {
	        if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
	          result.push(key);
	        }
	      }
	      return result;
	    }
	
	    /**
	     * The base implementation of `_.lt` which doesn't coerce arguments.
	     *
	     * @private
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if `value` is less than `other`,
	     *  else `false`.
	     */
	    function baseLt(value, other) {
	      return value < other;
	    }
	
	    /**
	     * The base implementation of `_.map` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Array} Returns the new mapped array.
	     */
	    function baseMap(collection, iteratee) {
	      var index = -1,
	          result = isArrayLike(collection) ? Array(collection.length) : [];
	
	      baseEach(collection, function(value, key, collection) {
	        result[++index] = iteratee(value, key, collection);
	      });
	      return result;
	    }
	
	    /**
	     * The base implementation of `_.matches` which doesn't clone `source`.
	     *
	     * @private
	     * @param {Object} source The object of property values to match.
	     * @returns {Function} Returns the new spec function.
	     */
	    function baseMatches(source) {
	      var matchData = getMatchData(source);
	      if (matchData.length == 1 && matchData[0][2]) {
	        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
	      }
	      return function(object) {
	        return object === source || baseIsMatch(object, source, matchData);
	      };
	    }
	
	    /**
	     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
	     *
	     * @private
	     * @param {string} path The path of the property to get.
	     * @param {*} srcValue The value to match.
	     * @returns {Function} Returns the new spec function.
	     */
	    function baseMatchesProperty(path, srcValue) {
	      if (isKey(path) && isStrictComparable(srcValue)) {
	        return matchesStrictComparable(toKey(path), srcValue);
	      }
	      return function(object) {
	        var objValue = get(object, path);
	        return (objValue === undefined && objValue === srcValue)
	          ? hasIn(object, path)
	          : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
	      };
	    }
	
	    /**
	     * The base implementation of `_.merge` without support for multiple sources.
	     *
	     * @private
	     * @param {Object} object The destination object.
	     * @param {Object} source The source object.
	     * @param {number} srcIndex The index of `source`.
	     * @param {Function} [customizer] The function to customize merged values.
	     * @param {Object} [stack] Tracks traversed source values and their merged
	     *  counterparts.
	     */
	    function baseMerge(object, source, srcIndex, customizer, stack) {
	      if (object === source) {
	        return;
	      }
	      baseFor(source, function(srcValue, key) {
	        if (isObject(srcValue)) {
	          stack || (stack = new Stack);
	          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
	        }
	        else {
	          var newValue = customizer
	            ? customizer(object[key], srcValue, (key + ''), object, source, stack)
	            : undefined;
	
	          if (newValue === undefined) {
	            newValue = srcValue;
	          }
	          assignMergeValue(object, key, newValue);
	        }
	      }, keysIn);
	    }
	
	    /**
	     * A specialized version of `baseMerge` for arrays and objects which performs
	     * deep merges and tracks traversed objects enabling objects with circular
	     * references to be merged.
	     *
	     * @private
	     * @param {Object} object The destination object.
	     * @param {Object} source The source object.
	     * @param {string} key The key of the value to merge.
	     * @param {number} srcIndex The index of `source`.
	     * @param {Function} mergeFunc The function to merge values.
	     * @param {Function} [customizer] The function to customize assigned values.
	     * @param {Object} [stack] Tracks traversed source values and their merged
	     *  counterparts.
	     */
	    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
	      var objValue = object[key],
	          srcValue = source[key],
	          stacked = stack.get(srcValue);
	
	      if (stacked) {
	        assignMergeValue(object, key, stacked);
	        return;
	      }
	      var newValue = customizer
	        ? customizer(objValue, srcValue, (key + ''), object, source, stack)
	        : undefined;
	
	      var isCommon = newValue === undefined;
	
	      if (isCommon) {
	        var isArr = isArray(srcValue),
	            isBuff = !isArr && isBuffer(srcValue),
	            isTyped = !isArr && !isBuff && isTypedArray(srcValue);
	
	        newValue = srcValue;
	        if (isArr || isBuff || isTyped) {
	          if (isArray(objValue)) {
	            newValue = objValue;
	          }
	          else if (isArrayLikeObject(objValue)) {
	            newValue = copyArray(objValue);
	          }
	          else if (isBuff) {
	            isCommon = false;
	            newValue = cloneBuffer(srcValue, true);
	          }
	          else if (isTyped) {
	            isCommon = false;
	            newValue = cloneTypedArray(srcValue, true);
	          }
	          else {
	            newValue = [];
	          }
	        }
	        else if (isPlainObject(srcValue) || isArguments(srcValue)) {
	          newValue = objValue;
	          if (isArguments(objValue)) {
	            newValue = toPlainObject(objValue);
	          }
	          else if (!isObject(objValue) || (srcIndex && isFunction(objValue))) {
	            newValue = initCloneObject(srcValue);
	          }
	        }
	        else {
	          isCommon = false;
	        }
	      }
	      if (isCommon) {
	        // Recursively merge objects and arrays (susceptible to call stack limits).
	        stack.set(srcValue, newValue);
	        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
	        stack['delete'](srcValue);
	      }
	      assignMergeValue(object, key, newValue);
	    }
	
	    /**
	     * The base implementation of `_.nth` which doesn't coerce arguments.
	     *
	     * @private
	     * @param {Array} array The array to query.
	     * @param {number} n The index of the element to return.
	     * @returns {*} Returns the nth element of `array`.
	     */
	    function baseNth(array, n) {
	      var length = array.length;
	      if (!length) {
	        return;
	      }
	      n += n < 0 ? length : 0;
	      return isIndex(n, length) ? array[n] : undefined;
	    }
	
	    /**
	     * The base implementation of `_.orderBy` without param guards.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
	     * @param {string[]} orders The sort orders of `iteratees`.
	     * @returns {Array} Returns the new sorted array.
	     */
	    function baseOrderBy(collection, iteratees, orders) {
	      var index = -1;
	      iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(getIteratee()));
	
	      var result = baseMap(collection, function(value, key, collection) {
	        var criteria = arrayMap(iteratees, function(iteratee) {
	          return iteratee(value);
	        });
	        return { 'criteria': criteria, 'index': ++index, 'value': value };
	      });
	
	      return baseSortBy(result, function(object, other) {
	        return compareMultiple(object, other, orders);
	      });
	    }
	
	    /**
	     * The base implementation of `_.pick` without support for individual
	     * property identifiers.
	     *
	     * @private
	     * @param {Object} object The source object.
	     * @param {string[]} paths The property paths to pick.
	     * @returns {Object} Returns the new object.
	     */
	    function basePick(object, paths) {
	      object = Object(object);
	      return basePickBy(object, paths, function(value, path) {
	        return hasIn(object, path);
	      });
	    }
	
	    /**
	     * The base implementation of  `_.pickBy` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Object} object The source object.
	     * @param {string[]} paths The property paths to pick.
	     * @param {Function} predicate The function invoked per property.
	     * @returns {Object} Returns the new object.
	     */
	    function basePickBy(object, paths, predicate) {
	      var index = -1,
	          length = paths.length,
	          result = {};
	
	      while (++index < length) {
	        var path = paths[index],
	            value = baseGet(object, path);
	
	        if (predicate(value, path)) {
	          baseSet(result, castPath(path, object), value);
	        }
	      }
	      return result;
	    }
	
	    /**
	     * A specialized version of `baseProperty` which supports deep paths.
	     *
	     * @private
	     * @param {Array|string} path The path of the property to get.
	     * @returns {Function} Returns the new accessor function.
	     */
	    function basePropertyDeep(path) {
	      return function(object) {
	        return baseGet(object, path);
	      };
	    }
	
	    /**
	     * The base implementation of `_.pullAllBy` without support for iteratee
	     * shorthands.
	     *
	     * @private
	     * @param {Array} array The array to modify.
	     * @param {Array} values The values to remove.
	     * @param {Function} [iteratee] The iteratee invoked per element.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns `array`.
	     */
	    function basePullAll(array, values, iteratee, comparator) {
	      var indexOf = comparator ? baseIndexOfWith : baseIndexOf,
	          index = -1,
	          length = values.length,
	          seen = array;
	
	      if (array === values) {
	        values = copyArray(values);
	      }
	      if (iteratee) {
	        seen = arrayMap(array, baseUnary(iteratee));
	      }
	      while (++index < length) {
	        var fromIndex = 0,
	            value = values[index],
	            computed = iteratee ? iteratee(value) : value;
	
	        while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
	          if (seen !== array) {
	            splice.call(seen, fromIndex, 1);
	          }
	          splice.call(array, fromIndex, 1);
	        }
	      }
	      return array;
	    }
	
	    /**
	     * The base implementation of `_.pullAt` without support for individual
	     * indexes or capturing the removed elements.
	     *
	     * @private
	     * @param {Array} array The array to modify.
	     * @param {number[]} indexes The indexes of elements to remove.
	     * @returns {Array} Returns `array`.
	     */
	    function basePullAt(array, indexes) {
	      var length = array ? indexes.length : 0,
	          lastIndex = length - 1;
	
	      while (length--) {
	        var index = indexes[length];
	        if (length == lastIndex || index !== previous) {
	          var previous = index;
	          if (isIndex(index)) {
	            splice.call(array, index, 1);
	          } else {
	            baseUnset(array, index);
	          }
	        }
	      }
	      return array;
	    }
	
	    /**
	     * The base implementation of `_.random` without support for returning
	     * floating-point numbers.
	     *
	     * @private
	     * @param {number} lower The lower bound.
	     * @param {number} upper The upper bound.
	     * @returns {number} Returns the random number.
	     */
	    function baseRandom(lower, upper) {
	      return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
	    }
	
	    /**
	     * The base implementation of `_.range` and `_.rangeRight` which doesn't
	     * coerce arguments.
	     *
	     * @private
	     * @param {number} start The start of the range.
	     * @param {number} end The end of the range.
	     * @param {number} step The value to increment or decrement by.
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Array} Returns the range of numbers.
	     */
	    function baseRange(start, end, step, fromRight) {
	      var index = -1,
	          length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
	          result = Array(length);
	
	      while (length--) {
	        result[fromRight ? length : ++index] = start;
	        start += step;
	      }
	      return result;
	    }
	
	    /**
	     * The base implementation of `_.repeat` which doesn't coerce arguments.
	     *
	     * @private
	     * @param {string} string The string to repeat.
	     * @param {number} n The number of times to repeat the string.
	     * @returns {string} Returns the repeated string.
	     */
	    function baseRepeat(string, n) {
	      var result = '';
	      if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
	        return result;
	      }
	      // Leverage the exponentiation by squaring algorithm for a faster repeat.
	      // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
	      do {
	        if (n % 2) {
	          result += string;
	        }
	        n = nativeFloor(n / 2);
	        if (n) {
	          string += string;
	        }
	      } while (n);
	
	      return result;
	    }
	
	    /**
	     * The base implementation of `_.rest` which doesn't validate or coerce arguments.
	     *
	     * @private
	     * @param {Function} func The function to apply a rest parameter to.
	     * @param {number} [start=func.length-1] The start position of the rest parameter.
	     * @returns {Function} Returns the new function.
	     */
	    function baseRest(func, start) {
	      return setToString(overRest(func, start, identity), func + '');
	    }
	
	    /**
	     * The base implementation of `_.sample`.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to sample.
	     * @returns {*} Returns the random element.
	     */
	    function baseSample(collection) {
	      return arraySample(values(collection));
	    }
	
	    /**
	     * The base implementation of `_.sampleSize` without param guards.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to sample.
	     * @param {number} n The number of elements to sample.
	     * @returns {Array} Returns the random elements.
	     */
	    function baseSampleSize(collection, n) {
	      var array = values(collection);
	      return shuffleSelf(array, baseClamp(n, 0, array.length));
	    }
	
	    /**
	     * The base implementation of `_.set`.
	     *
	     * @private
	     * @param {Object} object The object to modify.
	     * @param {Array|string} path The path of the property to set.
	     * @param {*} value The value to set.
	     * @param {Function} [customizer] The function to customize path creation.
	     * @returns {Object} Returns `object`.
	     */
	    function baseSet(object, path, value, customizer) {
	      if (!isObject(object)) {
	        return object;
	      }
	      path = castPath(path, object);
	
	      var index = -1,
	          length = path.length,
	          lastIndex = length - 1,
	          nested = object;
	
	      while (nested != null && ++index < length) {
	        var key = toKey(path[index]),
	            newValue = value;
	
	        if (index != lastIndex) {
	          var objValue = nested[key];
	          newValue = customizer ? customizer(objValue, key, nested) : undefined;
	          if (newValue === undefined) {
	            newValue = isObject(objValue)
	              ? objValue
	              : (isIndex(path[index + 1]) ? [] : {});
	          }
	        }
	        assignValue(nested, key, newValue);
	        nested = nested[key];
	      }
	      return object;
	    }
	
	    /**
	     * The base implementation of `setData` without support for hot loop shorting.
	     *
	     * @private
	     * @param {Function} func The function to associate metadata with.
	     * @param {*} data The metadata.
	     * @returns {Function} Returns `func`.
	     */
	    var baseSetData = !metaMap ? identity : function(func, data) {
	      metaMap.set(func, data);
	      return func;
	    };
	
	    /**
	     * The base implementation of `setToString` without support for hot loop shorting.
	     *
	     * @private
	     * @param {Function} func The function to modify.
	     * @param {Function} string The `toString` result.
	     * @returns {Function} Returns `func`.
	     */
	    var baseSetToString = !defineProperty ? identity : function(func, string) {
	      return defineProperty(func, 'toString', {
	        'configurable': true,
	        'enumerable': false,
	        'value': constant(string),
	        'writable': true
	      });
	    };
	
	    /**
	     * The base implementation of `_.shuffle`.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to shuffle.
	     * @returns {Array} Returns the new shuffled array.
	     */
	    function baseShuffle(collection) {
	      return shuffleSelf(values(collection));
	    }
	
	    /**
	     * The base implementation of `_.slice` without an iteratee call guard.
	     *
	     * @private
	     * @param {Array} array The array to slice.
	     * @param {number} [start=0] The start position.
	     * @param {number} [end=array.length] The end position.
	     * @returns {Array} Returns the slice of `array`.
	     */
	    function baseSlice(array, start, end) {
	      var index = -1,
	          length = array.length;
	
	      if (start < 0) {
	        start = -start > length ? 0 : (length + start);
	      }
	      end = end > length ? length : end;
	      if (end < 0) {
	        end += length;
	      }
	      length = start > end ? 0 : ((end - start) >>> 0);
	      start >>>= 0;
	
	      var result = Array(length);
	      while (++index < length) {
	        result[index] = array[index + start];
	      }
	      return result;
	    }
	
	    /**
	     * The base implementation of `_.some` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} predicate The function invoked per iteration.
	     * @returns {boolean} Returns `true` if any element passes the predicate check,
	     *  else `false`.
	     */
	    function baseSome(collection, predicate) {
	      var result;
	
	      baseEach(collection, function(value, index, collection) {
	        result = predicate(value, index, collection);
	        return !result;
	      });
	      return !!result;
	    }
	
	    /**
	     * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which
	     * performs a binary search of `array` to determine the index at which `value`
	     * should be inserted into `array` in order to maintain its sort order.
	     *
	     * @private
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @param {boolean} [retHighest] Specify returning the highest qualified index.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     */
	    function baseSortedIndex(array, value, retHighest) {
	      var low = 0,
	          high = array == null ? low : array.length;
	
	      if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
	        while (low < high) {
	          var mid = (low + high) >>> 1,
	              computed = array[mid];
	
	          if (computed !== null && !isSymbol(computed) &&
	              (retHighest ? (computed <= value) : (computed < value))) {
	            low = mid + 1;
	          } else {
	            high = mid;
	          }
	        }
	        return high;
	      }
	      return baseSortedIndexBy(array, value, identity, retHighest);
	    }
	
	    /**
	     * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`
	     * which invokes `iteratee` for `value` and each element of `array` to compute
	     * their sort ranking. The iteratee is invoked with one argument; (value).
	     *
	     * @private
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @param {Function} iteratee The iteratee invoked per element.
	     * @param {boolean} [retHighest] Specify returning the highest qualified index.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     */
	    function baseSortedIndexBy(array, value, iteratee, retHighest) {
	      value = iteratee(value);
	
	      var low = 0,
	          high = array == null ? 0 : array.length,
	          valIsNaN = value !== value,
	          valIsNull = value === null,
	          valIsSymbol = isSymbol(value),
	          valIsUndefined = value === undefined;
	
	      while (low < high) {
	        var mid = nativeFloor((low + high) / 2),
	            computed = iteratee(array[mid]),
	            othIsDefined = computed !== undefined,
	            othIsNull = computed === null,
	            othIsReflexive = computed === computed,
	            othIsSymbol = isSymbol(computed);
	
	        if (valIsNaN) {
	          var setLow = retHighest || othIsReflexive;
	        } else if (valIsUndefined) {
	          setLow = othIsReflexive && (retHighest || othIsDefined);
	        } else if (valIsNull) {
	          setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
	        } else if (valIsSymbol) {
	          setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
	        } else if (othIsNull || othIsSymbol) {
	          setLow = false;
	        } else {
	          setLow = retHighest ? (computed <= value) : (computed < value);
	        }
	        if (setLow) {
	          low = mid + 1;
	        } else {
	          high = mid;
	        }
	      }
	      return nativeMin(high, MAX_ARRAY_INDEX);
	    }
	
	    /**
	     * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without
	     * support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array} array The array to inspect.
	     * @param {Function} [iteratee] The iteratee invoked per element.
	     * @returns {Array} Returns the new duplicate free array.
	     */
	    function baseSortedUniq(array, iteratee) {
	      var index = -1,
	          length = array.length,
	          resIndex = 0,
	          result = [];
	
	      while (++index < length) {
	        var value = array[index],
	            computed = iteratee ? iteratee(value) : value;
	
	        if (!index || !eq(computed, seen)) {
	          var seen = computed;
	          result[resIndex++] = value === 0 ? 0 : value;
	        }
	      }
	      return result;
	    }
	
	    /**
	     * The base implementation of `_.toNumber` which doesn't ensure correct
	     * conversions of binary, hexadecimal, or octal string values.
	     *
	     * @private
	     * @param {*} value The value to process.
	     * @returns {number} Returns the number.
	     */
	    function baseToNumber(value) {
	      if (typeof value == 'number') {
	        return value;
	      }
	      if (isSymbol(value)) {
	        return NAN;
	      }
	      return +value;
	    }
	
	    /**
	     * The base implementation of `_.toString` which doesn't convert nullish
	     * values to empty strings.
	     *
	     * @private
	     * @param {*} value The value to process.
	     * @returns {string} Returns the string.
	     */
	    function baseToString(value) {
	      // Exit early for strings to avoid a performance hit in some environments.
	      if (typeof value == 'string') {
	        return value;
	      }
	      if (isArray(value)) {
	        // Recursively convert values (susceptible to call stack limits).
	        return arrayMap(value, baseToString) + '';
	      }
	      if (isSymbol(value)) {
	        return symbolToString ? symbolToString.call(value) : '';
	      }
	      var result = (value + '');
	      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
	    }
	
	    /**
	     * The base implementation of `_.uniqBy` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array} array The array to inspect.
	     * @param {Function} [iteratee] The iteratee invoked per element.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new duplicate free array.
	     */
	    function baseUniq(array, iteratee, comparator) {
	      var index = -1,
	          includes = arrayIncludes,
	          length = array.length,
	          isCommon = true,
	          result = [],
	          seen = result;
	
	      if (comparator) {
	        isCommon = false;
	        includes = arrayIncludesWith;
	      }
	      else if (length >= LARGE_ARRAY_SIZE) {
	        var set = iteratee ? null : createSet(array);
	        if (set) {
	          return setToArray(set);
	        }
	        isCommon = false;
	        includes = cacheHas;
	        seen = new SetCache;
	      }
	      else {
	        seen = iteratee ? [] : result;
	      }
	      outer:
	      while (++index < length) {
	        var value = array[index],
	            computed = iteratee ? iteratee(value) : value;
	
	        value = (comparator || value !== 0) ? value : 0;
	        if (isCommon && computed === computed) {
	          var seenIndex = seen.length;
	          while (seenIndex--) {
	            if (seen[seenIndex] === computed) {
	              continue outer;
	            }
	          }
	          if (iteratee) {
	            seen.push(computed);
	          }
	          result.push(value);
	        }
	        else if (!includes(seen, computed, comparator)) {
	          if (seen !== result) {
	            seen.push(computed);
	          }
	          result.push(value);
	        }
	      }
	      return result;
	    }
	
	    /**
	     * The base implementation of `_.unset`.
	     *
	     * @private
	     * @param {Object} object The object to modify.
	     * @param {Array|string} path The property path to unset.
	     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
	     */
	    function baseUnset(object, path) {
	      path = castPath(path, object);
	      object = parent(object, path);
	      return object == null || delete object[toKey(last(path))];
	    }
	
	    /**
	     * The base implementation of `_.update`.
	     *
	     * @private
	     * @param {Object} object The object to modify.
	     * @param {Array|string} path The path of the property to update.
	     * @param {Function} updater The function to produce the updated value.
	     * @param {Function} [customizer] The function to customize path creation.
	     * @returns {Object} Returns `object`.
	     */
	    function baseUpdate(object, path, updater, customizer) {
	      return baseSet(object, path, updater(baseGet(object, path)), customizer);
	    }
	
	    /**
	     * The base implementation of methods like `_.dropWhile` and `_.takeWhile`
	     * without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array} array The array to query.
	     * @param {Function} predicate The function invoked per iteration.
	     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Array} Returns the slice of `array`.
	     */
	    function baseWhile(array, predicate, isDrop, fromRight) {
	      var length = array.length,
	          index = fromRight ? length : -1;
	
	      while ((fromRight ? index-- : ++index < length) &&
	        predicate(array[index], index, array)) {}
	
	      return isDrop
	        ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))
	        : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));
	    }
	
	    /**
	     * The base implementation of `wrapperValue` which returns the result of
	     * performing a sequence of actions on the unwrapped `value`, where each
	     * successive action is supplied the return value of the previous.
	     *
	     * @private
	     * @param {*} value The unwrapped value.
	     * @param {Array} actions Actions to perform to resolve the unwrapped value.
	     * @returns {*} Returns the resolved value.
	     */
	    function baseWrapperValue(value, actions) {
	      var result = value;
	      if (result instanceof LazyWrapper) {
	        result = result.value();
	      }
	      return arrayReduce(actions, function(result, action) {
	        return action.func.apply(action.thisArg, arrayPush([result], action.args));
	      }, result);
	    }
	
	    /**
	     * The base implementation of methods like `_.xor`, without support for
	     * iteratee shorthands, that accepts an array of arrays to inspect.
	     *
	     * @private
	     * @param {Array} arrays The arrays to inspect.
	     * @param {Function} [iteratee] The iteratee invoked per element.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new array of values.
	     */
	    function baseXor(arrays, iteratee, comparator) {
	      var length = arrays.length;
	      if (length < 2) {
	        return length ? baseUniq(arrays[0]) : [];
	      }
	      var index = -1,
	          result = Array(length);
	
	      while (++index < length) {
	        var array = arrays[index],
	            othIndex = -1;
	
	        while (++othIndex < length) {
	          if (othIndex != index) {
	            result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator);
	          }
	        }
	      }
	      return baseUniq(baseFlatten(result, 1), iteratee, comparator);
	    }
	
	    /**
	     * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
	     *
	     * @private
	     * @param {Array} props The property identifiers.
	     * @param {Array} values The property values.
	     * @param {Function} assignFunc The function to assign values.
	     * @returns {Object} Returns the new object.
	     */
	    function baseZipObject(props, values, assignFunc) {
	      var index = -1,
	          length = props.length,
	          valsLength = values.length,
	          result = {};
	
	      while (++index < length) {
	        var value = index < valsLength ? values[index] : undefined;
	        assignFunc(result, props[index], value);
	      }
	      return result;
	    }
	
	    /**
	     * Casts `value` to an empty array if it's not an array like object.
	     *
	     * @private
	     * @param {*} value The value to inspect.
	     * @returns {Array|Object} Returns the cast array-like object.
	     */
	    function castArrayLikeObject(value) {
	      return isArrayLikeObject(value) ? value : [];
	    }
	
	    /**
	     * Casts `value` to `identity` if it's not a function.
	     *
	     * @private
	     * @param {*} value The value to inspect.
	     * @returns {Function} Returns cast function.
	     */
	    function castFunction(value) {
	      return typeof value == 'function' ? value : identity;
	    }
	
	    /**
	     * Casts `value` to a path array if it's not one.
	     *
	     * @private
	     * @param {*} value The value to inspect.
	     * @param {Object} [object] The object to query keys on.
	     * @returns {Array} Returns the cast property path array.
	     */
	    function castPath(value, object) {
	      if (isArray(value)) {
	        return value;
	      }
	      return isKey(value, object) ? [value] : stringToPath(toString(value));
	    }
	
	    /**
	     * A `baseRest` alias which can be replaced with `identity` by module
	     * replacement plugins.
	     *
	     * @private
	     * @type {Function}
	     * @param {Function} func The function to apply a rest parameter to.
	     * @returns {Function} Returns the new function.
	     */
	    var castRest = baseRest;
	
	    /**
	     * Casts `array` to a slice if it's needed.
	     *
	     * @private
	     * @param {Array} array The array to inspect.
	     * @param {number} start The start position.
	     * @param {number} [end=array.length] The end position.
	     * @returns {Array} Returns the cast slice.
	     */
	    function castSlice(array, start, end) {
	      var length = array.length;
	      end = end === undefined ? length : end;
	      return (!start && end >= length) ? array : baseSlice(array, start, end);
	    }
	
	    /**
	     * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).
	     *
	     * @private
	     * @param {number|Object} id The timer id or timeout object of the timer to clear.
	     */
	    var clearTimeout = ctxClearTimeout || function(id) {
	      return root.clearTimeout(id);
	    };
	
	    /**
	     * Creates a clone of  `buffer`.
	     *
	     * @private
	     * @param {Buffer} buffer The buffer to clone.
	     * @param {boolean} [isDeep] Specify a deep clone.
	     * @returns {Buffer} Returns the cloned buffer.
	     */
	    function cloneBuffer(buffer, isDeep) {
	      if (isDeep) {
	        return buffer.slice();
	      }
	      var length = buffer.length,
	          result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
	
	      buffer.copy(result);
	      return result;
	    }
	
	    /**
	     * Creates a clone of `arrayBuffer`.
	     *
	     * @private
	     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
	     * @returns {ArrayBuffer} Returns the cloned array buffer.
	     */
	    function cloneArrayBuffer(arrayBuffer) {
	      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
	      new Uint8Array(result).set(new Uint8Array(arrayBuffer));
	      return result;
	    }
	
	    /**
	     * Creates a clone of `dataView`.
	     *
	     * @private
	     * @param {Object} dataView The data view to clone.
	     * @param {boolean} [isDeep] Specify a deep clone.
	     * @returns {Object} Returns the cloned data view.
	     */
	    function cloneDataView(dataView, isDeep) {
	      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
	      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
	    }
	
	    /**
	     * Creates a clone of `map`.
	     *
	     * @private
	     * @param {Object} map The map to clone.
	     * @param {Function} cloneFunc The function to clone values.
	     * @param {boolean} [isDeep] Specify a deep clone.
	     * @returns {Object} Returns the cloned map.
	     */
	    function cloneMap(map, isDeep, cloneFunc) {
	      var array = isDeep ? cloneFunc(mapToArray(map), CLONE_DEEP_FLAG) : mapToArray(map);
	      return arrayReduce(array, addMapEntry, new map.constructor);
	    }
	
	    /**
	     * Creates a clone of `regexp`.
	     *
	     * @private
	     * @param {Object} regexp The regexp to clone.
	     * @returns {Object} Returns the cloned regexp.
	     */
	    function cloneRegExp(regexp) {
	      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
	      result.lastIndex = regexp.lastIndex;
	      return result;
	    }
	
	    /**
	     * Creates a clone of `set`.
	     *
	     * @private
	     * @param {Object} set The set to clone.
	     * @param {Function} cloneFunc The function to clone values.
	     * @param {boolean} [isDeep] Specify a deep clone.
	     * @returns {Object} Returns the cloned set.
	     */
	    function cloneSet(set, isDeep, cloneFunc) {
	      var array = isDeep ? cloneFunc(setToArray(set), CLONE_DEEP_FLAG) : setToArray(set);
	      return arrayReduce(array, addSetEntry, new set.constructor);
	    }
	
	    /**
	     * Creates a clone of the `symbol` object.
	     *
	     * @private
	     * @param {Object} symbol The symbol object to clone.
	     * @returns {Object} Returns the cloned symbol object.
	     */
	    function cloneSymbol(symbol) {
	      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
	    }
	
	    /**
	     * Creates a clone of `typedArray`.
	     *
	     * @private
	     * @param {Object} typedArray The typed array to clone.
	     * @param {boolean} [isDeep] Specify a deep clone.
	     * @returns {Object} Returns the cloned typed array.
	     */
	    function cloneTypedArray(typedArray, isDeep) {
	      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
	      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
	    }
	
	    /**
	     * Compares values to sort them in ascending order.
	     *
	     * @private
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {number} Returns the sort order indicator for `value`.
	     */
	    function compareAscending(value, other) {
	      if (value !== other) {
	        var valIsDefined = value !== undefined,
	            valIsNull = value === null,
	            valIsReflexive = value === value,
	            valIsSymbol = isSymbol(value);
	
	        var othIsDefined = other !== undefined,
	            othIsNull = other === null,
	            othIsReflexive = other === other,
	            othIsSymbol = isSymbol(other);
	
	        if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||
	            (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||
	            (valIsNull && othIsDefined && othIsReflexive) ||
	            (!valIsDefined && othIsReflexive) ||
	            !valIsReflexive) {
	          return 1;
	        }
	        if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||
	            (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||
	            (othIsNull && valIsDefined && valIsReflexive) ||
	            (!othIsDefined && valIsReflexive) ||
	            !othIsReflexive) {
	          return -1;
	        }
	      }
	      return 0;
	    }
	
	    /**
	     * Used by `_.orderBy` to compare multiple properties of a value to another
	     * and stable sort them.
	     *
	     * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
	     * specify an order of "desc" for descending or "asc" for ascending sort order
	     * of corresponding values.
	     *
	     * @private
	     * @param {Object} object The object to compare.
	     * @param {Object} other The other object to compare.
	     * @param {boolean[]|string[]} orders The order to sort by for each property.
	     * @returns {number} Returns the sort order indicator for `object`.
	     */
	    function compareMultiple(object, other, orders) {
	      var index = -1,
	          objCriteria = object.criteria,
	          othCriteria = other.criteria,
	          length = objCriteria.length,
	          ordersLength = orders.length;
	
	      while (++index < length) {
	        var result = compareAscending(objCriteria[index], othCriteria[index]);
	        if (result) {
	          if (index >= ordersLength) {
	            return result;
	          }
	          var order = orders[index];
	          return result * (order == 'desc' ? -1 : 1);
	        }
	      }
	      // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
	      // that causes it, under certain circumstances, to provide the same value for
	      // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
	      // for more details.
	      //
	      // This also ensures a stable sort in V8 and other engines.
	      // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
	      return object.index - other.index;
	    }
	
	    /**
	     * Creates an array that is the composition of partially applied arguments,
	     * placeholders, and provided arguments into a single array of arguments.
	     *
	     * @private
	     * @param {Array} args The provided arguments.
	     * @param {Array} partials The arguments to prepend to those provided.
	     * @param {Array} holders The `partials` placeholder indexes.
	     * @params {boolean} [isCurried] Specify composing for a curried function.
	     * @returns {Array} Returns the new array of composed arguments.
	     */
	    function composeArgs(args, partials, holders, isCurried) {
	      var argsIndex = -1,
	          argsLength = args.length,
	          holdersLength = holders.length,
	          leftIndex = -1,
	          leftLength = partials.length,
	          rangeLength = nativeMax(argsLength - holdersLength, 0),
	          result = Array(leftLength + rangeLength),
	          isUncurried = !isCurried;
	
	      while (++leftIndex < leftLength) {
	        result[leftIndex] = partials[leftIndex];
	      }
	      while (++argsIndex < holdersLength) {
	        if (isUncurried || argsIndex < argsLength) {
	          result[holders[argsIndex]] = args[argsIndex];
	        }
	      }
	      while (rangeLength--) {
	        result[leftIndex++] = args[argsIndex++];
	      }
	      return result;
	    }
	
	    /**
	     * This function is like `composeArgs` except that the arguments composition
	     * is tailored for `_.partialRight`.
	     *
	     * @private
	     * @param {Array} args The provided arguments.
	     * @param {Array} partials The arguments to append to those provided.
	     * @param {Array} holders The `partials` placeholder indexes.
	     * @params {boolean} [isCurried] Specify composing for a curried function.
	     * @returns {Array} Returns the new array of composed arguments.
	     */
	    function composeArgsRight(args, partials, holders, isCurried) {
	      var argsIndex = -1,
	          argsLength = args.length,
	          holdersIndex = -1,
	          holdersLength = holders.length,
	          rightIndex = -1,
	          rightLength = partials.length,
	          rangeLength = nativeMax(argsLength - holdersLength, 0),
	          result = Array(rangeLength + rightLength),
	          isUncurried = !isCurried;
	
	      while (++argsIndex < rangeLength) {
	        result[argsIndex] = args[argsIndex];
	      }
	      var offset = argsIndex;
	      while (++rightIndex < rightLength) {
	        result[offset + rightIndex] = partials[rightIndex];
	      }
	      while (++holdersIndex < holdersLength) {
	        if (isUncurried || argsIndex < argsLength) {
	          result[offset + holders[holdersIndex]] = args[argsIndex++];
	        }
	      }
	      return result;
	    }
	
	    /**
	     * Copies the values of `source` to `array`.
	     *
	     * @private
	     * @param {Array} source The array to copy values from.
	     * @param {Array} [array=[]] The array to copy values to.
	     * @returns {Array} Returns `array`.
	     */
	    function copyArray(source, array) {
	      var index = -1,
	          length = source.length;
	
	      array || (array = Array(length));
	      while (++index < length) {
	        array[index] = source[index];
	      }
	      return array;
	    }
	
	    /**
	     * Copies properties of `source` to `object`.
	     *
	     * @private
	     * @param {Object} source The object to copy properties from.
	     * @param {Array} props The property identifiers to copy.
	     * @param {Object} [object={}] The object to copy properties to.
	     * @param {Function} [customizer] The function to customize copied values.
	     * @returns {Object} Returns `object`.
	     */
	    function copyObject(source, props, object, customizer) {
	      var isNew = !object;
	      object || (object = {});
	
	      var index = -1,
	          length = props.length;
	
	      while (++index < length) {
	        var key = props[index];
	
	        var newValue = customizer
	          ? customizer(object[key], source[key], key, object, source)
	          : undefined;
	
	        if (newValue === undefined) {
	          newValue = source[key];
	        }
	        if (isNew) {
	          baseAssignValue(object, key, newValue);
	        } else {
	          assignValue(object, key, newValue);
	        }
	      }
	      return object;
	    }
	
	    /**
	     * Copies own symbols of `source` to `object`.
	     *
	     * @private
	     * @param {Object} source The object to copy symbols from.
	     * @param {Object} [object={}] The object to copy symbols to.
	     * @returns {Object} Returns `object`.
	     */
	    function copySymbols(source, object) {
	      return copyObject(source, getSymbols(source), object);
	    }
	
	    /**
	     * Copies own and inherited symbols of `source` to `object`.
	     *
	     * @private
	     * @param {Object} source The object to copy symbols from.
	     * @param {Object} [object={}] The object to copy symbols to.
	     * @returns {Object} Returns `object`.
	     */
	    function copySymbolsIn(source, object) {
	      return copyObject(source, getSymbolsIn(source), object);
	    }
	
	    /**
	     * Creates a function like `_.groupBy`.
	     *
	     * @private
	     * @param {Function} setter The function to set accumulator values.
	     * @param {Function} [initializer] The accumulator object initializer.
	     * @returns {Function} Returns the new aggregator function.
	     */
	    function createAggregator(setter, initializer) {
	      return function(collection, iteratee) {
	        var func = isArray(collection) ? arrayAggregator : baseAggregator,
	            accumulator = initializer ? initializer() : {};
	
	        return func(collection, setter, getIteratee(iteratee, 2), accumulator);
	      };
	    }
	
	    /**
	     * Creates a function like `_.assign`.
	     *
	     * @private
	     * @param {Function} assigner The function to assign values.
	     * @returns {Function} Returns the new assigner function.
	     */
	    function createAssigner(assigner) {
	      return baseRest(function(object, sources) {
	        var index = -1,
	            length = sources.length,
	            customizer = length > 1 ? sources[length - 1] : undefined,
	            guard = length > 2 ? sources[2] : undefined;
	
	        customizer = (assigner.length > 3 && typeof customizer == 'function')
	          ? (length--, customizer)
	          : undefined;
	
	        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
	          customizer = length < 3 ? undefined : customizer;
	          length = 1;
	        }
	        object = Object(object);
	        while (++index < length) {
	          var source = sources[index];
	          if (source) {
	            assigner(object, source, index, customizer);
	          }
	        }
	        return object;
	      });
	    }
	
	    /**
	     * Creates a `baseEach` or `baseEachRight` function.
	     *
	     * @private
	     * @param {Function} eachFunc The function to iterate over a collection.
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Function} Returns the new base function.
	     */
	    function createBaseEach(eachFunc, fromRight) {
	      return function(collection, iteratee) {
	        if (collection == null) {
	          return collection;
	        }
	        if (!isArrayLike(collection)) {
	          return eachFunc(collection, iteratee);
	        }
	        var length = collection.length,
	            index = fromRight ? length : -1,
	            iterable = Object(collection);
	
	        while ((fromRight ? index-- : ++index < length)) {
	          if (iteratee(iterable[index], index, iterable) === false) {
	            break;
	          }
	        }
	        return collection;
	      };
	    }
	
	    /**
	     * Creates a base function for methods like `_.forIn` and `_.forOwn`.
	     *
	     * @private
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Function} Returns the new base function.
	     */
	    function createBaseFor(fromRight) {
	      return function(object, iteratee, keysFunc) {
	        var index = -1,
	            iterable = Object(object),
	            props = keysFunc(object),
	            length = props.length;
	
	        while (length--) {
	          var key = props[fromRight ? length : ++index];
	          if (iteratee(iterable[key], key, iterable) === false) {
	            break;
	          }
	        }
	        return object;
	      };
	    }
	
	    /**
	     * Creates a function that wraps `func` to invoke it with the optional `this`
	     * binding of `thisArg`.
	     *
	     * @private
	     * @param {Function} func The function to wrap.
	     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	     * @param {*} [thisArg] The `this` binding of `func`.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createBind(func, bitmask, thisArg) {
	      var isBind = bitmask & WRAP_BIND_FLAG,
	          Ctor = createCtor(func);
	
	      function wrapper() {
	        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
	        return fn.apply(isBind ? thisArg : this, arguments);
	      }
	      return wrapper;
	    }
	
	    /**
	     * Creates a function like `_.lowerFirst`.
	     *
	     * @private
	     * @param {string} methodName The name of the `String` case method to use.
	     * @returns {Function} Returns the new case function.
	     */
	    function createCaseFirst(methodName) {
	      return function(string) {
	        string = toString(string);
	
	        var strSymbols = hasUnicode(string)
	          ? stringToArray(string)
	          : undefined;
	
	        var chr = strSymbols
	          ? strSymbols[0]
	          : string.charAt(0);
	
	        var trailing = strSymbols
	          ? castSlice(strSymbols, 1).join('')
	          : string.slice(1);
	
	        return chr[methodName]() + trailing;
	      };
	    }
	
	    /**
	     * Creates a function like `_.camelCase`.
	     *
	     * @private
	     * @param {Function} callback The function to combine each word.
	     * @returns {Function} Returns the new compounder function.
	     */
	    function createCompounder(callback) {
	      return function(string) {
	        return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
	      };
	    }
	
	    /**
	     * Creates a function that produces an instance of `Ctor` regardless of
	     * whether it was invoked as part of a `new` expression or by `call` or `apply`.
	     *
	     * @private
	     * @param {Function} Ctor The constructor to wrap.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createCtor(Ctor) {
	      return function() {
	        // Use a `switch` statement to work with class constructors. See
	        // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
	        // for more details.
	        var args = arguments;
	        switch (args.length) {
	          case 0: return new Ctor;
	          case 1: return new Ctor(args[0]);
	          case 2: return new Ctor(args[0], args[1]);
	          case 3: return new Ctor(args[0], args[1], args[2]);
	          case 4: return new Ctor(args[0], args[1], args[2], args[3]);
	          case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
	          case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
	          case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
	        }
	        var thisBinding = baseCreate(Ctor.prototype),
	            result = Ctor.apply(thisBinding, args);
	
	        // Mimic the constructor's `return` behavior.
	        // See https://es5.github.io/#x13.2.2 for more details.
	        return isObject(result) ? result : thisBinding;
	      };
	    }
	
	    /**
	     * Creates a function that wraps `func` to enable currying.
	     *
	     * @private
	     * @param {Function} func The function to wrap.
	     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	     * @param {number} arity The arity of `func`.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createCurry(func, bitmask, arity) {
	      var Ctor = createCtor(func);
	
	      function wrapper() {
	        var length = arguments.length,
	            args = Array(length),
	            index = length,
	            placeholder = getHolder(wrapper);
	
	        while (index--) {
	          args[index] = arguments[index];
	        }
	        var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder)
	          ? []
	          : replaceHolders(args, placeholder);
	
	        length -= holders.length;
	        if (length < arity) {
	          return createRecurry(
	            func, bitmask, createHybrid, wrapper.placeholder, undefined,
	            args, holders, undefined, undefined, arity - length);
	        }
	        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
	        return apply(fn, this, args);
	      }
	      return wrapper;
	    }
	
	    /**
	     * Creates a `_.find` or `_.findLast` function.
	     *
	     * @private
	     * @param {Function} findIndexFunc The function to find the collection index.
	     * @returns {Function} Returns the new find function.
	     */
	    function createFind(findIndexFunc) {
	      return function(collection, predicate, fromIndex) {
	        var iterable = Object(collection);
	        if (!isArrayLike(collection)) {
	          var iteratee = getIteratee(predicate, 3);
	          collection = keys(collection);
	          predicate = function(key) { return iteratee(iterable[key], key, iterable); };
	        }
	        var index = findIndexFunc(collection, predicate, fromIndex);
	        return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
	      };
	    }
	
	    /**
	     * Creates a `_.flow` or `_.flowRight` function.
	     *
	     * @private
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Function} Returns the new flow function.
	     */
	    function createFlow(fromRight) {
	      return flatRest(function(funcs) {
	        var length = funcs.length,
	            index = length,
	            prereq = LodashWrapper.prototype.thru;
	
	        if (fromRight) {
	          funcs.reverse();
	        }
	        while (index--) {
	          var func = funcs[index];
	          if (typeof func != 'function') {
	            throw new TypeError(FUNC_ERROR_TEXT);
	          }
	          if (prereq && !wrapper && getFuncName(func) == 'wrapper') {
	            var wrapper = new LodashWrapper([], true);
	          }
	        }
	        index = wrapper ? index : length;
	        while (++index < length) {
	          func = funcs[index];
	
	          var funcName = getFuncName(func),
	              data = funcName == 'wrapper' ? getData(func) : undefined;
	
	          if (data && isLaziable(data[0]) &&
	                data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) &&
	                !data[4].length && data[9] == 1
	              ) {
	            wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
	          } else {
	            wrapper = (func.length == 1 && isLaziable(func))
	              ? wrapper[funcName]()
	              : wrapper.thru(func);
	          }
	        }
	        return function() {
	          var args = arguments,
	              value = args[0];
	
	          if (wrapper && args.length == 1 &&
	              isArray(value) && value.length >= LARGE_ARRAY_SIZE) {
	            return wrapper.plant(value).value();
	          }
	          var index = 0,
	              result = length ? funcs[index].apply(this, args) : value;
	
	          while (++index < length) {
	            result = funcs[index].call(this, result);
	          }
	          return result;
	        };
	      });
	    }
	
	    /**
	     * Creates a function that wraps `func` to invoke it with optional `this`
	     * binding of `thisArg`, partial application, and currying.
	     *
	     * @private
	     * @param {Function|string} func The function or method name to wrap.
	     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	     * @param {*} [thisArg] The `this` binding of `func`.
	     * @param {Array} [partials] The arguments to prepend to those provided to
	     *  the new function.
	     * @param {Array} [holders] The `partials` placeholder indexes.
	     * @param {Array} [partialsRight] The arguments to append to those provided
	     *  to the new function.
	     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
	     * @param {Array} [argPos] The argument positions of the new function.
	     * @param {number} [ary] The arity cap of `func`.
	     * @param {number} [arity] The arity of `func`.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
	      var isAry = bitmask & WRAP_ARY_FLAG,
	          isBind = bitmask & WRAP_BIND_FLAG,
	          isBindKey = bitmask & WRAP_BIND_KEY_FLAG,
	          isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG),
	          isFlip = bitmask & WRAP_FLIP_FLAG,
	          Ctor = isBindKey ? undefined : createCtor(func);
	
	      function wrapper() {
	        var length = arguments.length,
	            args = Array(length),
	            index = length;
	
	        while (index--) {
	          args[index] = arguments[index];
	        }
	        if (isCurried) {
	          var placeholder = getHolder(wrapper),
	              holdersCount = countHolders(args, placeholder);
	        }
	        if (partials) {
	          args = composeArgs(args, partials, holders, isCurried);
	        }
	        if (partialsRight) {
	          args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
	        }
	        length -= holdersCount;
	        if (isCurried && length < arity) {
	          var newHolders = replaceHolders(args, placeholder);
	          return createRecurry(
	            func, bitmask, createHybrid, wrapper.placeholder, thisArg,
	            args, newHolders, argPos, ary, arity - length
	          );
	        }
	        var thisBinding = isBind ? thisArg : this,
	            fn = isBindKey ? thisBinding[func] : func;
	
	        length = args.length;
	        if (argPos) {
	          args = reorder(args, argPos);
	        } else if (isFlip && length > 1) {
	          args.reverse();
	        }
	        if (isAry && ary < length) {
	          args.length = ary;
	        }
	        if (this && this !== root && this instanceof wrapper) {
	          fn = Ctor || createCtor(fn);
	        }
	        return fn.apply(thisBinding, args);
	      }
	      return wrapper;
	    }
	
	    /**
	     * Creates a function like `_.invertBy`.
	     *
	     * @private
	     * @param {Function} setter The function to set accumulator values.
	     * @param {Function} toIteratee The function to resolve iteratees.
	     * @returns {Function} Returns the new inverter function.
	     */
	    function createInverter(setter, toIteratee) {
	      return function(object, iteratee) {
	        return baseInverter(object, setter, toIteratee(iteratee), {});
	      };
	    }
	
	    /**
	     * Creates a function that performs a mathematical operation on two values.
	     *
	     * @private
	     * @param {Function} operator The function to perform the operation.
	     * @param {number} [defaultValue] The value used for `undefined` arguments.
	     * @returns {Function} Returns the new mathematical operation function.
	     */
	    function createMathOperation(operator, defaultValue) {
	      return function(value, other) {
	        var result;
	        if (value === undefined && other === undefined) {
	          return defaultValue;
	        }
	        if (value !== undefined) {
	          result = value;
	        }
	        if (other !== undefined) {
	          if (result === undefined) {
	            return other;
	          }
	          if (typeof value == 'string' || typeof other == 'string') {
	            value = baseToString(value);
	            other = baseToString(other);
	          } else {
	            value = baseToNumber(value);
	            other = baseToNumber(other);
	          }
	          result = operator(value, other);
	        }
	        return result;
	      };
	    }
	
	    /**
	     * Creates a function like `_.over`.
	     *
	     * @private
	     * @param {Function} arrayFunc The function to iterate over iteratees.
	     * @returns {Function} Returns the new over function.
	     */
	    function createOver(arrayFunc) {
	      return flatRest(function(iteratees) {
	        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
	        return baseRest(function(args) {
	          var thisArg = this;
	          return arrayFunc(iteratees, function(iteratee) {
	            return apply(iteratee, thisArg, args);
	          });
	        });
	      });
	    }
	
	    /**
	     * Creates the padding for `string` based on `length`. The `chars` string
	     * is truncated if the number of characters exceeds `length`.
	     *
	     * @private
	     * @param {number} length The padding length.
	     * @param {string} [chars=' '] The string used as padding.
	     * @returns {string} Returns the padding for `string`.
	     */
	    function createPadding(length, chars) {
	      chars = chars === undefined ? ' ' : baseToString(chars);
	
	      var charsLength = chars.length;
	      if (charsLength < 2) {
	        return charsLength ? baseRepeat(chars, length) : chars;
	      }
	      var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
	      return hasUnicode(chars)
	        ? castSlice(stringToArray(result), 0, length).join('')
	        : result.slice(0, length);
	    }
	
	    /**
	     * Creates a function that wraps `func` to invoke it with the `this` binding
	     * of `thisArg` and `partials` prepended to the arguments it receives.
	     *
	     * @private
	     * @param {Function} func The function to wrap.
	     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	     * @param {*} thisArg The `this` binding of `func`.
	     * @param {Array} partials The arguments to prepend to those provided to
	     *  the new function.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createPartial(func, bitmask, thisArg, partials) {
	      var isBind = bitmask & WRAP_BIND_FLAG,
	          Ctor = createCtor(func);
	
	      function wrapper() {
	        var argsIndex = -1,
	            argsLength = arguments.length,
	            leftIndex = -1,
	            leftLength = partials.length,
	            args = Array(leftLength + argsLength),
	            fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
	
	        while (++leftIndex < leftLength) {
	          args[leftIndex] = partials[leftIndex];
	        }
	        while (argsLength--) {
	          args[leftIndex++] = arguments[++argsIndex];
	        }
	        return apply(fn, isBind ? thisArg : this, args);
	      }
	      return wrapper;
	    }
	
	    /**
	     * Creates a `_.range` or `_.rangeRight` function.
	     *
	     * @private
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Function} Returns the new range function.
	     */
	    function createRange(fromRight) {
	      return function(start, end, step) {
	        if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {
	          end = step = undefined;
	        }
	        // Ensure the sign of `-0` is preserved.
	        start = toFinite(start);
	        if (end === undefined) {
	          end = start;
	          start = 0;
	        } else {
	          end = toFinite(end);
	        }
	        step = step === undefined ? (start < end ? 1 : -1) : toFinite(step);
	        return baseRange(start, end, step, fromRight);
	      };
	    }
	
	    /**
	     * Creates a function that performs a relational operation on two values.
	     *
	     * @private
	     * @param {Function} operator The function to perform the operation.
	     * @returns {Function} Returns the new relational operation function.
	     */
	    function createRelationalOperation(operator) {
	      return function(value, other) {
	        if (!(typeof value == 'string' && typeof other == 'string')) {
	          value = toNumber(value);
	          other = toNumber(other);
	        }
	        return operator(value, other);
	      };
	    }
	
	    /**
	     * Creates a function that wraps `func` to continue currying.
	     *
	     * @private
	     * @param {Function} func The function to wrap.
	     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	     * @param {Function} wrapFunc The function to create the `func` wrapper.
	     * @param {*} placeholder The placeholder value.
	     * @param {*} [thisArg] The `this` binding of `func`.
	     * @param {Array} [partials] The arguments to prepend to those provided to
	     *  the new function.
	     * @param {Array} [holders] The `partials` placeholder indexes.
	     * @param {Array} [argPos] The argument positions of the new function.
	     * @param {number} [ary] The arity cap of `func`.
	     * @param {number} [arity] The arity of `func`.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
	      var isCurry = bitmask & WRAP_CURRY_FLAG,
	          newHolders = isCurry ? holders : undefined,
	          newHoldersRight = isCurry ? undefined : holders,
	          newPartials = isCurry ? partials : undefined,
	          newPartialsRight = isCurry ? undefined : partials;
	
	      bitmask |= (isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG);
	      bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
	
	      if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
	        bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
	      }
	      var newData = [
	        func, bitmask, thisArg, newPartials, newHolders, newPartialsRight,
	        newHoldersRight, argPos, ary, arity
	      ];
	
	      var result = wrapFunc.apply(undefined, newData);
	      if (isLaziable(func)) {
	        setData(result, newData);
	      }
	      result.placeholder = placeholder;
	      return setWrapToString(result, func, bitmask);
	    }
	
	    /**
	     * Creates a function like `_.round`.
	     *
	     * @private
	     * @param {string} methodName The name of the `Math` method to use when rounding.
	     * @returns {Function} Returns the new round function.
	     */
	    function createRound(methodName) {
	      var func = Math[methodName];
	      return function(number, precision) {
	        number = toNumber(number);
	        precision = nativeMin(toInteger(precision), 292);
	        if (precision) {
	          // Shift with exponential notation to avoid floating-point issues.
	          // See [MDN](https://mdn.io/round#Examples) for more details.
	          var pair = (toString(number) + 'e').split('e'),
	              value = func(pair[0] + 'e' + (+pair[1] + precision));
	
	          pair = (toString(value) + 'e').split('e');
	          return +(pair[0] + 'e' + (+pair[1] - precision));
	        }
	        return func(number);
	      };
	    }
	
	    /**
	     * Creates a set object of `values`.
	     *
	     * @private
	     * @param {Array} values The values to add to the set.
	     * @returns {Object} Returns the new set.
	     */
	    var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {
	      return new Set(values);
	    };
	
	    /**
	     * Creates a `_.toPairs` or `_.toPairsIn` function.
	     *
	     * @private
	     * @param {Function} keysFunc The function to get the keys of a given object.
	     * @returns {Function} Returns the new pairs function.
	     */
	    function createToPairs(keysFunc) {
	      return function(object) {
	        var tag = getTag(object);
	        if (tag == mapTag) {
	          return mapToArray(object);
	        }
	        if (tag == setTag) {
	          return setToPairs(object);
	        }
	        return baseToPairs(object, keysFunc(object));
	      };
	    }
	
	    /**
	     * Creates a function that either curries or invokes `func` with optional
	     * `this` binding and partially applied arguments.
	     *
	     * @private
	     * @param {Function|string} func The function or method name to wrap.
	     * @param {number} bitmask The bitmask flags.
	     *    1 - `_.bind`
	     *    2 - `_.bindKey`
	     *    4 - `_.curry` or `_.curryRight` of a bound function
	     *    8 - `_.curry`
	     *   16 - `_.curryRight`
	     *   32 - `_.partial`
	     *   64 - `_.partialRight`
	     *  128 - `_.rearg`
	     *  256 - `_.ary`
	     *  512 - `_.flip`
	     * @param {*} [thisArg] The `this` binding of `func`.
	     * @param {Array} [partials] The arguments to be partially applied.
	     * @param {Array} [holders] The `partials` placeholder indexes.
	     * @param {Array} [argPos] The argument positions of the new function.
	     * @param {number} [ary] The arity cap of `func`.
	     * @param {number} [arity] The arity of `func`.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
	      var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
	      if (!isBindKey && typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      var length = partials ? partials.length : 0;
	      if (!length) {
	        bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
	        partials = holders = undefined;
	      }
	      ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);
	      arity = arity === undefined ? arity : toInteger(arity);
	      length -= holders ? holders.length : 0;
	
	      if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
	        var partialsRight = partials,
	            holdersRight = holders;
	
	        partials = holders = undefined;
	      }
	      var data = isBindKey ? undefined : getData(func);
	
	      var newData = [
	        func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,
	        argPos, ary, arity
	      ];
	
	      if (data) {
	        mergeData(newData, data);
	      }
	      func = newData[0];
	      bitmask = newData[1];
	      thisArg = newData[2];
	      partials = newData[3];
	      holders = newData[4];
	      arity = newData[9] = newData[9] == null
	        ? (isBindKey ? 0 : func.length)
	        : nativeMax(newData[9] - length, 0);
	
	      if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
	        bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
	      }
	      if (!bitmask || bitmask == WRAP_BIND_FLAG) {
	        var result = createBind(func, bitmask, thisArg);
	      } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
	        result = createCurry(func, bitmask, arity);
	      } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
	        result = createPartial(func, bitmask, thisArg, partials);
	      } else {
	        result = createHybrid.apply(undefined, newData);
	      }
	      var setter = data ? baseSetData : setData;
	      return setWrapToString(setter(result, newData), func, bitmask);
	    }
	
	    /**
	     * A specialized version of `baseIsEqualDeep` for arrays with support for
	     * partial deep comparisons.
	     *
	     * @private
	     * @param {Array} array The array to compare.
	     * @param {Array} other The other array to compare.
	     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	     * @param {Function} customizer The function to customize comparisons.
	     * @param {Function} equalFunc The function to determine equivalents of values.
	     * @param {Object} stack Tracks traversed `array` and `other` objects.
	     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
	     */
	    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
	      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
	          arrLength = array.length,
	          othLength = other.length;
	
	      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
	        return false;
	      }
	      // Assume cyclic values are equal.
	      var stacked = stack.get(array);
	      if (stacked && stack.get(other)) {
	        return stacked == other;
	      }
	      var index = -1,
	          result = true,
	          seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;
	
	      stack.set(array, other);
	      stack.set(other, array);
	
	      // Ignore non-index properties.
	      while (++index < arrLength) {
	        var arrValue = array[index],
	            othValue = other[index];
	
	        if (customizer) {
	          var compared = isPartial
	            ? customizer(othValue, arrValue, index, other, array, stack)
	            : customizer(arrValue, othValue, index, array, other, stack);
	        }
	        if (compared !== undefined) {
	          if (compared) {
	            continue;
	          }
	          result = false;
	          break;
	        }
	        // Recursively compare arrays (susceptible to call stack limits).
	        if (seen) {
	          if (!arraySome(other, function(othValue, othIndex) {
	                if (!cacheHas(seen, othIndex) &&
	                    (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
	                  return seen.push(othIndex);
	                }
	              })) {
	            result = false;
	            break;
	          }
	        } else if (!(
	              arrValue === othValue ||
	                equalFunc(arrValue, othValue, bitmask, customizer, stack)
	            )) {
	          result = false;
	          break;
	        }
	      }
	      stack['delete'](array);
	      stack['delete'](other);
	      return result;
	    }
	
	    /**
	     * A specialized version of `baseIsEqualDeep` for comparing objects of
	     * the same `toStringTag`.
	     *
	     * **Note:** This function only supports comparing values with tags of
	     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
	     *
	     * @private
	     * @param {Object} object The object to compare.
	     * @param {Object} other The other object to compare.
	     * @param {string} tag The `toStringTag` of the objects to compare.
	     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	     * @param {Function} customizer The function to customize comparisons.
	     * @param {Function} equalFunc The function to determine equivalents of values.
	     * @param {Object} stack Tracks traversed `object` and `other` objects.
	     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	     */
	    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
	      switch (tag) {
	        case dataViewTag:
	          if ((object.byteLength != other.byteLength) ||
	              (object.byteOffset != other.byteOffset)) {
	            return false;
	          }
	          object = object.buffer;
	          other = other.buffer;
	
	        case arrayBufferTag:
	          if ((object.byteLength != other.byteLength) ||
	              !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
	            return false;
	          }
	          return true;
	
	        case boolTag:
	        case dateTag:
	        case numberTag:
	          // Coerce booleans to `1` or `0` and dates to milliseconds.
	          // Invalid dates are coerced to `NaN`.
	          return eq(+object, +other);
	
	        case errorTag:
	          return object.name == other.name && object.message == other.message;
	
	        case regexpTag:
	        case stringTag:
	          // Coerce regexes to strings and treat strings, primitives and objects,
	          // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
	          // for more details.
	          return object == (other + '');
	
	        case mapTag:
	          var convert = mapToArray;
	
	        case setTag:
	          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
	          convert || (convert = setToArray);
	
	          if (object.size != other.size && !isPartial) {
	            return false;
	          }
	          // Assume cyclic values are equal.
	          var stacked = stack.get(object);
	          if (stacked) {
	            return stacked == other;
	          }
	          bitmask |= COMPARE_UNORDERED_FLAG;
	
	          // Recursively compare objects (susceptible to call stack limits).
	          stack.set(object, other);
	          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
	          stack['delete'](object);
	          return result;
	
	        case symbolTag:
	          if (symbolValueOf) {
	            return symbolValueOf.call(object) == symbolValueOf.call(other);
	          }
	      }
	      return false;
	    }
	
	    /**
	     * A specialized version of `baseIsEqualDeep` for objects with support for
	     * partial deep comparisons.
	     *
	     * @private
	     * @param {Object} object The object to compare.
	     * @param {Object} other The other object to compare.
	     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	     * @param {Function} customizer The function to customize comparisons.
	     * @param {Function} equalFunc The function to determine equivalents of values.
	     * @param {Object} stack Tracks traversed `object` and `other` objects.
	     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	     */
	    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
	      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
	          objProps = keys(object),
	          objLength = objProps.length,
	          othProps = keys(other),
	          othLength = othProps.length;
	
	      if (objLength != othLength && !isPartial) {
	        return false;
	      }
	      var index = objLength;
	      while (index--) {
	        var key = objProps[index];
	        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
	          return false;
	        }
	      }
	      // Assume cyclic values are equal.
	      var stacked = stack.get(object);
	      if (stacked && stack.get(other)) {
	        return stacked == other;
	      }
	      var result = true;
	      stack.set(object, other);
	      stack.set(other, object);
	
	      var skipCtor = isPartial;
	      while (++index < objLength) {
	        key = objProps[index];
	        var objValue = object[key],
	            othValue = other[key];
	
	        if (customizer) {
	          var compared = isPartial
	            ? customizer(othValue, objValue, key, other, object, stack)
	            : customizer(objValue, othValue, key, object, other, stack);
	        }
	        // Recursively compare objects (susceptible to call stack limits).
	        if (!(compared === undefined
	              ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
	              : compared
	            )) {
	          result = false;
	          break;
	        }
	        skipCtor || (skipCtor = key == 'constructor');
	      }
	      if (result && !skipCtor) {
	        var objCtor = object.constructor,
	            othCtor = other.constructor;
	
	        // Non `Object` object instances with different constructors are not equal.
	        if (objCtor != othCtor &&
	            ('constructor' in object && 'constructor' in other) &&
	            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
	              typeof othCtor == 'function' && othCtor instanceof othCtor)) {
	          result = false;
	        }
	      }
	      stack['delete'](object);
	      stack['delete'](other);
	      return result;
	    }
	
	    /**
	     * A specialized version of `baseRest` which flattens the rest array.
	     *
	     * @private
	     * @param {Function} func The function to apply a rest parameter to.
	     * @returns {Function} Returns the new function.
	     */
	    function flatRest(func) {
	      return setToString(overRest(func, undefined, flatten), func + '');
	    }
	
	    /**
	     * Creates an array of own enumerable property names and symbols of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names and symbols.
	     */
	    function getAllKeys(object) {
	      return baseGetAllKeys(object, keys, getSymbols);
	    }
	
	    /**
	     * Creates an array of own and inherited enumerable property names and
	     * symbols of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names and symbols.
	     */
	    function getAllKeysIn(object) {
	      return baseGetAllKeys(object, keysIn, getSymbolsIn);
	    }
	
	    /**
	     * Gets metadata for `func`.
	     *
	     * @private
	     * @param {Function} func The function to query.
	     * @returns {*} Returns the metadata for `func`.
	     */
	    var getData = !metaMap ? noop : function(func) {
	      return metaMap.get(func);
	    };
	
	    /**
	     * Gets the name of `func`.
	     *
	     * @private
	     * @param {Function} func The function to query.
	     * @returns {string} Returns the function name.
	     */
	    function getFuncName(func) {
	      var result = (func.name + ''),
	          array = realNames[result],
	          length = hasOwnProperty.call(realNames, result) ? array.length : 0;
	
	      while (length--) {
	        var data = array[length],
	            otherFunc = data.func;
	        if (otherFunc == null || otherFunc == func) {
	          return data.name;
	        }
	      }
	      return result;
	    }
	
	    /**
	     * Gets the argument placeholder value for `func`.
	     *
	     * @private
	     * @param {Function} func The function to inspect.
	     * @returns {*} Returns the placeholder value.
	     */
	    function getHolder(func) {
	      var object = hasOwnProperty.call(lodash, 'placeholder') ? lodash : func;
	      return object.placeholder;
	    }
	
	    /**
	     * Gets the appropriate "iteratee" function. If `_.iteratee` is customized,
	     * this function returns the custom method, otherwise it returns `baseIteratee`.
	     * If arguments are provided, the chosen function is invoked with them and
	     * its result is returned.
	     *
	     * @private
	     * @param {*} [value] The value to convert to an iteratee.
	     * @param {number} [arity] The arity of the created iteratee.
	     * @returns {Function} Returns the chosen function or its result.
	     */
	    function getIteratee() {
	      var result = lodash.iteratee || iteratee;
	      result = result === iteratee ? baseIteratee : result;
	      return arguments.length ? result(arguments[0], arguments[1]) : result;
	    }
	
	    /**
	     * Gets the data for `map`.
	     *
	     * @private
	     * @param {Object} map The map to query.
	     * @param {string} key The reference key.
	     * @returns {*} Returns the map data.
	     */
	    function getMapData(map, key) {
	      var data = map.__data__;
	      return isKeyable(key)
	        ? data[typeof key == 'string' ? 'string' : 'hash']
	        : data.map;
	    }
	
	    /**
	     * Gets the property names, values, and compare flags of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the match data of `object`.
	     */
	    function getMatchData(object) {
	      var result = keys(object),
	          length = result.length;
	
	      while (length--) {
	        var key = result[length],
	            value = object[key];
	
	        result[length] = [key, value, isStrictComparable(value)];
	      }
	      return result;
	    }
	
	    /**
	     * Gets the native function at `key` of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {string} key The key of the method to get.
	     * @returns {*} Returns the function if it's native, else `undefined`.
	     */
	    function getNative(object, key) {
	      var value = getValue(object, key);
	      return baseIsNative(value) ? value : undefined;
	    }
	
	    /**
	     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
	     *
	     * @private
	     * @param {*} value The value to query.
	     * @returns {string} Returns the raw `toStringTag`.
	     */
	    function getRawTag(value) {
	      var isOwn = hasOwnProperty.call(value, symToStringTag),
	          tag = value[symToStringTag];
	
	      try {
	        value[symToStringTag] = undefined;
	        var unmasked = true;
	      } catch (e) {}
	
	      var result = nativeObjectToString.call(value);
	      if (unmasked) {
	        if (isOwn) {
	          value[symToStringTag] = tag;
	        } else {
	          delete value[symToStringTag];
	        }
	      }
	      return result;
	    }
	
	    /**
	     * Creates an array of the own enumerable symbols of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of symbols.
	     */
	    var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;
	
	    /**
	     * Creates an array of the own and inherited enumerable symbols of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of symbols.
	     */
	    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
	      var result = [];
	      while (object) {
	        arrayPush(result, getSymbols(object));
	        object = getPrototype(object);
	      }
	      return result;
	    };
	
	    /**
	     * Gets the `toStringTag` of `value`.
	     *
	     * @private
	     * @param {*} value The value to query.
	     * @returns {string} Returns the `toStringTag`.
	     */
	    var getTag = baseGetTag;
	
	    // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
	    if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
	        (Map && getTag(new Map) != mapTag) ||
	        (Promise && getTag(Promise.resolve()) != promiseTag) ||
	        (Set && getTag(new Set) != setTag) ||
	        (WeakMap && getTag(new WeakMap) != weakMapTag)) {
	      getTag = function(value) {
	        var result = baseGetTag(value),
	            Ctor = result == objectTag ? value.constructor : undefined,
	            ctorString = Ctor ? toSource(Ctor) : '';
	
	        if (ctorString) {
	          switch (ctorString) {
	            case dataViewCtorString: return dataViewTag;
	            case mapCtorString: return mapTag;
	            case promiseCtorString: return promiseTag;
	            case setCtorString: return setTag;
	            case weakMapCtorString: return weakMapTag;
	          }
	        }
	        return result;
	      };
	    }
	
	    /**
	     * Gets the view, applying any `transforms` to the `start` and `end` positions.
	     *
	     * @private
	     * @param {number} start The start of the view.
	     * @param {number} end The end of the view.
	     * @param {Array} transforms The transformations to apply to the view.
	     * @returns {Object} Returns an object containing the `start` and `end`
	     *  positions of the view.
	     */
	    function getView(start, end, transforms) {
	      var index = -1,
	          length = transforms.length;
	
	      while (++index < length) {
	        var data = transforms[index],
	            size = data.size;
	
	        switch (data.type) {
	          case 'drop':      start += size; break;
	          case 'dropRight': end -= size; break;
	          case 'take':      end = nativeMin(end, start + size); break;
	          case 'takeRight': start = nativeMax(start, end - size); break;
	        }
	      }
	      return { 'start': start, 'end': end };
	    }
	
	    /**
	     * Extracts wrapper details from the `source` body comment.
	     *
	     * @private
	     * @param {string} source The source to inspect.
	     * @returns {Array} Returns the wrapper details.
	     */
	    function getWrapDetails(source) {
	      var match = source.match(reWrapDetails);
	      return match ? match[1].split(reSplitDetails) : [];
	    }
	
	    /**
	     * Checks if `path` exists on `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path to check.
	     * @param {Function} hasFunc The function to check properties.
	     * @returns {boolean} Returns `true` if `path` exists, else `false`.
	     */
	    function hasPath(object, path, hasFunc) {
	      path = castPath(path, object);
	
	      var index = -1,
	          length = path.length,
	          result = false;
	
	      while (++index < length) {
	        var key = toKey(path[index]);
	        if (!(result = object != null && hasFunc(object, key))) {
	          break;
	        }
	        object = object[key];
	      }
	      if (result || ++index != length) {
	        return result;
	      }
	      length = object == null ? 0 : object.length;
	      return !!length && isLength(length) && isIndex(key, length) &&
	        (isArray(object) || isArguments(object));
	    }
	
	    /**
	     * Initializes an array clone.
	     *
	     * @private
	     * @param {Array} array The array to clone.
	     * @returns {Array} Returns the initialized clone.
	     */
	    function initCloneArray(array) {
	      var length = array.length,
	          result = array.constructor(length);
	
	      // Add properties assigned by `RegExp#exec`.
	      if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
	        result.index = array.index;
	        result.input = array.input;
	      }
	      return result;
	    }
	
	    /**
	     * Initializes an object clone.
	     *
	     * @private
	     * @param {Object} object The object to clone.
	     * @returns {Object} Returns the initialized clone.
	     */
	    function initCloneObject(object) {
	      return (typeof object.constructor == 'function' && !isPrototype(object))
	        ? baseCreate(getPrototype(object))
	        : {};
	    }
	
	    /**
	     * Initializes an object clone based on its `toStringTag`.
	     *
	     * **Note:** This function only supports cloning values with tags of
	     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
	     *
	     * @private
	     * @param {Object} object The object to clone.
	     * @param {string} tag The `toStringTag` of the object to clone.
	     * @param {Function} cloneFunc The function to clone values.
	     * @param {boolean} [isDeep] Specify a deep clone.
	     * @returns {Object} Returns the initialized clone.
	     */
	    function initCloneByTag(object, tag, cloneFunc, isDeep) {
	      var Ctor = object.constructor;
	      switch (tag) {
	        case arrayBufferTag:
	          return cloneArrayBuffer(object);
	
	        case boolTag:
	        case dateTag:
	          return new Ctor(+object);
	
	        case dataViewTag:
	          return cloneDataView(object, isDeep);
	
	        case float32Tag: case float64Tag:
	        case int8Tag: case int16Tag: case int32Tag:
	        case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
	          return cloneTypedArray(object, isDeep);
	
	        case mapTag:
	          return cloneMap(object, isDeep, cloneFunc);
	
	        case numberTag:
	        case stringTag:
	          return new Ctor(object);
	
	        case regexpTag:
	          return cloneRegExp(object);
	
	        case setTag:
	          return cloneSet(object, isDeep, cloneFunc);
	
	        case symbolTag:
	          return cloneSymbol(object);
	      }
	    }
	
	    /**
	     * Inserts wrapper `details` in a comment at the top of the `source` body.
	     *
	     * @private
	     * @param {string} source The source to modify.
	     * @returns {Array} details The details to insert.
	     * @returns {string} Returns the modified source.
	     */
	    function insertWrapDetails(source, details) {
	      var length = details.length;
	      if (!length) {
	        return source;
	      }
	      var lastIndex = length - 1;
	      details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];
	      details = details.join(length > 2 ? ', ' : ' ');
	      return source.replace(reWrapComment, '{\n/* [wrapped with ' + details + '] */\n');
	    }
	
	    /**
	     * Checks if `value` is a flattenable `arguments` object or array.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
	     */
	    function isFlattenable(value) {
	      return isArray(value) || isArguments(value) ||
	        !!(spreadableSymbol && value && value[spreadableSymbol]);
	    }
	
	    /**
	     * Checks if `value` is a valid array-like index.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	     */
	    function isIndex(value, length) {
	      length = length == null ? MAX_SAFE_INTEGER : length;
	      return !!length &&
	        (typeof value == 'number' || reIsUint.test(value)) &&
	        (value > -1 && value % 1 == 0 && value < length);
	    }
	
	    /**
	     * Checks if the given arguments are from an iteratee call.
	     *
	     * @private
	     * @param {*} value The potential iteratee value argument.
	     * @param {*} index The potential iteratee index or key argument.
	     * @param {*} object The potential iteratee object argument.
	     * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
	     *  else `false`.
	     */
	    function isIterateeCall(value, index, object) {
	      if (!isObject(object)) {
	        return false;
	      }
	      var type = typeof index;
	      if (type == 'number'
	            ? (isArrayLike(object) && isIndex(index, object.length))
	            : (type == 'string' && index in object)
	          ) {
	        return eq(object[index], value);
	      }
	      return false;
	    }
	
	    /**
	     * Checks if `value` is a property name and not a property path.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @param {Object} [object] The object to query keys on.
	     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
	     */
	    function isKey(value, object) {
	      if (isArray(value)) {
	        return false;
	      }
	      var type = typeof value;
	      if (type == 'number' || type == 'symbol' || type == 'boolean' ||
	          value == null || isSymbol(value)) {
	        return true;
	      }
	      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
	        (object != null && value in Object(object));
	    }
	
	    /**
	     * Checks if `value` is suitable for use as unique object key.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
	     */
	    function isKeyable(value) {
	      var type = typeof value;
	      return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
	        ? (value !== '__proto__')
	        : (value === null);
	    }
	
	    /**
	     * Checks if `func` has a lazy counterpart.
	     *
	     * @private
	     * @param {Function} func The function to check.
	     * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
	     *  else `false`.
	     */
	    function isLaziable(func) {
	      var funcName = getFuncName(func),
	          other = lodash[funcName];
	
	      if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {
	        return false;
	      }
	      if (func === other) {
	        return true;
	      }
	      var data = getData(other);
	      return !!data && func === data[0];
	    }
	
	    /**
	     * Checks if `func` has its source masked.
	     *
	     * @private
	     * @param {Function} func The function to check.
	     * @returns {boolean} Returns `true` if `func` is masked, else `false`.
	     */
	    function isMasked(func) {
	      return !!maskSrcKey && (maskSrcKey in func);
	    }
	
	    /**
	     * Checks if `func` is capable of being masked.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `func` is maskable, else `false`.
	     */
	    var isMaskable = coreJsData ? isFunction : stubFalse;
	
	    /**
	     * Checks if `value` is likely a prototype object.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
	     */
	    function isPrototype(value) {
	      var Ctor = value && value.constructor,
	          proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;
	
	      return value === proto;
	    }
	
	    /**
	     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` if suitable for strict
	     *  equality comparisons, else `false`.
	     */
	    function isStrictComparable(value) {
	      return value === value && !isObject(value);
	    }
	
	    /**
	     * A specialized version of `matchesProperty` for source values suitable
	     * for strict equality comparisons, i.e. `===`.
	     *
	     * @private
	     * @param {string} key The key of the property to get.
	     * @param {*} srcValue The value to match.
	     * @returns {Function} Returns the new spec function.
	     */
	    function matchesStrictComparable(key, srcValue) {
	      return function(object) {
	        if (object == null) {
	          return false;
	        }
	        return object[key] === srcValue &&
	          (srcValue !== undefined || (key in Object(object)));
	      };
	    }
	
	    /**
	     * A specialized version of `_.memoize` which clears the memoized function's
	     * cache when it exceeds `MAX_MEMOIZE_SIZE`.
	     *
	     * @private
	     * @param {Function} func The function to have its output memoized.
	     * @returns {Function} Returns the new memoized function.
	     */
	    function memoizeCapped(func) {
	      var result = memoize(func, function(key) {
	        if (cache.size === MAX_MEMOIZE_SIZE) {
	          cache.clear();
	        }
	        return key;
	      });
	
	      var cache = result.cache;
	      return result;
	    }
	
	    /**
	     * Merges the function metadata of `source` into `data`.
	     *
	     * Merging metadata reduces the number of wrappers used to invoke a function.
	     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
	     * may be applied regardless of execution order. Methods like `_.ary` and
	     * `_.rearg` modify function arguments, making the order in which they are
	     * executed important, preventing the merging of metadata. However, we make
	     * an exception for a safe combined case where curried functions have `_.ary`
	     * and or `_.rearg` applied.
	     *
	     * @private
	     * @param {Array} data The destination metadata.
	     * @param {Array} source The source metadata.
	     * @returns {Array} Returns `data`.
	     */
	    function mergeData(data, source) {
	      var bitmask = data[1],
	          srcBitmask = source[1],
	          newBitmask = bitmask | srcBitmask,
	          isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
	
	      var isCombo =
	        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_CURRY_FLAG)) ||
	        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_REARG_FLAG) && (data[7].length <= source[8])) ||
	        ((srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG)) && (source[7].length <= source[8]) && (bitmask == WRAP_CURRY_FLAG));
	
	      // Exit early if metadata can't be merged.
	      if (!(isCommon || isCombo)) {
	        return data;
	      }
	      // Use source `thisArg` if available.
	      if (srcBitmask & WRAP_BIND_FLAG) {
	        data[2] = source[2];
	        // Set when currying a bound function.
	        newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
	      }
	      // Compose partial arguments.
	      var value = source[3];
	      if (value) {
	        var partials = data[3];
	        data[3] = partials ? composeArgs(partials, value, source[4]) : value;
	        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
	      }
	      // Compose partial right arguments.
	      value = source[5];
	      if (value) {
	        partials = data[5];
	        data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
	        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
	      }
	      // Use source `argPos` if available.
	      value = source[7];
	      if (value) {
	        data[7] = value;
	      }
	      // Use source `ary` if it's smaller.
	      if (srcBitmask & WRAP_ARY_FLAG) {
	        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
	      }
	      // Use source `arity` if one is not provided.
	      if (data[9] == null) {
	        data[9] = source[9];
	      }
	      // Use source `func` and merge bitmasks.
	      data[0] = source[0];
	      data[1] = newBitmask;
	
	      return data;
	    }
	
	    /**
	     * Used by `_.defaultsDeep` to customize its `_.merge` use.
	     *
	     * @private
	     * @param {*} objValue The destination value.
	     * @param {*} srcValue The source value.
	     * @param {string} key The key of the property to merge.
	     * @param {Object} object The parent object of `objValue`.
	     * @param {Object} source The parent object of `srcValue`.
	     * @param {Object} [stack] Tracks traversed source values and their merged
	     *  counterparts.
	     * @returns {*} Returns the value to assign.
	     */
	    function mergeDefaults(objValue, srcValue, key, object, source, stack) {
	      if (isObject(objValue) && isObject(srcValue)) {
	        // Recursively merge objects and arrays (susceptible to call stack limits).
	        stack.set(srcValue, objValue);
	        baseMerge(objValue, srcValue, undefined, mergeDefaults, stack);
	        stack['delete'](srcValue);
	      }
	      return objValue;
	    }
	
	    /**
	     * This function is like
	     * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	     * except that it includes inherited enumerable properties.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names.
	     */
	    function nativeKeysIn(object) {
	      var result = [];
	      if (object != null) {
	        for (var key in Object(object)) {
	          result.push(key);
	        }
	      }
	      return result;
	    }
	
	    /**
	     * Converts `value` to a string using `Object.prototype.toString`.
	     *
	     * @private
	     * @param {*} value The value to convert.
	     * @returns {string} Returns the converted string.
	     */
	    function objectToString(value) {
	      return nativeObjectToString.call(value);
	    }
	
	    /**
	     * A specialized version of `baseRest` which transforms the rest array.
	     *
	     * @private
	     * @param {Function} func The function to apply a rest parameter to.
	     * @param {number} [start=func.length-1] The start position of the rest parameter.
	     * @param {Function} transform The rest array transform.
	     * @returns {Function} Returns the new function.
	     */
	    function overRest(func, start, transform) {
	      start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
	      return function() {
	        var args = arguments,
	            index = -1,
	            length = nativeMax(args.length - start, 0),
	            array = Array(length);
	
	        while (++index < length) {
	          array[index] = args[start + index];
	        }
	        index = -1;
	        var otherArgs = Array(start + 1);
	        while (++index < start) {
	          otherArgs[index] = args[index];
	        }
	        otherArgs[start] = transform(array);
	        return apply(func, this, otherArgs);
	      };
	    }
	
	    /**
	     * Gets the parent value at `path` of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {Array} path The path to get the parent value of.
	     * @returns {*} Returns the parent value.
	     */
	    function parent(object, path) {
	      return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
	    }
	
	    /**
	     * Reorder `array` according to the specified indexes where the element at
	     * the first index is assigned as the first element, the element at
	     * the second index is assigned as the second element, and so on.
	     *
	     * @private
	     * @param {Array} array The array to reorder.
	     * @param {Array} indexes The arranged array indexes.
	     * @returns {Array} Returns `array`.
	     */
	    function reorder(array, indexes) {
	      var arrLength = array.length,
	          length = nativeMin(indexes.length, arrLength),
	          oldArray = copyArray(array);
	
	      while (length--) {
	        var index = indexes[length];
	        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
	      }
	      return array;
	    }
	
	    /**
	     * Sets metadata for `func`.
	     *
	     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
	     * period of time, it will trip its breaker and transition to an identity
	     * function to avoid garbage collection pauses in V8. See
	     * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
	     * for more details.
	     *
	     * @private
	     * @param {Function} func The function to associate metadata with.
	     * @param {*} data The metadata.
	     * @returns {Function} Returns `func`.
	     */
	    var setData = shortOut(baseSetData);
	
	    /**
	     * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).
	     *
	     * @private
	     * @param {Function} func The function to delay.
	     * @param {number} wait The number of milliseconds to delay invocation.
	     * @returns {number|Object} Returns the timer id or timeout object.
	     */
	    var setTimeout = ctxSetTimeout || function(func, wait) {
	      return root.setTimeout(func, wait);
	    };
	
	    /**
	     * Sets the `toString` method of `func` to return `string`.
	     *
	     * @private
	     * @param {Function} func The function to modify.
	     * @param {Function} string The `toString` result.
	     * @returns {Function} Returns `func`.
	     */
	    var setToString = shortOut(baseSetToString);
	
	    /**
	     * Sets the `toString` method of `wrapper` to mimic the source of `reference`
	     * with wrapper details in a comment at the top of the source body.
	     *
	     * @private
	     * @param {Function} wrapper The function to modify.
	     * @param {Function} reference The reference function.
	     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	     * @returns {Function} Returns `wrapper`.
	     */
	    function setWrapToString(wrapper, reference, bitmask) {
	      var source = (reference + '');
	      return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
	    }
	
	    /**
	     * Creates a function that'll short out and invoke `identity` instead
	     * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
	     * milliseconds.
	     *
	     * @private
	     * @param {Function} func The function to restrict.
	     * @returns {Function} Returns the new shortable function.
	     */
	    function shortOut(func) {
	      var count = 0,
	          lastCalled = 0;
	
	      return function() {
	        var stamp = nativeNow(),
	            remaining = HOT_SPAN - (stamp - lastCalled);
	
	        lastCalled = stamp;
	        if (remaining > 0) {
	          if (++count >= HOT_COUNT) {
	            return arguments[0];
	          }
	        } else {
	          count = 0;
	        }
	        return func.apply(undefined, arguments);
	      };
	    }
	
	    /**
	     * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
	     *
	     * @private
	     * @param {Array} array The array to shuffle.
	     * @param {number} [size=array.length] The size of `array`.
	     * @returns {Array} Returns `array`.
	     */
	    function shuffleSelf(array, size) {
	      var index = -1,
	          length = array.length,
	          lastIndex = length - 1;
	
	      size = size === undefined ? length : size;
	      while (++index < size) {
	        var rand = baseRandom(index, lastIndex),
	            value = array[rand];
	
	        array[rand] = array[index];
	        array[index] = value;
	      }
	      array.length = size;
	      return array;
	    }
	
	    /**
	     * Converts `string` to a property path array.
	     *
	     * @private
	     * @param {string} string The string to convert.
	     * @returns {Array} Returns the property path array.
	     */
	    var stringToPath = memoizeCapped(function(string) {
	      var result = [];
	      if (reLeadingDot.test(string)) {
	        result.push('');
	      }
	      string.replace(rePropName, function(match, number, quote, string) {
	        result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
	      });
	      return result;
	    });
	
	    /**
	     * Converts `value` to a string key if it's not a string or symbol.
	     *
	     * @private
	     * @param {*} value The value to inspect.
	     * @returns {string|symbol} Returns the key.
	     */
	    function toKey(value) {
	      if (typeof value == 'string' || isSymbol(value)) {
	        return value;
	      }
	      var result = (value + '');
	      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
	    }
	
	    /**
	     * Converts `func` to its source code.
	     *
	     * @private
	     * @param {Function} func The function to convert.
	     * @returns {string} Returns the source code.
	     */
	    function toSource(func) {
	      if (func != null) {
	        try {
	          return funcToString.call(func);
	        } catch (e) {}
	        try {
	          return (func + '');
	        } catch (e) {}
	      }
	      return '';
	    }
	
	    /**
	     * Updates wrapper `details` based on `bitmask` flags.
	     *
	     * @private
	     * @returns {Array} details The details to modify.
	     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	     * @returns {Array} Returns `details`.
	     */
	    function updateWrapDetails(details, bitmask) {
	      arrayEach(wrapFlags, function(pair) {
	        var value = '_.' + pair[0];
	        if ((bitmask & pair[1]) && !arrayIncludes(details, value)) {
	          details.push(value);
	        }
	      });
	      return details.sort();
	    }
	
	    /**
	     * Creates a clone of `wrapper`.
	     *
	     * @private
	     * @param {Object} wrapper The wrapper to clone.
	     * @returns {Object} Returns the cloned wrapper.
	     */
	    function wrapperClone(wrapper) {
	      if (wrapper instanceof LazyWrapper) {
	        return wrapper.clone();
	      }
	      var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
	      result.__actions__ = copyArray(wrapper.__actions__);
	      result.__index__  = wrapper.__index__;
	      result.__values__ = wrapper.__values__;
	      return result;
	    }
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * Creates an array of elements split into groups the length of `size`.
	     * If `array` can't be split evenly, the final chunk will be the remaining
	     * elements.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to process.
	     * @param {number} [size=1] The length of each chunk
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Array} Returns the new array of chunks.
	     * @example
	     *
	     * _.chunk(['a', 'b', 'c', 'd'], 2);
	     * // => [['a', 'b'], ['c', 'd']]
	     *
	     * _.chunk(['a', 'b', 'c', 'd'], 3);
	     * // => [['a', 'b', 'c'], ['d']]
	     */
	    function chunk(array, size, guard) {
	      if ((guard ? isIterateeCall(array, size, guard) : size === undefined)) {
	        size = 1;
	      } else {
	        size = nativeMax(toInteger(size), 0);
	      }
	      var length = array == null ? 0 : array.length;
	      if (!length || size < 1) {
	        return [];
	      }
	      var index = 0,
	          resIndex = 0,
	          result = Array(nativeCeil(length / size));
	
	      while (index < length) {
	        result[resIndex++] = baseSlice(array, index, (index += size));
	      }
	      return result;
	    }
	
	    /**
	     * Creates an array with all falsey values removed. The values `false`, `null`,
	     * `0`, `""`, `undefined`, and `NaN` are falsey.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to compact.
	     * @returns {Array} Returns the new array of filtered values.
	     * @example
	     *
	     * _.compact([0, 1, false, 2, '', 3]);
	     * // => [1, 2, 3]
	     */
	    function compact(array) {
	      var index = -1,
	          length = array == null ? 0 : array.length,
	          resIndex = 0,
	          result = [];
	
	      while (++index < length) {
	        var value = array[index];
	        if (value) {
	          result[resIndex++] = value;
	        }
	      }
	      return result;
	    }
	
	    /**
	     * Creates a new array concatenating `array` with any additional arrays
	     * and/or values.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to concatenate.
	     * @param {...*} [values] The values to concatenate.
	     * @returns {Array} Returns the new concatenated array.
	     * @example
	     *
	     * var array = [1];
	     * var other = _.concat(array, 2, [3], [[4]]);
	     *
	     * console.log(other);
	     * // => [1, 2, 3, [4]]
	     *
	     * console.log(array);
	     * // => [1]
	     */
	    function concat() {
	      var length = arguments.length;
	      if (!length) {
	        return [];
	      }
	      var args = Array(length - 1),
	          array = arguments[0],
	          index = length;
	
	      while (index--) {
	        args[index - 1] = arguments[index];
	      }
	      return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
	    }
	
	    /**
	     * Creates an array of `array` values not included in the other given arrays
	     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * for equality comparisons. The order and references of result values are
	     * determined by the first array.
	     *
	     * **Note:** Unlike `_.pullAll`, this method returns a new array.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {...Array} [values] The values to exclude.
	     * @returns {Array} Returns the new array of filtered values.
	     * @see _.without, _.xor
	     * @example
	     *
	     * _.difference([2, 1], [2, 3]);
	     * // => [1]
	     */
	    var difference = baseRest(function(array, values) {
	      return isArrayLikeObject(array)
	        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))
	        : [];
	    });
	
	    /**
	     * This method is like `_.difference` except that it accepts `iteratee` which
	     * is invoked for each element of `array` and `values` to generate the criterion
	     * by which they're compared. The order and references of result values are
	     * determined by the first array. The iteratee is invoked with one argument:
	     * (value).
	     *
	     * **Note:** Unlike `_.pullAllBy`, this method returns a new array.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {...Array} [values] The values to exclude.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {Array} Returns the new array of filtered values.
	     * @example
	     *
	     * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);
	     * // => [1.2]
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
	     * // => [{ 'x': 2 }]
	     */
	    var differenceBy = baseRest(function(array, values) {
	      var iteratee = last(values);
	      if (isArrayLikeObject(iteratee)) {
	        iteratee = undefined;
	      }
	      return isArrayLikeObject(array)
	        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee, 2))
	        : [];
	    });
	
	    /**
	     * This method is like `_.difference` except that it accepts `comparator`
	     * which is invoked to compare elements of `array` to `values`. The order and
	     * references of result values are determined by the first array. The comparator
	     * is invoked with two arguments: (arrVal, othVal).
	     *
	     * **Note:** Unlike `_.pullAllWith`, this method returns a new array.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {...Array} [values] The values to exclude.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new array of filtered values.
	     * @example
	     *
	     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
	     *
	     * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
	     * // => [{ 'x': 2, 'y': 1 }]
	     */
	    var differenceWith = baseRest(function(array, values) {
	      var comparator = last(values);
	      if (isArrayLikeObject(comparator)) {
	        comparator = undefined;
	      }
	      return isArrayLikeObject(array)
	        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined, comparator)
	        : [];
	    });
	
	    /**
	     * Creates a slice of `array` with `n` elements dropped from the beginning.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.5.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {number} [n=1] The number of elements to drop.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.drop([1, 2, 3]);
	     * // => [2, 3]
	     *
	     * _.drop([1, 2, 3], 2);
	     * // => [3]
	     *
	     * _.drop([1, 2, 3], 5);
	     * // => []
	     *
	     * _.drop([1, 2, 3], 0);
	     * // => [1, 2, 3]
	     */
	    function drop(array, n, guard) {
	      var length = array == null ? 0 : array.length;
	      if (!length) {
	        return [];
	      }
	      n = (guard || n === undefined) ? 1 : toInteger(n);
	      return baseSlice(array, n < 0 ? 0 : n, length);
	    }
	
	    /**
	     * Creates a slice of `array` with `n` elements dropped from the end.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {number} [n=1] The number of elements to drop.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.dropRight([1, 2, 3]);
	     * // => [1, 2]
	     *
	     * _.dropRight([1, 2, 3], 2);
	     * // => [1]
	     *
	     * _.dropRight([1, 2, 3], 5);
	     * // => []
	     *
	     * _.dropRight([1, 2, 3], 0);
	     * // => [1, 2, 3]
	     */
	    function dropRight(array, n, guard) {
	      var length = array == null ? 0 : array.length;
	      if (!length) {
	        return [];
	      }
	      n = (guard || n === undefined) ? 1 : toInteger(n);
	      n = length - n;
	      return baseSlice(array, 0, n < 0 ? 0 : n);
	    }
	
	    /**
	     * Creates a slice of `array` excluding elements dropped from the end.
	     * Elements are dropped until `predicate` returns falsey. The predicate is
	     * invoked with three arguments: (value, index, array).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': true },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': false }
	     * ];
	     *
	     * _.dropRightWhile(users, function(o) { return !o.active; });
	     * // => objects for ['barney']
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });
	     * // => objects for ['barney', 'fred']
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.dropRightWhile(users, ['active', false]);
	     * // => objects for ['barney']
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.dropRightWhile(users, 'active');
	     * // => objects for ['barney', 'fred', 'pebbles']
	     */
	    function dropRightWhile(array, predicate) {
	      return (array && array.length)
	        ? baseWhile(array, getIteratee(predicate, 3), true, true)
	        : [];
	    }
	
	    /**
	     * Creates a slice of `array` excluding elements dropped from the beginning.
	     * Elements are dropped until `predicate` returns falsey. The predicate is
	     * invoked with three arguments: (value, index, array).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': false },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': true }
	     * ];
	     *
	     * _.dropWhile(users, function(o) { return !o.active; });
	     * // => objects for ['pebbles']
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.dropWhile(users, { 'user': 'barney', 'active': false });
	     * // => objects for ['fred', 'pebbles']
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.dropWhile(users, ['active', false]);
	     * // => objects for ['pebbles']
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.dropWhile(users, 'active');
	     * // => objects for ['barney', 'fred', 'pebbles']
	     */
	    function dropWhile(array, predicate) {
	      return (array && array.length)
	        ? baseWhile(array, getIteratee(predicate, 3), true)
	        : [];
	    }
	
	    /**
	     * Fills elements of `array` with `value` from `start` up to, but not
	     * including, `end`.
	     *
	     * **Note:** This method mutates `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.2.0
	     * @category Array
	     * @param {Array} array The array to fill.
	     * @param {*} value The value to fill `array` with.
	     * @param {number} [start=0] The start position.
	     * @param {number} [end=array.length] The end position.
	     * @returns {Array} Returns `array`.
	     * @example
	     *
	     * var array = [1, 2, 3];
	     *
	     * _.fill(array, 'a');
	     * console.log(array);
	     * // => ['a', 'a', 'a']
	     *
	     * _.fill(Array(3), 2);
	     * // => [2, 2, 2]
	     *
	     * _.fill([4, 6, 8, 10], '*', 1, 3);
	     * // => [4, '*', '*', 10]
	     */
	    function fill(array, value, start, end) {
	      var length = array == null ? 0 : array.length;
	      if (!length) {
	        return [];
	      }
	      if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
	        start = 0;
	        end = length;
	      }
	      return baseFill(array, value, start, end);
	    }
	
	    /**
	     * This method is like `_.find` except that it returns the index of the first
	     * element `predicate` returns truthy for instead of the element itself.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.1.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @param {number} [fromIndex=0] The index to search from.
	     * @returns {number} Returns the index of the found element, else `-1`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': false },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': true }
	     * ];
	     *
	     * _.findIndex(users, function(o) { return o.user == 'barney'; });
	     * // => 0
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.findIndex(users, { 'user': 'fred', 'active': false });
	     * // => 1
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.findIndex(users, ['active', false]);
	     * // => 0
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.findIndex(users, 'active');
	     * // => 2
	     */
	    function findIndex(array, predicate, fromIndex) {
	      var length = array == null ? 0 : array.length;
	      if (!length) {
	        return -1;
	      }
	      var index = fromIndex == null ? 0 : toInteger(fromIndex);
	      if (index < 0) {
	        index = nativeMax(length + index, 0);
	      }
	      return baseFindIndex(array, getIteratee(predicate, 3), index);
	    }
	
	    /**
	     * This method is like `_.findIndex` except that it iterates over elements
	     * of `collection` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @param {number} [fromIndex=array.length-1] The index to search from.
	     * @returns {number} Returns the index of the found element, else `-1`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': true },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': false }
	     * ];
	     *
	     * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
	     * // => 2
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.findLastIndex(users, { 'user': 'barney', 'active': true });
	     * // => 0
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.findLastIndex(users, ['active', false]);
	     * // => 2
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.findLastIndex(users, 'active');
	     * // => 0
	     */
	    function findLastIndex(array, predicate, fromIndex) {
	      var length = array == null ? 0 : array.length;
	      if (!length) {
	        return -1;
	      }
	      var index = length - 1;
	      if (fromIndex !== undefined) {
	        index = toInteger(fromIndex);
	        index = fromIndex < 0
	          ? nativeMax(length + index, 0)
	          : nativeMin(index, length - 1);
	      }
	      return baseFindIndex(array, getIteratee(predicate, 3), index, true);
	    }
	
	    /**
	     * Flattens `array` a single level deep.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to flatten.
	     * @returns {Array} Returns the new flattened array.
	     * @example
	     *
	     * _.flatten([1, [2, [3, [4]], 5]]);
	     * // => [1, 2, [3, [4]], 5]
	     */
	    function flatten(array) {
	      var length = array == null ? 0 : array.length;
	      return length ? baseFlatten(array, 1) : [];
	    }
	
	    /**
	     * Recursively flattens `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to flatten.
	     * @returns {Array} Returns the new flattened array.
	     * @example
	     *
	     * _.flattenDeep([1, [2, [3, [4]], 5]]);
	     * // => [1, 2, 3, 4, 5]
	     */
	    function flattenDeep(array) {
	      var length = array == null ? 0 : array.length;
	      return length ? baseFlatten(array, INFINITY) : [];
	    }
	
	    /**
	     * Recursively flatten `array` up to `depth` times.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.4.0
	     * @category Array
	     * @param {Array} array The array to flatten.
	     * @param {number} [depth=1] The maximum recursion depth.
	     * @returns {Array} Returns the new flattened array.
	     * @example
	     *
	     * var array = [1, [2, [3, [4]], 5]];
	     *
	     * _.flattenDepth(array, 1);
	     * // => [1, 2, [3, [4]], 5]
	     *
	     * _.flattenDepth(array, 2);
	     * // => [1, 2, 3, [4], 5]
	     */
	    function flattenDepth(array, depth) {
	      var length = array == null ? 0 : array.length;
	      if (!length) {
	        return [];
	      }
	      depth = depth === undefined ? 1 : toInteger(depth);
	      return baseFlatten(array, depth);
	    }
	
	    /**
	     * The inverse of `_.toPairs`; this method returns an object composed
	     * from key-value `pairs`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} pairs The key-value pairs.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * _.fromPairs([['a', 1], ['b', 2]]);
	     * // => { 'a': 1, 'b': 2 }
	     */
	    function fromPairs(pairs) {
	      var index = -1,
	          length = pairs == null ? 0 : pairs.length,
	          result = {};
	
	      while (++index < length) {
	        var pair = pairs[index];
	        result[pair[0]] = pair[1];
	      }
	      return result;
	    }
	
	    /**
	     * Gets the first element of `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @alias first
	     * @category Array
	     * @param {Array} array The array to query.
	     * @returns {*} Returns the first element of `array`.
	     * @example
	     *
	     * _.head([1, 2, 3]);
	     * // => 1
	     *
	     * _.head([]);
	     * // => undefined
	     */
	    function head(array) {
	      return (array && array.length) ? array[0] : undefined;
	    }
	
	    /**
	     * Gets the index at which the first occurrence of `value` is found in `array`
	     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * for equality comparisons. If `fromIndex` is negative, it's used as the
	     * offset from the end of `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {*} value The value to search for.
	     * @param {number} [fromIndex=0] The index to search from.
	     * @returns {number} Returns the index of the matched value, else `-1`.
	     * @example
	     *
	     * _.indexOf([1, 2, 1, 2], 2);
	     * // => 1
	     *
	     * // Search from the `fromIndex`.
	     * _.indexOf([1, 2, 1, 2], 2, 2);
	     * // => 3
	     */
	    function indexOf(array, value, fromIndex) {
	      var length = array == null ? 0 : array.length;
	      if (!length) {
	        return -1;
	      }
	      var index = fromIndex == null ? 0 : toInteger(fromIndex);
	      if (index < 0) {
	        index = nativeMax(length + index, 0);
	      }
	      return baseIndexOf(array, value, index);
	    }
	
	    /**
	     * Gets all but the last element of `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.initial([1, 2, 3]);
	     * // => [1, 2]
	     */
	    function initial(array) {
	      var length = array == null ? 0 : array.length;
	      return length ? baseSlice(array, 0, -1) : [];
	    }
	
	    /**
	     * Creates an array of unique values that are included in all given arrays
	     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * for equality comparisons. The order and references of result values are
	     * determined by the first array.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @returns {Array} Returns the new array of intersecting values.
	     * @example
	     *
	     * _.intersection([2, 1], [2, 3]);
	     * // => [2]
	     */
	    var intersection = baseRest(function(arrays) {
	      var mapped = arrayMap(arrays, castArrayLikeObject);
	      return (mapped.length && mapped[0] === arrays[0])
	        ? baseIntersection(mapped)
	        : [];
	    });
	
	    /**
	     * This method is like `_.intersection` except that it accepts `iteratee`
	     * which is invoked for each element of each `arrays` to generate the criterion
	     * by which they're compared. The order and references of result values are
	     * determined by the first array. The iteratee is invoked with one argument:
	     * (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {Array} Returns the new array of intersecting values.
	     * @example
	     *
	     * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);
	     * // => [2.1]
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
	     * // => [{ 'x': 1 }]
	     */
	    var intersectionBy = baseRest(function(arrays) {
	      var iteratee = last(arrays),
	          mapped = arrayMap(arrays, castArrayLikeObject);
	
	      if (iteratee === last(mapped)) {
	        iteratee = undefined;
	      } else {
	        mapped.pop();
	      }
	      return (mapped.length && mapped[0] === arrays[0])
	        ? baseIntersection(mapped, getIteratee(iteratee, 2))
	        : [];
	    });
	
	    /**
	     * This method is like `_.intersection` except that it accepts `comparator`
	     * which is invoked to compare elements of `arrays`. The order and references
	     * of result values are determined by the first array. The comparator is
	     * invoked with two arguments: (arrVal, othVal).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new array of intersecting values.
	     * @example
	     *
	     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
	     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
	     *
	     * _.intersectionWith(objects, others, _.isEqual);
	     * // => [{ 'x': 1, 'y': 2 }]
	     */
	    var intersectionWith = baseRest(function(arrays) {
	      var comparator = last(arrays),
	          mapped = arrayMap(arrays, castArrayLikeObject);
	
	      comparator = typeof comparator == 'function' ? comparator : undefined;
	      if (comparator) {
	        mapped.pop();
	      }
	      return (mapped.length && mapped[0] === arrays[0])
	        ? baseIntersection(mapped, undefined, comparator)
	        : [];
	    });
	
	    /**
	     * Converts all elements in `array` into a string separated by `separator`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to convert.
	     * @param {string} [separator=','] The element separator.
	     * @returns {string} Returns the joined string.
	     * @example
	     *
	     * _.join(['a', 'b', 'c'], '~');
	     * // => 'a~b~c'
	     */
	    function join(array, separator) {
	      return array == null ? '' : nativeJoin.call(array, separator);
	    }
	
	    /**
	     * Gets the last element of `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @returns {*} Returns the last element of `array`.
	     * @example
	     *
	     * _.last([1, 2, 3]);
	     * // => 3
	     */
	    function last(array) {
	      var length = array == null ? 0 : array.length;
	      return length ? array[length - 1] : undefined;
	    }
	
	    /**
	     * This method is like `_.indexOf` except that it iterates over elements of
	     * `array` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {*} value The value to search for.
	     * @param {number} [fromIndex=array.length-1] The index to search from.
	     * @returns {number} Returns the index of the matched value, else `-1`.
	     * @example
	     *
	     * _.lastIndexOf([1, 2, 1, 2], 2);
	     * // => 3
	     *
	     * // Search from the `fromIndex`.
	     * _.lastIndexOf([1, 2, 1, 2], 2, 2);
	     * // => 1
	     */
	    function lastIndexOf(array, value, fromIndex) {
	      var length = array == null ? 0 : array.length;
	      if (!length) {
	        return -1;
	      }
	      var index = length;
	      if (fromIndex !== undefined) {
	        index = toInteger(fromIndex);
	        index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
	      }
	      return value === value
	        ? strictLastIndexOf(array, value, index)
	        : baseFindIndex(array, baseIsNaN, index, true);
	    }
	
	    /**
	     * Gets the element at index `n` of `array`. If `n` is negative, the nth
	     * element from the end is returned.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.11.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {number} [n=0] The index of the element to return.
	     * @returns {*} Returns the nth element of `array`.
	     * @example
	     *
	     * var array = ['a', 'b', 'c', 'd'];
	     *
	     * _.nth(array, 1);
	     * // => 'b'
	     *
	     * _.nth(array, -2);
	     * // => 'c';
	     */
	    function nth(array, n) {
	      return (array && array.length) ? baseNth(array, toInteger(n)) : undefined;
	    }
	
	    /**
	     * Removes all given values from `array` using
	     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * for equality comparisons.
	     *
	     * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`
	     * to remove elements from an array by predicate.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {...*} [values] The values to remove.
	     * @returns {Array} Returns `array`.
	     * @example
	     *
	     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
	     *
	     * _.pull(array, 'a', 'c');
	     * console.log(array);
	     * // => ['b', 'b']
	     */
	    var pull = baseRest(pullAll);
	
	    /**
	     * This method is like `_.pull` except that it accepts an array of values to remove.
	     *
	     * **Note:** Unlike `_.difference`, this method mutates `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {Array} values The values to remove.
	     * @returns {Array} Returns `array`.
	     * @example
	     *
	     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
	     *
	     * _.pullAll(array, ['a', 'c']);
	     * console.log(array);
	     * // => ['b', 'b']
	     */
	    function pullAll(array, values) {
	      return (array && array.length && values && values.length)
	        ? basePullAll(array, values)
	        : array;
	    }
	
	    /**
	     * This method is like `_.pullAll` except that it accepts `iteratee` which is
	     * invoked for each element of `array` and `values` to generate the criterion
	     * by which they're compared. The iteratee is invoked with one argument: (value).
	     *
	     * **Note:** Unlike `_.differenceBy`, this method mutates `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {Array} values The values to remove.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {Array} Returns `array`.
	     * @example
	     *
	     * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];
	     *
	     * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');
	     * console.log(array);
	     * // => [{ 'x': 2 }]
	     */
	    function pullAllBy(array, values, iteratee) {
	      return (array && array.length && values && values.length)
	        ? basePullAll(array, values, getIteratee(iteratee, 2))
	        : array;
	    }
	
	    /**
	     * This method is like `_.pullAll` except that it accepts `comparator` which
	     * is invoked to compare elements of `array` to `values`. The comparator is
	     * invoked with two arguments: (arrVal, othVal).
	     *
	     * **Note:** Unlike `_.differenceWith`, this method mutates `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.6.0
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {Array} values The values to remove.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns `array`.
	     * @example
	     *
	     * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];
	     *
	     * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);
	     * console.log(array);
	     * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]
	     */
	    function pullAllWith(array, values, comparator) {
	      return (array && array.length && values && values.length)
	        ? basePullAll(array, values, undefined, comparator)
	        : array;
	    }
	
	    /**
	     * Removes elements from `array` corresponding to `indexes` and returns an
	     * array of removed elements.
	     *
	     * **Note:** Unlike `_.at`, this method mutates `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {...(number|number[])} [indexes] The indexes of elements to remove.
	     * @returns {Array} Returns the new array of removed elements.
	     * @example
	     *
	     * var array = ['a', 'b', 'c', 'd'];
	     * var pulled = _.pullAt(array, [1, 3]);
	     *
	     * console.log(array);
	     * // => ['a', 'c']
	     *
	     * console.log(pulled);
	     * // => ['b', 'd']
	     */
	    var pullAt = flatRest(function(array, indexes) {
	      var length = array == null ? 0 : array.length,
	          result = baseAt(array, indexes);
	
	      basePullAt(array, arrayMap(indexes, function(index) {
	        return isIndex(index, length) ? +index : index;
	      }).sort(compareAscending));
	
	      return result;
	    });
	
	    /**
	     * Removes all elements from `array` that `predicate` returns truthy for
	     * and returns an array of the removed elements. The predicate is invoked
	     * with three arguments: (value, index, array).
	     *
	     * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
	     * to pull elements from an array by value.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the new array of removed elements.
	     * @example
	     *
	     * var array = [1, 2, 3, 4];
	     * var evens = _.remove(array, function(n) {
	     *   return n % 2 == 0;
	     * });
	     *
	     * console.log(array);
	     * // => [1, 3]
	     *
	     * console.log(evens);
	     * // => [2, 4]
	     */
	    function remove(array, predicate) {
	      var result = [];
	      if (!(array && array.length)) {
	        return result;
	      }
	      var index = -1,
	          indexes = [],
	          length = array.length;
	
	      predicate = getIteratee(predicate, 3);
	      while (++index < length) {
	        var value = array[index];
	        if (predicate(value, index, array)) {
	          result.push(value);
	          indexes.push(index);
	        }
	      }
	      basePullAt(array, indexes);
	      return result;
	    }
	
	    /**
	     * Reverses `array` so that the first element becomes the last, the second
	     * element becomes the second to last, and so on.
	     *
	     * **Note:** This method mutates `array` and is based on
	     * [`Array#reverse`](https://mdn.io/Array/reverse).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @returns {Array} Returns `array`.
	     * @example
	     *
	     * var array = [1, 2, 3];
	     *
	     * _.reverse(array);
	     * // => [3, 2, 1]
	     *
	     * console.log(array);
	     * // => [3, 2, 1]
	     */
	    function reverse(array) {
	      return array == null ? array : nativeReverse.call(array);
	    }
	
	    /**
	     * Creates a slice of `array` from `start` up to, but not including, `end`.
	     *
	     * **Note:** This method is used instead of
	     * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are
	     * returned.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to slice.
	     * @param {number} [start=0] The start position.
	     * @param {number} [end=array.length] The end position.
	     * @returns {Array} Returns the slice of `array`.
	     */
	    function slice(array, start, end) {
	      var length = array == null ? 0 : array.length;
	      if (!length) {
	        return [];
	      }
	      if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
	        start = 0;
	        end = length;
	      }
	      else {
	        start = start == null ? 0 : toInteger(start);
	        end = end === undefined ? length : toInteger(end);
	      }
	      return baseSlice(array, start, end);
	    }
	
	    /**
	     * Uses a binary search to determine the lowest index at which `value`
	     * should be inserted into `array` in order to maintain its sort order.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     * @example
	     *
	     * _.sortedIndex([30, 50], 40);
	     * // => 1
	     */
	    function sortedIndex(array, value) {
	      return baseSortedIndex(array, value);
	    }
	
	    /**
	     * This method is like `_.sortedIndex` except that it accepts `iteratee`
	     * which is invoked for `value` and each element of `array` to compute their
	     * sort ranking. The iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     * @example
	     *
	     * var objects = [{ 'x': 4 }, { 'x': 5 }];
	     *
	     * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
	     * // => 0
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.sortedIndexBy(objects, { 'x': 4 }, 'x');
	     * // => 0
	     */
	    function sortedIndexBy(array, value, iteratee) {
	      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2));
	    }
	
	    /**
	     * This method is like `_.indexOf` except that it performs a binary
	     * search on a sorted `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {*} value The value to search for.
	     * @returns {number} Returns the index of the matched value, else `-1`.
	     * @example
	     *
	     * _.sortedIndexOf([4, 5, 5, 5, 6], 5);
	     * // => 1
	     */
	    function sortedIndexOf(array, value) {
	      var length = array == null ? 0 : array.length;
	      if (length) {
	        var index = baseSortedIndex(array, value);
	        if (index < length && eq(array[index], value)) {
	          return index;
	        }
	      }
	      return -1;
	    }
	
	    /**
	     * This method is like `_.sortedIndex` except that it returns the highest
	     * index at which `value` should be inserted into `array` in order to
	     * maintain its sort order.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     * @example
	     *
	     * _.sortedLastIndex([4, 5, 5, 5, 6], 5);
	     * // => 4
	     */
	    function sortedLastIndex(array, value) {
	      return baseSortedIndex(array, value, true);
	    }
	
	    /**
	     * This method is like `_.sortedLastIndex` except that it accepts `iteratee`
	     * which is invoked for `value` and each element of `array` to compute their
	     * sort ranking. The iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     * @example
	     *
	     * var objects = [{ 'x': 4 }, { 'x': 5 }];
	     *
	     * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
	     * // => 1
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');
	     * // => 1
	     */
	    function sortedLastIndexBy(array, value, iteratee) {
	      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2), true);
	    }
	
	    /**
	     * This method is like `_.lastIndexOf` except that it performs a binary
	     * search on a sorted `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {*} value The value to search for.
	     * @returns {number} Returns the index of the matched value, else `-1`.
	     * @example
	     *
	     * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);
	     * // => 3
	     */
	    function sortedLastIndexOf(array, value) {
	      var length = array == null ? 0 : array.length;
	      if (length) {
	        var index = baseSortedIndex(array, value, true) - 1;
	        if (eq(array[index], value)) {
	          return index;
	        }
	      }
	      return -1;
	    }
	
	    /**
	     * This method is like `_.uniq` except that it's designed and optimized
	     * for sorted arrays.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @returns {Array} Returns the new duplicate free array.
	     * @example
	     *
	     * _.sortedUniq([1, 1, 2]);
	     * // => [1, 2]
	     */
	    function sortedUniq(array) {
	      return (array && array.length)
	        ? baseSortedUniq(array)
	        : [];
	    }
	
	    /**
	     * This method is like `_.uniqBy` except that it's designed and optimized
	     * for sorted arrays.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {Function} [iteratee] The iteratee invoked per element.
	     * @returns {Array} Returns the new duplicate free array.
	     * @example
	     *
	     * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);
	     * // => [1.1, 2.3]
	     */
	    function sortedUniqBy(array, iteratee) {
	      return (array && array.length)
	        ? baseSortedUniq(array, getIteratee(iteratee, 2))
	        : [];
	    }
	
	    /**
	     * Gets all but the first element of `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.tail([1, 2, 3]);
	     * // => [2, 3]
	     */
	    function tail(array) {
	      var length = array == null ? 0 : array.length;
	      return length ? baseSlice(array, 1, length) : [];
	    }
	
	    /**
	     * Creates a slice of `array` with `n` elements taken from the beginning.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {number} [n=1] The number of elements to take.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.take([1, 2, 3]);
	     * // => [1]
	     *
	     * _.take([1, 2, 3], 2);
	     * // => [1, 2]
	     *
	     * _.take([1, 2, 3], 5);
	     * // => [1, 2, 3]
	     *
	     * _.take([1, 2, 3], 0);
	     * // => []
	     */
	    function take(array, n, guard) {
	      if (!(array && array.length)) {
	        return [];
	      }
	      n = (guard || n === undefined) ? 1 : toInteger(n);
	      return baseSlice(array, 0, n < 0 ? 0 : n);
	    }
	
	    /**
	     * Creates a slice of `array` with `n` elements taken from the end.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {number} [n=1] The number of elements to take.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.takeRight([1, 2, 3]);
	     * // => [3]
	     *
	     * _.takeRight([1, 2, 3], 2);
	     * // => [2, 3]
	     *
	     * _.takeRight([1, 2, 3], 5);
	     * // => [1, 2, 3]
	     *
	     * _.takeRight([1, 2, 3], 0);
	     * // => []
	     */
	    function takeRight(array, n, guard) {
	      var length = array == null ? 0 : array.length;
	      if (!length) {
	        return [];
	      }
	      n = (guard || n === undefined) ? 1 : toInteger(n);
	      n = length - n;
	      return baseSlice(array, n < 0 ? 0 : n, length);
	    }
	
	    /**
	     * Creates a slice of `array` with elements taken from the end. Elements are
	     * taken until `predicate` returns falsey. The predicate is invoked with
	     * three arguments: (value, index, array).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': true },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': false }
	     * ];
	     *
	     * _.takeRightWhile(users, function(o) { return !o.active; });
	     * // => objects for ['fred', 'pebbles']
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });
	     * // => objects for ['pebbles']
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.takeRightWhile(users, ['active', false]);
	     * // => objects for ['fred', 'pebbles']
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.takeRightWhile(users, 'active');
	     * // => []
	     */
	    function takeRightWhile(array, predicate) {
	      return (array && array.length)
	        ? baseWhile(array, getIteratee(predicate, 3), false, true)
	        : [];
	    }
	
	    /**
	     * Creates a slice of `array` with elements taken from the beginning. Elements
	     * are taken until `predicate` returns falsey. The predicate is invoked with
	     * three arguments: (value, index, array).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': false },
	     *   { 'user': 'fred',    'active': false},
	     *   { 'user': 'pebbles', 'active': true }
	     * ];
	     *
	     * _.takeWhile(users, function(o) { return !o.active; });
	     * // => objects for ['barney', 'fred']
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.takeWhile(users, { 'user': 'barney', 'active': false });
	     * // => objects for ['barney']
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.takeWhile(users, ['active', false]);
	     * // => objects for ['barney', 'fred']
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.takeWhile(users, 'active');
	     * // => []
	     */
	    function takeWhile(array, predicate) {
	      return (array && array.length)
	        ? baseWhile(array, getIteratee(predicate, 3))
	        : [];
	    }
	
	    /**
	     * Creates an array of unique values, in order, from all given arrays using
	     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * for equality comparisons.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @returns {Array} Returns the new array of combined values.
	     * @example
	     *
	     * _.union([2], [1, 2]);
	     * // => [2, 1]
	     */
	    var union = baseRest(function(arrays) {
	      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
	    });
	
	    /**
	     * This method is like `_.union` except that it accepts `iteratee` which is
	     * invoked for each element of each `arrays` to generate the criterion by
	     * which uniqueness is computed. Result values are chosen from the first
	     * array in which the value occurs. The iteratee is invoked with one argument:
	     * (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {Array} Returns the new array of combined values.
	     * @example
	     *
	     * _.unionBy([2.1], [1.2, 2.3], Math.floor);
	     * // => [2.1, 1.2]
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
	     * // => [{ 'x': 1 }, { 'x': 2 }]
	     */
	    var unionBy = baseRest(function(arrays) {
	      var iteratee = last(arrays);
	      if (isArrayLikeObject(iteratee)) {
	        iteratee = undefined;
	      }
	      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee, 2));
	    });
	
	    /**
	     * This method is like `_.union` except that it accepts `comparator` which
	     * is invoked to compare elements of `arrays`. Result values are chosen from
	     * the first array in which the value occurs. The comparator is invoked
	     * with two arguments: (arrVal, othVal).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new array of combined values.
	     * @example
	     *
	     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
	     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
	     *
	     * _.unionWith(objects, others, _.isEqual);
	     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
	     */
	    var unionWith = baseRest(function(arrays) {
	      var comparator = last(arrays);
	      comparator = typeof comparator == 'function' ? comparator : undefined;
	      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined, comparator);
	    });
	
	    /**
	     * Creates a duplicate-free version of an array, using
	     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * for equality comparisons, in which only the first occurrence of each element
	     * is kept. The order of result values is determined by the order they occur
	     * in the array.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @returns {Array} Returns the new duplicate free array.
	     * @example
	     *
	     * _.uniq([2, 1, 2]);
	     * // => [2, 1]
	     */
	    function uniq(array) {
	      return (array && array.length) ? baseUniq(array) : [];
	    }
	
	    /**
	     * This method is like `_.uniq` except that it accepts `iteratee` which is
	     * invoked for each element in `array` to generate the criterion by which
	     * uniqueness is computed. The order of result values is determined by the
	     * order they occur in the array. The iteratee is invoked with one argument:
	     * (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {Array} Returns the new duplicate free array.
	     * @example
	     *
	     * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
	     * // => [2.1, 1.2]
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
	     * // => [{ 'x': 1 }, { 'x': 2 }]
	     */
	    function uniqBy(array, iteratee) {
	      return (array && array.length) ? baseUniq(array, getIteratee(iteratee, 2)) : [];
	    }
	
	    /**
	     * This method is like `_.uniq` except that it accepts `comparator` which
	     * is invoked to compare elements of `array`. The order of result values is
	     * determined by the order they occur in the array.The comparator is invoked
	     * with two arguments: (arrVal, othVal).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new duplicate free array.
	     * @example
	     *
	     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];
	     *
	     * _.uniqWith(objects, _.isEqual);
	     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
	     */
	    function uniqWith(array, comparator) {
	      comparator = typeof comparator == 'function' ? comparator : undefined;
	      return (array && array.length) ? baseUniq(array, undefined, comparator) : [];
	    }
	
	    /**
	     * This method is like `_.zip` except that it accepts an array of grouped
	     * elements and creates an array regrouping the elements to their pre-zip
	     * configuration.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.2.0
	     * @category Array
	     * @param {Array} array The array of grouped elements to process.
	     * @returns {Array} Returns the new array of regrouped elements.
	     * @example
	     *
	     * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);
	     * // => [['a', 1, true], ['b', 2, false]]
	     *
	     * _.unzip(zipped);
	     * // => [['a', 'b'], [1, 2], [true, false]]
	     */
	    function unzip(array) {
	      if (!(array && array.length)) {
	        return [];
	      }
	      var length = 0;
	      array = arrayFilter(array, function(group) {
	        if (isArrayLikeObject(group)) {
	          length = nativeMax(group.length, length);
	          return true;
	        }
	      });
	      return baseTimes(length, function(index) {
	        return arrayMap(array, baseProperty(index));
	      });
	    }
	
	    /**
	     * This method is like `_.unzip` except that it accepts `iteratee` to specify
	     * how regrouped values should be combined. The iteratee is invoked with the
	     * elements of each group: (...group).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.8.0
	     * @category Array
	     * @param {Array} array The array of grouped elements to process.
	     * @param {Function} [iteratee=_.identity] The function to combine
	     *  regrouped values.
	     * @returns {Array} Returns the new array of regrouped elements.
	     * @example
	     *
	     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
	     * // => [[1, 10, 100], [2, 20, 200]]
	     *
	     * _.unzipWith(zipped, _.add);
	     * // => [3, 30, 300]
	     */
	    function unzipWith(array, iteratee) {
	      if (!(array && array.length)) {
	        return [];
	      }
	      var result = unzip(array);
	      if (iteratee == null) {
	        return result;
	      }
	      return arrayMap(result, function(group) {
	        return apply(iteratee, undefined, group);
	      });
	    }
	
	    /**
	     * Creates an array excluding all given values using
	     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * for equality comparisons.
	     *
	     * **Note:** Unlike `_.pull`, this method returns a new array.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {...*} [values] The values to exclude.
	     * @returns {Array} Returns the new array of filtered values.
	     * @see _.difference, _.xor
	     * @example
	     *
	     * _.without([2, 1, 2, 3], 1, 2);
	     * // => [3]
	     */
	    var without = baseRest(function(array, values) {
	      return isArrayLikeObject(array)
	        ? baseDifference(array, values)
	        : [];
	    });
	
	    /**
	     * Creates an array of unique values that is the
	     * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
	     * of the given arrays. The order of result values is determined by the order
	     * they occur in the arrays.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.4.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @returns {Array} Returns the new array of filtered values.
	     * @see _.difference, _.without
	     * @example
	     *
	     * _.xor([2, 1], [2, 3]);
	     * // => [1, 3]
	     */
	    var xor = baseRest(function(arrays) {
	      return baseXor(arrayFilter(arrays, isArrayLikeObject));
	    });
	
	    /**
	     * This method is like `_.xor` except that it accepts `iteratee` which is
	     * invoked for each element of each `arrays` to generate the criterion by
	     * which by which they're compared. The order of result values is determined
	     * by the order they occur in the arrays. The iteratee is invoked with one
	     * argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {Array} Returns the new array of filtered values.
	     * @example
	     *
	     * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);
	     * // => [1.2, 3.4]
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
	     * // => [{ 'x': 2 }]
	     */
	    var xorBy = baseRest(function(arrays) {
	      var iteratee = last(arrays);
	      if (isArrayLikeObject(iteratee)) {
	        iteratee = undefined;
	      }
	      return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2));
	    });
	
	    /**
	     * This method is like `_.xor` except that it accepts `comparator` which is
	     * invoked to compare elements of `arrays`. The order of result values is
	     * determined by the order they occur in the arrays. The comparator is invoked
	     * with two arguments: (arrVal, othVal).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new array of filtered values.
	     * @example
	     *
	     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
	     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
	     *
	     * _.xorWith(objects, others, _.isEqual);
	     * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
	     */
	    var xorWith = baseRest(function(arrays) {
	      var comparator = last(arrays);
	      comparator = typeof comparator == 'function' ? comparator : undefined;
	      return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator);
	    });
	
	    /**
	     * Creates an array of grouped elements, the first of which contains the
	     * first elements of the given arrays, the second of which contains the
	     * second elements of the given arrays, and so on.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to process.
	     * @returns {Array} Returns the new array of grouped elements.
	     * @example
	     *
	     * _.zip(['a', 'b'], [1, 2], [true, false]);
	     * // => [['a', 1, true], ['b', 2, false]]
	     */
	    var zip = baseRest(unzip);
	
	    /**
	     * This method is like `_.fromPairs` except that it accepts two arrays,
	     * one of property identifiers and one of corresponding values.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.4.0
	     * @category Array
	     * @param {Array} [props=[]] The property identifiers.
	     * @param {Array} [values=[]] The property values.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * _.zipObject(['a', 'b'], [1, 2]);
	     * // => { 'a': 1, 'b': 2 }
	     */
	    function zipObject(props, values) {
	      return baseZipObject(props || [], values || [], assignValue);
	    }
	
	    /**
	     * This method is like `_.zipObject` except that it supports property paths.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.1.0
	     * @category Array
	     * @param {Array} [props=[]] The property identifiers.
	     * @param {Array} [values=[]] The property values.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);
	     * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }
	     */
	    function zipObjectDeep(props, values) {
	      return baseZipObject(props || [], values || [], baseSet);
	    }
	
	    /**
	     * This method is like `_.zip` except that it accepts `iteratee` to specify
	     * how grouped values should be combined. The iteratee is invoked with the
	     * elements of each group: (...group).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.8.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to process.
	     * @param {Function} [iteratee=_.identity] The function to combine
	     *  grouped values.
	     * @returns {Array} Returns the new array of grouped elements.
	     * @example
	     *
	     * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {
	     *   return a + b + c;
	     * });
	     * // => [111, 222]
	     */
	    var zipWith = baseRest(function(arrays) {
	      var length = arrays.length,
	          iteratee = length > 1 ? arrays[length - 1] : undefined;
	
	      iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined;
	      return unzipWith(arrays, iteratee);
	    });
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * Creates a `lodash` wrapper instance that wraps `value` with explicit method
	     * chain sequences enabled. The result of such sequences must be unwrapped
	     * with `_#value`.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.3.0
	     * @category Seq
	     * @param {*} value The value to wrap.
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'age': 36 },
	     *   { 'user': 'fred',    'age': 40 },
	     *   { 'user': 'pebbles', 'age': 1 }
	     * ];
	     *
	     * var youngest = _
	     *   .chain(users)
	     *   .sortBy('age')
	     *   .map(function(o) {
	     *     return o.user + ' is ' + o.age;
	     *   })
	     *   .head()
	     *   .value();
	     * // => 'pebbles is 1'
	     */
	    function chain(value) {
	      var result = lodash(value);
	      result.__chain__ = true;
	      return result;
	    }
	
	    /**
	     * This method invokes `interceptor` and returns `value`. The interceptor
	     * is invoked with one argument; (value). The purpose of this method is to
	     * "tap into" a method chain sequence in order to modify intermediate results.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Seq
	     * @param {*} value The value to provide to `interceptor`.
	     * @param {Function} interceptor The function to invoke.
	     * @returns {*} Returns `value`.
	     * @example
	     *
	     * _([1, 2, 3])
	     *  .tap(function(array) {
	     *    // Mutate input array.
	     *    array.pop();
	     *  })
	     *  .reverse()
	     *  .value();
	     * // => [2, 1]
	     */
	    function tap(value, interceptor) {
	      interceptor(value);
	      return value;
	    }
	
	    /**
	     * This method is like `_.tap` except that it returns the result of `interceptor`.
	     * The purpose of this method is to "pass thru" values replacing intermediate
	     * results in a method chain sequence.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Seq
	     * @param {*} value The value to provide to `interceptor`.
	     * @param {Function} interceptor The function to invoke.
	     * @returns {*} Returns the result of `interceptor`.
	     * @example
	     *
	     * _('  abc  ')
	     *  .chain()
	     *  .trim()
	     *  .thru(function(value) {
	     *    return [value];
	     *  })
	     *  .value();
	     * // => ['abc']
	     */
	    function thru(value, interceptor) {
	      return interceptor(value);
	    }
	
	    /**
	     * This method is the wrapper version of `_.at`.
	     *
	     * @name at
	     * @memberOf _
	     * @since 1.0.0
	     * @category Seq
	     * @param {...(string|string[])} [paths] The property paths to pick.
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
	     *
	     * _(object).at(['a[0].b.c', 'a[1]']).value();
	     * // => [3, 4]
	     */
	    var wrapperAt = flatRest(function(paths) {
	      var length = paths.length,
	          start = length ? paths[0] : 0,
	          value = this.__wrapped__,
	          interceptor = function(object) { return baseAt(object, paths); };
	
	      if (length > 1 || this.__actions__.length ||
	          !(value instanceof LazyWrapper) || !isIndex(start)) {
	        return this.thru(interceptor);
	      }
	      value = value.slice(start, +start + (length ? 1 : 0));
	      value.__actions__.push({
	        'func': thru,
	        'args': [interceptor],
	        'thisArg': undefined
	      });
	      return new LodashWrapper(value, this.__chain__).thru(function(array) {
	        if (length && !array.length) {
	          array.push(undefined);
	        }
	        return array;
	      });
	    });
	
	    /**
	     * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.
	     *
	     * @name chain
	     * @memberOf _
	     * @since 0.1.0
	     * @category Seq
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36 },
	     *   { 'user': 'fred',   'age': 40 }
	     * ];
	     *
	     * // A sequence without explicit chaining.
	     * _(users).head();
	     * // => { 'user': 'barney', 'age': 36 }
	     *
	     * // A sequence with explicit chaining.
	     * _(users)
	     *   .chain()
	     *   .head()
	     *   .pick('user')
	     *   .value();
	     * // => { 'user': 'barney' }
	     */
	    function wrapperChain() {
	      return chain(this);
	    }
	
	    /**
	     * Executes the chain sequence and returns the wrapped result.
	     *
	     * @name commit
	     * @memberOf _
	     * @since 3.2.0
	     * @category Seq
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var array = [1, 2];
	     * var wrapped = _(array).push(3);
	     *
	     * console.log(array);
	     * // => [1, 2]
	     *
	     * wrapped = wrapped.commit();
	     * console.log(array);
	     * // => [1, 2, 3]
	     *
	     * wrapped.last();
	     * // => 3
	     *
	     * console.log(array);
	     * // => [1, 2, 3]
	     */
	    function wrapperCommit() {
	      return new LodashWrapper(this.value(), this.__chain__);
	    }
	
	    /**
	     * Gets the next value on a wrapped object following the
	     * [iterator protocol](https://mdn.io/iteration_protocols#iterator).
	     *
	     * @name next
	     * @memberOf _
	     * @since 4.0.0
	     * @category Seq
	     * @returns {Object} Returns the next iterator value.
	     * @example
	     *
	     * var wrapped = _([1, 2]);
	     *
	     * wrapped.next();
	     * // => { 'done': false, 'value': 1 }
	     *
	     * wrapped.next();
	     * // => { 'done': false, 'value': 2 }
	     *
	     * wrapped.next();
	     * // => { 'done': true, 'value': undefined }
	     */
	    function wrapperNext() {
	      if (this.__values__ === undefined) {
	        this.__values__ = toArray(this.value());
	      }
	      var done = this.__index__ >= this.__values__.length,
	          value = done ? undefined : this.__values__[this.__index__++];
	
	      return { 'done': done, 'value': value };
	    }
	
	    /**
	     * Enables the wrapper to be iterable.
	     *
	     * @name Symbol.iterator
	     * @memberOf _
	     * @since 4.0.0
	     * @category Seq
	     * @returns {Object} Returns the wrapper object.
	     * @example
	     *
	     * var wrapped = _([1, 2]);
	     *
	     * wrapped[Symbol.iterator]() === wrapped;
	     * // => true
	     *
	     * Array.from(wrapped);
	     * // => [1, 2]
	     */
	    function wrapperToIterator() {
	      return this;
	    }
	
	    /**
	     * Creates a clone of the chain sequence planting `value` as the wrapped value.
	     *
	     * @name plant
	     * @memberOf _
	     * @since 3.2.0
	     * @category Seq
	     * @param {*} value The value to plant.
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * function square(n) {
	     *   return n * n;
	     * }
	     *
	     * var wrapped = _([1, 2]).map(square);
	     * var other = wrapped.plant([3, 4]);
	     *
	     * other.value();
	     * // => [9, 16]
	     *
	     * wrapped.value();
	     * // => [1, 4]
	     */
	    function wrapperPlant(value) {
	      var result,
	          parent = this;
	
	      while (parent instanceof baseLodash) {
	        var clone = wrapperClone(parent);
	        clone.__index__ = 0;
	        clone.__values__ = undefined;
	        if (result) {
	          previous.__wrapped__ = clone;
	        } else {
	          result = clone;
	        }
	        var previous = clone;
	        parent = parent.__wrapped__;
	      }
	      previous.__wrapped__ = value;
	      return result;
	    }
	
	    /**
	     * This method is the wrapper version of `_.reverse`.
	     *
	     * **Note:** This method mutates the wrapped array.
	     *
	     * @name reverse
	     * @memberOf _
	     * @since 0.1.0
	     * @category Seq
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var array = [1, 2, 3];
	     *
	     * _(array).reverse().value()
	     * // => [3, 2, 1]
	     *
	     * console.log(array);
	     * // => [3, 2, 1]
	     */
	    function wrapperReverse() {
	      var value = this.__wrapped__;
	      if (value instanceof LazyWrapper) {
	        var wrapped = value;
	        if (this.__actions__.length) {
	          wrapped = new LazyWrapper(this);
	        }
	        wrapped = wrapped.reverse();
	        wrapped.__actions__.push({
	          'func': thru,
	          'args': [reverse],
	          'thisArg': undefined
	        });
	        return new LodashWrapper(wrapped, this.__chain__);
	      }
	      return this.thru(reverse);
	    }
	
	    /**
	     * Executes the chain sequence to resolve the unwrapped value.
	     *
	     * @name value
	     * @memberOf _
	     * @since 0.1.0
	     * @alias toJSON, valueOf
	     * @category Seq
	     * @returns {*} Returns the resolved unwrapped value.
	     * @example
	     *
	     * _([1, 2, 3]).value();
	     * // => [1, 2, 3]
	     */
	    function wrapperValue() {
	      return baseWrapperValue(this.__wrapped__, this.__actions__);
	    }
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * Creates an object composed of keys generated from the results of running
	     * each element of `collection` thru `iteratee`. The corresponding value of
	     * each key is the number of times the key was returned by `iteratee`. The
	     * iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.5.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
	     * @returns {Object} Returns the composed aggregate object.
	     * @example
	     *
	     * _.countBy([6.1, 4.2, 6.3], Math.floor);
	     * // => { '4': 1, '6': 2 }
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.countBy(['one', 'two', 'three'], 'length');
	     * // => { '3': 2, '5': 1 }
	     */
	    var countBy = createAggregator(function(result, value, key) {
	      if (hasOwnProperty.call(result, key)) {
	        ++result[key];
	      } else {
	        baseAssignValue(result, key, 1);
	      }
	    });
	
	    /**
	     * Checks if `predicate` returns truthy for **all** elements of `collection`.
	     * Iteration is stopped once `predicate` returns falsey. The predicate is
	     * invoked with three arguments: (value, index|key, collection).
	     *
	     * **Note:** This method returns `true` for
	     * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because
	     * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of
	     * elements of empty collections.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {boolean} Returns `true` if all elements pass the predicate check,
	     *  else `false`.
	     * @example
	     *
	     * _.every([true, 1, null, 'yes'], Boolean);
	     * // => false
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36, 'active': false },
	     *   { 'user': 'fred',   'age': 40, 'active': false }
	     * ];
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.every(users, { 'user': 'barney', 'active': false });
	     * // => false
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.every(users, ['active', false]);
	     * // => true
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.every(users, 'active');
	     * // => false
	     */
	    function every(collection, predicate, guard) {
	      var func = isArray(collection) ? arrayEvery : baseEvery;
	      if (guard && isIterateeCall(collection, predicate, guard)) {
	        predicate = undefined;
	      }
	      return func(collection, getIteratee(predicate, 3));
	    }
	
	    /**
	     * Iterates over elements of `collection`, returning an array of all elements
	     * `predicate` returns truthy for. The predicate is invoked with three
	     * arguments: (value, index|key, collection).
	     *
	     * **Note:** Unlike `_.remove`, this method returns a new array.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the new filtered array.
	     * @see _.reject
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36, 'active': true },
	     *   { 'user': 'fred',   'age': 40, 'active': false }
	     * ];
	     *
	     * _.filter(users, function(o) { return !o.active; });
	     * // => objects for ['fred']
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.filter(users, { 'age': 36, 'active': true });
	     * // => objects for ['barney']
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.filter(users, ['active', false]);
	     * // => objects for ['fred']
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.filter(users, 'active');
	     * // => objects for ['barney']
	     */
	    function filter(collection, predicate) {
	      var func = isArray(collection) ? arrayFilter : baseFilter;
	      return func(collection, getIteratee(predicate, 3));
	    }
	
	    /**
	     * Iterates over elements of `collection`, returning the first element
	     * `predicate` returns truthy for. The predicate is invoked with three
	     * arguments: (value, index|key, collection).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to inspect.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @param {number} [fromIndex=0] The index to search from.
	     * @returns {*} Returns the matched element, else `undefined`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'age': 36, 'active': true },
	     *   { 'user': 'fred',    'age': 40, 'active': false },
	     *   { 'user': 'pebbles', 'age': 1,  'active': true }
	     * ];
	     *
	     * _.find(users, function(o) { return o.age < 40; });
	     * // => object for 'barney'
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.find(users, { 'age': 1, 'active': true });
	     * // => object for 'pebbles'
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.find(users, ['active', false]);
	     * // => object for 'fred'
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.find(users, 'active');
	     * // => object for 'barney'
	     */
	    var find = createFind(findIndex);
	
	    /**
	     * This method is like `_.find` except that it iterates over elements of
	     * `collection` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to inspect.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @param {number} [fromIndex=collection.length-1] The index to search from.
	     * @returns {*} Returns the matched element, else `undefined`.
	     * @example
	     *
	     * _.findLast([1, 2, 3, 4], function(n) {
	     *   return n % 2 == 1;
	     * });
	     * // => 3
	     */
	    var findLast = createFind(findLastIndex);
	
	    /**
	     * Creates a flattened array of values by running each element in `collection`
	     * thru `iteratee` and flattening the mapped results. The iteratee is invoked
	     * with three arguments: (value, index|key, collection).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the new flattened array.
	     * @example
	     *
	     * function duplicate(n) {
	     *   return [n, n];
	     * }
	     *
	     * _.flatMap([1, 2], duplicate);
	     * // => [1, 1, 2, 2]
	     */
	    function flatMap(collection, iteratee) {
	      return baseFlatten(map(collection, iteratee), 1);
	    }
	
	    /**
	     * This method is like `_.flatMap` except that it recursively flattens the
	     * mapped results.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.7.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the new flattened array.
	     * @example
	     *
	     * function duplicate(n) {
	     *   return [[[n, n]]];
	     * }
	     *
	     * _.flatMapDeep([1, 2], duplicate);
	     * // => [1, 1, 2, 2]
	     */
	    function flatMapDeep(collection, iteratee) {
	      return baseFlatten(map(collection, iteratee), INFINITY);
	    }
	
	    /**
	     * This method is like `_.flatMap` except that it recursively flattens the
	     * mapped results up to `depth` times.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.7.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {number} [depth=1] The maximum recursion depth.
	     * @returns {Array} Returns the new flattened array.
	     * @example
	     *
	     * function duplicate(n) {
	     *   return [[[n, n]]];
	     * }
	     *
	     * _.flatMapDepth([1, 2], duplicate, 2);
	     * // => [[1, 1], [2, 2]]
	     */
	    function flatMapDepth(collection, iteratee, depth) {
	      depth = depth === undefined ? 1 : toInteger(depth);
	      return baseFlatten(map(collection, iteratee), depth);
	    }
	
	    /**
	     * Iterates over elements of `collection` and invokes `iteratee` for each element.
	     * The iteratee is invoked with three arguments: (value, index|key, collection).
	     * Iteratee functions may exit iteration early by explicitly returning `false`.
	     *
	     * **Note:** As with other "Collections" methods, objects with a "length"
	     * property are iterated like arrays. To avoid this behavior use `_.forIn`
	     * or `_.forOwn` for object iteration.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @alias each
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Array|Object} Returns `collection`.
	     * @see _.forEachRight
	     * @example
	     *
	     * _.forEach([1, 2], function(value) {
	     *   console.log(value);
	     * });
	     * // => Logs `1` then `2`.
	     *
	     * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
	     *   console.log(key);
	     * });
	     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
	     */
	    function forEach(collection, iteratee) {
	      var func = isArray(collection) ? arrayEach : baseEach;
	      return func(collection, getIteratee(iteratee, 3));
	    }
	
	    /**
	     * This method is like `_.forEach` except that it iterates over elements of
	     * `collection` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @alias eachRight
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Array|Object} Returns `collection`.
	     * @see _.forEach
	     * @example
	     *
	     * _.forEachRight([1, 2], function(value) {
	     *   console.log(value);
	     * });
	     * // => Logs `2` then `1`.
	     */
	    function forEachRight(collection, iteratee) {
	      var func = isArray(collection) ? arrayEachRight : baseEachRight;
	      return func(collection, getIteratee(iteratee, 3));
	    }
	
	    /**
	     * Creates an object composed of keys generated from the results of running
	     * each element of `collection` thru `iteratee`. The order of grouped values
	     * is determined by the order they occur in `collection`. The corresponding
	     * value of each key is an array of elements responsible for generating the
	     * key. The iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
	     * @returns {Object} Returns the composed aggregate object.
	     * @example
	     *
	     * _.groupBy([6.1, 4.2, 6.3], Math.floor);
	     * // => { '4': [4.2], '6': [6.1, 6.3] }
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.groupBy(['one', 'two', 'three'], 'length');
	     * // => { '3': ['one', 'two'], '5': ['three'] }
	     */
	    var groupBy = createAggregator(function(result, value, key) {
	      if (hasOwnProperty.call(result, key)) {
	        result[key].push(value);
	      } else {
	        baseAssignValue(result, key, [value]);
	      }
	    });
	
	    /**
	     * Checks if `value` is in `collection`. If `collection` is a string, it's
	     * checked for a substring of `value`, otherwise
	     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * is used for equality comparisons. If `fromIndex` is negative, it's used as
	     * the offset from the end of `collection`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to inspect.
	     * @param {*} value The value to search for.
	     * @param {number} [fromIndex=0] The index to search from.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
	     * @returns {boolean} Returns `true` if `value` is found, else `false`.
	     * @example
	     *
	     * _.includes([1, 2, 3], 1);
	     * // => true
	     *
	     * _.includes([1, 2, 3], 1, 2);
	     * // => false
	     *
	     * _.includes({ 'a': 1, 'b': 2 }, 1);
	     * // => true
	     *
	     * _.includes('abcd', 'bc');
	     * // => true
	     */
	    function includes(collection, value, fromIndex, guard) {
	      collection = isArrayLike(collection) ? collection : values(collection);
	      fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;
	
	      var length = collection.length;
	      if (fromIndex < 0) {
	        fromIndex = nativeMax(length + fromIndex, 0);
	      }
	      return isString(collection)
	        ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)
	        : (!!length && baseIndexOf(collection, value, fromIndex) > -1);
	    }
	
	    /**
	     * Invokes the method at `path` of each element in `collection`, returning
	     * an array of the results of each invoked method. Any additional arguments
	     * are provided to each invoked method. If `path` is a function, it's invoked
	     * for, and `this` bound to, each element in `collection`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Array|Function|string} path The path of the method to invoke or
	     *  the function invoked per iteration.
	     * @param {...*} [args] The arguments to invoke each method with.
	     * @returns {Array} Returns the array of results.
	     * @example
	     *
	     * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');
	     * // => [[1, 5, 7], [1, 2, 3]]
	     *
	     * _.invokeMap([123, 456], String.prototype.split, '');
	     * // => [['1', '2', '3'], ['4', '5', '6']]
	     */
	    var invokeMap = baseRest(function(collection, path, args) {
	      var index = -1,
	          isFunc = typeof path == 'function',
	          result = isArrayLike(collection) ? Array(collection.length) : [];
	
	      baseEach(collection, function(value) {
	        result[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
	      });
	      return result;
	    });
	
	    /**
	     * Creates an object composed of keys generated from the results of running
	     * each element of `collection` thru `iteratee`. The corresponding value of
	     * each key is the last element responsible for generating the key. The
	     * iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
	     * @returns {Object} Returns the composed aggregate object.
	     * @example
	     *
	     * var array = [
	     *   { 'dir': 'left', 'code': 97 },
	     *   { 'dir': 'right', 'code': 100 }
	     * ];
	     *
	     * _.keyBy(array, function(o) {
	     *   return String.fromCharCode(o.code);
	     * });
	     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
	     *
	     * _.keyBy(array, 'dir');
	     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
	     */
	    var keyBy = createAggregator(function(result, value, key) {
	      baseAssignValue(result, key, value);
	    });
	
	    /**
	     * Creates an array of values by running each element in `collection` thru
	     * `iteratee`. The iteratee is invoked with three arguments:
	     * (value, index|key, collection).
	     *
	     * Many lodash methods are guarded to work as iteratees for methods like
	     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
	     *
	     * The guarded methods are:
	     * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
	     * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
	     * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
	     * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the new mapped array.
	     * @example
	     *
	     * function square(n) {
	     *   return n * n;
	     * }
	     *
	     * _.map([4, 8], square);
	     * // => [16, 64]
	     *
	     * _.map({ 'a': 4, 'b': 8 }, square);
	     * // => [16, 64] (iteration order is not guaranteed)
	     *
	     * var users = [
	     *   { 'user': 'barney' },
	     *   { 'user': 'fred' }
	     * ];
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.map(users, 'user');
	     * // => ['barney', 'fred']
	     */
	    function map(collection, iteratee) {
	      var func = isArray(collection) ? arrayMap : baseMap;
	      return func(collection, getIteratee(iteratee, 3));
	    }
	
	    /**
	     * This method is like `_.sortBy` except that it allows specifying the sort
	     * orders of the iteratees to sort by. If `orders` is unspecified, all values
	     * are sorted in ascending order. Otherwise, specify an order of "desc" for
	     * descending or "asc" for ascending sort order of corresponding values.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
	     *  The iteratees to sort by.
	     * @param {string[]} [orders] The sort orders of `iteratees`.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
	     * @returns {Array} Returns the new sorted array.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'fred',   'age': 48 },
	     *   { 'user': 'barney', 'age': 34 },
	     *   { 'user': 'fred',   'age': 40 },
	     *   { 'user': 'barney', 'age': 36 }
	     * ];
	     *
	     * // Sort by `user` in ascending order and by `age` in descending order.
	     * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
	     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
	     */
	    function orderBy(collection, iteratees, orders, guard) {
	      if (collection == null) {
	        return [];
	      }
	      if (!isArray(iteratees)) {
	        iteratees = iteratees == null ? [] : [iteratees];
	      }
	      orders = guard ? undefined : orders;
	      if (!isArray(orders)) {
	        orders = orders == null ? [] : [orders];
	      }
	      return baseOrderBy(collection, iteratees, orders);
	    }
	
	    /**
	     * Creates an array of elements split into two groups, the first of which
	     * contains elements `predicate` returns truthy for, the second of which
	     * contains elements `predicate` returns falsey for. The predicate is
	     * invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the array of grouped elements.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'age': 36, 'active': false },
	     *   { 'user': 'fred',    'age': 40, 'active': true },
	     *   { 'user': 'pebbles', 'age': 1,  'active': false }
	     * ];
	     *
	     * _.partition(users, function(o) { return o.active; });
	     * // => objects for [['fred'], ['barney', 'pebbles']]
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.partition(users, { 'age': 1, 'active': false });
	     * // => objects for [['pebbles'], ['barney', 'fred']]
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.partition(users, ['active', false]);
	     * // => objects for [['barney', 'pebbles'], ['fred']]
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.partition(users, 'active');
	     * // => objects for [['fred'], ['barney', 'pebbles']]
	     */
	    var partition = createAggregator(function(result, value, key) {
	      result[key ? 0 : 1].push(value);
	    }, function() { return [[], []]; });
	
	    /**
	     * Reduces `collection` to a value which is the accumulated result of running
	     * each element in `collection` thru `iteratee`, where each successive
	     * invocation is supplied the return value of the previous. If `accumulator`
	     * is not given, the first element of `collection` is used as the initial
	     * value. The iteratee is invoked with four arguments:
	     * (accumulator, value, index|key, collection).
	     *
	     * Many lodash methods are guarded to work as iteratees for methods like
	     * `_.reduce`, `_.reduceRight`, and `_.transform`.
	     *
	     * The guarded methods are:
	     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
	     * and `sortBy`
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [accumulator] The initial value.
	     * @returns {*} Returns the accumulated value.
	     * @see _.reduceRight
	     * @example
	     *
	     * _.reduce([1, 2], function(sum, n) {
	     *   return sum + n;
	     * }, 0);
	     * // => 3
	     *
	     * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
	     *   (result[value] || (result[value] = [])).push(key);
	     *   return result;
	     * }, {});
	     * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
	     */
	    function reduce(collection, iteratee, accumulator) {
	      var func = isArray(collection) ? arrayReduce : baseReduce,
	          initAccum = arguments.length < 3;
	
	      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);
	    }
	
	    /**
	     * This method is like `_.reduce` except that it iterates over elements of
	     * `collection` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [accumulator] The initial value.
	     * @returns {*} Returns the accumulated value.
	     * @see _.reduce
	     * @example
	     *
	     * var array = [[0, 1], [2, 3], [4, 5]];
	     *
	     * _.reduceRight(array, function(flattened, other) {
	     *   return flattened.concat(other);
	     * }, []);
	     * // => [4, 5, 2, 3, 0, 1]
	     */
	    function reduceRight(collection, iteratee, accumulator) {
	      var func = isArray(collection) ? arrayReduceRight : baseReduce,
	          initAccum = arguments.length < 3;
	
	      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);
	    }
	
	    /**
	     * The opposite of `_.filter`; this method returns the elements of `collection`
	     * that `predicate` does **not** return truthy for.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the new filtered array.
	     * @see _.filter
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36, 'active': false },
	     *   { 'user': 'fred',   'age': 40, 'active': true }
	     * ];
	     *
	     * _.reject(users, function(o) { return !o.active; });
	     * // => objects for ['fred']
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.reject(users, { 'age': 40, 'active': true });
	     * // => objects for ['barney']
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.reject(users, ['active', false]);
	     * // => objects for ['fred']
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.reject(users, 'active');
	     * // => objects for ['barney']
	     */
	    function reject(collection, predicate) {
	      var func = isArray(collection) ? arrayFilter : baseFilter;
	      return func(collection, negate(getIteratee(predicate, 3)));
	    }
	
	    /**
	     * Gets a random element from `collection`.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to sample.
	     * @returns {*} Returns the random element.
	     * @example
	     *
	     * _.sample([1, 2, 3, 4]);
	     * // => 2
	     */
	    function sample(collection) {
	      var func = isArray(collection) ? arraySample : baseSample;
	      return func(collection);
	    }
	
	    /**
	     * Gets `n` random elements at unique keys from `collection` up to the
	     * size of `collection`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to sample.
	     * @param {number} [n=1] The number of elements to sample.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Array} Returns the random elements.
	     * @example
	     *
	     * _.sampleSize([1, 2, 3], 2);
	     * // => [3, 1]
	     *
	     * _.sampleSize([1, 2, 3], 4);
	     * // => [2, 3, 1]
	     */
	    function sampleSize(collection, n, guard) {
	      if ((guard ? isIterateeCall(collection, n, guard) : n === undefined)) {
	        n = 1;
	      } else {
	        n = toInteger(n);
	      }
	      var func = isArray(collection) ? arraySampleSize : baseSampleSize;
	      return func(collection, n);
	    }
	
	    /**
	     * Creates an array of shuffled values, using a version of the
	     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to shuffle.
	     * @returns {Array} Returns the new shuffled array.
	     * @example
	     *
	     * _.shuffle([1, 2, 3, 4]);
	     * // => [4, 1, 3, 2]
	     */
	    function shuffle(collection) {
	      var func = isArray(collection) ? arrayShuffle : baseShuffle;
	      return func(collection);
	    }
	
	    /**
	     * Gets the size of `collection` by returning its length for array-like
	     * values or the number of own enumerable string keyed properties for objects.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to inspect.
	     * @returns {number} Returns the collection size.
	     * @example
	     *
	     * _.size([1, 2, 3]);
	     * // => 3
	     *
	     * _.size({ 'a': 1, 'b': 2 });
	     * // => 2
	     *
	     * _.size('pebbles');
	     * // => 7
	     */
	    function size(collection) {
	      if (collection == null) {
	        return 0;
	      }
	      if (isArrayLike(collection)) {
	        return isString(collection) ? stringSize(collection) : collection.length;
	      }
	      var tag = getTag(collection);
	      if (tag == mapTag || tag == setTag) {
	        return collection.size;
	      }
	      return baseKeys(collection).length;
	    }
	
	    /**
	     * Checks if `predicate` returns truthy for **any** element of `collection`.
	     * Iteration is stopped once `predicate` returns truthy. The predicate is
	     * invoked with three arguments: (value, index|key, collection).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {boolean} Returns `true` if any element passes the predicate check,
	     *  else `false`.
	     * @example
	     *
	     * _.some([null, 0, 'yes', false], Boolean);
	     * // => true
	     *
	     * var users = [
	     *   { 'user': 'barney', 'active': true },
	     *   { 'user': 'fred',   'active': false }
	     * ];
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.some(users, { 'user': 'barney', 'active': false });
	     * // => false
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.some(users, ['active', false]);
	     * // => true
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.some(users, 'active');
	     * // => true
	     */
	    function some(collection, predicate, guard) {
	      var func = isArray(collection) ? arraySome : baseSome;
	      if (guard && isIterateeCall(collection, predicate, guard)) {
	        predicate = undefined;
	      }
	      return func(collection, getIteratee(predicate, 3));
	    }
	
	    /**
	     * Creates an array of elements, sorted in ascending order by the results of
	     * running each element in a collection thru each iteratee. This method
	     * performs a stable sort, that is, it preserves the original sort order of
	     * equal elements. The iteratees are invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {...(Function|Function[])} [iteratees=[_.identity]]
	     *  The iteratees to sort by.
	     * @returns {Array} Returns the new sorted array.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'fred',   'age': 48 },
	     *   { 'user': 'barney', 'age': 36 },
	     *   { 'user': 'fred',   'age': 40 },
	     *   { 'user': 'barney', 'age': 34 }
	     * ];
	     *
	     * _.sortBy(users, [function(o) { return o.user; }]);
	     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
	     *
	     * _.sortBy(users, ['user', 'age']);
	     * // => objects for [['barney', 34], ['barney', 36], ['fred', 40], ['fred', 48]]
	     */
	    var sortBy = baseRest(function(collection, iteratees) {
	      if (collection == null) {
	        return [];
	      }
	      var length = iteratees.length;
	      if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
	        iteratees = [];
	      } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
	        iteratees = [iteratees[0]];
	      }
	      return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
	    });
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * Gets the timestamp of the number of milliseconds that have elapsed since
	     * the Unix epoch (1 January 1970 00:00:00 UTC).
	     *
	     * @static
	     * @memberOf _
	     * @since 2.4.0
	     * @category Date
	     * @returns {number} Returns the timestamp.
	     * @example
	     *
	     * _.defer(function(stamp) {
	     *   console.log(_.now() - stamp);
	     * }, _.now());
	     * // => Logs the number of milliseconds it took for the deferred invocation.
	     */
	    var now = ctxNow || function() {
	      return root.Date.now();
	    };
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * The opposite of `_.before`; this method creates a function that invokes
	     * `func` once it's called `n` or more times.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {number} n The number of calls before `func` is invoked.
	     * @param {Function} func The function to restrict.
	     * @returns {Function} Returns the new restricted function.
	     * @example
	     *
	     * var saves = ['profile', 'settings'];
	     *
	     * var done = _.after(saves.length, function() {
	     *   console.log('done saving!');
	     * });
	     *
	     * _.forEach(saves, function(type) {
	     *   asyncSave({ 'type': type, 'complete': done });
	     * });
	     * // => Logs 'done saving!' after the two async saves have completed.
	     */
	    function after(n, func) {
	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      n = toInteger(n);
	      return function() {
	        if (--n < 1) {
	          return func.apply(this, arguments);
	        }
	      };
	    }
	
	    /**
	     * Creates a function that invokes `func`, with up to `n` arguments,
	     * ignoring any additional arguments.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Function
	     * @param {Function} func The function to cap arguments for.
	     * @param {number} [n=func.length] The arity cap.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Function} Returns the new capped function.
	     * @example
	     *
	     * _.map(['6', '8', '10'], _.ary(parseInt, 1));
	     * // => [6, 8, 10]
	     */
	    function ary(func, n, guard) {
	      n = guard ? undefined : n;
	      n = (func && n == null) ? func.length : n;
	      return createWrap(func, WRAP_ARY_FLAG, undefined, undefined, undefined, undefined, n);
	    }
	
	    /**
	     * Creates a function that invokes `func`, with the `this` binding and arguments
	     * of the created function, while it's called less than `n` times. Subsequent
	     * calls to the created function return the result of the last `func` invocation.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Function
	     * @param {number} n The number of calls at which `func` is no longer invoked.
	     * @param {Function} func The function to restrict.
	     * @returns {Function} Returns the new restricted function.
	     * @example
	     *
	     * jQuery(element).on('click', _.before(5, addContactToList));
	     * // => Allows adding up to 4 contacts to the list.
	     */
	    function before(n, func) {
	      var result;
	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      n = toInteger(n);
	      return function() {
	        if (--n > 0) {
	          result = func.apply(this, arguments);
	        }
	        if (n <= 1) {
	          func = undefined;
	        }
	        return result;
	      };
	    }
	
	    /**
	     * Creates a function that invokes `func` with the `this` binding of `thisArg`
	     * and `partials` prepended to the arguments it receives.
	     *
	     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
	     * may be used as a placeholder for partially applied arguments.
	     *
	     * **Note:** Unlike native `Function#bind`, this method doesn't set the "length"
	     * property of bound functions.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {Function} func The function to bind.
	     * @param {*} thisArg The `this` binding of `func`.
	     * @param {...*} [partials] The arguments to be partially applied.
	     * @returns {Function} Returns the new bound function.
	     * @example
	     *
	     * function greet(greeting, punctuation) {
	     *   return greeting + ' ' + this.user + punctuation;
	     * }
	     *
	     * var object = { 'user': 'fred' };
	     *
	     * var bound = _.bind(greet, object, 'hi');
	     * bound('!');
	     * // => 'hi fred!'
	     *
	     * // Bound with placeholders.
	     * var bound = _.bind(greet, object, _, '!');
	     * bound('hi');
	     * // => 'hi fred!'
	     */
	    var bind = baseRest(function(func, thisArg, partials) {
	      var bitmask = WRAP_BIND_FLAG;
	      if (partials.length) {
	        var holders = replaceHolders(partials, getHolder(bind));
	        bitmask |= WRAP_PARTIAL_FLAG;
	      }
	      return createWrap(func, bitmask, thisArg, partials, holders);
	    });
	
	    /**
	     * Creates a function that invokes the method at `object[key]` with `partials`
	     * prepended to the arguments it receives.
	     *
	     * This method differs from `_.bind` by allowing bound functions to reference
	     * methods that may be redefined or don't yet exist. See
	     * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
	     * for more details.
	     *
	     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
	     * builds, may be used as a placeholder for partially applied arguments.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.10.0
	     * @category Function
	     * @param {Object} object The object to invoke the method on.
	     * @param {string} key The key of the method.
	     * @param {...*} [partials] The arguments to be partially applied.
	     * @returns {Function} Returns the new bound function.
	     * @example
	     *
	     * var object = {
	     *   'user': 'fred',
	     *   'greet': function(greeting, punctuation) {
	     *     return greeting + ' ' + this.user + punctuation;
	     *   }
	     * };
	     *
	     * var bound = _.bindKey(object, 'greet', 'hi');
	     * bound('!');
	     * // => 'hi fred!'
	     *
	     * object.greet = function(greeting, punctuation) {
	     *   return greeting + 'ya ' + this.user + punctuation;
	     * };
	     *
	     * bound('!');
	     * // => 'hiya fred!'
	     *
	     * // Bound with placeholders.
	     * var bound = _.bindKey(object, 'greet', _, '!');
	     * bound('hi');
	     * // => 'hiya fred!'
	     */
	    var bindKey = baseRest(function(object, key, partials) {
	      var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
	      if (partials.length) {
	        var holders = replaceHolders(partials, getHolder(bindKey));
	        bitmask |= WRAP_PARTIAL_FLAG;
	      }
	      return createWrap(key, bitmask, object, partials, holders);
	    });
	
	    /**
	     * Creates a function that accepts arguments of `func` and either invokes
	     * `func` returning its result, if at least `arity` number of arguments have
	     * been provided, or returns a function that accepts the remaining `func`
	     * arguments, and so on. The arity of `func` may be specified if `func.length`
	     * is not sufficient.
	     *
	     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
	     * may be used as a placeholder for provided arguments.
	     *
	     * **Note:** This method doesn't set the "length" property of curried functions.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Function
	     * @param {Function} func The function to curry.
	     * @param {number} [arity=func.length] The arity of `func`.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Function} Returns the new curried function.
	     * @example
	     *
	     * var abc = function(a, b, c) {
	     *   return [a, b, c];
	     * };
	     *
	     * var curried = _.curry(abc);
	     *
	     * curried(1)(2)(3);
	     * // => [1, 2, 3]
	     *
	     * curried(1, 2)(3);
	     * // => [1, 2, 3]
	     *
	     * curried(1, 2, 3);
	     * // => [1, 2, 3]
	     *
	     * // Curried with placeholders.
	     * curried(1)(_, 3)(2);
	     * // => [1, 2, 3]
	     */
	    function curry(func, arity, guard) {
	      arity = guard ? undefined : arity;
	      var result = createWrap(func, WRAP_CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
	      result.placeholder = curry.placeholder;
	      return result;
	    }
	
	    /**
	     * This method is like `_.curry` except that arguments are applied to `func`
	     * in the manner of `_.partialRight` instead of `_.partial`.
	     *
	     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
	     * builds, may be used as a placeholder for provided arguments.
	     *
	     * **Note:** This method doesn't set the "length" property of curried functions.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Function
	     * @param {Function} func The function to curry.
	     * @param {number} [arity=func.length] The arity of `func`.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Function} Returns the new curried function.
	     * @example
	     *
	     * var abc = function(a, b, c) {
	     *   return [a, b, c];
	     * };
	     *
	     * var curried = _.curryRight(abc);
	     *
	     * curried(3)(2)(1);
	     * // => [1, 2, 3]
	     *
	     * curried(2, 3)(1);
	     * // => [1, 2, 3]
	     *
	     * curried(1, 2, 3);
	     * // => [1, 2, 3]
	     *
	     * // Curried with placeholders.
	     * curried(3)(1, _)(2);
	     * // => [1, 2, 3]
	     */
	    function curryRight(func, arity, guard) {
	      arity = guard ? undefined : arity;
	      var result = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
	      result.placeholder = curryRight.placeholder;
	      return result;
	    }
	
	    /**
	     * Creates a debounced function that delays invoking `func` until after `wait`
	     * milliseconds have elapsed since the last time the debounced function was
	     * invoked. The debounced function comes with a `cancel` method to cancel
	     * delayed `func` invocations and a `flush` method to immediately invoke them.
	     * Provide `options` to indicate whether `func` should be invoked on the
	     * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
	     * with the last arguments provided to the debounced function. Subsequent
	     * calls to the debounced function return the result of the last `func`
	     * invocation.
	     *
	     * **Note:** If `leading` and `trailing` options are `true`, `func` is
	     * invoked on the trailing edge of the timeout only if the debounced function
	     * is invoked more than once during the `wait` timeout.
	     *
	     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
	     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
	     *
	     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
	     * for details over the differences between `_.debounce` and `_.throttle`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {Function} func The function to debounce.
	     * @param {number} [wait=0] The number of milliseconds to delay.
	     * @param {Object} [options={}] The options object.
	     * @param {boolean} [options.leading=false]
	     *  Specify invoking on the leading edge of the timeout.
	     * @param {number} [options.maxWait]
	     *  The maximum time `func` is allowed to be delayed before it's invoked.
	     * @param {boolean} [options.trailing=true]
	     *  Specify invoking on the trailing edge of the timeout.
	     * @returns {Function} Returns the new debounced function.
	     * @example
	     *
	     * // Avoid costly calculations while the window size is in flux.
	     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
	     *
	     * // Invoke `sendMail` when clicked, debouncing subsequent calls.
	     * jQuery(element).on('click', _.debounce(sendMail, 300, {
	     *   'leading': true,
	     *   'trailing': false
	     * }));
	     *
	     * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
	     * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
	     * var source = new EventSource('/stream');
	     * jQuery(source).on('message', debounced);
	     *
	     * // Cancel the trailing debounced invocation.
	     * jQuery(window).on('popstate', debounced.cancel);
	     */
	    function debounce(func, wait, options) {
	      var lastArgs,
	          lastThis,
	          maxWait,
	          result,
	          timerId,
	          lastCallTime,
	          lastInvokeTime = 0,
	          leading = false,
	          maxing = false,
	          trailing = true;
	
	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      wait = toNumber(wait) || 0;
	      if (isObject(options)) {
	        leading = !!options.leading;
	        maxing = 'maxWait' in options;
	        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
	        trailing = 'trailing' in options ? !!options.trailing : trailing;
	      }
	
	      function invokeFunc(time) {
	        var args = lastArgs,
	            thisArg = lastThis;
	
	        lastArgs = lastThis = undefined;
	        lastInvokeTime = time;
	        result = func.apply(thisArg, args);
	        return result;
	      }
	
	      function leadingEdge(time) {
	        // Reset any `maxWait` timer.
	        lastInvokeTime = time;
	        // Start the timer for the trailing edge.
	        timerId = setTimeout(timerExpired, wait);
	        // Invoke the leading edge.
	        return leading ? invokeFunc(time) : result;
	      }
	
	      function remainingWait(time) {
	        var timeSinceLastCall = time - lastCallTime,
	            timeSinceLastInvoke = time - lastInvokeTime,
	            result = wait - timeSinceLastCall;
	
	        return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
	      }
	
	      function shouldInvoke(time) {
	        var timeSinceLastCall = time - lastCallTime,
	            timeSinceLastInvoke = time - lastInvokeTime;
	
	        // Either this is the first call, activity has stopped and we're at the
	        // trailing edge, the system time has gone backwards and we're treating
	        // it as the trailing edge, or we've hit the `maxWait` limit.
	        return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
	          (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
	      }
	
	      function timerExpired() {
	        var time = now();
	        if (shouldInvoke(time)) {
	          return trailingEdge(time);
	        }
	        // Restart the timer.
	        timerId = setTimeout(timerExpired, remainingWait(time));
	      }
	
	      function trailingEdge(time) {
	        timerId = undefined;
	
	        // Only invoke if we have `lastArgs` which means `func` has been
	        // debounced at least once.
	        if (trailing && lastArgs) {
	          return invokeFunc(time);
	        }
	        lastArgs = lastThis = undefined;
	        return result;
	      }
	
	      function cancel() {
	        if (timerId !== undefined) {
	          clearTimeout(timerId);
	        }
	        lastInvokeTime = 0;
	        lastArgs = lastCallTime = lastThis = timerId = undefined;
	      }
	
	      function flush() {
	        return timerId === undefined ? result : trailingEdge(now());
	      }
	
	      function debounced() {
	        var time = now(),
	            isInvoking = shouldInvoke(time);
	
	        lastArgs = arguments;
	        lastThis = this;
	        lastCallTime = time;
	
	        if (isInvoking) {
	          if (timerId === undefined) {
	            return leadingEdge(lastCallTime);
	          }
	          if (maxing) {
	            // Handle invocations in a tight loop.
	            timerId = setTimeout(timerExpired, wait);
	            return invokeFunc(lastCallTime);
	          }
	        }
	        if (timerId === undefined) {
	          timerId = setTimeout(timerExpired, wait);
	        }
	        return result;
	      }
	      debounced.cancel = cancel;
	      debounced.flush = flush;
	      return debounced;
	    }
	
	    /**
	     * Defers invoking the `func` until the current call stack has cleared. Any
	     * additional arguments are provided to `func` when it's invoked.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {Function} func The function to defer.
	     * @param {...*} [args] The arguments to invoke `func` with.
	     * @returns {number} Returns the timer id.
	     * @example
	     *
	     * _.defer(function(text) {
	     *   console.log(text);
	     * }, 'deferred');
	     * // => Logs 'deferred' after one millisecond.
	     */
	    var defer = baseRest(function(func, args) {
	      return baseDelay(func, 1, args);
	    });
	
	    /**
	     * Invokes `func` after `wait` milliseconds. Any additional arguments are
	     * provided to `func` when it's invoked.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {Function} func The function to delay.
	     * @param {number} wait The number of milliseconds to delay invocation.
	     * @param {...*} [args] The arguments to invoke `func` with.
	     * @returns {number} Returns the timer id.
	     * @example
	     *
	     * _.delay(function(text) {
	     *   console.log(text);
	     * }, 1000, 'later');
	     * // => Logs 'later' after one second.
	     */
	    var delay = baseRest(function(func, wait, args) {
	      return baseDelay(func, toNumber(wait) || 0, args);
	    });
	
	    /**
	     * Creates a function that invokes `func` with arguments reversed.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Function
	     * @param {Function} func The function to flip arguments for.
	     * @returns {Function} Returns the new flipped function.
	     * @example
	     *
	     * var flipped = _.flip(function() {
	     *   return _.toArray(arguments);
	     * });
	     *
	     * flipped('a', 'b', 'c', 'd');
	     * // => ['d', 'c', 'b', 'a']
	     */
	    function flip(func) {
	      return createWrap(func, WRAP_FLIP_FLAG);
	    }
	
	    /**
	     * Creates a function that memoizes the result of `func`. If `resolver` is
	     * provided, it determines the cache key for storing the result based on the
	     * arguments provided to the memoized function. By default, the first argument
	     * provided to the memoized function is used as the map cache key. The `func`
	     * is invoked with the `this` binding of the memoized function.
	     *
	     * **Note:** The cache is exposed as the `cache` property on the memoized
	     * function. Its creation may be customized by replacing the `_.memoize.Cache`
	     * constructor with one whose instances implement the
	     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
	     * method interface of `clear`, `delete`, `get`, `has`, and `set`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {Function} func The function to have its output memoized.
	     * @param {Function} [resolver] The function to resolve the cache key.
	     * @returns {Function} Returns the new memoized function.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': 2 };
	     * var other = { 'c': 3, 'd': 4 };
	     *
	     * var values = _.memoize(_.values);
	     * values(object);
	     * // => [1, 2]
	     *
	     * values(other);
	     * // => [3, 4]
	     *
	     * object.a = 2;
	     * values(object);
	     * // => [1, 2]
	     *
	     * // Modify the result cache.
	     * values.cache.set(object, ['a', 'b']);
	     * values(object);
	     * // => ['a', 'b']
	     *
	     * // Replace `_.memoize.Cache`.
	     * _.memoize.Cache = WeakMap;
	     */
	    function memoize(func, resolver) {
	      if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      var memoized = function() {
	        var args = arguments,
	            key = resolver ? resolver.apply(this, args) : args[0],
	            cache = memoized.cache;
	
	        if (cache.has(key)) {
	          return cache.get(key);
	        }
	        var result = func.apply(this, args);
	        memoized.cache = cache.set(key, result) || cache;
	        return result;
	      };
	      memoized.cache = new (memoize.Cache || MapCache);
	      return memoized;
	    }
	
	    // Expose `MapCache`.
	    memoize.Cache = MapCache;
	
	    /**
	     * Creates a function that negates the result of the predicate `func`. The
	     * `func` predicate is invoked with the `this` binding and arguments of the
	     * created function.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Function
	     * @param {Function} predicate The predicate to negate.
	     * @returns {Function} Returns the new negated function.
	     * @example
	     *
	     * function isEven(n) {
	     *   return n % 2 == 0;
	     * }
	     *
	     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
	     * // => [1, 3, 5]
	     */
	    function negate(predicate) {
	      if (typeof predicate != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      return function() {
	        var args = arguments;
	        switch (args.length) {
	          case 0: return !predicate.call(this);
	          case 1: return !predicate.call(this, args[0]);
	          case 2: return !predicate.call(this, args[0], args[1]);
	          case 3: return !predicate.call(this, args[0], args[1], args[2]);
	        }
	        return !predicate.apply(this, args);
	      };
	    }
	
	    /**
	     * Creates a function that is restricted to invoking `func` once. Repeat calls
	     * to the function return the value of the first invocation. The `func` is
	     * invoked with the `this` binding and arguments of the created function.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {Function} func The function to restrict.
	     * @returns {Function} Returns the new restricted function.
	     * @example
	     *
	     * var initialize = _.once(createApplication);
	     * initialize();
	     * initialize();
	     * // => `createApplication` is invoked once
	     */
	    function once(func) {
	      return before(2, func);
	    }
	
	    /**
	     * Creates a function that invokes `func` with its arguments transformed.
	     *
	     * @static
	     * @since 4.0.0
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to wrap.
	     * @param {...(Function|Function[])} [transforms=[_.identity]]
	     *  The argument transforms.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * function doubled(n) {
	     *   return n * 2;
	     * }
	     *
	     * function square(n) {
	     *   return n * n;
	     * }
	     *
	     * var func = _.overArgs(function(x, y) {
	     *   return [x, y];
	     * }, [square, doubled]);
	     *
	     * func(9, 3);
	     * // => [81, 6]
	     *
	     * func(10, 5);
	     * // => [100, 10]
	     */
	    var overArgs = castRest(function(func, transforms) {
	      transforms = (transforms.length == 1 && isArray(transforms[0]))
	        ? arrayMap(transforms[0], baseUnary(getIteratee()))
	        : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
	
	      var funcsLength = transforms.length;
	      return baseRest(function(args) {
	        var index = -1,
	            length = nativeMin(args.length, funcsLength);
	
	        while (++index < length) {
	          args[index] = transforms[index].call(this, args[index]);
	        }
	        return apply(func, this, args);
	      });
	    });
	
	    /**
	     * Creates a function that invokes `func` with `partials` prepended to the
	     * arguments it receives. This method is like `_.bind` except it does **not**
	     * alter the `this` binding.
	     *
	     * The `_.partial.placeholder` value, which defaults to `_` in monolithic
	     * builds, may be used as a placeholder for partially applied arguments.
	     *
	     * **Note:** This method doesn't set the "length" property of partially
	     * applied functions.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.2.0
	     * @category Function
	     * @param {Function} func The function to partially apply arguments to.
	     * @param {...*} [partials] The arguments to be partially applied.
	     * @returns {Function} Returns the new partially applied function.
	     * @example
	     *
	     * function greet(greeting, name) {
	     *   return greeting + ' ' + name;
	     * }
	     *
	     * var sayHelloTo = _.partial(greet, 'hello');
	     * sayHelloTo('fred');
	     * // => 'hello fred'
	     *
	     * // Partially applied with placeholders.
	     * var greetFred = _.partial(greet, _, 'fred');
	     * greetFred('hi');
	     * // => 'hi fred'
	     */
	    var partial = baseRest(function(func, partials) {
	      var holders = replaceHolders(partials, getHolder(partial));
	      return createWrap(func, WRAP_PARTIAL_FLAG, undefined, partials, holders);
	    });
	
	    /**
	     * This method is like `_.partial` except that partially applied arguments
	     * are appended to the arguments it receives.
	     *
	     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
	     * builds, may be used as a placeholder for partially applied arguments.
	     *
	     * **Note:** This method doesn't set the "length" property of partially
	     * applied functions.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.0.0
	     * @category Function
	     * @param {Function} func The function to partially apply arguments to.
	     * @param {...*} [partials] The arguments to be partially applied.
	     * @returns {Function} Returns the new partially applied function.
	     * @example
	     *
	     * function greet(greeting, name) {
	     *   return greeting + ' ' + name;
	     * }
	     *
	     * var greetFred = _.partialRight(greet, 'fred');
	     * greetFred('hi');
	     * // => 'hi fred'
	     *
	     * // Partially applied with placeholders.
	     * var sayHelloTo = _.partialRight(greet, 'hello', _);
	     * sayHelloTo('fred');
	     * // => 'hello fred'
	     */
	    var partialRight = baseRest(function(func, partials) {
	      var holders = replaceHolders(partials, getHolder(partialRight));
	      return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined, partials, holders);
	    });
	
	    /**
	     * Creates a function that invokes `func` with arguments arranged according
	     * to the specified `indexes` where the argument value at the first index is
	     * provided as the first argument, the argument value at the second index is
	     * provided as the second argument, and so on.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Function
	     * @param {Function} func The function to rearrange arguments for.
	     * @param {...(number|number[])} indexes The arranged argument indexes.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var rearged = _.rearg(function(a, b, c) {
	     *   return [a, b, c];
	     * }, [2, 0, 1]);
	     *
	     * rearged('b', 'c', 'a')
	     * // => ['a', 'b', 'c']
	     */
	    var rearg = flatRest(function(func, indexes) {
	      return createWrap(func, WRAP_REARG_FLAG, undefined, undefined, undefined, indexes);
	    });
	
	    /**
	     * Creates a function that invokes `func` with the `this` binding of the
	     * created function and arguments from `start` and beyond provided as
	     * an array.
	     *
	     * **Note:** This method is based on the
	     * [rest parameter](https://mdn.io/rest_parameters).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Function
	     * @param {Function} func The function to apply a rest parameter to.
	     * @param {number} [start=func.length-1] The start position of the rest parameter.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var say = _.rest(function(what, names) {
	     *   return what + ' ' + _.initial(names).join(', ') +
	     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
	     * });
	     *
	     * say('hello', 'fred', 'barney', 'pebbles');
	     * // => 'hello fred, barney, & pebbles'
	     */
	    function rest(func, start) {
	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      start = start === undefined ? start : toInteger(start);
	      return baseRest(func, start);
	    }
	
	    /**
	     * Creates a function that invokes `func` with the `this` binding of the
	     * create function and an array of arguments much like
	     * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).
	     *
	     * **Note:** This method is based on the
	     * [spread operator](https://mdn.io/spread_operator).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.2.0
	     * @category Function
	     * @param {Function} func The function to spread arguments over.
	     * @param {number} [start=0] The start position of the spread.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var say = _.spread(function(who, what) {
	     *   return who + ' says ' + what;
	     * });
	     *
	     * say(['fred', 'hello']);
	     * // => 'fred says hello'
	     *
	     * var numbers = Promise.all([
	     *   Promise.resolve(40),
	     *   Promise.resolve(36)
	     * ]);
	     *
	     * numbers.then(_.spread(function(x, y) {
	     *   return x + y;
	     * }));
	     * // => a Promise of 76
	     */
	    function spread(func, start) {
	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      start = start === undefined ? 0 : nativeMax(toInteger(start), 0);
	      return baseRest(function(args) {
	        var array = args[start],
	            otherArgs = castSlice(args, 0, start);
	
	        if (array) {
	          arrayPush(otherArgs, array);
	        }
	        return apply(func, this, otherArgs);
	      });
	    }
	
	    /**
	     * Creates a throttled function that only invokes `func` at most once per
	     * every `wait` milliseconds. The throttled function comes with a `cancel`
	     * method to cancel delayed `func` invocations and a `flush` method to
	     * immediately invoke them. Provide `options` to indicate whether `func`
	     * should be invoked on the leading and/or trailing edge of the `wait`
	     * timeout. The `func` is invoked with the last arguments provided to the
	     * throttled function. Subsequent calls to the throttled function return the
	     * result of the last `func` invocation.
	     *
	     * **Note:** If `leading` and `trailing` options are `true`, `func` is
	     * invoked on the trailing edge of the timeout only if the throttled function
	     * is invoked more than once during the `wait` timeout.
	     *
	     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
	     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
	     *
	     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
	     * for details over the differences between `_.throttle` and `_.debounce`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {Function} func The function to throttle.
	     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
	     * @param {Object} [options={}] The options object.
	     * @param {boolean} [options.leading=true]
	     *  Specify invoking on the leading edge of the timeout.
	     * @param {boolean} [options.trailing=true]
	     *  Specify invoking on the trailing edge of the timeout.
	     * @returns {Function} Returns the new throttled function.
	     * @example
	     *
	     * // Avoid excessively updating the position while scrolling.
	     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
	     *
	     * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
	     * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
	     * jQuery(element).on('click', throttled);
	     *
	     * // Cancel the trailing throttled invocation.
	     * jQuery(window).on('popstate', throttled.cancel);
	     */
	    function throttle(func, wait, options) {
	      var leading = true,
	          trailing = true;
	
	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      if (isObject(options)) {
	        leading = 'leading' in options ? !!options.leading : leading;
	        trailing = 'trailing' in options ? !!options.trailing : trailing;
	      }
	      return debounce(func, wait, {
	        'leading': leading,
	        'maxWait': wait,
	        'trailing': trailing
	      });
	    }
	
	    /**
	     * Creates a function that accepts up to one argument, ignoring any
	     * additional arguments.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Function
	     * @param {Function} func The function to cap arguments for.
	     * @returns {Function} Returns the new capped function.
	     * @example
	     *
	     * _.map(['6', '8', '10'], _.unary(parseInt));
	     * // => [6, 8, 10]
	     */
	    function unary(func) {
	      return ary(func, 1);
	    }
	
	    /**
	     * Creates a function that provides `value` to `wrapper` as its first
	     * argument. Any additional arguments provided to the function are appended
	     * to those provided to the `wrapper`. The wrapper is invoked with the `this`
	     * binding of the created function.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {*} value The value to wrap.
	     * @param {Function} [wrapper=identity] The wrapper function.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var p = _.wrap(_.escape, function(func, text) {
	     *   return '<p>' + func(text) + '</p>';
	     * });
	     *
	     * p('fred, barney, & pebbles');
	     * // => '<p>fred, barney, &amp; pebbles</p>'
	     */
	    function wrap(value, wrapper) {
	      return partial(castFunction(wrapper), value);
	    }
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * Casts `value` as an array if it's not one.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.4.0
	     * @category Lang
	     * @param {*} value The value to inspect.
	     * @returns {Array} Returns the cast array.
	     * @example
	     *
	     * _.castArray(1);
	     * // => [1]
	     *
	     * _.castArray({ 'a': 1 });
	     * // => [{ 'a': 1 }]
	     *
	     * _.castArray('abc');
	     * // => ['abc']
	     *
	     * _.castArray(null);
	     * // => [null]
	     *
	     * _.castArray(undefined);
	     * // => [undefined]
	     *
	     * _.castArray();
	     * // => []
	     *
	     * var array = [1, 2, 3];
	     * console.log(_.castArray(array) === array);
	     * // => true
	     */
	    function castArray() {
	      if (!arguments.length) {
	        return [];
	      }
	      var value = arguments[0];
	      return isArray(value) ? value : [value];
	    }
	
	    /**
	     * Creates a shallow clone of `value`.
	     *
	     * **Note:** This method is loosely based on the
	     * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
	     * and supports cloning arrays, array buffers, booleans, date objects, maps,
	     * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
	     * arrays. The own enumerable properties of `arguments` objects are cloned
	     * as plain objects. An empty object is returned for uncloneable values such
	     * as error objects, functions, DOM nodes, and WeakMaps.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to clone.
	     * @returns {*} Returns the cloned value.
	     * @see _.cloneDeep
	     * @example
	     *
	     * var objects = [{ 'a': 1 }, { 'b': 2 }];
	     *
	     * var shallow = _.clone(objects);
	     * console.log(shallow[0] === objects[0]);
	     * // => true
	     */
	    function clone(value) {
	      return baseClone(value, CLONE_SYMBOLS_FLAG);
	    }
	
	    /**
	     * This method is like `_.clone` except that it accepts `customizer` which
	     * is invoked to produce the cloned value. If `customizer` returns `undefined`,
	     * cloning is handled by the method instead. The `customizer` is invoked with
	     * up to four arguments; (value [, index|key, object, stack]).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to clone.
	     * @param {Function} [customizer] The function to customize cloning.
	     * @returns {*} Returns the cloned value.
	     * @see _.cloneDeepWith
	     * @example
	     *
	     * function customizer(value) {
	     *   if (_.isElement(value)) {
	     *     return value.cloneNode(false);
	     *   }
	     * }
	     *
	     * var el = _.cloneWith(document.body, customizer);
	     *
	     * console.log(el === document.body);
	     * // => false
	     * console.log(el.nodeName);
	     * // => 'BODY'
	     * console.log(el.childNodes.length);
	     * // => 0
	     */
	    function cloneWith(value, customizer) {
	      customizer = typeof customizer == 'function' ? customizer : undefined;
	      return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
	    }
	
	    /**
	     * This method is like `_.clone` except that it recursively clones `value`.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.0.0
	     * @category Lang
	     * @param {*} value The value to recursively clone.
	     * @returns {*} Returns the deep cloned value.
	     * @see _.clone
	     * @example
	     *
	     * var objects = [{ 'a': 1 }, { 'b': 2 }];
	     *
	     * var deep = _.cloneDeep(objects);
	     * console.log(deep[0] === objects[0]);
	     * // => false
	     */
	    function cloneDeep(value) {
	      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
	    }
	
	    /**
	     * This method is like `_.cloneWith` except that it recursively clones `value`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to recursively clone.
	     * @param {Function} [customizer] The function to customize cloning.
	     * @returns {*} Returns the deep cloned value.
	     * @see _.cloneWith
	     * @example
	     *
	     * function customizer(value) {
	     *   if (_.isElement(value)) {
	     *     return value.cloneNode(true);
	     *   }
	     * }
	     *
	     * var el = _.cloneDeepWith(document.body, customizer);
	     *
	     * console.log(el === document.body);
	     * // => false
	     * console.log(el.nodeName);
	     * // => 'BODY'
	     * console.log(el.childNodes.length);
	     * // => 20
	     */
	    function cloneDeepWith(value, customizer) {
	      customizer = typeof customizer == 'function' ? customizer : undefined;
	      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
	    }
	
	    /**
	     * Checks if `object` conforms to `source` by invoking the predicate
	     * properties of `source` with the corresponding property values of `object`.
	     *
	     * **Note:** This method is equivalent to `_.conforms` when `source` is
	     * partially applied.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.14.0
	     * @category Lang
	     * @param {Object} object The object to inspect.
	     * @param {Object} source The object of property predicates to conform to.
	     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': 2 };
	     *
	     * _.conformsTo(object, { 'b': function(n) { return n > 1; } });
	     * // => true
	     *
	     * _.conformsTo(object, { 'b': function(n) { return n > 2; } });
	     * // => false
	     */
	    function conformsTo(object, source) {
	      return source == null || baseConformsTo(object, source, keys(source));
	    }
	
	    /**
	     * Performs a
	     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * comparison between two values to determine if they are equivalent.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	     * @example
	     *
	     * var object = { 'a': 1 };
	     * var other = { 'a': 1 };
	     *
	     * _.eq(object, object);
	     * // => true
	     *
	     * _.eq(object, other);
	     * // => false
	     *
	     * _.eq('a', 'a');
	     * // => true
	     *
	     * _.eq('a', Object('a'));
	     * // => false
	     *
	     * _.eq(NaN, NaN);
	     * // => true
	     */
	    function eq(value, other) {
	      return value === other || (value !== value && other !== other);
	    }
	
	    /**
	     * Checks if `value` is greater than `other`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.9.0
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if `value` is greater than `other`,
	     *  else `false`.
	     * @see _.lt
	     * @example
	     *
	     * _.gt(3, 1);
	     * // => true
	     *
	     * _.gt(3, 3);
	     * // => false
	     *
	     * _.gt(1, 3);
	     * // => false
	     */
	    var gt = createRelationalOperation(baseGt);
	
	    /**
	     * Checks if `value` is greater than or equal to `other`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.9.0
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if `value` is greater than or equal to
	     *  `other`, else `false`.
	     * @see _.lte
	     * @example
	     *
	     * _.gte(3, 1);
	     * // => true
	     *
	     * _.gte(3, 3);
	     * // => true
	     *
	     * _.gte(1, 3);
	     * // => false
	     */
	    var gte = createRelationalOperation(function(value, other) {
	      return value >= other;
	    });
	
	    /**
	     * Checks if `value` is likely an `arguments` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	     *  else `false`.
	     * @example
	     *
	     * _.isArguments(function() { return arguments; }());
	     * // => true
	     *
	     * _.isArguments([1, 2, 3]);
	     * // => false
	     */
	    var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
	      return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
	        !propertyIsEnumerable.call(value, 'callee');
	    };
	
	    /**
	     * Checks if `value` is classified as an `Array` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
	     * @example
	     *
	     * _.isArray([1, 2, 3]);
	     * // => true
	     *
	     * _.isArray(document.body.children);
	     * // => false
	     *
	     * _.isArray('abc');
	     * // => false
	     *
	     * _.isArray(_.noop);
	     * // => false
	     */
	    var isArray = Array.isArray;
	
	    /**
	     * Checks if `value` is classified as an `ArrayBuffer` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.3.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
	     * @example
	     *
	     * _.isArrayBuffer(new ArrayBuffer(2));
	     * // => true
	     *
	     * _.isArrayBuffer(new Array(2));
	     * // => false
	     */
	    var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
	
	    /**
	     * Checks if `value` is array-like. A value is considered array-like if it's
	     * not a function and has a `value.length` that's an integer greater than or
	     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	     * @example
	     *
	     * _.isArrayLike([1, 2, 3]);
	     * // => true
	     *
	     * _.isArrayLike(document.body.children);
	     * // => true
	     *
	     * _.isArrayLike('abc');
	     * // => true
	     *
	     * _.isArrayLike(_.noop);
	     * // => false
	     */
	    function isArrayLike(value) {
	      return value != null && isLength(value.length) && !isFunction(value);
	    }
	
	    /**
	     * This method is like `_.isArrayLike` except that it also checks if `value`
	     * is an object.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an array-like object,
	     *  else `false`.
	     * @example
	     *
	     * _.isArrayLikeObject([1, 2, 3]);
	     * // => true
	     *
	     * _.isArrayLikeObject(document.body.children);
	     * // => true
	     *
	     * _.isArrayLikeObject('abc');
	     * // => false
	     *
	     * _.isArrayLikeObject(_.noop);
	     * // => false
	     */
	    function isArrayLikeObject(value) {
	      return isObjectLike(value) && isArrayLike(value);
	    }
	
	    /**
	     * Checks if `value` is classified as a boolean primitive or object.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
	     * @example
	     *
	     * _.isBoolean(false);
	     * // => true
	     *
	     * _.isBoolean(null);
	     * // => false
	     */
	    function isBoolean(value) {
	      return value === true || value === false ||
	        (isObjectLike(value) && baseGetTag(value) == boolTag);
	    }
	
	    /**
	     * Checks if `value` is a buffer.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.3.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
	     * @example
	     *
	     * _.isBuffer(new Buffer(2));
	     * // => true
	     *
	     * _.isBuffer(new Uint8Array(2));
	     * // => false
	     */
	    var isBuffer = nativeIsBuffer || stubFalse;
	
	    /**
	     * Checks if `value` is classified as a `Date` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
	     * @example
	     *
	     * _.isDate(new Date);
	     * // => true
	     *
	     * _.isDate('Mon April 23 2012');
	     * // => false
	     */
	    var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
	
	    /**
	     * Checks if `value` is likely a DOM element.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
	     * @example
	     *
	     * _.isElement(document.body);
	     * // => true
	     *
	     * _.isElement('<body>');
	     * // => false
	     */
	    function isElement(value) {
	      return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
	    }
	
	    /**
	     * Checks if `value` is an empty object, collection, map, or set.
	     *
	     * Objects are considered empty if they have no own enumerable string keyed
	     * properties.
	     *
	     * Array-like values such as `arguments` objects, arrays, buffers, strings, or
	     * jQuery-like collections are considered empty if they have a `length` of `0`.
	     * Similarly, maps and sets are considered empty if they have a `size` of `0`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is empty, else `false`.
	     * @example
	     *
	     * _.isEmpty(null);
	     * // => true
	     *
	     * _.isEmpty(true);
	     * // => true
	     *
	     * _.isEmpty(1);
	     * // => true
	     *
	     * _.isEmpty([1, 2, 3]);
	     * // => false
	     *
	     * _.isEmpty({ 'a': 1 });
	     * // => false
	     */
	    function isEmpty(value) {
	      if (value == null) {
	        return true;
	      }
	      if (isArrayLike(value) &&
	          (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||
	            isBuffer(value) || isTypedArray(value) || isArguments(value))) {
	        return !value.length;
	      }
	      var tag = getTag(value);
	      if (tag == mapTag || tag == setTag) {
	        return !value.size;
	      }
	      if (isPrototype(value)) {
	        return !baseKeys(value).length;
	      }
	      for (var key in value) {
	        if (hasOwnProperty.call(value, key)) {
	          return false;
	        }
	      }
	      return true;
	    }
	
	    /**
	     * Performs a deep comparison between two values to determine if they are
	     * equivalent.
	     *
	     * **Note:** This method supports comparing arrays, array buffers, booleans,
	     * date objects, error objects, maps, numbers, `Object` objects, regexes,
	     * sets, strings, symbols, and typed arrays. `Object` objects are compared
	     * by their own, not inherited, enumerable properties. Functions and DOM
	     * nodes are **not** supported.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	     * @example
	     *
	     * var object = { 'a': 1 };
	     * var other = { 'a': 1 };
	     *
	     * _.isEqual(object, other);
	     * // => true
	     *
	     * object === other;
	     * // => false
	     */
	    function isEqual(value, other) {
	      return baseIsEqual(value, other);
	    }
	
	    /**
	     * This method is like `_.isEqual` except that it accepts `customizer` which
	     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
	     * are handled by the method instead. The `customizer` is invoked with up to
	     * six arguments: (objValue, othValue [, index|key, object, other, stack]).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @param {Function} [customizer] The function to customize comparisons.
	     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	     * @example
	     *
	     * function isGreeting(value) {
	     *   return /^h(?:i|ello)$/.test(value);
	     * }
	     *
	     * function customizer(objValue, othValue) {
	     *   if (isGreeting(objValue) && isGreeting(othValue)) {
	     *     return true;
	     *   }
	     * }
	     *
	     * var array = ['hello', 'goodbye'];
	     * var other = ['hi', 'goodbye'];
	     *
	     * _.isEqualWith(array, other, customizer);
	     * // => true
	     */
	    function isEqualWith(value, other, customizer) {
	      customizer = typeof customizer == 'function' ? customizer : undefined;
	      var result = customizer ? customizer(value, other) : undefined;
	      return result === undefined ? baseIsEqual(value, other, undefined, customizer) : !!result;
	    }
	
	    /**
	     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
	     * `SyntaxError`, `TypeError`, or `URIError` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
	     * @example
	     *
	     * _.isError(new Error);
	     * // => true
	     *
	     * _.isError(Error);
	     * // => false
	     */
	    function isError(value) {
	      if (!isObjectLike(value)) {
	        return false;
	      }
	      var tag = baseGetTag(value);
	      return tag == errorTag || tag == domExcTag ||
	        (typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value));
	    }
	
	    /**
	     * Checks if `value` is a finite primitive number.
	     *
	     * **Note:** This method is based on
	     * [`Number.isFinite`](https://mdn.io/Number/isFinite).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
	     * @example
	     *
	     * _.isFinite(3);
	     * // => true
	     *
	     * _.isFinite(Number.MIN_VALUE);
	     * // => true
	     *
	     * _.isFinite(Infinity);
	     * // => false
	     *
	     * _.isFinite('3');
	     * // => false
	     */
	    function isFinite(value) {
	      return typeof value == 'number' && nativeIsFinite(value);
	    }
	
	    /**
	     * Checks if `value` is classified as a `Function` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
	     * @example
	     *
	     * _.isFunction(_);
	     * // => true
	     *
	     * _.isFunction(/abc/);
	     * // => false
	     */
	    function isFunction(value) {
	      if (!isObject(value)) {
	        return false;
	      }
	      // The use of `Object#toString` avoids issues with the `typeof` operator
	      // in Safari 9 which returns 'object' for typed arrays and other constructors.
	      var tag = baseGetTag(value);
	      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
	    }
	
	    /**
	     * Checks if `value` is an integer.
	     *
	     * **Note:** This method is based on
	     * [`Number.isInteger`](https://mdn.io/Number/isInteger).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
	     * @example
	     *
	     * _.isInteger(3);
	     * // => true
	     *
	     * _.isInteger(Number.MIN_VALUE);
	     * // => false
	     *
	     * _.isInteger(Infinity);
	     * // => false
	     *
	     * _.isInteger('3');
	     * // => false
	     */
	    function isInteger(value) {
	      return typeof value == 'number' && value == toInteger(value);
	    }
	
	    /**
	     * Checks if `value` is a valid array-like length.
	     *
	     * **Note:** This method is loosely based on
	     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	     * @example
	     *
	     * _.isLength(3);
	     * // => true
	     *
	     * _.isLength(Number.MIN_VALUE);
	     * // => false
	     *
	     * _.isLength(Infinity);
	     * // => false
	     *
	     * _.isLength('3');
	     * // => false
	     */
	    function isLength(value) {
	      return typeof value == 'number' &&
	        value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	    }
	
	    /**
	     * Checks if `value` is the
	     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	     * @example
	     *
	     * _.isObject({});
	     * // => true
	     *
	     * _.isObject([1, 2, 3]);
	     * // => true
	     *
	     * _.isObject(_.noop);
	     * // => true
	     *
	     * _.isObject(null);
	     * // => false
	     */
	    function isObject(value) {
	      var type = typeof value;
	      return value != null && (type == 'object' || type == 'function');
	    }
	
	    /**
	     * Checks if `value` is object-like. A value is object-like if it's not `null`
	     * and has a `typeof` result of "object".
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	     * @example
	     *
	     * _.isObjectLike({});
	     * // => true
	     *
	     * _.isObjectLike([1, 2, 3]);
	     * // => true
	     *
	     * _.isObjectLike(_.noop);
	     * // => false
	     *
	     * _.isObjectLike(null);
	     * // => false
	     */
	    function isObjectLike(value) {
	      return value != null && typeof value == 'object';
	    }
	
	    /**
	     * Checks if `value` is classified as a `Map` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.3.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
	     * @example
	     *
	     * _.isMap(new Map);
	     * // => true
	     *
	     * _.isMap(new WeakMap);
	     * // => false
	     */
	    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
	
	    /**
	     * Performs a partial deep comparison between `object` and `source` to
	     * determine if `object` contains equivalent property values.
	     *
	     * **Note:** This method is equivalent to `_.matches` when `source` is
	     * partially applied.
	     *
	     * Partial comparisons will match empty array and empty object `source`
	     * values against any array or object value, respectively. See `_.isEqual`
	     * for a list of supported value comparisons.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Lang
	     * @param {Object} object The object to inspect.
	     * @param {Object} source The object of property values to match.
	     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': 2 };
	     *
	     * _.isMatch(object, { 'b': 2 });
	     * // => true
	     *
	     * _.isMatch(object, { 'b': 1 });
	     * // => false
	     */
	    function isMatch(object, source) {
	      return object === source || baseIsMatch(object, source, getMatchData(source));
	    }
	
	    /**
	     * This method is like `_.isMatch` except that it accepts `customizer` which
	     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
	     * are handled by the method instead. The `customizer` is invoked with five
	     * arguments: (objValue, srcValue, index|key, object, source).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {Object} object The object to inspect.
	     * @param {Object} source The object of property values to match.
	     * @param {Function} [customizer] The function to customize comparisons.
	     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
	     * @example
	     *
	     * function isGreeting(value) {
	     *   return /^h(?:i|ello)$/.test(value);
	     * }
	     *
	     * function customizer(objValue, srcValue) {
	     *   if (isGreeting(objValue) && isGreeting(srcValue)) {
	     *     return true;
	     *   }
	     * }
	     *
	     * var object = { 'greeting': 'hello' };
	     * var source = { 'greeting': 'hi' };
	     *
	     * _.isMatchWith(object, source, customizer);
	     * // => true
	     */
	    function isMatchWith(object, source, customizer) {
	      customizer = typeof customizer == 'function' ? customizer : undefined;
	      return baseIsMatch(object, source, getMatchData(source), customizer);
	    }
	
	    /**
	     * Checks if `value` is `NaN`.
	     *
	     * **Note:** This method is based on
	     * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as
	     * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for
	     * `undefined` and other non-number values.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
	     * @example
	     *
	     * _.isNaN(NaN);
	     * // => true
	     *
	     * _.isNaN(new Number(NaN));
	     * // => true
	     *
	     * isNaN(undefined);
	     * // => true
	     *
	     * _.isNaN(undefined);
	     * // => false
	     */
	    function isNaN(value) {
	      // An `NaN` primitive is the only value that is not equal to itself.
	      // Perform the `toStringTag` check first to avoid errors with some
	      // ActiveX objects in IE.
	      return isNumber(value) && value != +value;
	    }
	
	    /**
	     * Checks if `value` is a pristine native function.
	     *
	     * **Note:** This method can't reliably detect native functions in the presence
	     * of the core-js package because core-js circumvents this kind of detection.
	     * Despite multiple requests, the core-js maintainer has made it clear: any
	     * attempt to fix the detection will be obstructed. As a result, we're left
	     * with little choice but to throw an error. Unfortunately, this also affects
	     * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),
	     * which rely on core-js.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a native function,
	     *  else `false`.
	     * @example
	     *
	     * _.isNative(Array.prototype.push);
	     * // => true
	     *
	     * _.isNative(_);
	     * // => false
	     */
	    function isNative(value) {
	      if (isMaskable(value)) {
	        throw new Error(CORE_ERROR_TEXT);
	      }
	      return baseIsNative(value);
	    }
	
	    /**
	     * Checks if `value` is `null`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
	     * @example
	     *
	     * _.isNull(null);
	     * // => true
	     *
	     * _.isNull(void 0);
	     * // => false
	     */
	    function isNull(value) {
	      return value === null;
	    }
	
	    /**
	     * Checks if `value` is `null` or `undefined`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
	     * @example
	     *
	     * _.isNil(null);
	     * // => true
	     *
	     * _.isNil(void 0);
	     * // => true
	     *
	     * _.isNil(NaN);
	     * // => false
	     */
	    function isNil(value) {
	      return value == null;
	    }
	
	    /**
	     * Checks if `value` is classified as a `Number` primitive or object.
	     *
	     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
	     * classified as numbers, use the `_.isFinite` method.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a number, else `false`.
	     * @example
	     *
	     * _.isNumber(3);
	     * // => true
	     *
	     * _.isNumber(Number.MIN_VALUE);
	     * // => true
	     *
	     * _.isNumber(Infinity);
	     * // => true
	     *
	     * _.isNumber('3');
	     * // => false
	     */
	    function isNumber(value) {
	      return typeof value == 'number' ||
	        (isObjectLike(value) && baseGetTag(value) == numberTag);
	    }
	
	    /**
	     * Checks if `value` is a plain object, that is, an object created by the
	     * `Object` constructor or one with a `[[Prototype]]` of `null`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.8.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     * }
	     *
	     * _.isPlainObject(new Foo);
	     * // => false
	     *
	     * _.isPlainObject([1, 2, 3]);
	     * // => false
	     *
	     * _.isPlainObject({ 'x': 0, 'y': 0 });
	     * // => true
	     *
	     * _.isPlainObject(Object.create(null));
	     * // => true
	     */
	    function isPlainObject(value) {
	      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
	        return false;
	      }
	      var proto = getPrototype(value);
	      if (proto === null) {
	        return true;
	      }
	      var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
	      return typeof Ctor == 'function' && Ctor instanceof Ctor &&
	        funcToString.call(Ctor) == objectCtorString;
	    }
	
	    /**
	     * Checks if `value` is classified as a `RegExp` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
	     * @example
	     *
	     * _.isRegExp(/abc/);
	     * // => true
	     *
	     * _.isRegExp('/abc/');
	     * // => false
	     */
	    var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
	
	    /**
	     * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754
	     * double precision number which isn't the result of a rounded unsafe integer.
	     *
	     * **Note:** This method is based on
	     * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.
	     * @example
	     *
	     * _.isSafeInteger(3);
	     * // => true
	     *
	     * _.isSafeInteger(Number.MIN_VALUE);
	     * // => false
	     *
	     * _.isSafeInteger(Infinity);
	     * // => false
	     *
	     * _.isSafeInteger('3');
	     * // => false
	     */
	    function isSafeInteger(value) {
	      return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
	    }
	
	    /**
	     * Checks if `value` is classified as a `Set` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.3.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
	     * @example
	     *
	     * _.isSet(new Set);
	     * // => true
	     *
	     * _.isSet(new WeakSet);
	     * // => false
	     */
	    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
	
	    /**
	     * Checks if `value` is classified as a `String` primitive or object.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a string, else `false`.
	     * @example
	     *
	     * _.isString('abc');
	     * // => true
	     *
	     * _.isString(1);
	     * // => false
	     */
	    function isString(value) {
	      return typeof value == 'string' ||
	        (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
	    }
	
	    /**
	     * Checks if `value` is classified as a `Symbol` primitive or object.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
	     * @example
	     *
	     * _.isSymbol(Symbol.iterator);
	     * // => true
	     *
	     * _.isSymbol('abc');
	     * // => false
	     */
	    function isSymbol(value) {
	      return typeof value == 'symbol' ||
	        (isObjectLike(value) && baseGetTag(value) == symbolTag);
	    }
	
	    /**
	     * Checks if `value` is classified as a typed array.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	     * @example
	     *
	     * _.isTypedArray(new Uint8Array);
	     * // => true
	     *
	     * _.isTypedArray([]);
	     * // => false
	     */
	    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
	
	    /**
	     * Checks if `value` is `undefined`.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
	     * @example
	     *
	     * _.isUndefined(void 0);
	     * // => true
	     *
	     * _.isUndefined(null);
	     * // => false
	     */
	    function isUndefined(value) {
	      return value === undefined;
	    }
	
	    /**
	     * Checks if `value` is classified as a `WeakMap` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.3.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.
	     * @example
	     *
	     * _.isWeakMap(new WeakMap);
	     * // => true
	     *
	     * _.isWeakMap(new Map);
	     * // => false
	     */
	    function isWeakMap(value) {
	      return isObjectLike(value) && getTag(value) == weakMapTag;
	    }
	
	    /**
	     * Checks if `value` is classified as a `WeakSet` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.3.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.
	     * @example
	     *
	     * _.isWeakSet(new WeakSet);
	     * // => true
	     *
	     * _.isWeakSet(new Set);
	     * // => false
	     */
	    function isWeakSet(value) {
	      return isObjectLike(value) && baseGetTag(value) == weakSetTag;
	    }
	
	    /**
	     * Checks if `value` is less than `other`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.9.0
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if `value` is less than `other`,
	     *  else `false`.
	     * @see _.gt
	     * @example
	     *
	     * _.lt(1, 3);
	     * // => true
	     *
	     * _.lt(3, 3);
	     * // => false
	     *
	     * _.lt(3, 1);
	     * // => false
	     */
	    var lt = createRelationalOperation(baseLt);
	
	    /**
	     * Checks if `value` is less than or equal to `other`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.9.0
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if `value` is less than or equal to
	     *  `other`, else `false`.
	     * @see _.gte
	     * @example
	     *
	     * _.lte(1, 3);
	     * // => true
	     *
	     * _.lte(3, 3);
	     * // => true
	     *
	     * _.lte(3, 1);
	     * // => false
	     */
	    var lte = createRelationalOperation(function(value, other) {
	      return value <= other;
	    });
	
	    /**
	     * Converts `value` to an array.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {Array} Returns the converted array.
	     * @example
	     *
	     * _.toArray({ 'a': 1, 'b': 2 });
	     * // => [1, 2]
	     *
	     * _.toArray('abc');
	     * // => ['a', 'b', 'c']
	     *
	     * _.toArray(1);
	     * // => []
	     *
	     * _.toArray(null);
	     * // => []
	     */
	    function toArray(value) {
	      if (!value) {
	        return [];
	      }
	      if (isArrayLike(value)) {
	        return isString(value) ? stringToArray(value) : copyArray(value);
	      }
	      if (symIterator && value[symIterator]) {
	        return iteratorToArray(value[symIterator]());
	      }
	      var tag = getTag(value),
	          func = tag == mapTag ? mapToArray : (tag == setTag ? setToArray : values);
	
	      return func(value);
	    }
	
	    /**
	     * Converts `value` to a finite number.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.12.0
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {number} Returns the converted number.
	     * @example
	     *
	     * _.toFinite(3.2);
	     * // => 3.2
	     *
	     * _.toFinite(Number.MIN_VALUE);
	     * // => 5e-324
	     *
	     * _.toFinite(Infinity);
	     * // => 1.7976931348623157e+308
	     *
	     * _.toFinite('3.2');
	     * // => 3.2
	     */
	    function toFinite(value) {
	      if (!value) {
	        return value === 0 ? value : 0;
	      }
	      value = toNumber(value);
	      if (value === INFINITY || value === -INFINITY) {
	        var sign = (value < 0 ? -1 : 1);
	        return sign * MAX_INTEGER;
	      }
	      return value === value ? value : 0;
	    }
	
	    /**
	     * Converts `value` to an integer.
	     *
	     * **Note:** This method is loosely based on
	     * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {number} Returns the converted integer.
	     * @example
	     *
	     * _.toInteger(3.2);
	     * // => 3
	     *
	     * _.toInteger(Number.MIN_VALUE);
	     * // => 0
	     *
	     * _.toInteger(Infinity);
	     * // => 1.7976931348623157e+308
	     *
	     * _.toInteger('3.2');
	     * // => 3
	     */
	    function toInteger(value) {
	      var result = toFinite(value),
	          remainder = result % 1;
	
	      return result === result ? (remainder ? result - remainder : result) : 0;
	    }
	
	    /**
	     * Converts `value` to an integer suitable for use as the length of an
	     * array-like object.
	     *
	     * **Note:** This method is based on
	     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {number} Returns the converted integer.
	     * @example
	     *
	     * _.toLength(3.2);
	     * // => 3
	     *
	     * _.toLength(Number.MIN_VALUE);
	     * // => 0
	     *
	     * _.toLength(Infinity);
	     * // => 4294967295
	     *
	     * _.toLength('3.2');
	     * // => 3
	     */
	    function toLength(value) {
	      return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
	    }
	
	    /**
	     * Converts `value` to a number.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to process.
	     * @returns {number} Returns the number.
	     * @example
	     *
	     * _.toNumber(3.2);
	     * // => 3.2
	     *
	     * _.toNumber(Number.MIN_VALUE);
	     * // => 5e-324
	     *
	     * _.toNumber(Infinity);
	     * // => Infinity
	     *
	     * _.toNumber('3.2');
	     * // => 3.2
	     */
	    function toNumber(value) {
	      if (typeof value == 'number') {
	        return value;
	      }
	      if (isSymbol(value)) {
	        return NAN;
	      }
	      if (isObject(value)) {
	        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
	        value = isObject(other) ? (other + '') : other;
	      }
	      if (typeof value != 'string') {
	        return value === 0 ? value : +value;
	      }
	      value = value.replace(reTrim, '');
	      var isBinary = reIsBinary.test(value);
	      return (isBinary || reIsOctal.test(value))
	        ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
	        : (reIsBadHex.test(value) ? NAN : +value);
	    }
	
	    /**
	     * Converts `value` to a plain object flattening inherited enumerable string
	     * keyed properties of `value` to own properties of the plain object.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {Object} Returns the converted plain object.
	     * @example
	     *
	     * function Foo() {
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.assign({ 'a': 1 }, new Foo);
	     * // => { 'a': 1, 'b': 2 }
	     *
	     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
	     * // => { 'a': 1, 'b': 2, 'c': 3 }
	     */
	    function toPlainObject(value) {
	      return copyObject(value, keysIn(value));
	    }
	
	    /**
	     * Converts `value` to a safe integer. A safe integer can be compared and
	     * represented correctly.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {number} Returns the converted integer.
	     * @example
	     *
	     * _.toSafeInteger(3.2);
	     * // => 3
	     *
	     * _.toSafeInteger(Number.MIN_VALUE);
	     * // => 0
	     *
	     * _.toSafeInteger(Infinity);
	     * // => 9007199254740991
	     *
	     * _.toSafeInteger('3.2');
	     * // => 3
	     */
	    function toSafeInteger(value) {
	      return baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
	    }
	
	    /**
	     * Converts `value` to a string. An empty string is returned for `null`
	     * and `undefined` values. The sign of `-0` is preserved.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {string} Returns the converted string.
	     * @example
	     *
	     * _.toString(null);
	     * // => ''
	     *
	     * _.toString(-0);
	     * // => '-0'
	     *
	     * _.toString([1, 2, 3]);
	     * // => '1,2,3'
	     */
	    function toString(value) {
	      return value == null ? '' : baseToString(value);
	    }
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * Assigns own enumerable string keyed properties of source objects to the
	     * destination object. Source objects are applied from left to right.
	     * Subsequent sources overwrite property assignments of previous sources.
	     *
	     * **Note:** This method mutates `object` and is loosely based on
	     * [`Object.assign`](https://mdn.io/Object/assign).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.10.0
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} [sources] The source objects.
	     * @returns {Object} Returns `object`.
	     * @see _.assignIn
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     * }
	     *
	     * function Bar() {
	     *   this.c = 3;
	     * }
	     *
	     * Foo.prototype.b = 2;
	     * Bar.prototype.d = 4;
	     *
	     * _.assign({ 'a': 0 }, new Foo, new Bar);
	     * // => { 'a': 1, 'c': 3 }
	     */
	    var assign = createAssigner(function(object, source) {
	      if (isPrototype(source) || isArrayLike(source)) {
	        copyObject(source, keys(source), object);
	        return;
	      }
	      for (var key in source) {
	        if (hasOwnProperty.call(source, key)) {
	          assignValue(object, key, source[key]);
	        }
	      }
	    });
	
	    /**
	     * This method is like `_.assign` except that it iterates over own and
	     * inherited source properties.
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @alias extend
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} [sources] The source objects.
	     * @returns {Object} Returns `object`.
	     * @see _.assign
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     * }
	     *
	     * function Bar() {
	     *   this.c = 3;
	     * }
	     *
	     * Foo.prototype.b = 2;
	     * Bar.prototype.d = 4;
	     *
	     * _.assignIn({ 'a': 0 }, new Foo, new Bar);
	     * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
	     */
	    var assignIn = createAssigner(function(object, source) {
	      copyObject(source, keysIn(source), object);
	    });
	
	    /**
	     * This method is like `_.assignIn` except that it accepts `customizer`
	     * which is invoked to produce the assigned values. If `customizer` returns
	     * `undefined`, assignment is handled by the method instead. The `customizer`
	     * is invoked with five arguments: (objValue, srcValue, key, object, source).
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @alias extendWith
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} sources The source objects.
	     * @param {Function} [customizer] The function to customize assigned values.
	     * @returns {Object} Returns `object`.
	     * @see _.assignWith
	     * @example
	     *
	     * function customizer(objValue, srcValue) {
	     *   return _.isUndefined(objValue) ? srcValue : objValue;
	     * }
	     *
	     * var defaults = _.partialRight(_.assignInWith, customizer);
	     *
	     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
	     * // => { 'a': 1, 'b': 2 }
	     */
	    var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
	      copyObject(source, keysIn(source), object, customizer);
	    });
	
	    /**
	     * This method is like `_.assign` except that it accepts `customizer`
	     * which is invoked to produce the assigned values. If `customizer` returns
	     * `undefined`, assignment is handled by the method instead. The `customizer`
	     * is invoked with five arguments: (objValue, srcValue, key, object, source).
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} sources The source objects.
	     * @param {Function} [customizer] The function to customize assigned values.
	     * @returns {Object} Returns `object`.
	     * @see _.assignInWith
	     * @example
	     *
	     * function customizer(objValue, srcValue) {
	     *   return _.isUndefined(objValue) ? srcValue : objValue;
	     * }
	     *
	     * var defaults = _.partialRight(_.assignWith, customizer);
	     *
	     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
	     * // => { 'a': 1, 'b': 2 }
	     */
	    var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
	      copyObject(source, keys(source), object, customizer);
	    });
	
	    /**
	     * Creates an array of values corresponding to `paths` of `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.0.0
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {...(string|string[])} [paths] The property paths to pick.
	     * @returns {Array} Returns the picked values.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
	     *
	     * _.at(object, ['a[0].b.c', 'a[1]']);
	     * // => [3, 4]
	     */
	    var at = flatRest(baseAt);
	
	    /**
	     * Creates an object that inherits from the `prototype` object. If a
	     * `properties` object is given, its own enumerable string keyed properties
	     * are assigned to the created object.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.3.0
	     * @category Object
	     * @param {Object} prototype The object to inherit from.
	     * @param {Object} [properties] The properties to assign to the object.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * function Shape() {
	     *   this.x = 0;
	     *   this.y = 0;
	     * }
	     *
	     * function Circle() {
	     *   Shape.call(this);
	     * }
	     *
	     * Circle.prototype = _.create(Shape.prototype, {
	     *   'constructor': Circle
	     * });
	     *
	     * var circle = new Circle;
	     * circle instanceof Circle;
	     * // => true
	     *
	     * circle instanceof Shape;
	     * // => true
	     */
	    function create(prototype, properties) {
	      var result = baseCreate(prototype);
	      return properties == null ? result : baseAssign(result, properties);
	    }
	
	    /**
	     * Assigns own and inherited enumerable string keyed properties of source
	     * objects to the destination object for all destination properties that
	     * resolve to `undefined`. Source objects are applied from left to right.
	     * Once a property is set, additional values of the same property are ignored.
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} [sources] The source objects.
	     * @returns {Object} Returns `object`.
	     * @see _.defaultsDeep
	     * @example
	     *
	     * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
	     * // => { 'a': 1, 'b': 2 }
	     */
	    var defaults = baseRest(function(args) {
	      args.push(undefined, assignInDefaults);
	      return apply(assignInWith, undefined, args);
	    });
	
	    /**
	     * This method is like `_.defaults` except that it recursively assigns
	     * default properties.
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.10.0
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} [sources] The source objects.
	     * @returns {Object} Returns `object`.
	     * @see _.defaults
	     * @example
	     *
	     * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });
	     * // => { 'a': { 'b': 2, 'c': 3 } }
	     */
	    var defaultsDeep = baseRest(function(args) {
	      args.push(undefined, mergeDefaults);
	      return apply(mergeWith, undefined, args);
	    });
	
	    /**
	     * This method is like `_.find` except that it returns the key of the first
	     * element `predicate` returns truthy for instead of the element itself.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.1.0
	     * @category Object
	     * @param {Object} object The object to inspect.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {string|undefined} Returns the key of the matched element,
	     *  else `undefined`.
	     * @example
	     *
	     * var users = {
	     *   'barney':  { 'age': 36, 'active': true },
	     *   'fred':    { 'age': 40, 'active': false },
	     *   'pebbles': { 'age': 1,  'active': true }
	     * };
	     *
	     * _.findKey(users, function(o) { return o.age < 40; });
	     * // => 'barney' (iteration order is not guaranteed)
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.findKey(users, { 'age': 1, 'active': true });
	     * // => 'pebbles'
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.findKey(users, ['active', false]);
	     * // => 'fred'
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.findKey(users, 'active');
	     * // => 'barney'
	     */
	    function findKey(object, predicate) {
	      return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
	    }
	
	    /**
	     * This method is like `_.findKey` except that it iterates over elements of
	     * a collection in the opposite order.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Object
	     * @param {Object} object The object to inspect.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {string|undefined} Returns the key of the matched element,
	     *  else `undefined`.
	     * @example
	     *
	     * var users = {
	     *   'barney':  { 'age': 36, 'active': true },
	     *   'fred':    { 'age': 40, 'active': false },
	     *   'pebbles': { 'age': 1,  'active': true }
	     * };
	     *
	     * _.findLastKey(users, function(o) { return o.age < 40; });
	     * // => returns 'pebbles' assuming `_.findKey` returns 'barney'
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.findLastKey(users, { 'age': 36, 'active': true });
	     * // => 'barney'
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.findLastKey(users, ['active', false]);
	     * // => 'fred'
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.findLastKey(users, 'active');
	     * // => 'pebbles'
	     */
	    function findLastKey(object, predicate) {
	      return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
	    }
	
	    /**
	     * Iterates over own and inherited enumerable string keyed properties of an
	     * object and invokes `iteratee` for each property. The iteratee is invoked
	     * with three arguments: (value, key, object). Iteratee functions may exit
	     * iteration early by explicitly returning `false`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.3.0
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     * @see _.forInRight
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.forIn(new Foo, function(value, key) {
	     *   console.log(key);
	     * });
	     * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
	     */
	    function forIn(object, iteratee) {
	      return object == null
	        ? object
	        : baseFor(object, getIteratee(iteratee, 3), keysIn);
	    }
	
	    /**
	     * This method is like `_.forIn` except that it iterates over properties of
	     * `object` in the opposite order.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     * @see _.forIn
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.forInRight(new Foo, function(value, key) {
	     *   console.log(key);
	     * });
	     * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.
	     */
	    function forInRight(object, iteratee) {
	      return object == null
	        ? object
	        : baseForRight(object, getIteratee(iteratee, 3), keysIn);
	    }
	
	    /**
	     * Iterates over own enumerable string keyed properties of an object and
	     * invokes `iteratee` for each property. The iteratee is invoked with three
	     * arguments: (value, key, object). Iteratee functions may exit iteration
	     * early by explicitly returning `false`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.3.0
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     * @see _.forOwnRight
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.forOwn(new Foo, function(value, key) {
	     *   console.log(key);
	     * });
	     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
	     */
	    function forOwn(object, iteratee) {
	      return object && baseForOwn(object, getIteratee(iteratee, 3));
	    }
	
	    /**
	     * This method is like `_.forOwn` except that it iterates over properties of
	     * `object` in the opposite order.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     * @see _.forOwn
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.forOwnRight(new Foo, function(value, key) {
	     *   console.log(key);
	     * });
	     * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.
	     */
	    function forOwnRight(object, iteratee) {
	      return object && baseForOwnRight(object, getIteratee(iteratee, 3));
	    }
	
	    /**
	     * Creates an array of function property names from own enumerable properties
	     * of `object`.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to inspect.
	     * @returns {Array} Returns the function names.
	     * @see _.functionsIn
	     * @example
	     *
	     * function Foo() {
	     *   this.a = _.constant('a');
	     *   this.b = _.constant('b');
	     * }
	     *
	     * Foo.prototype.c = _.constant('c');
	     *
	     * _.functions(new Foo);
	     * // => ['a', 'b']
	     */
	    function functions(object) {
	      return object == null ? [] : baseFunctions(object, keys(object));
	    }
	
	    /**
	     * Creates an array of function property names from own and inherited
	     * enumerable properties of `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The object to inspect.
	     * @returns {Array} Returns the function names.
	     * @see _.functions
	     * @example
	     *
	     * function Foo() {
	     *   this.a = _.constant('a');
	     *   this.b = _.constant('b');
	     * }
	     *
	     * Foo.prototype.c = _.constant('c');
	     *
	     * _.functionsIn(new Foo);
	     * // => ['a', 'b', 'c']
	     */
	    function functionsIn(object) {
	      return object == null ? [] : baseFunctions(object, keysIn(object));
	    }
	
	    /**
	     * Gets the value at `path` of `object`. If the resolved value is
	     * `undefined`, the `defaultValue` is returned in its place.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.7.0
	     * @category Object
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path of the property to get.
	     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
	     * @returns {*} Returns the resolved value.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	     *
	     * _.get(object, 'a[0].b.c');
	     * // => 3
	     *
	     * _.get(object, ['a', '0', 'b', 'c']);
	     * // => 3
	     *
	     * _.get(object, 'a.b.c', 'default');
	     * // => 'default'
	     */
	    function get(object, path, defaultValue) {
	      var result = object == null ? undefined : baseGet(object, path);
	      return result === undefined ? defaultValue : result;
	    }
	
	    /**
	     * Checks if `path` is a direct property of `object`.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path to check.
	     * @returns {boolean} Returns `true` if `path` exists, else `false`.
	     * @example
	     *
	     * var object = { 'a': { 'b': 2 } };
	     * var other = _.create({ 'a': _.create({ 'b': 2 }) });
	     *
	     * _.has(object, 'a');
	     * // => true
	     *
	     * _.has(object, 'a.b');
	     * // => true
	     *
	     * _.has(object, ['a', 'b']);
	     * // => true
	     *
	     * _.has(other, 'a');
	     * // => false
	     */
	    function has(object, path) {
	      return object != null && hasPath(object, path, baseHas);
	    }
	
	    /**
	     * Checks if `path` is a direct or inherited property of `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path to check.
	     * @returns {boolean} Returns `true` if `path` exists, else `false`.
	     * @example
	     *
	     * var object = _.create({ 'a': _.create({ 'b': 2 }) });
	     *
	     * _.hasIn(object, 'a');
	     * // => true
	     *
	     * _.hasIn(object, 'a.b');
	     * // => true
	     *
	     * _.hasIn(object, ['a', 'b']);
	     * // => true
	     *
	     * _.hasIn(object, 'b');
	     * // => false
	     */
	    function hasIn(object, path) {
	      return object != null && hasPath(object, path, baseHasIn);
	    }
	
	    /**
	     * Creates an object composed of the inverted keys and values of `object`.
	     * If `object` contains duplicate values, subsequent values overwrite
	     * property assignments of previous values.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.7.0
	     * @category Object
	     * @param {Object} object The object to invert.
	     * @returns {Object} Returns the new inverted object.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': 2, 'c': 1 };
	     *
	     * _.invert(object);
	     * // => { '1': 'c', '2': 'b' }
	     */
	    var invert = createInverter(function(result, value, key) {
	      result[value] = key;
	    }, constant(identity));
	
	    /**
	     * This method is like `_.invert` except that the inverted object is generated
	     * from the results of running each element of `object` thru `iteratee`. The
	     * corresponding inverted value of each inverted key is an array of keys
	     * responsible for generating the inverted value. The iteratee is invoked
	     * with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.1.0
	     * @category Object
	     * @param {Object} object The object to invert.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {Object} Returns the new inverted object.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': 2, 'c': 1 };
	     *
	     * _.invertBy(object);
	     * // => { '1': ['a', 'c'], '2': ['b'] }
	     *
	     * _.invertBy(object, function(value) {
	     *   return 'group' + value;
	     * });
	     * // => { 'group1': ['a', 'c'], 'group2': ['b'] }
	     */
	    var invertBy = createInverter(function(result, value, key) {
	      if (hasOwnProperty.call(result, value)) {
	        result[value].push(key);
	      } else {
	        result[value] = [key];
	      }
	    }, getIteratee);
	
	    /**
	     * Invokes the method at `path` of `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path of the method to invoke.
	     * @param {...*} [args] The arguments to invoke the method with.
	     * @returns {*} Returns the result of the invoked method.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };
	     *
	     * _.invoke(object, 'a[0].b.c.slice', 1, 3);
	     * // => [2, 3]
	     */
	    var invoke = baseRest(baseInvoke);
	
	    /**
	     * Creates an array of the own enumerable property names of `object`.
	     *
	     * **Note:** Non-object values are coerced to objects. See the
	     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	     * for more details.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.keys(new Foo);
	     * // => ['a', 'b'] (iteration order is not guaranteed)
	     *
	     * _.keys('hi');
	     * // => ['0', '1']
	     */
	    function keys(object) {
	      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
	    }
	
	    /**
	     * Creates an array of the own and inherited enumerable property names of `object`.
	     *
	     * **Note:** Non-object values are coerced to objects.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.keysIn(new Foo);
	     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
	     */
	    function keysIn(object) {
	      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
	    }
	
	    /**
	     * The opposite of `_.mapValues`; this method creates an object with the
	     * same values as `object` and keys generated by running each own enumerable
	     * string keyed property of `object` thru `iteratee`. The iteratee is invoked
	     * with three arguments: (value, key, object).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.8.0
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Object} Returns the new mapped object.
	     * @see _.mapValues
	     * @example
	     *
	     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
	     *   return key + value;
	     * });
	     * // => { 'a1': 1, 'b2': 2 }
	     */
	    function mapKeys(object, iteratee) {
	      var result = {};
	      iteratee = getIteratee(iteratee, 3);
	
	      baseForOwn(object, function(value, key, object) {
	        baseAssignValue(result, iteratee(value, key, object), value);
	      });
	      return result;
	    }
	
	    /**
	     * Creates an object with the same keys as `object` and values generated
	     * by running each own enumerable string keyed property of `object` thru
	     * `iteratee`. The iteratee is invoked with three arguments:
	     * (value, key, object).
	     *
	     * @static
	     * @memberOf _
	     * @since 2.4.0
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Object} Returns the new mapped object.
	     * @see _.mapKeys
	     * @example
	     *
	     * var users = {
	     *   'fred':    { 'user': 'fred',    'age': 40 },
	     *   'pebbles': { 'user': 'pebbles', 'age': 1 }
	     * };
	     *
	     * _.mapValues(users, function(o) { return o.age; });
	     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.mapValues(users, 'age');
	     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
	     */
	    function mapValues(object, iteratee) {
	      var result = {};
	      iteratee = getIteratee(iteratee, 3);
	
	      baseForOwn(object, function(value, key, object) {
	        baseAssignValue(result, key, iteratee(value, key, object));
	      });
	      return result;
	    }
	
	    /**
	     * This method is like `_.assign` except that it recursively merges own and
	     * inherited enumerable string keyed properties of source objects into the
	     * destination object. Source properties that resolve to `undefined` are
	     * skipped if a destination value exists. Array and plain object properties
	     * are merged recursively. Other objects and value types are overridden by
	     * assignment. Source objects are applied from left to right. Subsequent
	     * sources overwrite property assignments of previous sources.
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.5.0
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} [sources] The source objects.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * var object = {
	     *   'a': [{ 'b': 2 }, { 'd': 4 }]
	     * };
	     *
	     * var other = {
	     *   'a': [{ 'c': 3 }, { 'e': 5 }]
	     * };
	     *
	     * _.merge(object, other);
	     * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
	     */
	    var merge = createAssigner(function(object, source, srcIndex) {
	      baseMerge(object, source, srcIndex);
	    });
	
	    /**
	     * This method is like `_.merge` except that it accepts `customizer` which
	     * is invoked to produce the merged values of the destination and source
	     * properties. If `customizer` returns `undefined`, merging is handled by the
	     * method instead. The `customizer` is invoked with six arguments:
	     * (objValue, srcValue, key, object, source, stack).
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} sources The source objects.
	     * @param {Function} customizer The function to customize assigned values.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * function customizer(objValue, srcValue) {
	     *   if (_.isArray(objValue)) {
	     *     return objValue.concat(srcValue);
	     *   }
	     * }
	     *
	     * var object = { 'a': [1], 'b': [2] };
	     * var other = { 'a': [3], 'b': [4] };
	     *
	     * _.mergeWith(object, other, customizer);
	     * // => { 'a': [1, 3], 'b': [2, 4] }
	     */
	    var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
	      baseMerge(object, source, srcIndex, customizer);
	    });
	
	    /**
	     * The opposite of `_.pick`; this method creates an object composed of the
	     * own and inherited enumerable property paths of `object` that are not omitted.
	     *
	     * **Note:** This method is considerably slower than `_.pick`.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The source object.
	     * @param {...(string|string[])} [paths] The property paths to omit.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': '2', 'c': 3 };
	     *
	     * _.omit(object, ['a', 'c']);
	     * // => { 'b': '2' }
	     */
	    var omit = flatRest(function(object, paths) {
	      var result = {};
	      if (object == null) {
	        return result;
	      }
	      var isDeep = false;
	      paths = arrayMap(paths, function(path) {
	        path = castPath(path, object);
	        isDeep || (isDeep = path.length > 1);
	        return path;
	      });
	      copyObject(object, getAllKeysIn(object), result);
	      if (isDeep) {
	        result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG);
	      }
	      var length = paths.length;
	      while (length--) {
	        baseUnset(result, paths[length]);
	      }
	      return result;
	    });
	
	    /**
	     * The opposite of `_.pickBy`; this method creates an object composed of
	     * the own and inherited enumerable string keyed properties of `object` that
	     * `predicate` doesn't return truthy for. The predicate is invoked with two
	     * arguments: (value, key).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The source object.
	     * @param {Function} [predicate=_.identity] The function invoked per property.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': '2', 'c': 3 };
	     *
	     * _.omitBy(object, _.isNumber);
	     * // => { 'b': '2' }
	     */
	    function omitBy(object, predicate) {
	      return pickBy(object, negate(getIteratee(predicate)));
	    }
	
	    /**
	     * Creates an object composed of the picked `object` properties.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The source object.
	     * @param {...(string|string[])} [paths] The property paths to pick.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': '2', 'c': 3 };
	     *
	     * _.pick(object, ['a', 'c']);
	     * // => { 'a': 1, 'c': 3 }
	     */
	    var pick = flatRest(function(object, paths) {
	      return object == null ? {} : basePick(object, paths);
	    });
	
	    /**
	     * Creates an object composed of the `object` properties `predicate` returns
	     * truthy for. The predicate is invoked with two arguments: (value, key).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The source object.
	     * @param {Function} [predicate=_.identity] The function invoked per property.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': '2', 'c': 3 };
	     *
	     * _.pickBy(object, _.isNumber);
	     * // => { 'a': 1, 'c': 3 }
	     */
	    function pickBy(object, predicate) {
	      if (object == null) {
	        return {};
	      }
	      var props = arrayMap(getAllKeysIn(object), function(prop) {
	        return [prop];
	      });
	      predicate = getIteratee(predicate);
	      return basePickBy(object, props, function(value, path) {
	        return predicate(value, path[0]);
	      });
	    }
	
	    /**
	     * This method is like `_.get` except that if the resolved value is a
	     * function it's invoked with the `this` binding of its parent object and
	     * its result is returned.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path of the property to resolve.
	     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
	     * @returns {*} Returns the resolved value.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
	     *
	     * _.result(object, 'a[0].b.c1');
	     * // => 3
	     *
	     * _.result(object, 'a[0].b.c2');
	     * // => 4
	     *
	     * _.result(object, 'a[0].b.c3', 'default');
	     * // => 'default'
	     *
	     * _.result(object, 'a[0].b.c3', _.constant('default'));
	     * // => 'default'
	     */
	    function result(object, path, defaultValue) {
	      path = castPath(path, object);
	
	      var index = -1,
	          length = path.length;
	
	      // Ensure the loop is entered when path is empty.
	      if (!length) {
	        length = 1;
	        object = undefined;
	      }
	      while (++index < length) {
	        var value = object == null ? undefined : object[toKey(path[index])];
	        if (value === undefined) {
	          index = length;
	          value = defaultValue;
	        }
	        object = isFunction(value) ? value.call(object) : value;
	      }
	      return object;
	    }
	
	    /**
	     * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
	     * it's created. Arrays are created for missing index properties while objects
	     * are created for all other missing properties. Use `_.setWith` to customize
	     * `path` creation.
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.7.0
	     * @category Object
	     * @param {Object} object The object to modify.
	     * @param {Array|string} path The path of the property to set.
	     * @param {*} value The value to set.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	     *
	     * _.set(object, 'a[0].b.c', 4);
	     * console.log(object.a[0].b.c);
	     * // => 4
	     *
	     * _.set(object, ['x', '0', 'y', 'z'], 5);
	     * console.log(object.x[0].y.z);
	     * // => 5
	     */
	    function set(object, path, value) {
	      return object == null ? object : baseSet(object, path, value);
	    }
	
	    /**
	     * This method is like `_.set` except that it accepts `customizer` which is
	     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
	     * path creation is handled by the method instead. The `customizer` is invoked
	     * with three arguments: (nsValue, key, nsObject).
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The object to modify.
	     * @param {Array|string} path The path of the property to set.
	     * @param {*} value The value to set.
	     * @param {Function} [customizer] The function to customize assigned values.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * var object = {};
	     *
	     * _.setWith(object, '[0][1]', 'a', Object);
	     * // => { '0': { '1': 'a' } }
	     */
	    function setWith(object, path, value, customizer) {
	      customizer = typeof customizer == 'function' ? customizer : undefined;
	      return object == null ? object : baseSet(object, path, value, customizer);
	    }
	
	    /**
	     * Creates an array of own enumerable string keyed-value pairs for `object`
	     * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
	     * entries are returned.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @alias entries
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the key-value pairs.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.toPairs(new Foo);
	     * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
	     */
	    var toPairs = createToPairs(keys);
	
	    /**
	     * Creates an array of own and inherited enumerable string keyed-value pairs
	     * for `object` which can be consumed by `_.fromPairs`. If `object` is a map
	     * or set, its entries are returned.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @alias entriesIn
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the key-value pairs.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.toPairsIn(new Foo);
	     * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)
	     */
	    var toPairsIn = createToPairs(keysIn);
	
	    /**
	     * An alternative to `_.reduce`; this method transforms `object` to a new
	     * `accumulator` object which is the result of running each of its own
	     * enumerable string keyed properties thru `iteratee`, with each invocation
	     * potentially mutating the `accumulator` object. If `accumulator` is not
	     * provided, a new object with the same `[[Prototype]]` will be used. The
	     * iteratee is invoked with four arguments: (accumulator, value, key, object).
	     * Iteratee functions may exit iteration early by explicitly returning `false`.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.3.0
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [accumulator] The custom accumulator value.
	     * @returns {*} Returns the accumulated value.
	     * @example
	     *
	     * _.transform([2, 3, 4], function(result, n) {
	     *   result.push(n *= n);
	     *   return n % 2 == 0;
	     * }, []);
	     * // => [4, 9]
	     *
	     * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
	     *   (result[value] || (result[value] = [])).push(key);
	     * }, {});
	     * // => { '1': ['a', 'c'], '2': ['b'] }
	     */
	    function transform(object, iteratee, accumulator) {
	      var isArr = isArray(object),
	          isArrLike = isArr || isBuffer(object) || isTypedArray(object);
	
	      iteratee = getIteratee(iteratee, 4);
	      if (accumulator == null) {
	        var Ctor = object && object.constructor;
	        if (isArrLike) {
	          accumulator = isArr ? new Ctor : [];
	        }
	        else if (isObject(object)) {
	          accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
	        }
	        else {
	          accumulator = {};
	        }
	      }
	      (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object) {
	        return iteratee(accumulator, value, index, object);
	      });
	      return accumulator;
	    }
	
	    /**
	     * Removes the property at `path` of `object`.
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The object to modify.
	     * @param {Array|string} path The path of the property to unset.
	     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': 7 } }] };
	     * _.unset(object, 'a[0].b.c');
	     * // => true
	     *
	     * console.log(object);
	     * // => { 'a': [{ 'b': {} }] };
	     *
	     * _.unset(object, ['a', '0', 'b', 'c']);
	     * // => true
	     *
	     * console.log(object);
	     * // => { 'a': [{ 'b': {} }] };
	     */
	    function unset(object, path) {
	      return object == null ? true : baseUnset(object, path);
	    }
	
	    /**
	     * This method is like `_.set` except that accepts `updater` to produce the
	     * value to set. Use `_.updateWith` to customize `path` creation. The `updater`
	     * is invoked with one argument: (value).
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.6.0
	     * @category Object
	     * @param {Object} object The object to modify.
	     * @param {Array|string} path The path of the property to set.
	     * @param {Function} updater The function to produce the updated value.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	     *
	     * _.update(object, 'a[0].b.c', function(n) { return n * n; });
	     * console.log(object.a[0].b.c);
	     * // => 9
	     *
	     * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });
	     * console.log(object.x[0].y.z);
	     * // => 0
	     */
	    function update(object, path, updater) {
	      return object == null ? object : baseUpdate(object, path, castFunction(updater));
	    }
	
	    /**
	     * This method is like `_.update` except that it accepts `customizer` which is
	     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
	     * path creation is handled by the method instead. The `customizer` is invoked
	     * with three arguments: (nsValue, key, nsObject).
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.6.0
	     * @category Object
	     * @param {Object} object The object to modify.
	     * @param {Array|string} path The path of the property to set.
	     * @param {Function} updater The function to produce the updated value.
	     * @param {Function} [customizer] The function to customize assigned values.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * var object = {};
	     *
	     * _.updateWith(object, '[0][1]', _.constant('a'), Object);
	     * // => { '0': { '1': 'a' } }
	     */
	    function updateWith(object, path, updater, customizer) {
	      customizer = typeof customizer == 'function' ? customizer : undefined;
	      return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
	    }
	
	    /**
	     * Creates an array of the own enumerable string keyed property values of `object`.
	     *
	     * **Note:** Non-object values are coerced to objects.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property values.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.values(new Foo);
	     * // => [1, 2] (iteration order is not guaranteed)
	     *
	     * _.values('hi');
	     * // => ['h', 'i']
	     */
	    function values(object) {
	      return object == null ? [] : baseValues(object, keys(object));
	    }
	
	    /**
	     * Creates an array of the own and inherited enumerable string keyed property
	     * values of `object`.
	     *
	     * **Note:** Non-object values are coerced to objects.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property values.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.valuesIn(new Foo);
	     * // => [1, 2, 3] (iteration order is not guaranteed)
	     */
	    function valuesIn(object) {
	      return object == null ? [] : baseValues(object, keysIn(object));
	    }
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * Clamps `number` within the inclusive `lower` and `upper` bounds.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Number
	     * @param {number} number The number to clamp.
	     * @param {number} [lower] The lower bound.
	     * @param {number} upper The upper bound.
	     * @returns {number} Returns the clamped number.
	     * @example
	     *
	     * _.clamp(-10, -5, 5);
	     * // => -5
	     *
	     * _.clamp(10, -5, 5);
	     * // => 5
	     */
	    function clamp(number, lower, upper) {
	      if (upper === undefined) {
	        upper = lower;
	        lower = undefined;
	      }
	      if (upper !== undefined) {
	        upper = toNumber(upper);
	        upper = upper === upper ? upper : 0;
	      }
	      if (lower !== undefined) {
	        lower = toNumber(lower);
	        lower = lower === lower ? lower : 0;
	      }
	      return baseClamp(toNumber(number), lower, upper);
	    }
	
	    /**
	     * Checks if `n` is between `start` and up to, but not including, `end`. If
	     * `end` is not specified, it's set to `start` with `start` then set to `0`.
	     * If `start` is greater than `end` the params are swapped to support
	     * negative ranges.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.3.0
	     * @category Number
	     * @param {number} number The number to check.
	     * @param {number} [start=0] The start of the range.
	     * @param {number} end The end of the range.
	     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
	     * @see _.range, _.rangeRight
	     * @example
	     *
	     * _.inRange(3, 2, 4);
	     * // => true
	     *
	     * _.inRange(4, 8);
	     * // => true
	     *
	     * _.inRange(4, 2);
	     * // => false
	     *
	     * _.inRange(2, 2);
	     * // => false
	     *
	     * _.inRange(1.2, 2);
	     * // => true
	     *
	     * _.inRange(5.2, 4);
	     * // => false
	     *
	     * _.inRange(-3, -2, -6);
	     * // => true
	     */
	    function inRange(number, start, end) {
	      start = toFinite(start);
	      if (end === undefined) {
	        end = start;
	        start = 0;
	      } else {
	        end = toFinite(end);
	      }
	      number = toNumber(number);
	      return baseInRange(number, start, end);
	    }
	
	    /**
	     * Produces a random number between the inclusive `lower` and `upper` bounds.
	     * If only one argument is provided a number between `0` and the given number
	     * is returned. If `floating` is `true`, or either `lower` or `upper` are
	     * floats, a floating-point number is returned instead of an integer.
	     *
	     * **Note:** JavaScript follows the IEEE-754 standard for resolving
	     * floating-point values which can produce unexpected results.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.7.0
	     * @category Number
	     * @param {number} [lower=0] The lower bound.
	     * @param {number} [upper=1] The upper bound.
	     * @param {boolean} [floating] Specify returning a floating-point number.
	     * @returns {number} Returns the random number.
	     * @example
	     *
	     * _.random(0, 5);
	     * // => an integer between 0 and 5
	     *
	     * _.random(5);
	     * // => also an integer between 0 and 5
	     *
	     * _.random(5, true);
	     * // => a floating-point number between 0 and 5
	     *
	     * _.random(1.2, 5.2);
	     * // => a floating-point number between 1.2 and 5.2
	     */
	    function random(lower, upper, floating) {
	      if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) {
	        upper = floating = undefined;
	      }
	      if (floating === undefined) {
	        if (typeof upper == 'boolean') {
	          floating = upper;
	          upper = undefined;
	        }
	        else if (typeof lower == 'boolean') {
	          floating = lower;
	          lower = undefined;
	        }
	      }
	      if (lower === undefined && upper === undefined) {
	        lower = 0;
	        upper = 1;
	      }
	      else {
	        lower = toFinite(lower);
	        if (upper === undefined) {
	          upper = lower;
	          lower = 0;
	        } else {
	          upper = toFinite(upper);
	        }
	      }
	      if (lower > upper) {
	        var temp = lower;
	        lower = upper;
	        upper = temp;
	      }
	      if (floating || lower % 1 || upper % 1) {
	        var rand = nativeRandom();
	        return nativeMin(lower + (rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1)))), upper);
	      }
	      return baseRandom(lower, upper);
	    }
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the camel cased string.
	     * @example
	     *
	     * _.camelCase('Foo Bar');
	     * // => 'fooBar'
	     *
	     * _.camelCase('--foo-bar--');
	     * // => 'fooBar'
	     *
	     * _.camelCase('__FOO_BAR__');
	     * // => 'fooBar'
	     */
	    var camelCase = createCompounder(function(result, word, index) {
	      word = word.toLowerCase();
	      return result + (index ? capitalize(word) : word);
	    });
	
	    /**
	     * Converts the first character of `string` to upper case and the remaining
	     * to lower case.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to capitalize.
	     * @returns {string} Returns the capitalized string.
	     * @example
	     *
	     * _.capitalize('FRED');
	     * // => 'Fred'
	     */
	    function capitalize(string) {
	      return upperFirst(toString(string).toLowerCase());
	    }
	
	    /**
	     * Deburrs `string` by converting
	     * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
	     * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
	     * letters to basic Latin letters and removing
	     * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to deburr.
	     * @returns {string} Returns the deburred string.
	     * @example
	     *
	     * _.deburr('dj vu');
	     * // => 'deja vu'
	     */
	    function deburr(string) {
	      string = toString(string);
	      return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
	    }
	
	    /**
	     * Checks if `string` ends with the given target string.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to inspect.
	     * @param {string} [target] The string to search for.
	     * @param {number} [position=string.length] The position to search up to.
	     * @returns {boolean} Returns `true` if `string` ends with `target`,
	     *  else `false`.
	     * @example
	     *
	     * _.endsWith('abc', 'c');
	     * // => true
	     *
	     * _.endsWith('abc', 'b');
	     * // => false
	     *
	     * _.endsWith('abc', 'b', 2);
	     * // => true
	     */
	    function endsWith(string, target, position) {
	      string = toString(string);
	      target = baseToString(target);
	
	      var length = string.length;
	      position = position === undefined
	        ? length
	        : baseClamp(toInteger(position), 0, length);
	
	      var end = position;
	      position -= target.length;
	      return position >= 0 && string.slice(position, end) == target;
	    }
	
	    /**
	     * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
	     * corresponding HTML entities.
	     *
	     * **Note:** No other characters are escaped. To escape additional
	     * characters use a third-party library like [_he_](https://mths.be/he).
	     *
	     * Though the ">" character is escaped for symmetry, characters like
	     * ">" and "/" don't need escaping in HTML and have no special meaning
	     * unless they're part of a tag or unquoted attribute value. See
	     * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
	     * (under "semi-related fun fact") for more details.
	     *
	     * When working with HTML you should always
	     * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
	     * XSS vectors.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to escape.
	     * @returns {string} Returns the escaped string.
	     * @example
	     *
	     * _.escape('fred, barney, & pebbles');
	     * // => 'fred, barney, &amp; pebbles'
	     */
	    function escape(string) {
	      string = toString(string);
	      return (string && reHasUnescapedHtml.test(string))
	        ? string.replace(reUnescapedHtml, escapeHtmlChar)
	        : string;
	    }
	
	    /**
	     * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
	     * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to escape.
	     * @returns {string} Returns the escaped string.
	     * @example
	     *
	     * _.escapeRegExp('[lodash](https://lodash.com/)');
	     * // => '\[lodash\]\(https://lodash\.com/\)'
	     */
	    function escapeRegExp(string) {
	      string = toString(string);
	      return (string && reHasRegExpChar.test(string))
	        ? string.replace(reRegExpChar, '\\$&')
	        : string;
	    }
	
	    /**
	     * Converts `string` to
	     * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the kebab cased string.
	     * @example
	     *
	     * _.kebabCase('Foo Bar');
	     * // => 'foo-bar'
	     *
	     * _.kebabCase('fooBar');
	     * // => 'foo-bar'
	     *
	     * _.kebabCase('__FOO_BAR__');
	     * // => 'foo-bar'
	     */
	    var kebabCase = createCompounder(function(result, word, index) {
	      return result + (index ? '-' : '') + word.toLowerCase();
	    });
	
	    /**
	     * Converts `string`, as space separated words, to lower case.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the lower cased string.
	     * @example
	     *
	     * _.lowerCase('--Foo-Bar--');
	     * // => 'foo bar'
	     *
	     * _.lowerCase('fooBar');
	     * // => 'foo bar'
	     *
	     * _.lowerCase('__FOO_BAR__');
	     * // => 'foo bar'
	     */
	    var lowerCase = createCompounder(function(result, word, index) {
	      return result + (index ? ' ' : '') + word.toLowerCase();
	    });
	
	    /**
	     * Converts the first character of `string` to lower case.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the converted string.
	     * @example
	     *
	     * _.lowerFirst('Fred');
	     * // => 'fred'
	     *
	     * _.lowerFirst('FRED');
	     * // => 'fRED'
	     */
	    var lowerFirst = createCaseFirst('toLowerCase');
	
	    /**
	     * Pads `string` on the left and right sides if it's shorter than `length`.
	     * Padding characters are truncated if they can't be evenly divided by `length`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to pad.
	     * @param {number} [length=0] The padding length.
	     * @param {string} [chars=' '] The string used as padding.
	     * @returns {string} Returns the padded string.
	     * @example
	     *
	     * _.pad('abc', 8);
	     * // => '  abc   '
	     *
	     * _.pad('abc', 8, '_-');
	     * // => '_-abc_-_'
	     *
	     * _.pad('abc', 3);
	     * // => 'abc'
	     */
	    function pad(string, length, chars) {
	      string = toString(string);
	      length = toInteger(length);
	
	      var strLength = length ? stringSize(string) : 0;
	      if (!length || strLength >= length) {
	        return string;
	      }
	      var mid = (length - strLength) / 2;
	      return (
	        createPadding(nativeFloor(mid), chars) +
	        string +
	        createPadding(nativeCeil(mid), chars)
	      );
	    }
	
	    /**
	     * Pads `string` on the right side if it's shorter than `length`. Padding
	     * characters are truncated if they exceed `length`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to pad.
	     * @param {number} [length=0] The padding length.
	     * @param {string} [chars=' '] The string used as padding.
	     * @returns {string} Returns the padded string.
	     * @example
	     *
	     * _.padEnd('abc', 6);
	     * // => 'abc   '
	     *
	     * _.padEnd('abc', 6, '_-');
	     * // => 'abc_-_'
	     *
	     * _.padEnd('abc', 3);
	     * // => 'abc'
	     */
	    function padEnd(string, length, chars) {
	      string = toString(string);
	      length = toInteger(length);
	
	      var strLength = length ? stringSize(string) : 0;
	      return (length && strLength < length)
	        ? (string + createPadding(length - strLength, chars))
	        : string;
	    }
	
	    /**
	     * Pads `string` on the left side if it's shorter than `length`. Padding
	     * characters are truncated if they exceed `length`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to pad.
	     * @param {number} [length=0] The padding length.
	     * @param {string} [chars=' '] The string used as padding.
	     * @returns {string} Returns the padded string.
	     * @example
	     *
	     * _.padStart('abc', 6);
	     * // => '   abc'
	     *
	     * _.padStart('abc', 6, '_-');
	     * // => '_-_abc'
	     *
	     * _.padStart('abc', 3);
	     * // => 'abc'
	     */
	    function padStart(string, length, chars) {
	      string = toString(string);
	      length = toInteger(length);
	
	      var strLength = length ? stringSize(string) : 0;
	      return (length && strLength < length)
	        ? (createPadding(length - strLength, chars) + string)
	        : string;
	    }
	
	    /**
	     * Converts `string` to an integer of the specified radix. If `radix` is
	     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a
	     * hexadecimal, in which case a `radix` of `16` is used.
	     *
	     * **Note:** This method aligns with the
	     * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.1.0
	     * @category String
	     * @param {string} string The string to convert.
	     * @param {number} [radix=10] The radix to interpret `value` by.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {number} Returns the converted integer.
	     * @example
	     *
	     * _.parseInt('08');
	     * // => 8
	     *
	     * _.map(['6', '08', '10'], _.parseInt);
	     * // => [6, 8, 10]
	     */
	    function parseInt(string, radix, guard) {
	      if (guard || radix == null) {
	        radix = 0;
	      } else if (radix) {
	        radix = +radix;
	      }
	      return nativeParseInt(toString(string).replace(reTrimStart, ''), radix || 0);
	    }
	
	    /**
	     * Repeats the given string `n` times.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to repeat.
	     * @param {number} [n=1] The number of times to repeat the string.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {string} Returns the repeated string.
	     * @example
	     *
	     * _.repeat('*', 3);
	     * // => '***'
	     *
	     * _.repeat('abc', 2);
	     * // => 'abcabc'
	     *
	     * _.repeat('abc', 0);
	     * // => ''
	     */
	    function repeat(string, n, guard) {
	      if ((guard ? isIterateeCall(string, n, guard) : n === undefined)) {
	        n = 1;
	      } else {
	        n = toInteger(n);
	      }
	      return baseRepeat(toString(string), n);
	    }
	
	    /**
	     * Replaces matches for `pattern` in `string` with `replacement`.
	     *
	     * **Note:** This method is based on
	     * [`String#replace`](https://mdn.io/String/replace).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to modify.
	     * @param {RegExp|string} pattern The pattern to replace.
	     * @param {Function|string} replacement The match replacement.
	     * @returns {string} Returns the modified string.
	     * @example
	     *
	     * _.replace('Hi Fred', 'Fred', 'Barney');
	     * // => 'Hi Barney'
	     */
	    function replace() {
	      var args = arguments,
	          string = toString(args[0]);
	
	      return args.length < 3 ? string : string.replace(args[1], args[2]);
	    }
	
	    /**
	     * Converts `string` to
	     * [snake case](https://en.wikipedia.org/wiki/Snake_case).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the snake cased string.
	     * @example
	     *
	     * _.snakeCase('Foo Bar');
	     * // => 'foo_bar'
	     *
	     * _.snakeCase('fooBar');
	     * // => 'foo_bar'
	     *
	     * _.snakeCase('--FOO-BAR--');
	     * // => 'foo_bar'
	     */
	    var snakeCase = createCompounder(function(result, word, index) {
	      return result + (index ? '_' : '') + word.toLowerCase();
	    });
	
	    /**
	     * Splits `string` by `separator`.
	     *
	     * **Note:** This method is based on
	     * [`String#split`](https://mdn.io/String/split).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to split.
	     * @param {RegExp|string} separator The separator pattern to split by.
	     * @param {number} [limit] The length to truncate results to.
	     * @returns {Array} Returns the string segments.
	     * @example
	     *
	     * _.split('a-b-c', '-', 2);
	     * // => ['a', 'b']
	     */
	    function split(string, separator, limit) {
	      if (limit && typeof limit != 'number' && isIterateeCall(string, separator, limit)) {
	        separator = limit = undefined;
	      }
	      limit = limit === undefined ? MAX_ARRAY_LENGTH : limit >>> 0;
	      if (!limit) {
	        return [];
	      }
	      string = toString(string);
	      if (string && (
	            typeof separator == 'string' ||
	            (separator != null && !isRegExp(separator))
	          )) {
	        separator = baseToString(separator);
	        if (!separator && hasUnicode(string)) {
	          return castSlice(stringToArray(string), 0, limit);
	        }
	      }
	      return string.split(separator, limit);
	    }
	
	    /**
	     * Converts `string` to
	     * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.1.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the start cased string.
	     * @example
	     *
	     * _.startCase('--foo-bar--');
	     * // => 'Foo Bar'
	     *
	     * _.startCase('fooBar');
	     * // => 'Foo Bar'
	     *
	     * _.startCase('__FOO_BAR__');
	     * // => 'FOO BAR'
	     */
	    var startCase = createCompounder(function(result, word, index) {
	      return result + (index ? ' ' : '') + upperFirst(word);
	    });
	
	    /**
	     * Checks if `string` starts with the given target string.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to inspect.
	     * @param {string} [target] The string to search for.
	     * @param {number} [position=0] The position to search from.
	     * @returns {boolean} Returns `true` if `string` starts with `target`,
	     *  else `false`.
	     * @example
	     *
	     * _.startsWith('abc', 'a');
	     * // => true
	     *
	     * _.startsWith('abc', 'b');
	     * // => false
	     *
	     * _.startsWith('abc', 'b', 1);
	     * // => true
	     */
	    function startsWith(string, target, position) {
	      string = toString(string);
	      position = baseClamp(toInteger(position), 0, string.length);
	      target = baseToString(target);
	      return string.slice(position, position + target.length) == target;
	    }
	
	    /**
	     * Creates a compiled template function that can interpolate data properties
	     * in "interpolate" delimiters, HTML-escape interpolated data properties in
	     * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
	     * properties may be accessed as free variables in the template. If a setting
	     * object is given, it takes precedence over `_.templateSettings` values.
	     *
	     * **Note:** In the development build `_.template` utilizes
	     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
	     * for easier debugging.
	     *
	     * For more information on precompiling templates see
	     * [lodash's custom builds documentation](https://lodash.com/custom-builds).
	     *
	     * For more information on Chrome extension sandboxes see
	     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The template string.
	     * @param {Object} [options={}] The options object.
	     * @param {RegExp} [options.escape=_.templateSettings.escape]
	     *  The HTML "escape" delimiter.
	     * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
	     *  The "evaluate" delimiter.
	     * @param {Object} [options.imports=_.templateSettings.imports]
	     *  An object to import into the template as free variables.
	     * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
	     *  The "interpolate" delimiter.
	     * @param {string} [options.sourceURL='lodash.templateSources[n]']
	     *  The sourceURL of the compiled template.
	     * @param {string} [options.variable='obj']
	     *  The data object variable name.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Function} Returns the compiled template function.
	     * @example
	     *
	     * // Use the "interpolate" delimiter to create a compiled template.
	     * var compiled = _.template('hello <%= user %>!');
	     * compiled({ 'user': 'fred' });
	     * // => 'hello fred!'
	     *
	     * // Use the HTML "escape" delimiter to escape data property values.
	     * var compiled = _.template('<b><%- value %></b>');
	     * compiled({ 'value': '<script>' });
	     * // => '<b>&lt;script&gt;</b>'
	     *
	     * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
	     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
	     * compiled({ 'users': ['fred', 'barney'] });
	     * // => '<li>fred</li><li>barney</li>'
	     *
	     * // Use the internal `print` function in "evaluate" delimiters.
	     * var compiled = _.template('<% print("hello " + user); %>!');
	     * compiled({ 'user': 'barney' });
	     * // => 'hello barney!'
	     *
	     * // Use the ES template literal delimiter as an "interpolate" delimiter.
	     * // Disable support by replacing the "interpolate" delimiter.
	     * var compiled = _.template('hello ${ user }!');
	     * compiled({ 'user': 'pebbles' });
	     * // => 'hello pebbles!'
	     *
	     * // Use backslashes to treat delimiters as plain text.
	     * var compiled = _.template('<%= "\\<%- value %\\>" %>');
	     * compiled({ 'value': 'ignored' });
	     * // => '<%- value %>'
	     *
	     * // Use the `imports` option to import `jQuery` as `jq`.
	     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
	     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
	     * compiled({ 'users': ['fred', 'barney'] });
	     * // => '<li>fred</li><li>barney</li>'
	     *
	     * // Use the `sourceURL` option to specify a custom sourceURL for the template.
	     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
	     * compiled(data);
	     * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
	     *
	     * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
	     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
	     * compiled.source;
	     * // => function(data) {
	     * //   var __t, __p = '';
	     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
	     * //   return __p;
	     * // }
	     *
	     * // Use custom template delimiters.
	     * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
	     * var compiled = _.template('hello {{ user }}!');
	     * compiled({ 'user': 'mustache' });
	     * // => 'hello mustache!'
	     *
	     * // Use the `source` property to inline compiled templates for meaningful
	     * // line numbers in error messages and stack traces.
	     * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
	     *   var JST = {\
	     *     "main": ' + _.template(mainText).source + '\
	     *   };\
	     * ');
	     */
	    function template(string, options, guard) {
	      // Based on John Resig's `tmpl` implementation
	      // (http://ejohn.org/blog/javascript-micro-templating/)
	      // and Laura Doktorova's doT.js (https://github.com/olado/doT).
	      var settings = lodash.templateSettings;
	
	      if (guard && isIterateeCall(string, options, guard)) {
	        options = undefined;
	      }
	      string = toString(string);
	      options = assignInWith({}, options, settings, assignInDefaults);
	
	      var imports = assignInWith({}, options.imports, settings.imports, assignInDefaults),
	          importsKeys = keys(imports),
	          importsValues = baseValues(imports, importsKeys);
	
	      var isEscaping,
	          isEvaluating,
	          index = 0,
	          interpolate = options.interpolate || reNoMatch,
	          source = "__p += '";
	
	      // Compile the regexp to match each delimiter.
	      var reDelimiters = RegExp(
	        (options.escape || reNoMatch).source + '|' +
	        interpolate.source + '|' +
	        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
	        (options.evaluate || reNoMatch).source + '|$'
	      , 'g');
	
	      // Use a sourceURL for easier debugging.
	      var sourceURL = '//# sourceURL=' +
	        ('sourceURL' in options
	          ? options.sourceURL
	          : ('lodash.templateSources[' + (++templateCounter) + ']')
	        ) + '\n';
	
	      string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
	        interpolateValue || (interpolateValue = esTemplateValue);
	
	        // Escape characters that can't be included in string literals.
	        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
	
	        // Replace delimiters with snippets.
	        if (escapeValue) {
	          isEscaping = true;
	          source += "' +\n__e(" + escapeValue + ") +\n'";
	        }
	        if (evaluateValue) {
	          isEvaluating = true;
	          source += "';\n" + evaluateValue + ";\n__p += '";
	        }
	        if (interpolateValue) {
	          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
	        }
	        index = offset + match.length;
	
	        // The JS engine embedded in Adobe products needs `match` returned in
	        // order to produce the correct `offset` value.
	        return match;
	      });
	
	      source += "';\n";
	
	      // If `variable` is not specified wrap a with-statement around the generated
	      // code to add the data object to the top of the scope chain.
	      var variable = options.variable;
	      if (!variable) {
	        source = 'with (obj) {\n' + source + '\n}\n';
	      }
	      // Cleanup code by stripping empty strings.
	      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
	        .replace(reEmptyStringMiddle, '$1')
	        .replace(reEmptyStringTrailing, '$1;');
	
	      // Frame code as the function body.
	      source = 'function(' + (variable || 'obj') + ') {\n' +
	        (variable
	          ? ''
	          : 'obj || (obj = {});\n'
	        ) +
	        "var __t, __p = ''" +
	        (isEscaping
	           ? ', __e = _.escape'
	           : ''
	        ) +
	        (isEvaluating
	          ? ', __j = Array.prototype.join;\n' +
	            "function print() { __p += __j.call(arguments, '') }\n"
	          : ';\n'
	        ) +
	        source +
	        'return __p\n}';
	
	      var result = attempt(function() {
	        return Function(importsKeys, sourceURL + 'return ' + source)
	          .apply(undefined, importsValues);
	      });
	
	      // Provide the compiled function's source by its `toString` method or
	      // the `source` property as a convenience for inlining compiled templates.
	      result.source = source;
	      if (isError(result)) {
	        throw result;
	      }
	      return result;
	    }
	
	    /**
	     * Converts `string`, as a whole, to lower case just like
	     * [String#toLowerCase](https://mdn.io/toLowerCase).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the lower cased string.
	     * @example
	     *
	     * _.toLower('--Foo-Bar--');
	     * // => '--foo-bar--'
	     *
	     * _.toLower('fooBar');
	     * // => 'foobar'
	     *
	     * _.toLower('__FOO_BAR__');
	     * // => '__foo_bar__'
	     */
	    function toLower(value) {
	      return toString(value).toLowerCase();
	    }
	
	    /**
	     * Converts `string`, as a whole, to upper case just like
	     * [String#toUpperCase](https://mdn.io/toUpperCase).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the upper cased string.
	     * @example
	     *
	     * _.toUpper('--foo-bar--');
	     * // => '--FOO-BAR--'
	     *
	     * _.toUpper('fooBar');
	     * // => 'FOOBAR'
	     *
	     * _.toUpper('__foo_bar__');
	     * // => '__FOO_BAR__'
	     */
	    function toUpper(value) {
	      return toString(value).toUpperCase();
	    }
	
	    /**
	     * Removes leading and trailing whitespace or specified characters from `string`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to trim.
	     * @param {string} [chars=whitespace] The characters to trim.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {string} Returns the trimmed string.
	     * @example
	     *
	     * _.trim('  abc  ');
	     * // => 'abc'
	     *
	     * _.trim('-_-abc-_-', '_-');
	     * // => 'abc'
	     *
	     * _.map(['  foo  ', '  bar  '], _.trim);
	     * // => ['foo', 'bar']
	     */
	    function trim(string, chars, guard) {
	      string = toString(string);
	      if (string && (guard || chars === undefined)) {
	        return string.replace(reTrim, '');
	      }
	      if (!string || !(chars = baseToString(chars))) {
	        return string;
	      }
	      var strSymbols = stringToArray(string),
	          chrSymbols = stringToArray(chars),
	          start = charsStartIndex(strSymbols, chrSymbols),
	          end = charsEndIndex(strSymbols, chrSymbols) + 1;
	
	      return castSlice(strSymbols, start, end).join('');
	    }
	
	    /**
	     * Removes trailing whitespace or specified characters from `string`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to trim.
	     * @param {string} [chars=whitespace] The characters to trim.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {string} Returns the trimmed string.
	     * @example
	     *
	     * _.trimEnd('  abc  ');
	     * // => '  abc'
	     *
	     * _.trimEnd('-_-abc-_-', '_-');
	     * // => '-_-abc'
	     */
	    function trimEnd(string, chars, guard) {
	      string = toString(string);
	      if (string && (guard || chars === undefined)) {
	        return string.replace(reTrimEnd, '');
	      }
	      if (!string || !(chars = baseToString(chars))) {
	        return string;
	      }
	      var strSymbols = stringToArray(string),
	          end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
	
	      return castSlice(strSymbols, 0, end).join('');
	    }
	
	    /**
	     * Removes leading whitespace or specified characters from `string`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to trim.
	     * @param {string} [chars=whitespace] The characters to trim.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {string} Returns the trimmed string.
	     * @example
	     *
	     * _.trimStart('  abc  ');
	     * // => 'abc  '
	     *
	     * _.trimStart('-_-abc-_-', '_-');
	     * // => 'abc-_-'
	     */
	    function trimStart(string, chars, guard) {
	      string = toString(string);
	      if (string && (guard || chars === undefined)) {
	        return string.replace(reTrimStart, '');
	      }
	      if (!string || !(chars = baseToString(chars))) {
	        return string;
	      }
	      var strSymbols = stringToArray(string),
	          start = charsStartIndex(strSymbols, stringToArray(chars));
	
	      return castSlice(strSymbols, start).join('');
	    }
	
	    /**
	     * Truncates `string` if it's longer than the given maximum string length.
	     * The last characters of the truncated string are replaced with the omission
	     * string which defaults to "...".
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to truncate.
	     * @param {Object} [options={}] The options object.
	     * @param {number} [options.length=30] The maximum string length.
	     * @param {string} [options.omission='...'] The string to indicate text is omitted.
	     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
	     * @returns {string} Returns the truncated string.
	     * @example
	     *
	     * _.truncate('hi-diddly-ho there, neighborino');
	     * // => 'hi-diddly-ho there, neighbo...'
	     *
	     * _.truncate('hi-diddly-ho there, neighborino', {
	     *   'length': 24,
	     *   'separator': ' '
	     * });
	     * // => 'hi-diddly-ho there,...'
	     *
	     * _.truncate('hi-diddly-ho there, neighborino', {
	     *   'length': 24,
	     *   'separator': /,? +/
	     * });
	     * // => 'hi-diddly-ho there...'
	     *
	     * _.truncate('hi-diddly-ho there, neighborino', {
	     *   'omission': ' [...]'
	     * });
	     * // => 'hi-diddly-ho there, neig [...]'
	     */
	    function truncate(string, options) {
	      var length = DEFAULT_TRUNC_LENGTH,
	          omission = DEFAULT_TRUNC_OMISSION;
	
	      if (isObject(options)) {
	        var separator = 'separator' in options ? options.separator : separator;
	        length = 'length' in options ? toInteger(options.length) : length;
	        omission = 'omission' in options ? baseToString(options.omission) : omission;
	      }
	      string = toString(string);
	
	      var strLength = string.length;
	      if (hasUnicode(string)) {
	        var strSymbols = stringToArray(string);
	        strLength = strSymbols.length;
	      }
	      if (length >= strLength) {
	        return string;
	      }
	      var end = length - stringSize(omission);
	      if (end < 1) {
	        return omission;
	      }
	      var result = strSymbols
	        ? castSlice(strSymbols, 0, end).join('')
	        : string.slice(0, end);
	
	      if (separator === undefined) {
	        return result + omission;
	      }
	      if (strSymbols) {
	        end += (result.length - end);
	      }
	      if (isRegExp(separator)) {
	        if (string.slice(end).search(separator)) {
	          var match,
	              substring = result;
	
	          if (!separator.global) {
	            separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g');
	          }
	          separator.lastIndex = 0;
	          while ((match = separator.exec(substring))) {
	            var newEnd = match.index;
	          }
	          result = result.slice(0, newEnd === undefined ? end : newEnd);
	        }
	      } else if (string.indexOf(baseToString(separator), end) != end) {
	        var index = result.lastIndexOf(separator);
	        if (index > -1) {
	          result = result.slice(0, index);
	        }
	      }
	      return result + omission;
	    }
	
	    /**
	     * The inverse of `_.escape`; this method converts the HTML entities
	     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to
	     * their corresponding characters.
	     *
	     * **Note:** No other HTML entities are unescaped. To unescape additional
	     * HTML entities use a third-party library like [_he_](https://mths.be/he).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.6.0
	     * @category String
	     * @param {string} [string=''] The string to unescape.
	     * @returns {string} Returns the unescaped string.
	     * @example
	     *
	     * _.unescape('fred, barney, &amp; pebbles');
	     * // => 'fred, barney, & pebbles'
	     */
	    function unescape(string) {
	      string = toString(string);
	      return (string && reHasEscapedHtml.test(string))
	        ? string.replace(reEscapedHtml, unescapeHtmlChar)
	        : string;
	    }
	
	    /**
	     * Converts `string`, as space separated words, to upper case.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the upper cased string.
	     * @example
	     *
	     * _.upperCase('--foo-bar');
	     * // => 'FOO BAR'
	     *
	     * _.upperCase('fooBar');
	     * // => 'FOO BAR'
	     *
	     * _.upperCase('__foo_bar__');
	     * // => 'FOO BAR'
	     */
	    var upperCase = createCompounder(function(result, word, index) {
	      return result + (index ? ' ' : '') + word.toUpperCase();
	    });
	
	    /**
	     * Converts the first character of `string` to upper case.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the converted string.
	     * @example
	     *
	     * _.upperFirst('fred');
	     * // => 'Fred'
	     *
	     * _.upperFirst('FRED');
	     * // => 'FRED'
	     */
	    var upperFirst = createCaseFirst('toUpperCase');
	
	    /**
	     * Splits `string` into an array of its words.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to inspect.
	     * @param {RegExp|string} [pattern] The pattern to match words.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Array} Returns the words of `string`.
	     * @example
	     *
	     * _.words('fred, barney, & pebbles');
	     * // => ['fred', 'barney', 'pebbles']
	     *
	     * _.words('fred, barney, & pebbles', /[^, ]+/g);
	     * // => ['fred', 'barney', '&', 'pebbles']
	     */
	    function words(string, pattern, guard) {
	      string = toString(string);
	      pattern = guard ? undefined : pattern;
	
	      if (pattern === undefined) {
	        return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
	      }
	      return string.match(pattern) || [];
	    }
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * Attempts to invoke `func`, returning either the result or the caught error
	     * object. Any additional arguments are provided to `func` when it's invoked.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Util
	     * @param {Function} func The function to attempt.
	     * @param {...*} [args] The arguments to invoke `func` with.
	     * @returns {*} Returns the `func` result or error object.
	     * @example
	     *
	     * // Avoid throwing errors for invalid selectors.
	     * var elements = _.attempt(function(selector) {
	     *   return document.querySelectorAll(selector);
	     * }, '>_>');
	     *
	     * if (_.isError(elements)) {
	     *   elements = [];
	     * }
	     */
	    var attempt = baseRest(function(func, args) {
	      try {
	        return apply(func, undefined, args);
	      } catch (e) {
	        return isError(e) ? e : new Error(e);
	      }
	    });
	
	    /**
	     * Binds methods of an object to the object itself, overwriting the existing
	     * method.
	     *
	     * **Note:** This method doesn't set the "length" property of bound functions.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Util
	     * @param {Object} object The object to bind and assign the bound methods to.
	     * @param {...(string|string[])} methodNames The object method names to bind.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * var view = {
	     *   'label': 'docs',
	     *   'click': function() {
	     *     console.log('clicked ' + this.label);
	     *   }
	     * };
	     *
	     * _.bindAll(view, ['click']);
	     * jQuery(element).on('click', view.click);
	     * // => Logs 'clicked docs' when clicked.
	     */
	    var bindAll = flatRest(function(object, methodNames) {
	      arrayEach(methodNames, function(key) {
	        key = toKey(key);
	        baseAssignValue(object, key, bind(object[key], object));
	      });
	      return object;
	    });
	
	    /**
	     * Creates a function that iterates over `pairs` and invokes the corresponding
	     * function of the first predicate to return truthy. The predicate-function
	     * pairs are invoked with the `this` binding and arguments of the created
	     * function.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Util
	     * @param {Array} pairs The predicate-function pairs.
	     * @returns {Function} Returns the new composite function.
	     * @example
	     *
	     * var func = _.cond([
	     *   [_.matches({ 'a': 1 }),           _.constant('matches A')],
	     *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],
	     *   [_.stubTrue,                      _.constant('no match')]
	     * ]);
	     *
	     * func({ 'a': 1, 'b': 2 });
	     * // => 'matches A'
	     *
	     * func({ 'a': 0, 'b': 1 });
	     * // => 'matches B'
	     *
	     * func({ 'a': '1', 'b': '2' });
	     * // => 'no match'
	     */
	    function cond(pairs) {
	      var length = pairs == null ? 0 : pairs.length,
	          toIteratee = getIteratee();
	
	      pairs = !length ? [] : arrayMap(pairs, function(pair) {
	        if (typeof pair[1] != 'function') {
	          throw new TypeError(FUNC_ERROR_TEXT);
	        }
	        return [toIteratee(pair[0]), pair[1]];
	      });
	
	      return baseRest(function(args) {
	        var index = -1;
	        while (++index < length) {
	          var pair = pairs[index];
	          if (apply(pair[0], this, args)) {
	            return apply(pair[1], this, args);
	          }
	        }
	      });
	    }
	
	    /**
	     * Creates a function that invokes the predicate properties of `source` with
	     * the corresponding property values of a given object, returning `true` if
	     * all predicates return truthy, else `false`.
	     *
	     * **Note:** The created function is equivalent to `_.conformsTo` with
	     * `source` partially applied.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Util
	     * @param {Object} source The object of property predicates to conform to.
	     * @returns {Function} Returns the new spec function.
	     * @example
	     *
	     * var objects = [
	     *   { 'a': 2, 'b': 1 },
	     *   { 'a': 1, 'b': 2 }
	     * ];
	     *
	     * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));
	     * // => [{ 'a': 1, 'b': 2 }]
	     */
	    function conforms(source) {
	      return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
	    }
	
	    /**
	     * Creates a function that returns `value`.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.4.0
	     * @category Util
	     * @param {*} value The value to return from the new function.
	     * @returns {Function} Returns the new constant function.
	     * @example
	     *
	     * var objects = _.times(2, _.constant({ 'a': 1 }));
	     *
	     * console.log(objects);
	     * // => [{ 'a': 1 }, { 'a': 1 }]
	     *
	     * console.log(objects[0] === objects[1]);
	     * // => true
	     */
	    function constant(value) {
	      return function() {
	        return value;
	      };
	    }
	
	    /**
	     * Checks `value` to determine whether a default value should be returned in
	     * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,
	     * or `undefined`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.14.0
	     * @category Util
	     * @param {*} value The value to check.
	     * @param {*} defaultValue The default value.
	     * @returns {*} Returns the resolved value.
	     * @example
	     *
	     * _.defaultTo(1, 10);
	     * // => 1
	     *
	     * _.defaultTo(undefined, 10);
	     * // => 10
	     */
	    function defaultTo(value, defaultValue) {
	      return (value == null || value !== value) ? defaultValue : value;
	    }
	
	    /**
	     * Creates a function that returns the result of invoking the given functions
	     * with the `this` binding of the created function, where each successive
	     * invocation is supplied the return value of the previous.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Util
	     * @param {...(Function|Function[])} [funcs] The functions to invoke.
	     * @returns {Function} Returns the new composite function.
	     * @see _.flowRight
	     * @example
	     *
	     * function square(n) {
	     *   return n * n;
	     * }
	     *
	     * var addSquare = _.flow([_.add, square]);
	     * addSquare(1, 2);
	     * // => 9
	     */
	    var flow = createFlow();
	
	    /**
	     * This method is like `_.flow` except that it creates a function that
	     * invokes the given functions from right to left.
	     *
	     * @static
	     * @since 3.0.0
	     * @memberOf _
	     * @category Util
	     * @param {...(Function|Function[])} [funcs] The functions to invoke.
	     * @returns {Function} Returns the new composite function.
	     * @see _.flow
	     * @example
	     *
	     * function square(n) {
	     *   return n * n;
	     * }
	     *
	     * var addSquare = _.flowRight([square, _.add]);
	     * addSquare(1, 2);
	     * // => 9
	     */
	    var flowRight = createFlow(true);
	
	    /**
	     * This method returns the first argument it receives.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Util
	     * @param {*} value Any value.
	     * @returns {*} Returns `value`.
	     * @example
	     *
	     * var object = { 'a': 1 };
	     *
	     * console.log(_.identity(object) === object);
	     * // => true
	     */
	    function identity(value) {
	      return value;
	    }
	
	    /**
	     * Creates a function that invokes `func` with the arguments of the created
	     * function. If `func` is a property name, the created function returns the
	     * property value for a given element. If `func` is an array or object, the
	     * created function returns `true` for elements that contain the equivalent
	     * source properties, otherwise it returns `false`.
	     *
	     * @static
	     * @since 4.0.0
	     * @memberOf _
	     * @category Util
	     * @param {*} [func=_.identity] The value to convert to a callback.
	     * @returns {Function} Returns the callback.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36, 'active': true },
	     *   { 'user': 'fred',   'age': 40, 'active': false }
	     * ];
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));
	     * // => [{ 'user': 'barney', 'age': 36, 'active': true }]
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.filter(users, _.iteratee(['user', 'fred']));
	     * // => [{ 'user': 'fred', 'age': 40 }]
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.map(users, _.iteratee('user'));
	     * // => ['barney', 'fred']
	     *
	     * // Create custom iteratee shorthands.
	     * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {
	     *   return !_.isRegExp(func) ? iteratee(func) : function(string) {
	     *     return func.test(string);
	     *   };
	     * });
	     *
	     * _.filter(['abc', 'def'], /ef/);
	     * // => ['def']
	     */
	    function iteratee(func) {
	      return baseIteratee(typeof func == 'function' ? func : baseClone(func, CLONE_DEEP_FLAG));
	    }
	
	    /**
	     * Creates a function that performs a partial deep comparison between a given
	     * object and `source`, returning `true` if the given object has equivalent
	     * property values, else `false`.
	     *
	     * **Note:** The created function is equivalent to `_.isMatch` with `source`
	     * partially applied.
	     *
	     * Partial comparisons will match empty array and empty object `source`
	     * values against any array or object value, respectively. See `_.isEqual`
	     * for a list of supported value comparisons.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Util
	     * @param {Object} source The object of property values to match.
	     * @returns {Function} Returns the new spec function.
	     * @example
	     *
	     * var objects = [
	     *   { 'a': 1, 'b': 2, 'c': 3 },
	     *   { 'a': 4, 'b': 5, 'c': 6 }
	     * ];
	     *
	     * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));
	     * // => [{ 'a': 4, 'b': 5, 'c': 6 }]
	     */
	    function matches(source) {
	      return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
	    }
	
	    /**
	     * Creates a function that performs a partial deep comparison between the
	     * value at `path` of a given object to `srcValue`, returning `true` if the
	     * object value is equivalent, else `false`.
	     *
	     * **Note:** Partial comparisons will match empty array and empty object
	     * `srcValue` values against any array or object value, respectively. See
	     * `_.isEqual` for a list of supported value comparisons.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.2.0
	     * @category Util
	     * @param {Array|string} path The path of the property to get.
	     * @param {*} srcValue The value to match.
	     * @returns {Function} Returns the new spec function.
	     * @example
	     *
	     * var objects = [
	     *   { 'a': 1, 'b': 2, 'c': 3 },
	     *   { 'a': 4, 'b': 5, 'c': 6 }
	     * ];
	     *
	     * _.find(objects, _.matchesProperty('a', 4));
	     * // => { 'a': 4, 'b': 5, 'c': 6 }
	     */
	    function matchesProperty(path, srcValue) {
	      return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
	    }
	
	    /**
	     * Creates a function that invokes the method at `path` of a given object.
	     * Any additional arguments are provided to the invoked method.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.7.0
	     * @category Util
	     * @param {Array|string} path The path of the method to invoke.
	     * @param {...*} [args] The arguments to invoke the method with.
	     * @returns {Function} Returns the new invoker function.
	     * @example
	     *
	     * var objects = [
	     *   { 'a': { 'b': _.constant(2) } },
	     *   { 'a': { 'b': _.constant(1) } }
	     * ];
	     *
	     * _.map(objects, _.method('a.b'));
	     * // => [2, 1]
	     *
	     * _.map(objects, _.method(['a', 'b']));
	     * // => [2, 1]
	     */
	    var method = baseRest(function(path, args) {
	      return function(object) {
	        return baseInvoke(object, path, args);
	      };
	    });
	
	    /**
	     * The opposite of `_.method`; this method creates a function that invokes
	     * the method at a given path of `object`. Any additional arguments are
	     * provided to the invoked method.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.7.0
	     * @category Util
	     * @param {Object} object The object to query.
	     * @param {...*} [args] The arguments to invoke the method with.
	     * @returns {Function} Returns the new invoker function.
	     * @example
	     *
	     * var array = _.times(3, _.constant),
	     *     object = { 'a': array, 'b': array, 'c': array };
	     *
	     * _.map(['a[2]', 'c[0]'], _.methodOf(object));
	     * // => [2, 0]
	     *
	     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
	     * // => [2, 0]
	     */
	    var methodOf = baseRest(function(object, args) {
	      return function(path) {
	        return baseInvoke(object, path, args);
	      };
	    });
	
	    /**
	     * Adds all own enumerable string keyed function properties of a source
	     * object to the destination object. If `object` is a function, then methods
	     * are added to its prototype as well.
	     *
	     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
	     * avoid conflicts caused by modifying the original.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Util
	     * @param {Function|Object} [object=lodash] The destination object.
	     * @param {Object} source The object of functions to add.
	     * @param {Object} [options={}] The options object.
	     * @param {boolean} [options.chain=true] Specify whether mixins are chainable.
	     * @returns {Function|Object} Returns `object`.
	     * @example
	     *
	     * function vowels(string) {
	     *   return _.filter(string, function(v) {
	     *     return /[aeiou]/i.test(v);
	     *   });
	     * }
	     *
	     * _.mixin({ 'vowels': vowels });
	     * _.vowels('fred');
	     * // => ['e']
	     *
	     * _('fred').vowels().value();
	     * // => ['e']
	     *
	     * _.mixin({ 'vowels': vowels }, { 'chain': false });
	     * _('fred').vowels();
	     * // => ['e']
	     */
	    function mixin(object, source, options) {
	      var props = keys(source),
	          methodNames = baseFunctions(source, props);
	
	      if (options == null &&
	          !(isObject(source) && (methodNames.length || !props.length))) {
	        options = source;
	        source = object;
	        object = this;
	        methodNames = baseFunctions(source, keys(source));
	      }
	      var chain = !(isObject(options) && 'chain' in options) || !!options.chain,
	          isFunc = isFunction(object);
	
	      arrayEach(methodNames, function(methodName) {
	        var func = source[methodName];
	        object[methodName] = func;
	        if (isFunc) {
	          object.prototype[methodName] = function() {
	            var chainAll = this.__chain__;
	            if (chain || chainAll) {
	              var result = object(this.__wrapped__),
	                  actions = result.__actions__ = copyArray(this.__actions__);
	
	              actions.push({ 'func': func, 'args': arguments, 'thisArg': object });
	              result.__chain__ = chainAll;
	              return result;
	            }
	            return func.apply(object, arrayPush([this.value()], arguments));
	          };
	        }
	      });
	
	      return object;
	    }
	
	    /**
	     * Reverts the `_` variable to its previous value and returns a reference to
	     * the `lodash` function.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Util
	     * @returns {Function} Returns the `lodash` function.
	     * @example
	     *
	     * var lodash = _.noConflict();
	     */
	    function noConflict() {
	      if (root._ === this) {
	        root._ = oldDash;
	      }
	      return this;
	    }
	
	    /**
	     * This method returns `undefined`.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.3.0
	     * @category Util
	     * @example
	     *
	     * _.times(2, _.noop);
	     * // => [undefined, undefined]
	     */
	    function noop() {
	      // No operation performed.
	    }
	
	    /**
	     * Creates a function that gets the argument at index `n`. If `n` is negative,
	     * the nth argument from the end is returned.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Util
	     * @param {number} [n=0] The index of the argument to return.
	     * @returns {Function} Returns the new pass-thru function.
	     * @example
	     *
	     * var func = _.nthArg(1);
	     * func('a', 'b', 'c', 'd');
	     * // => 'b'
	     *
	     * var func = _.nthArg(-2);
	     * func('a', 'b', 'c', 'd');
	     * // => 'c'
	     */
	    function nthArg(n) {
	      n = toInteger(n);
	      return baseRest(function(args) {
	        return baseNth(args, n);
	      });
	    }
	
	    /**
	     * Creates a function that invokes `iteratees` with the arguments it receives
	     * and returns their results.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Util
	     * @param {...(Function|Function[])} [iteratees=[_.identity]]
	     *  The iteratees to invoke.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var func = _.over([Math.max, Math.min]);
	     *
	     * func(1, 2, 3, 4);
	     * // => [4, 1]
	     */
	    var over = createOver(arrayMap);
	
	    /**
	     * Creates a function that checks if **all** of the `predicates` return
	     * truthy when invoked with the arguments it receives.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Util
	     * @param {...(Function|Function[])} [predicates=[_.identity]]
	     *  The predicates to check.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var func = _.overEvery([Boolean, isFinite]);
	     *
	     * func('1');
	     * // => true
	     *
	     * func(null);
	     * // => false
	     *
	     * func(NaN);
	     * // => false
	     */
	    var overEvery = createOver(arrayEvery);
	
	    /**
	     * Creates a function that checks if **any** of the `predicates` return
	     * truthy when invoked with the arguments it receives.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Util
	     * @param {...(Function|Function[])} [predicates=[_.identity]]
	     *  The predicates to check.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var func = _.overSome([Boolean, isFinite]);
	     *
	     * func('1');
	     * // => true
	     *
	     * func(null);
	     * // => true
	     *
	     * func(NaN);
	     * // => false
	     */
	    var overSome = createOver(arraySome);
	
	    /**
	     * Creates a function that returns the value at `path` of a given object.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.4.0
	     * @category Util
	     * @param {Array|string} path The path of the property to get.
	     * @returns {Function} Returns the new accessor function.
	     * @example
	     *
	     * var objects = [
	     *   { 'a': { 'b': 2 } },
	     *   { 'a': { 'b': 1 } }
	     * ];
	     *
	     * _.map(objects, _.property('a.b'));
	     * // => [2, 1]
	     *
	     * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
	     * // => [1, 2]
	     */
	    function property(path) {
	      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
	    }
	
	    /**
	     * The opposite of `_.property`; this method creates a function that returns
	     * the value at a given path of `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Util
	     * @param {Object} object The object to query.
	     * @returns {Function} Returns the new accessor function.
	     * @example
	     *
	     * var array = [0, 1, 2],
	     *     object = { 'a': array, 'b': array, 'c': array };
	     *
	     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
	     * // => [2, 0]
	     *
	     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
	     * // => [2, 0]
	     */
	    function propertyOf(object) {
	      return function(path) {
	        return object == null ? undefined : baseGet(object, path);
	      };
	    }
	
	    /**
	     * Creates an array of numbers (positive and/or negative) progressing from
	     * `start` up to, but not including, `end`. A step of `-1` is used if a negative
	     * `start` is specified without an `end` or `step`. If `end` is not specified,
	     * it's set to `start` with `start` then set to `0`.
	     *
	     * **Note:** JavaScript follows the IEEE-754 standard for resolving
	     * floating-point values which can produce unexpected results.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Util
	     * @param {number} [start=0] The start of the range.
	     * @param {number} end The end of the range.
	     * @param {number} [step=1] The value to increment or decrement by.
	     * @returns {Array} Returns the range of numbers.
	     * @see _.inRange, _.rangeRight
	     * @example
	     *
	     * _.range(4);
	     * // => [0, 1, 2, 3]
	     *
	     * _.range(-4);
	     * // => [0, -1, -2, -3]
	     *
	     * _.range(1, 5);
	     * // => [1, 2, 3, 4]
	     *
	     * _.range(0, 20, 5);
	     * // => [0, 5, 10, 15]
	     *
	     * _.range(0, -4, -1);
	     * // => [0, -1, -2, -3]
	     *
	     * _.range(1, 4, 0);
	     * // => [1, 1, 1]
	     *
	     * _.range(0);
	     * // => []
	     */
	    var range = createRange();
	
	    /**
	     * This method is like `_.range` except that it populates values in
	     * descending order.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Util
	     * @param {number} [start=0] The start of the range.
	     * @param {number} end The end of the range.
	     * @param {number} [step=1] The value to increment or decrement by.
	     * @returns {Array} Returns the range of numbers.
	     * @see _.inRange, _.range
	     * @example
	     *
	     * _.rangeRight(4);
	     * // => [3, 2, 1, 0]
	     *
	     * _.rangeRight(-4);
	     * // => [-3, -2, -1, 0]
	     *
	     * _.rangeRight(1, 5);
	     * // => [4, 3, 2, 1]
	     *
	     * _.rangeRight(0, 20, 5);
	     * // => [15, 10, 5, 0]
	     *
	     * _.rangeRight(0, -4, -1);
	     * // => [-3, -2, -1, 0]
	     *
	     * _.rangeRight(1, 4, 0);
	     * // => [1, 1, 1]
	     *
	     * _.rangeRight(0);
	     * // => []
	     */
	    var rangeRight = createRange(true);
	
	    /**
	     * This method returns a new empty array.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.13.0
	     * @category Util
	     * @returns {Array} Returns the new empty array.
	     * @example
	     *
	     * var arrays = _.times(2, _.stubArray);
	     *
	     * console.log(arrays);
	     * // => [[], []]
	     *
	     * console.log(arrays[0] === arrays[1]);
	     * // => false
	     */
	    function stubArray() {
	      return [];
	    }
	
	    /**
	     * This method returns `false`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.13.0
	     * @category Util
	     * @returns {boolean} Returns `false`.
	     * @example
	     *
	     * _.times(2, _.stubFalse);
	     * // => [false, false]
	     */
	    function stubFalse() {
	      return false;
	    }
	
	    /**
	     * This method returns a new empty object.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.13.0
	     * @category Util
	     * @returns {Object} Returns the new empty object.
	     * @example
	     *
	     * var objects = _.times(2, _.stubObject);
	     *
	     * console.log(objects);
	     * // => [{}, {}]
	     *
	     * console.log(objects[0] === objects[1]);
	     * // => false
	     */
	    function stubObject() {
	      return {};
	    }
	
	    /**
	     * This method returns an empty string.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.13.0
	     * @category Util
	     * @returns {string} Returns the empty string.
	     * @example
	     *
	     * _.times(2, _.stubString);
	     * // => ['', '']
	     */
	    function stubString() {
	      return '';
	    }
	
	    /**
	     * This method returns `true`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.13.0
	     * @category Util
	     * @returns {boolean} Returns `true`.
	     * @example
	     *
	     * _.times(2, _.stubTrue);
	     * // => [true, true]
	     */
	    function stubTrue() {
	      return true;
	    }
	
	    /**
	     * Invokes the iteratee `n` times, returning an array of the results of
	     * each invocation. The iteratee is invoked with one argument; (index).
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Util
	     * @param {number} n The number of times to invoke `iteratee`.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the array of results.
	     * @example
	     *
	     * _.times(3, String);
	     * // => ['0', '1', '2']
	     *
	     *  _.times(4, _.constant(0));
	     * // => [0, 0, 0, 0]
	     */
	    function times(n, iteratee) {
	      n = toInteger(n);
	      if (n < 1 || n > MAX_SAFE_INTEGER) {
	        return [];
	      }
	      var index = MAX_ARRAY_LENGTH,
	          length = nativeMin(n, MAX_ARRAY_LENGTH);
	
	      iteratee = getIteratee(iteratee);
	      n -= MAX_ARRAY_LENGTH;
	
	      var result = baseTimes(length, iteratee);
	      while (++index < n) {
	        iteratee(index);
	      }
	      return result;
	    }
	
	    /**
	     * Converts `value` to a property path array.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Util
	     * @param {*} value The value to convert.
	     * @returns {Array} Returns the new property path array.
	     * @example
	     *
	     * _.toPath('a.b.c');
	     * // => ['a', 'b', 'c']
	     *
	     * _.toPath('a[0].b.c');
	     * // => ['a', '0', 'b', 'c']
	     */
	    function toPath(value) {
	      if (isArray(value)) {
	        return arrayMap(value, toKey);
	      }
	      return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
	    }
	
	    /**
	     * Generates a unique ID. If `prefix` is given, the ID is appended to it.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Util
	     * @param {string} [prefix=''] The value to prefix the ID with.
	     * @returns {string} Returns the unique ID.
	     * @example
	     *
	     * _.uniqueId('contact_');
	     * // => 'contact_104'
	     *
	     * _.uniqueId();
	     * // => '105'
	     */
	    function uniqueId(prefix) {
	      var id = ++idCounter;
	      return toString(prefix) + id;
	    }
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * Adds two numbers.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.4.0
	     * @category Math
	     * @param {number} augend The first number in an addition.
	     * @param {number} addend The second number in an addition.
	     * @returns {number} Returns the total.
	     * @example
	     *
	     * _.add(6, 4);
	     * // => 10
	     */
	    var add = createMathOperation(function(augend, addend) {
	      return augend + addend;
	    }, 0);
	
	    /**
	     * Computes `number` rounded up to `precision`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.10.0
	     * @category Math
	     * @param {number} number The number to round up.
	     * @param {number} [precision=0] The precision to round up to.
	     * @returns {number} Returns the rounded up number.
	     * @example
	     *
	     * _.ceil(4.006);
	     * // => 5
	     *
	     * _.ceil(6.004, 2);
	     * // => 6.01
	     *
	     * _.ceil(6040, -2);
	     * // => 6100
	     */
	    var ceil = createRound('ceil');
	
	    /**
	     * Divide two numbers.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.7.0
	     * @category Math
	     * @param {number} dividend The first number in a division.
	     * @param {number} divisor The second number in a division.
	     * @returns {number} Returns the quotient.
	     * @example
	     *
	     * _.divide(6, 4);
	     * // => 1.5
	     */
	    var divide = createMathOperation(function(dividend, divisor) {
	      return dividend / divisor;
	    }, 1);
	
	    /**
	     * Computes `number` rounded down to `precision`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.10.0
	     * @category Math
	     * @param {number} number The number to round down.
	     * @param {number} [precision=0] The precision to round down to.
	     * @returns {number} Returns the rounded down number.
	     * @example
	     *
	     * _.floor(4.006);
	     * // => 4
	     *
	     * _.floor(0.046, 2);
	     * // => 0.04
	     *
	     * _.floor(4060, -2);
	     * // => 4000
	     */
	    var floor = createRound('floor');
	
	    /**
	     * Computes the maximum value of `array`. If `array` is empty or falsey,
	     * `undefined` is returned.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @returns {*} Returns the maximum value.
	     * @example
	     *
	     * _.max([4, 2, 8, 6]);
	     * // => 8
	     *
	     * _.max([]);
	     * // => undefined
	     */
	    function max(array) {
	      return (array && array.length)
	        ? baseExtremum(array, identity, baseGt)
	        : undefined;
	    }
	
	    /**
	     * This method is like `_.max` except that it accepts `iteratee` which is
	     * invoked for each element in `array` to generate the criterion by which
	     * the value is ranked. The iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {*} Returns the maximum value.
	     * @example
	     *
	     * var objects = [{ 'n': 1 }, { 'n': 2 }];
	     *
	     * _.maxBy(objects, function(o) { return o.n; });
	     * // => { 'n': 2 }
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.maxBy(objects, 'n');
	     * // => { 'n': 2 }
	     */
	    function maxBy(array, iteratee) {
	      return (array && array.length)
	        ? baseExtremum(array, getIteratee(iteratee, 2), baseGt)
	        : undefined;
	    }
	
	    /**
	     * Computes the mean of the values in `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @returns {number} Returns the mean.
	     * @example
	     *
	     * _.mean([4, 2, 8, 6]);
	     * // => 5
	     */
	    function mean(array) {
	      return baseMean(array, identity);
	    }
	
	    /**
	     * This method is like `_.mean` except that it accepts `iteratee` which is
	     * invoked for each element in `array` to generate the value to be averaged.
	     * The iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.7.0
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {number} Returns the mean.
	     * @example
	     *
	     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
	     *
	     * _.meanBy(objects, function(o) { return o.n; });
	     * // => 5
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.meanBy(objects, 'n');
	     * // => 5
	     */
	    function meanBy(array, iteratee) {
	      return baseMean(array, getIteratee(iteratee, 2));
	    }
	
	    /**
	     * Computes the minimum value of `array`. If `array` is empty or falsey,
	     * `undefined` is returned.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @returns {*} Returns the minimum value.
	     * @example
	     *
	     * _.min([4, 2, 8, 6]);
	     * // => 2
	     *
	     * _.min([]);
	     * // => undefined
	     */
	    function min(array) {
	      return (array && array.length)
	        ? baseExtremum(array, identity, baseLt)
	        : undefined;
	    }
	
	    /**
	     * This method is like `_.min` except that it accepts `iteratee` which is
	     * invoked for each element in `array` to generate the criterion by which
	     * the value is ranked. The iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {*} Returns the minimum value.
	     * @example
	     *
	     * var objects = [{ 'n': 1 }, { 'n': 2 }];
	     *
	     * _.minBy(objects, function(o) { return o.n; });
	     * // => { 'n': 1 }
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.minBy(objects, 'n');
	     * // => { 'n': 1 }
	     */
	    function minBy(array, iteratee) {
	      return (array && array.length)
	        ? baseExtremum(array, getIteratee(iteratee, 2), baseLt)
	        : undefined;
	    }
	
	    /**
	     * Multiply two numbers.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.7.0
	     * @category Math
	     * @param {number} multiplier The first number in a multiplication.
	     * @param {number} multiplicand The second number in a multiplication.
	     * @returns {number} Returns the product.
	     * @example
	     *
	     * _.multiply(6, 4);
	     * // => 24
	     */
	    var multiply = createMathOperation(function(multiplier, multiplicand) {
	      return multiplier * multiplicand;
	    }, 1);
	
	    /**
	     * Computes `number` rounded to `precision`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.10.0
	     * @category Math
	     * @param {number} number The number to round.
	     * @param {number} [precision=0] The precision to round to.
	     * @returns {number} Returns the rounded number.
	     * @example
	     *
	     * _.round(4.006);
	     * // => 4
	     *
	     * _.round(4.006, 2);
	     * // => 4.01
	     *
	     * _.round(4060, -2);
	     * // => 4100
	     */
	    var round = createRound('round');
	
	    /**
	     * Subtract two numbers.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Math
	     * @param {number} minuend The first number in a subtraction.
	     * @param {number} subtrahend The second number in a subtraction.
	     * @returns {number} Returns the difference.
	     * @example
	     *
	     * _.subtract(6, 4);
	     * // => 2
	     */
	    var subtract = createMathOperation(function(minuend, subtrahend) {
	      return minuend - subtrahend;
	    }, 0);
	
	    /**
	     * Computes the sum of the values in `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.4.0
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @returns {number} Returns the sum.
	     * @example
	     *
	     * _.sum([4, 2, 8, 6]);
	     * // => 20
	     */
	    function sum(array) {
	      return (array && array.length)
	        ? baseSum(array, identity)
	        : 0;
	    }
	
	    /**
	     * This method is like `_.sum` except that it accepts `iteratee` which is
	     * invoked for each element in `array` to generate the value to be summed.
	     * The iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {number} Returns the sum.
	     * @example
	     *
	     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
	     *
	     * _.sumBy(objects, function(o) { return o.n; });
	     * // => 20
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.sumBy(objects, 'n');
	     * // => 20
	     */
	    function sumBy(array, iteratee) {
	      return (array && array.length)
	        ? baseSum(array, getIteratee(iteratee, 2))
	        : 0;
	    }
	
	    /*------------------------------------------------------------------------*/
	
	    // Add methods that return wrapped values in chain sequences.
	    lodash.after = after;
	    lodash.ary = ary;
	    lodash.assign = assign;
	    lodash.assignIn = assignIn;
	    lodash.assignInWith = assignInWith;
	    lodash.assignWith = assignWith;
	    lodash.at = at;
	    lodash.before = before;
	    lodash.bind = bind;
	    lodash.bindAll = bindAll;
	    lodash.bindKey = bindKey;
	    lodash.castArray = castArray;
	    lodash.chain = chain;
	    lodash.chunk = chunk;
	    lodash.compact = compact;
	    lodash.concat = concat;
	    lodash.cond = cond;
	    lodash.conforms = conforms;
	    lodash.constant = constant;
	    lodash.countBy = countBy;
	    lodash.create = create;
	    lodash.curry = curry;
	    lodash.curryRight = curryRight;
	    lodash.debounce = debounce;
	    lodash.defaults = defaults;
	    lodash.defaultsDeep = defaultsDeep;
	    lodash.defer = defer;
	    lodash.delay = delay;
	    lodash.difference = difference;
	    lodash.differenceBy = differenceBy;
	    lodash.differenceWith = differenceWith;
	    lodash.drop = drop;
	    lodash.dropRight = dropRight;
	    lodash.dropRightWhile = dropRightWhile;
	    lodash.dropWhile = dropWhile;
	    lodash.fill = fill;
	    lodash.filter = filter;
	    lodash.flatMap = flatMap;
	    lodash.flatMapDeep = flatMapDeep;
	    lodash.flatMapDepth = flatMapDepth;
	    lodash.flatten = flatten;
	    lodash.flattenDeep = flattenDeep;
	    lodash.flattenDepth = flattenDepth;
	    lodash.flip = flip;
	    lodash.flow = flow;
	    lodash.flowRight = flowRight;
	    lodash.fromPairs = fromPairs;
	    lodash.functions = functions;
	    lodash.functionsIn = functionsIn;
	    lodash.groupBy = groupBy;
	    lodash.initial = initial;
	    lodash.intersection = intersection;
	    lodash.intersectionBy = intersectionBy;
	    lodash.intersectionWith = intersectionWith;
	    lodash.invert = invert;
	    lodash.invertBy = invertBy;
	    lodash.invokeMap = invokeMap;
	    lodash.iteratee = iteratee;
	    lodash.keyBy = keyBy;
	    lodash.keys = keys;
	    lodash.keysIn = keysIn;
	    lodash.map = map;
	    lodash.mapKeys = mapKeys;
	    lodash.mapValues = mapValues;
	    lodash.matches = matches;
	    lodash.matchesProperty = matchesProperty;
	    lodash.memoize = memoize;
	    lodash.merge = merge;
	    lodash.mergeWith = mergeWith;
	    lodash.method = method;
	    lodash.methodOf = methodOf;
	    lodash.mixin = mixin;
	    lodash.negate = negate;
	    lodash.nthArg = nthArg;
	    lodash.omit = omit;
	    lodash.omitBy = omitBy;
	    lodash.once = once;
	    lodash.orderBy = orderBy;
	    lodash.over = over;
	    lodash.overArgs = overArgs;
	    lodash.overEvery = overEvery;
	    lodash.overSome = overSome;
	    lodash.partial = partial;
	    lodash.partialRight = partialRight;
	    lodash.partition = partition;
	    lodash.pick = pick;
	    lodash.pickBy = pickBy;
	    lodash.property = property;
	    lodash.propertyOf = propertyOf;
	    lodash.pull = pull;
	    lodash.pullAll = pullAll;
	    lodash.pullAllBy = pullAllBy;
	    lodash.pullAllWith = pullAllWith;
	    lodash.pullAt = pullAt;
	    lodash.range = range;
	    lodash.rangeRight = rangeRight;
	    lodash.rearg = rearg;
	    lodash.reject = reject;
	    lodash.remove = remove;
	    lodash.rest = rest;
	    lodash.reverse = reverse;
	    lodash.sampleSize = sampleSize;
	    lodash.set = set;
	    lodash.setWith = setWith;
	    lodash.shuffle = shuffle;
	    lodash.slice = slice;
	    lodash.sortBy = sortBy;
	    lodash.sortedUniq = sortedUniq;
	    lodash.sortedUniqBy = sortedUniqBy;
	    lodash.split = split;
	    lodash.spread = spread;
	    lodash.tail = tail;
	    lodash.take = take;
	    lodash.takeRight = takeRight;
	    lodash.takeRightWhile = takeRightWhile;
	    lodash.takeWhile = takeWhile;
	    lodash.tap = tap;
	    lodash.throttle = throttle;
	    lodash.thru = thru;
	    lodash.toArray = toArray;
	    lodash.toPairs = toPairs;
	    lodash.toPairsIn = toPairsIn;
	    lodash.toPath = toPath;
	    lodash.toPlainObject = toPlainObject;
	    lodash.transform = transform;
	    lodash.unary = unary;
	    lodash.union = union;
	    lodash.unionBy = unionBy;
	    lodash.unionWith = unionWith;
	    lodash.uniq = uniq;
	    lodash.uniqBy = uniqBy;
	    lodash.uniqWith = uniqWith;
	    lodash.unset = unset;
	    lodash.unzip = unzip;
	    lodash.unzipWith = unzipWith;
	    lodash.update = update;
	    lodash.updateWith = updateWith;
	    lodash.values = values;
	    lodash.valuesIn = valuesIn;
	    lodash.without = without;
	    lodash.words = words;
	    lodash.wrap = wrap;
	    lodash.xor = xor;
	    lodash.xorBy = xorBy;
	    lodash.xorWith = xorWith;
	    lodash.zip = zip;
	    lodash.zipObject = zipObject;
	    lodash.zipObjectDeep = zipObjectDeep;
	    lodash.zipWith = zipWith;
	
	    // Add aliases.
	    lodash.entries = toPairs;
	    lodash.entriesIn = toPairsIn;
	    lodash.extend = assignIn;
	    lodash.extendWith = assignInWith;
	
	    // Add methods to `lodash.prototype`.
	    mixin(lodash, lodash);
	
	    /*------------------------------------------------------------------------*/
	
	    // Add methods that return unwrapped values in chain sequences.
	    lodash.add = add;
	    lodash.attempt = attempt;
	    lodash.camelCase = camelCase;
	    lodash.capitalize = capitalize;
	    lodash.ceil = ceil;
	    lodash.clamp = clamp;
	    lodash.clone = clone;
	    lodash.cloneDeep = cloneDeep;
	    lodash.cloneDeepWith = cloneDeepWith;
	    lodash.cloneWith = cloneWith;
	    lodash.conformsTo = conformsTo;
	    lodash.deburr = deburr;
	    lodash.defaultTo = defaultTo;
	    lodash.divide = divide;
	    lodash.endsWith = endsWith;
	    lodash.eq = eq;
	    lodash.escape = escape;
	    lodash.escapeRegExp = escapeRegExp;
	    lodash.every = every;
	    lodash.find = find;
	    lodash.findIndex = findIndex;
	    lodash.findKey = findKey;
	    lodash.findLast = findLast;
	    lodash.findLastIndex = findLastIndex;
	    lodash.findLastKey = findLastKey;
	    lodash.floor = floor;
	    lodash.forEach = forEach;
	    lodash.forEachRight = forEachRight;
	    lodash.forIn = forIn;
	    lodash.forInRight = forInRight;
	    lodash.forOwn = forOwn;
	    lodash.forOwnRight = forOwnRight;
	    lodash.get = get;
	    lodash.gt = gt;
	    lodash.gte = gte;
	    lodash.has = has;
	    lodash.hasIn = hasIn;
	    lodash.head = head;
	    lodash.identity = identity;
	    lodash.includes = includes;
	    lodash.indexOf = indexOf;
	    lodash.inRange = inRange;
	    lodash.invoke = invoke;
	    lodash.isArguments = isArguments;
	    lodash.isArray = isArray;
	    lodash.isArrayBuffer = isArrayBuffer;
	    lodash.isArrayLike = isArrayLike;
	    lodash.isArrayLikeObject = isArrayLikeObject;
	    lodash.isBoolean = isBoolean;
	    lodash.isBuffer = isBuffer;
	    lodash.isDate = isDate;
	    lodash.isElement = isElement;
	    lodash.isEmpty = isEmpty;
	    lodash.isEqual = isEqual;
	    lodash.isEqualWith = isEqualWith;
	    lodash.isError = isError;
	    lodash.isFinite = isFinite;
	    lodash.isFunction = isFunction;
	    lodash.isInteger = isInteger;
	    lodash.isLength = isLength;
	    lodash.isMap = isMap;
	    lodash.isMatch = isMatch;
	    lodash.isMatchWith = isMatchWith;
	    lodash.isNaN = isNaN;
	    lodash.isNative = isNative;
	    lodash.isNil = isNil;
	    lodash.isNull = isNull;
	    lodash.isNumber = isNumber;
	    lodash.isObject = isObject;
	    lodash.isObjectLike = isObjectLike;
	    lodash.isPlainObject = isPlainObject;
	    lodash.isRegExp = isRegExp;
	    lodash.isSafeInteger = isSafeInteger;
	    lodash.isSet = isSet;
	    lodash.isString = isString;
	    lodash.isSymbol = isSymbol;
	    lodash.isTypedArray = isTypedArray;
	    lodash.isUndefined = isUndefined;
	    lodash.isWeakMap = isWeakMap;
	    lodash.isWeakSet = isWeakSet;
	    lodash.join = join;
	    lodash.kebabCase = kebabCase;
	    lodash.last = last;
	    lodash.lastIndexOf = lastIndexOf;
	    lodash.lowerCase = lowerCase;
	    lodash.lowerFirst = lowerFirst;
	    lodash.lt = lt;
	    lodash.lte = lte;
	    lodash.max = max;
	    lodash.maxBy = maxBy;
	    lodash.mean = mean;
	    lodash.meanBy = meanBy;
	    lodash.min = min;
	    lodash.minBy = minBy;
	    lodash.stubArray = stubArray;
	    lodash.stubFalse = stubFalse;
	    lodash.stubObject = stubObject;
	    lodash.stubString = stubString;
	    lodash.stubTrue = stubTrue;
	    lodash.multiply = multiply;
	    lodash.nth = nth;
	    lodash.noConflict = noConflict;
	    lodash.noop = noop;
	    lodash.now = now;
	    lodash.pad = pad;
	    lodash.padEnd = padEnd;
	    lodash.padStart = padStart;
	    lodash.parseInt = parseInt;
	    lodash.random = random;
	    lodash.reduce = reduce;
	    lodash.reduceRight = reduceRight;
	    lodash.repeat = repeat;
	    lodash.replace = replace;
	    lodash.result = result;
	    lodash.round = round;
	    lodash.runInContext = runInContext;
	    lodash.sample = sample;
	    lodash.size = size;
	    lodash.snakeCase = snakeCase;
	    lodash.some = some;
	    lodash.sortedIndex = sortedIndex;
	    lodash.sortedIndexBy = sortedIndexBy;
	    lodash.sortedIndexOf = sortedIndexOf;
	    lodash.sortedLastIndex = sortedLastIndex;
	    lodash.sortedLastIndexBy = sortedLastIndexBy;
	    lodash.sortedLastIndexOf = sortedLastIndexOf;
	    lodash.startCase = startCase;
	    lodash.startsWith = startsWith;
	    lodash.subtract = subtract;
	    lodash.sum = sum;
	    lodash.sumBy = sumBy;
	    lodash.template = template;
	    lodash.times = times;
	    lodash.toFinite = toFinite;
	    lodash.toInteger = toInteger;
	    lodash.toLength = toLength;
	    lodash.toLower = toLower;
	    lodash.toNumber = toNumber;
	    lodash.toSafeInteger = toSafeInteger;
	    lodash.toString = toString;
	    lodash.toUpper = toUpper;
	    lodash.trim = trim;
	    lodash.trimEnd = trimEnd;
	    lodash.trimStart = trimStart;
	    lodash.truncate = truncate;
	    lodash.unescape = unescape;
	    lodash.uniqueId = uniqueId;
	    lodash.upperCase = upperCase;
	    lodash.upperFirst = upperFirst;
	
	    // Add aliases.
	    lodash.each = forEach;
	    lodash.eachRight = forEachRight;
	    lodash.first = head;
	
	    mixin(lodash, (function() {
	      var source = {};
	      baseForOwn(lodash, function(func, methodName) {
	        if (!hasOwnProperty.call(lodash.prototype, methodName)) {
	          source[methodName] = func;
	        }
	      });
	      return source;
	    }()), { 'chain': false });
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * The semantic version number.
	     *
	     * @static
	     * @memberOf _
	     * @type {string}
	     */
	    lodash.VERSION = VERSION;
	
	    // Assign default placeholders.
	    arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {
	      lodash[methodName].placeholder = lodash;
	    });
	
	    // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
	    arrayEach(['drop', 'take'], function(methodName, index) {
	      LazyWrapper.prototype[methodName] = function(n) {
	        var filtered = this.__filtered__;
	        if (filtered && !index) {
	          return new LazyWrapper(this);
	        }
	        n = n === undefined ? 1 : nativeMax(toInteger(n), 0);
	
	        var result = this.clone();
	        if (filtered) {
	          result.__takeCount__ = nativeMin(n, result.__takeCount__);
	        } else {
	          result.__views__.push({
	            'size': nativeMin(n, MAX_ARRAY_LENGTH),
	            'type': methodName + (result.__dir__ < 0 ? 'Right' : '')
	          });
	        }
	        return result;
	      };
	
	      LazyWrapper.prototype[methodName + 'Right'] = function(n) {
	        return this.reverse()[methodName](n).reverse();
	      };
	    });
	
	    // Add `LazyWrapper` methods that accept an `iteratee` value.
	    arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {
	      var type = index + 1,
	          isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
	
	      LazyWrapper.prototype[methodName] = function(iteratee) {
	        var result = this.clone();
	        result.__iteratees__.push({
	          'iteratee': getIteratee(iteratee, 3),
	          'type': type
	        });
	        result.__filtered__ = result.__filtered__ || isFilter;
	        return result;
	      };
	    });
	
	    // Add `LazyWrapper` methods for `_.head` and `_.last`.
	    arrayEach(['head', 'last'], function(methodName, index) {
	      var takeName = 'take' + (index ? 'Right' : '');
	
	      LazyWrapper.prototype[methodName] = function() {
	        return this[takeName](1).value()[0];
	      };
	    });
	
	    // Add `LazyWrapper` methods for `_.initial` and `_.tail`.
	    arrayEach(['initial', 'tail'], function(methodName, index) {
	      var dropName = 'drop' + (index ? '' : 'Right');
	
	      LazyWrapper.prototype[methodName] = function() {
	        return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
	      };
	    });
	
	    LazyWrapper.prototype.compact = function() {
	      return this.filter(identity);
	    };
	
	    LazyWrapper.prototype.find = function(predicate) {
	      return this.filter(predicate).head();
	    };
	
	    LazyWrapper.prototype.findLast = function(predicate) {
	      return this.reverse().find(predicate);
	    };
	
	    LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
	      if (typeof path == 'function') {
	        return new LazyWrapper(this);
	      }
	      return this.map(function(value) {
	        return baseInvoke(value, path, args);
	      });
	    });
	
	    LazyWrapper.prototype.reject = function(predicate) {
	      return this.filter(negate(getIteratee(predicate)));
	    };
	
	    LazyWrapper.prototype.slice = function(start, end) {
	      start = toInteger(start);
	
	      var result = this;
	      if (result.__filtered__ && (start > 0 || end < 0)) {
	        return new LazyWrapper(result);
	      }
	      if (start < 0) {
	        result = result.takeRight(-start);
	      } else if (start) {
	        result = result.drop(start);
	      }
	      if (end !== undefined) {
	        end = toInteger(end);
	        result = end < 0 ? result.dropRight(-end) : result.take(end - start);
	      }
	      return result;
	    };
	
	    LazyWrapper.prototype.takeRightWhile = function(predicate) {
	      return this.reverse().takeWhile(predicate).reverse();
	    };
	
	    LazyWrapper.prototype.toArray = function() {
	      return this.take(MAX_ARRAY_LENGTH);
	    };
	
	    // Add `LazyWrapper` methods to `lodash.prototype`.
	    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
	      var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName),
	          isTaker = /^(?:head|last)$/.test(methodName),
	          lodashFunc = lodash[isTaker ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName],
	          retUnwrapped = isTaker || /^find/.test(methodName);
	
	      if (!lodashFunc) {
	        return;
	      }
	      lodash.prototype[methodName] = function() {
	        var value = this.__wrapped__,
	            args = isTaker ? [1] : arguments,
	            isLazy = value instanceof LazyWrapper,
	            iteratee = args[0],
	            useLazy = isLazy || isArray(value);
	
	        var interceptor = function(value) {
	          var result = lodashFunc.apply(lodash, arrayPush([value], args));
	          return (isTaker && chainAll) ? result[0] : result;
	        };
	
	        if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
	          // Avoid lazy use if the iteratee has a "length" value other than `1`.
	          isLazy = useLazy = false;
	        }
	        var chainAll = this.__chain__,
	            isHybrid = !!this.__actions__.length,
	            isUnwrapped = retUnwrapped && !chainAll,
	            onlyLazy = isLazy && !isHybrid;
	
	        if (!retUnwrapped && useLazy) {
	          value = onlyLazy ? value : new LazyWrapper(this);
	          var result = func.apply(value, args);
	          result.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined });
	          return new LodashWrapper(result, chainAll);
	        }
	        if (isUnwrapped && onlyLazy) {
	          return func.apply(this, args);
	        }
	        result = this.thru(interceptor);
	        return isUnwrapped ? (isTaker ? result.value()[0] : result.value()) : result;
	      };
	    });
	
	    // Add `Array` methods to `lodash.prototype`.
	    arrayEach(['pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {
	      var func = arrayProto[methodName],
	          chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
	          retUnwrapped = /^(?:pop|shift)$/.test(methodName);
	
	      lodash.prototype[methodName] = function() {
	        var args = arguments;
	        if (retUnwrapped && !this.__chain__) {
	          var value = this.value();
	          return func.apply(isArray(value) ? value : [], args);
	        }
	        return this[chainName](function(value) {
	          return func.apply(isArray(value) ? value : [], args);
	        });
	      };
	    });
	
	    // Map minified method names to their real names.
	    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
	      var lodashFunc = lodash[methodName];
	      if (lodashFunc) {
	        var key = (lodashFunc.name + ''),
	            names = realNames[key] || (realNames[key] = []);
	
	        names.push({ 'name': methodName, 'func': lodashFunc });
	      }
	    });
	
	    realNames[createHybrid(undefined, WRAP_BIND_KEY_FLAG).name] = [{
	      'name': 'wrapper',
	      'func': undefined
	    }];
	
	    // Add methods to `LazyWrapper`.
	    LazyWrapper.prototype.clone = lazyClone;
	    LazyWrapper.prototype.reverse = lazyReverse;
	    LazyWrapper.prototype.value = lazyValue;
	
	    // Add chain sequence methods to the `lodash` wrapper.
	    lodash.prototype.at = wrapperAt;
	    lodash.prototype.chain = wrapperChain;
	    lodash.prototype.commit = wrapperCommit;
	    lodash.prototype.next = wrapperNext;
	    lodash.prototype.plant = wrapperPlant;
	    lodash.prototype.reverse = wrapperReverse;
	    lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
	
	    // Add lazy aliases.
	    lodash.prototype.first = lodash.prototype.head;
	
	    if (symIterator) {
	      lodash.prototype[symIterator] = wrapperToIterator;
	    }
	    return lodash;
	  });
	
	  /*--------------------------------------------------------------------------*/
	
	  // Export lodash.
	  var _ = runInContext();
	
	  // Some AMD build optimizers, like r.js, check for condition patterns like:
	  if (true) {
	    // Expose Lodash on the global object to prevent errors when Lodash is
	    // loaded by a script tag in the presence of an AMD loader.
	    // See http://requirejs.org/docs/errors.html#mismatch for more details.
	    // Use `_.noConflict` to remove Lodash from the global object.
	    root._ = _;
	
	    // Define as an anonymous module so, through path mapping, it can be
	    // referenced as the "underscore" module.
	    !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
	      return _;
	    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	  // Check for `exports` after `define` in case a build optimizer adds it.
	  else if (freeModule) {
	    // Export for Node.js.
	    (freeModule.exports = _)._ = _;
	    // Export for CommonJS support.
	    freeExports._ = _;
	  }
	  else {
	    // Export to the global object.
	    root._ = _;
	  }
	}.call(this));
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(101)(module)))

/***/ },
/* 199 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _ImageField = __webpack_require__(200);
	
	Object.defineProperty(exports, "ImageField", {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_ImageField).default;
	  }
	});
	
	var _TextField = __webpack_require__(228);
	
	Object.defineProperty(exports, "TextField", {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_TextField).default;
	  }
	});
	
	var _RichTextField = __webpack_require__(229);
	
	Object.defineProperty(exports, "RichTextField", {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_RichTextField).default;
	  }
	});
	
	var _SelectField = __webpack_require__(239);
	
	Object.defineProperty(exports, "SelectField", {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_SelectField).default;
	  }
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ },
/* 200 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _classCallCheck2 = __webpack_require__(2);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(20);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(89);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _BaseField2 = __webpack_require__(197);
	
	var _BaseField3 = _interopRequireDefault(_BaseField2);
	
	var _Utils = __webpack_require__(103);
	
	var _Utils2 = _interopRequireDefault(_Utils);
	
	var _simpleAjaxUploader = __webpack_require__(201);
	
	var _simpleAjaxUploader2 = _interopRequireDefault(_simpleAjaxUploader);
	
	var _axios = __webpack_require__(202);
	
	var _axios2 = _interopRequireDefault(_axios);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ImageField = function (_BaseField) {
	    (0, _inherits3.default)(ImageField, _BaseField);
	
	    function ImageField(opts) {
	        (0, _classCallCheck3.default)(this, ImageField);
	
	        var _this = (0, _possibleConstructorReturn3.default)(this, _BaseField.call(this, opts));
	
	        _this.onDeleteLocalized = _this.onDeleteLocalized.bind(_this);
	        _this.deleteLocalized = _this.deleteLocalized.bind(_this);
	        return _this;
	    }
	
	    ImageField.prototype.getDefaultOptions = function getDefaultOptions() {
	        return {
	            height: "200px",
	            endpoints: {
	                getPreview: 'path-to-server-get-preview-page',
	                upload: 'path-to-server-upload-page',
	                delete: 'path-to-server-delete-page'
	            },
	            labels: {
	                chooseFile: "Choose file",
	                chooseAnotherFile: "Choose another file",
	                uploading: "Uploading ...",
	                unableToUpload: "Unable to upload file",
	                genericError: "An error occurred.",
	                successfullyUploaded: " successfully uploaded.",
	                delete: "Delete",
	                deleteTitle: "Confirm delete",
	                deleteMessage: "Do you want to delete the image ?",
	                confirm: "Confirm",
	                cancel: "Cancel",
	                invalidFileType: "Invalid file type",
	                fileTooBig: "File too big"
	            },
	            allowedFileTypes: "*",
	            maxFileSize: 1024,
	            showMessage: true
	        };
	    };
	
	    ImageField.prototype.createLocalizedField = function createLocalizedField(lang) {
	        var uid = this.id() + "-" + lang;
	        var title = _Utils2.default.NoLang() === lang ? '' : ' title="' + this.settings.languages[lang] + '" ';
	        var elHtml = '\
	            <div id="upload-container-' + uid + '" class="composer-field image-upload-container" ' + title + ' data-lang="' + lang + '">\
	                <button class="upload-btn" style="height: ' + this.settings.height + ';">' + this.settings.labels.chooseFile + '</button>\
	                <div class="progress-bar-container">\
	                    <div class="progress-bar" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100"></div>\
	                </div>\
	                <div class="tasks">\
	                    <span class="task task-delete">' + this.settings.labels.delete + '</span>\
	                </div>\
	                <div class="msgbox"></div>\
	                <input type="hidden" class="upload-value" id="upload-value-' + uid + '" name="upload-value-' + uid + '" value="' + uid + '"/>\
	            </div>';
	
	        var parsedEl = new DOMParser().parseFromString(elHtml, "text/html");
	        return _BaseField.prototype.find.call(this, parsedEl, "#upload-container-" + uid);
	    };
	
	    ImageField.prototype.getComponentContainer = function getComponentContainer(uid) {
	        return _BaseField.prototype.find.call(this, document, "#upload-container-" + uid);
	    };
	
	    ImageField.prototype.getSubComponent = function getSubComponent(container, selector) {
	        if (typeof container === "string") {
	            if (container.match(/^[0-9a-z]{36}/i)) {
	                return _BaseField.prototype.find.call(this, _BaseField.prototype.find.call(this, document, "#upload-container-" + container), selector);
	            } else {
	                return _BaseField.prototype.find.call(this, _BaseField.prototype.find.call(this, document, "#" + container), selector);
	            }
	        } else {
	            return _BaseField.prototype.find.call(this, container, selector);
	        }
	    };
	
	    ImageField.prototype.init = function init() {
	        var _this2 = this;
	
	        var _loop = function _loop() {
	            if (_isArray) {
	                if (_i >= _iterator.length) return 'break';
	                _ref = _iterator[_i++];
	            } else {
	                _i = _iterator.next();
	                if (_i.done) return 'break';
	                _ref = _i.value;
	            }
	
	            var _ref2 = _ref;
	            lang = _ref2[0];
	            el = _ref2[1];
	
	
	            var uid = _this2.id() + "-" + lang;
	
	            var container = _this2.getComponentContainer(uid);
	
	            var uploadBtn = _this2.getSubComponent(container, '.upload-btn');
	            var progressBar = _this2.getSubComponent(container, '.progress-bar');
	            var progressContainer = _this2.getSubComponent(container, '.progress-bar-container');
	            var msgBox = _this2.getSubComponent(container, '.msgbox');
	            var deleteBtn = _this2.getSubComponent(container, '.task-delete');
	
	            deleteBtn.addEventListener("click", function () {
	                _this2.onDeleteLocalized(uid);
	            });
	
	            msgBox.style.display = _this2.settings.showMessage ? "block" : "none";
	
	            var uploader = new _simpleAjaxUploader2.default.SimpleUpload({
	                button: uploadBtn,
	                url: _this2.settings.endpoints.upload,
	                name: 'uploadfile',
	                multipart: true,
	                hoverClass: 'hover',
	                focusClass: 'focus',
	                responseType: 'json',
	                dropzone: uploadBtn,
	                data: {
	                    parameters: _this2.buildData(uid)
	                },
	                startXHR: function startXHR() {
	                    progressContainer.style.transitionDuration = "0s";
	                    progressContainer.style.opacity = '1';
	                    progressBar.style.width = "0px";
	                    uploader.setProgressBar(progressBar);
	                    uploader.setData({
	                        parameters: _this2.buildData(uid)
	                    });
	                },
	                onProgress: function onProgress(pct) {
	                    progressBar.style.width = pct + "%";
	                    progressBar.innerText = pct + "%";
	                },
	                onExtError: function onExtError(filename, extension) {
	                    _Utils2.default.AlertError(this.settings.labels.invalidFileType);
	                },
	                onSizeError: function onSizeError(filename, fileSize) {
	                    _Utils2.default.AlertError(this.settings.labels.fileTooBig);
	                },
	                onSubmit: function onSubmit() {
	                    msgBox.innerHTML = '';
	                    uploadBtn.innerHTML = _this2.settings.labels.uploading;
	                },
	                onComplete: function onComplete(filename, response) {
	                    if (response && response.status === true) {
	                        if (response.preview) {
	                            var preview = response.preview + "&" + _this2.getSizeForQueryString(uploadBtn);
	                            uploadBtn.style.backgroundImage = "url('" + preview + "')";
	                        }
	
	                        uploadBtn.innerHTML = _this2.settings.labels.chooseAnotherFile;
	                        deleteBtn.style.display = "inline";
	                        msgBox.innerHTML = '<strong>' + _Utils2.default.EscapeTags(response.fileName) + '</strong>';
	                        progressContainer.style.transitionDuration = "2s";
	                        progressContainer.style.opacity = '0';
	                    } else {
	                        msgBox.innerHTML = _this2.settings.labels.unableToUpload;
	                    }
	
	                    _BaseField.prototype.signalChange.call(_this2);
	                },
	                onError: function onError() {
	                    progressContainer.style.transitionDuration = "2s";
	                    progressContainer.style.opacity = '0';
	                    msgBox.innerHTML = _this2.settings.labels.unableToUpload;
	                    _BaseField.prototype.signalChange.call(_this2);
	                }
	            });
	        };
	
	        for (var _iterator = _BaseField.prototype.getComponents.call(this), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
	            var _ref;
	
	            var lang, el;
	
	            var _ret = _loop();
	
	            if (_ret === 'break') break;
	        }
	    };
	
	    ImageField.prototype.buildData = function buildData(uid) {
	        var valueEl = this.getSubComponent(uid, '.upload-value');
	
	        return _Utils2.default.ObjToBase64({
	            "UniqueID": valueEl.value,
	            "AllowedFileTypes": this.settings.allowedFileTypes,
	            "MaxFileSize": this.settings.maxFileSize
	        });
	    };
	
	    ImageField.prototype.onDeleteLocalized = function onDeleteLocalized(uid) {
	        var _this3 = this;
	
	        _Utils2.default.AlertWarning(this.settings.labels.deleteTitle, this.settings.labels.deleteMessage, true).then(function () {
	            _this3.deleteLocalized(uid).catch(function () {
	                _Utils2.default.AlertError();
	            });
	        });
	    };
	
	    ImageField.prototype.deleteLocalized = function deleteLocalized(uid) {
	        var _this4 = this;
	
	        return new Promise(function (resolve, reject) {
	
	            _axios2.default.get(_this4.settings.endpoints.delete + "&parameters=" + _this4.buildData(uid)).then(function () {
	
	                var uploadBtn = _this4.getSubComponent(uid, '.upload-btn');
	                var progressBar = _this4.getSubComponent(uid, '.progress-bar');
	                var progressContainer = _this4.getSubComponent(uid, '.progress-bar-container');
	                var msgBox = _this4.getSubComponent(uid, '.msgbox');
	                var deleteBtn = _this4.getSubComponent(uid, '.task-delete');
	
	                uploadBtn.style.removeProperty("background-image");
	                uploadBtn.innerHTML = _this4.settings.labels.chooseFile;
	
	                progressContainer.style.transitionDuration = "0s";
	                progressContainer.style.opacity = '0';
	
	                progressBar.style.width = "0px";
	
	                msgBox.innerText = "";
	
	                deleteBtn.style.display = "none";
	                _BaseField.prototype.signalChange.call(_this4);
	                resolve();
	            }).catch(function () {
	                _Utils2.default.AlertError();
	                reject();
	            });
	        });
	    };
	
	    ImageField.prototype.delete = function _delete() {
	
	        var deletePromises = [];
	
	        for (var _iterator2 = _BaseField.prototype.getComponents.call(this), _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
	            var _ref3;
	
	            if (_isArray2) {
	                if (_i2 >= _iterator2.length) break;
	                _ref3 = _iterator2[_i2++];
	            } else {
	                _i2 = _iterator2.next();
	                if (_i2.done) break;
	                _ref3 = _i2.value;
	            }
	
	            var _ref4 = _ref3,
	                lang = _ref4[0],
	                el = _ref4[1];
	
	            deletePromises.push(this.deleteLocalized(el.getAttribute("id")));
	        }
	
	        return Promise.all(deletePromises);
	    };
	
	    ImageField.prototype.getValueFromLocalizedField = function getValueFromLocalizedField(el, lang) {
	        return this.getSubComponent(el, '.upload-value').value;
	    };
	
	    ImageField.prototype.setValueToLocalizedField = function setValueToLocalizedField(el, value, lang) {
	        var _this5 = this;
	
	        var valueEl = this.getSubComponent(el, '.upload-value');
	        valueEl.value = value;
	        _axios2.default.get(this.settings.endpoints.getPreview + "&parameters=" + this.buildData(el)).then(function (response) {
	
	            if (response.data && response.data.preview) {
	                var _uploadBtn = _this5.getSubComponent(el, '.upload-btn');
	                var _deleteBtn = _this5.getSubComponent(el, '.task-delete');
	
	                var preview = response.data.preview + "&" + _this5.getSizeForQueryString(_uploadBtn, 200);
	
	                _uploadBtn.style.backgroundImage = "url('" + preview + "')";
	                _uploadBtn.innerHTML = _this5.settings.labels.chooseAnotherFile;
	
	                _deleteBtn.style.display = "inline";
	            }
	        }).catch(function () {
	            _Utils2.default.AlertError();
	        });
	    };
	
	    return ImageField;
	}(_BaseField3.default);
	
	exports.default = ImageField;

/***/ },
/* 201 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Simple Ajax Uploader
	 * Version 2.5.5
	 * https://github.com/LPology/Simple-Ajax-Uploader
	 *
	 * Copyright 2012-2016 LPology, LLC
	 * Released under the MIT license
	 */
	
	;(function( global, factory ) {
	    /*globals define, module */
	    if ( true ) {
	        !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
	            return factory( global );
	        }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	
	    } else if ( typeof module === 'object' && module.exports ) {
	        module.exports = factory( global );
	
	    } else {
	        global.ss = factory( global );
	    }
	
	}( typeof window !== 'undefined' ? window : this, function( window ) {
	
	var ss = window.ss || {},
	
	    // ss.trim()
	    rLWhitespace = /^\s+/,
	    rTWhitespace = /\s+$/,
	
	    // ss.getUID
	    uidReplace = /[xy]/g,
	
	    // ss.getFilename()
	    rPath = /.*(\/|\\)/,
	
	    // ss.getExt()
	    rExt = /.*[.]/,
	
	    // ss.hasClass()
	    rHasClass = /[\t\r\n]/g,
	
	    // Check for Safari -- it doesn't like multi file uploading. At all.
	    // http://stackoverflow.com/a/9851769/1091949
	    isSafari = Object.prototype.toString.call( window.HTMLElement ).indexOf( 'Constructor' ) > 0,
	
	    isIE7 = ( navigator.userAgent.indexOf('MSIE 7') !== -1 ),
	
	    // Check whether XHR uploads are supported
	    input = document.createElement( 'input' ),
	
	    XhrOk;
	
	input.type = 'file';
	
	XhrOk = ( 'multiple' in input &&
	          typeof File !== 'undefined' &&
	          typeof ( new XMLHttpRequest() ).upload !== 'undefined' );
	
	
	/**
	* Converts object to query string
	*/
	ss.obj2string = function( obj, prefix ) {
	    "use strict";
	
	    var str = [];
	
	    for ( var prop in obj ) {
	        if ( obj.hasOwnProperty( prop ) ) {
	            var k = prefix ? prefix + '[' + prop + ']' : prop, v = obj[prop];
	            str.push( typeof v === 'object' ?
	                        ss.obj2string( v, k ) :
	                        encodeURIComponent( k ) + '=' + encodeURIComponent( v ) );
	        }
	    }
	
	    return str.join( '&' );
	};
	
	/**
	* Copies all missing properties from second object to first object
	*/
	ss.extendObj = function( first, second ) {
	    "use strict";
	
	    for ( var prop in second ) {
	        if ( second.hasOwnProperty( prop ) ) {
	            first[prop] = second[prop];
	        }
	    }
	};
	
	ss.addEvent = function( elem, type, fn ) {
	    "use strict";
	
	    if ( elem.addEventListener ) {
	        elem.addEventListener( type, fn, false );
	
	    } else {
	        elem.attachEvent( 'on' + type, fn );
	    }
	    return function() {
	        ss.removeEvent( elem, type, fn );
	    };
	};
	
	ss.removeEvent = document.removeEventListener ?
	    function( elem, type, fn ) {
	        if ( elem.removeEventListener ) {
	            elem.removeEventListener( type, fn, false );
	        }
	    } :
	    function( elem, type, fn ) {
	        var name = 'on' + type;
	
	        if ( typeof elem[ name ] === 'undefined' ) {
	            elem[ name ] = null;
	        }
	
	        elem.detachEvent( name, fn );
	    };
	
	ss.newXHR = function() {
	    "use strict";
	
	    if ( typeof XMLHttpRequest !== 'undefined' ) {
	        return new window.XMLHttpRequest();
	
	    } else if ( window.ActiveXObject ) {
	        try {
	            return new window.ActiveXObject( 'Microsoft.XMLHTTP' );
	        } catch ( err ) {
	            return false;
	        }
	    }
	};
	
	ss.encodeUTF8 = function( str ) {
	    "use strict";
	    /*jshint nonstandard:true*/
	    return unescape( encodeURIComponent( str ) );
	};
	
	ss.getIFrame = function() {
	    "use strict";
	
	    var id = ss.getUID(),
	        iframe;
	
	    // IE7 can only create an iframe this way, all others are the other way
	    if ( isIE7 ) {
	        iframe = document.createElement('<iframe src="javascript:false;" name="' + id + '">');
	
	    } else {
	        iframe = document.createElement('iframe');
	        /*jshint scripturl:true*/
	        iframe.src = 'javascript:false;';
	        iframe.name = id;
	    }
	
	    iframe.style.display = 'none';
	    iframe.id = id;
	    return iframe;
	};
	
	ss.getForm = function( opts ) {
	    "use strict";
	
	    var form = document.createElement('form');
	
	    form.encoding = 'multipart/form-data'; // IE
	    form.enctype = 'multipart/form-data';
	    form.style.display = 'none';
	
	    for ( var prop in opts ) {
	        if ( opts.hasOwnProperty( prop ) ) {
	            form[prop] = opts[prop];
	        }
	    }
	
	    return form;
	};
	
	ss.getHidden = function( name, value ) {
	    "use strict";
	
	    var input = document.createElement( 'input' );
	
	    input.type = 'hidden';
	    input.name = name;
	    input.value = value;
	    return input;
	};
	
	/**
	* Parses a JSON string and returns a Javascript object
	* Borrowed from www.jquery.com
	*/
	ss.parseJSON = function( data ) {
	    "use strict";
	    /*jshint evil:true*/
	
	    if ( !data ) {
	        return false;
	    }
	
	    data = ss.trim( data + '' );
	
	    if ( window.JSON && window.JSON.parse ) {
	        try {
	            // Support: Android 2.3
	            // Workaround failure to string-cast null input
	            return window.JSON.parse( data + '' );
	        } catch ( err ) {
	            return false;
	        }
	    }
	
	    var rvalidtokens = /(,)|(\[|{)|(}|])|"(?:[^"\\\r\n]|\\["\\\/bfnrt]|\\u[\da-fA-F]{4})*"\s*:?|true|false|null|-?(?!0\d)\d+(?:\.\d+|)(?:[eE][+-]?\d+|)/g,
	        depth = null,
	        requireNonComma;
	
	    // Guard against invalid (and possibly dangerous) input by ensuring that nothing remains
	    // after removing valid tokens
	    return data && !ss.trim( data.replace( rvalidtokens, function( token, comma, open, close ) {
	
	        // Force termination if we see a misplaced comma
	        if ( requireNonComma && comma ) {
	            depth = 0;
	        }
	
	        // Perform no more replacements after returning to outermost depth
	        if ( depth === 0 ) {
	            return token;
	        }
	
	        // Commas must not follow "[", "{", or ","
	        requireNonComma = open || comma;
	
	        // Determine new depth
	        // array/object open ("[" or "{"): depth += true - false (increment)
	        // array/object close ("]" or "}"): depth += false - true (decrement)
	        // other cases ("," or primitive): depth += true - true (numeric cast)
	        depth += !close - !open;
	
	        // Remove this token
	        return '';
	    }) ) ?
	        ( Function( 'return ' + data ) )() :
	        false;
	};
	
	ss.getBox = function( elem ) {
	    "use strict";
	
	    var box,
	        docElem,
	        top = 0,
	        left = 0;
	
	    if ( elem.getBoundingClientRect ) {
	        box = elem.getBoundingClientRect();
	        docElem = document.documentElement;
	        top = box.top + ( window.pageYOffset || docElem.scrollTop )  - ( docElem.clientTop  || 0 );
	        left = box.left + ( window.pageXOffset || docElem.scrollLeft ) - ( docElem.clientLeft || 0 );
	
	    } else {
	        do {
	            left += elem.offsetLeft;
	            top += elem.offsetTop;
	        } while ( ( elem = elem.offsetParent ) );
	    }
	
	    return {
	        top: Math.round( top ),
	        left: Math.round( left )
	    };
	};
	
	/**
	* Helper that takes object literal
	* and add all properties to element.style
	* @param {Element} el
	* @param {Object} styles
	*/
	ss.addStyles = function( elem, styles ) {
	    "use strict";
	
	    for ( var name in styles ) {
	        if ( styles.hasOwnProperty( name ) ) {
	            elem.style[name] = styles[name];
	        }
	    }
	};
	
	/**
	* Function places an absolutely positioned
	* element on top of the specified element
	* copying position and dimensions.
	*/
	ss.copyLayout = function( from, to ) {
	    "use strict";
	
	    var box = ss.getBox( from );
	
	    ss.addStyles( to, {
	        position: 'absolute',
	        left : box.left + 'px',
	        top : box.top + 'px',
	        width : from.offsetWidth + 'px',
	        height : from.offsetHeight + 'px'
	    });
	};
	
	/**
	* Generates unique ID
	* Complies with RFC 4122 version 4
	* http://stackoverflow.com/a/2117523/1091949
	* ID begins with letter "a" to be safe for HTML elem ID/name attr (can't start w/ number)
	*/
	ss.getUID = function() {
	    "use strict";
	
	    /*jshint bitwise: false*/
	    return 'axxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(uidReplace, function(c) {
	        var r = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);
	        return v.toString(16);
	    });
	};
	
	/**
	* Removes white space from left and right of string
	* Uses native String.trim if available
	* Adapted from www.jquery.com
	*/
	var trim = "".trim;
	
	ss.trim = trim && !trim.call("\uFEFF\xA0") ?
	    function( text ) {
	        return text === null ?
	            "" :
	            trim.call( text );
	    } :
	    function( text ) {
	        return text === null ?
	            "" :
	            text.toString().replace( rLWhitespace, '' ).replace( rTWhitespace, '' );
	    };
	
	var arr = [];
	
	ss.indexOf = arr.indexOf ?
	    function( array, elem ) {
	        return array.indexOf( elem );
	    } :
	    function( array, elem ) {
	        for ( var i = 0, len = array.length; i < len; i++ ) {
	            if ( array[i] === elem ) {
	                return i;
	            }
	        }
	        return -1;
	    };
	
	/**
	* Removes an element from an array
	*/
	ss.arrayDelete = function( array, elem ) {
	    var index = ss.indexOf( array, elem );
	
	    if ( index > -1 ) {
	        array.splice( index, 1 );
	    }
	};
	
	/**
	* Extract file name from path
	*/
	ss.getFilename = function( path ) {
	    "use strict";
	    return path.replace( rPath, '' );
	};
	
	/**
	* Get file extension
	*/
	ss.getExt = function( file ) {
	    "use strict";
	    return ( -1 !== file.indexOf( '.' ) ) ? file.replace( rExt, '' ) : '';
	};
	
	/**
	* Checks whether an element is visible
	*/
	ss.isVisible = function( elem ) {
	    "use strict";
	
	    if ( !elem ) {
	        return false;
	    }
	
	    if ( elem.nodeType !== 1 || elem == document.body ) {
	        elem = null;
	        return true;
	    }
	
	    if ( elem.parentNode &&
	        ( elem.offsetWidth > 0 ||
	         elem.offsetHeight > 0 ||
	         ss.getStyle( elem, 'display' ).toLowerCase() != 'none' ) )
	    {
	        return ss.isVisible( elem.parentNode );
	    }
	
	    elem = null;
	    return false;
	};
	
	ss.getStyle = function( elem, style ) {
	    "use strict";
	
	    if ( window.getComputedStyle ) {
	        var cs = elem.ownerDocument.defaultView.getComputedStyle( elem, null );
	        return cs.getPropertyValue( style );
	
	    } else if ( elem.currentStyle && elem.currentStyle[ style ] ) {
	        return elem.currentStyle[ style ];
	    }
	};
	
	/**
	* Accepts a form element and returns an object with key/value pairs for the form fields
	*/
	ss.getFormObj = function( form ) {
	    "use strict";
	
	    var elems = form.elements,
	        ignore = ['button', 'submit', 'image', 'reset'],
	        inputs = {},
	        obj;
	
	    for ( var i = 0, len = elems.length; i < len; i++ ) {
	        obj = {};
	
	        if ( elems[ i ].name && !elems[ i ].disabled && ss.indexOf( ignore, elems[ i ].type ) === -1 ) {
	            if ( (elems[ i ].type == 'checkbox' || elems[ i ].type == 'radio') &&
	                 !elems[ i ].checked )
	            {
	                continue;
	            }
	
	            obj[ elems[ i ].name ] = ss.val( elems[ i ] );
	            ss.extendObj( inputs, obj );
	        }
	    }
	
	    return inputs;
	};
	
	/**
	* Accepts a form input element and returns its value
	*/
	ss.val = function( elem ) {
	    "use strict";
	
	    if ( !elem ) {
	        return;
	    }
	
	    if ( elem.nodeName.toUpperCase() == 'SELECT' ) {
	        var options = elem.options,
	            index = elem.selectedIndex,
	            one = elem.type === 'select-one' || index < 0,
	            values = one ? null : [],
	            value;
	
	        for ( var i = 0, len = options.length; i < len; i++ ) {
	            if ( ( options[ i ].selected || i === index ) && !options[ i ].disabled ) {
	                value = !options[ i ].value ? options[ i ].text : options[ i ].value;
	
	                if ( one ) {
	                    return value;
	                }
	
	                values.push( value );
	            }
	        }
	
	        return values;
	
	    } else {
	        return elem.value;
	    }
	};
	
	/**
	* Check whether element has a particular CSS class
	* Parts borrowed from www.jquery.com
	*/
	ss.hasClass = function( elem, name ) {
	    "use strict";
	
	    if ( !elem || !name ) {
	        return false;
	    }
	
	    return ( ' ' + elem.className + ' ' ).replace( rHasClass, ' ' ).indexOf( ' ' + name + ' ' ) >= 0;
	};
	
	/**
	* Adds CSS class to an element
	*/
	ss.addClass = function( elem, name ) {
	    "use strict";
	
	    if ( !elem || !name ) {
	        return false;
	    }
	
	    if ( !ss.hasClass( elem, name ) ) {
	        elem.className += ' ' + name;
	    }
	};
	
	/**
	* Removes CSS class from an element
	*/
	ss.removeClass = (function() {
	    "use strict";
	
	    var c = {}; //cache regexps for performance
	
	    return function( e, name ) {
	        if ( !e || !name ) {
	            return false;
	        }
	
	        if ( !c[name] ) {
	            c[name] = new RegExp('(?:^|\\s)' + name + '(?!\\S)');
	        }
	
	        e.className = e.className.replace( c[name], '' );
	    };
	})();
	
	/**
	* Nulls out event handlers to prevent memory leaks in IE6/IE7
	* http://javascript.crockford.com/memory/leak.html
	* @param {Element} d
	* @return void
	*/
	ss.purge = function( d ) {
	    "use strict";
	
	    var a = d.attributes, i, l, n;
	
	    if ( a ) {
	        for ( i = a.length - 1; i >= 0; i -= 1 ) {
	            n = a[i].name;
	
	            if ( typeof d[n] === 'function' ) {
	                d[n] = null;
	            }
	        }
	    }
	
	    a = d.childNodes;
	
	    if ( a ) {
	        l = a.length;
	        for ( i = 0; i < l; i += 1 ) {
	            ss.purge( d.childNodes[i] );
	        }
	    }
	};
	
	/**
	* Removes element from the DOM
	*/
	ss.remove = function( elem ) {
	    "use strict";
	
	    if ( elem && elem.parentNode ) {
	        // null out event handlers for IE
	        ss.purge( elem );
	        elem.parentNode.removeChild( elem );
	    }
	    elem = null;
	};
	
	/**
	* Accepts either a jQuery object, a string containing an element ID, or an element,
	* verifies that it exists, and returns the element.
	* @param {Mixed} elem
	* @return {Element}
	*/
	ss.verifyElem = function( elem ) {
	    "use strict";
	    /*globals jQuery */
	
	    if ( typeof jQuery !== 'undefined' && elem instanceof jQuery ) {
	        elem = elem[0];
	
	    } else if ( typeof elem === 'string' ) {
	        if ( elem.charAt( 0 ) == '#' ) {
	            elem = elem.substr( 1 );
	        }
	        elem = document.getElementById( elem );
	    }
	
	    if ( !elem || elem.nodeType !== 1 ) {
	        return false;
	    }
	
	    if ( elem.nodeName.toUpperCase() == 'A' ) {
	        elem.style.cursor = 'pointer';
	
	        ss.addEvent( elem, 'click', function( e ) {
	            if ( e && e.preventDefault ) {
	                e.preventDefault();
	
	            } else if ( window.event ) {
	                window.event.returnValue = false;
	            }
	        });
	    }
	
	    return elem;
	};
	
	ss._options = {};
	
	ss.uploadSetup = function( options ) {
	    "use strict";
	    ss.extendObj( ss._options, options );
	};
	
	ss.SimpleUpload = function( options ) {
	    "use strict";
	
	    this._opts = {
	        button: '',
	        url: '',
	        dropzone: '',
	        dragClass: '',
	        form: '',
	        overrideSubmit: true,
	        cors: false,
	        withCredentials: false,
	        progressUrl: false,
	        sessionProgressUrl: false,
	        nginxProgressUrl: false,
	        multiple: false,
	        maxUploads: 3,
	        queue: true,
	        checkProgressInterval: 500,
	        keyParamName: 'APC_UPLOAD_PROGRESS',
	        sessionProgressName: 'PHP_SESSION_UPLOAD_PROGRESS',
	        nginxProgressHeader: 'X-Progress-ID',
	        customProgressHeaders: {},
	        corsInputName: 'XHR_CORS_TARGETORIGIN',
	        allowedExtensions: [],
	        accept: '',
	        maxSize: false,
	        name: '',
	        data: {},
	        noParams: true,
	        autoSubmit: true,
	        multipart: true,
	        method: 'POST',
	        responseType: '',
	        debug: false,
	        hoverClass: '',
	        focusClass: '',
	        disabledClass: '',
	        customHeaders: {},
	        encodeHeaders: true,
	        autoCalibrate: true,
	        onBlankSubmit: function() {},
	        onAbort: function( filename, uploadBtn, size ) {},
	        onChange: function( filename, extension, uploadBtn, size, file ) {},
	        onSubmit: function( filename, extension, uploadBtn, size ) {},
	        onProgress: function( pct ) {},
	        onUpdateFileSize: function( filesize ) {},
	        onComplete: function( filename, response, uploadBtn, size ) {},
	        onExtError: function( filename, extension ) {},
	        onSizeError: function( filename, fileSize ) {},
	        onError: function( filename, type, status, statusText, response, uploadBtn, size ) {},
	        startXHR: function( filename, fileSize, uploadBtn ) {},
	        endXHR: function( filename, fileSize, uploadBtn ) {},
	        startNonXHR: function( filename, uploadBtn ) {},
	        endNonXHR: function( filename, uploadBtn ) {}
	    };
	
	    ss.extendObj( this._opts, ss._options ); // Include any setup options
	    ss.extendObj( this._opts, options ); // Then add options for this instance
	
	    // An array of objects, each containing two items: a file and a reference
	    // to the button which triggered the upload: { file: uploadFile, btn: button }
	    this._queue = [];
	
	    this._active = 0;
	    this._disabled = false; // if disabled, clicking on button won't do anything
	    this._maxFails = 10; // max allowed failed progress updates requests in iframe mode
	    this._progKeys = {}; // contains the currently active upload ID progress keys
	    this._sizeFlags = {}; // Cache progress keys after setting sizeBox for fewer trips to the DOM
	    this._btns = [];
	
	    this.addButton( this._opts.button );
	
	    delete this._opts.button;
	    this._opts.button = options = null;
	
	    if ( this._opts.multiple === false ) {
	        this._opts.maxUploads = 1;
	    }
	
	    if ( this._opts.dropzone !== '' ) {
	        this.addDZ( this._opts.dropzone );
	    }
	
	    if ( this._opts.dropzone === '' && this._btns.length < 1 ) {
	        throw new Error( "Invalid upload button. Make sure the element you're passing exists." );
	    }
	
	    if ( this._opts.form !== '' ) {
	        this.setForm( this._opts.form );
	    }
	
	    this._createInput();
	    this._manDisabled = false;
	    this.enable( true );
	};
	
	ss.SimpleUpload.prototype = {
	
	    destroy: function() {
	        "use strict";
	
	        // # of upload buttons
	        var i = this._btns.length;
	
	        // Put upload buttons back to the way we found them
	        while ( i-- ) {
	            // Remove event listener
	            if ( this._btns[i].off ) {
	                this._btns[i].off();
	            }
	
	            // Remove any lingering classes
	            ss.removeClass( this._btns[i], this._opts.hoverClass );
	            ss.removeClass( this._btns[i], this._opts.focusClass );
	            ss.removeClass( this._btns[i], this._opts.disabledClass );
	
	            // In case we disabled it
	            this._btns[i].disabled = false;
	        }
	
	        this._killInput();
	
	        // Set a flag to be checked in _last()
	        this._destroy = true;
	    },
	
	    /**
	    * Send data to browser console if debug is set to true
	    */
	    log: function( str ) {
	        "use strict";
	
	        if ( this._opts && this._opts.debug && window.console && window.console.log ) {
	            window.console.log( '[Uploader] ' + str );
	        }
	    },
	
	    /**
	    * Replaces user data
	    * Note that all previously set data is entirely removed and replaced
	    */
	    setData: function( data ) {
	        "use strict";
	        this._opts.data = data;
	    },
	
	    /**
	    * Set or change uploader options
	    * @param {Object} options
	    */
	    setOptions: function( options ) {
	        "use strict";
	        ss.extendObj( this._opts, options );
	    },
	
	    /**
	    * Designate an element as an upload button
	    */
	    addButton: function( button ) {
	        var btn;
	
	        // An array of buttons was passed
	        if ( button instanceof Array ) {
	
	            for ( var i = 0, len = button.length; i < len; i++ ) {
	                btn = ss.verifyElem( button[i] );
	
	                if ( btn !== false ) {
	                    this._btns.push( this.rerouteClicks( btn ) );
	
	                } else {
	                    this.log( 'Button with array index ' + i + ' is invalid' );
	                }
	            }
	
	        // A single button was passed
	        } else {
	            btn = ss.verifyElem( button );
	
	            if ( btn !== false ) {
	                this._btns.push( this.rerouteClicks( btn ) );
	            }
	        }
	    },
	
	    /**
	    * Designate an element as a drop zone
	    */
	    addDZ: function( dropzone ) {
	        if ( !XhrOk ) {
	            return;
	        }
	
	        dropzone = ss.verifyElem( dropzone );
	
	        if ( !dropzone ) {
	            this.log( 'Invalid or nonexistent element passed for drop zone' );
	        } else {
	            this.addDropZone( dropzone );
	        }
	    },
	
	    /**
	    * Designate an element as a progress bar
	    * The CSS width % of the element will be updated as the upload progresses
	    */
	    setProgressBar: function( elem ) {
	        "use strict";
	        this._progBar = ss.verifyElem( elem );
	    },
	
	    /**
	    * Designate an element to receive a string containing progress % during upload
	    * Note: Uses innerHTML, so any existing child elements will be wiped out
	    */
	    setPctBox: function( elem ) {
	        "use strict";
	        this._pctBox = ss.verifyElem( elem );
	    },
	
	    /**
	    * Designate an element to receive a string containing file size at start of upload
	    * Note: Uses innerHTML, so any existing child elements will be wiped out
	    */
	    setFileSizeBox: function( elem ) {
	        "use strict";
	        this._sizeBox = ss.verifyElem( elem );
	    },
	
	    /**
	    * Designate an element to be removed from DOM when upload is completed
	    * Useful for removing progress bar, file size, etc. after upload
	    */
	    setProgressContainer: function( elem ) {
	        "use strict";
	        this._progBox = ss.verifyElem( elem );
	    },
	
	    /**
	    * Designate an element to serve as the upload abort button
	    */
	    setAbortBtn: function( elem, remove ) {
	        "use strict";
	
	        this._abortBtn = ss.verifyElem( elem );
	        this._removeAbort = false;
	
	        if ( remove ) {
	            this._removeAbort = true;
	        }
	    },
	
	    setForm: function( form ) {
	        "use strict";
	
	        this._form = ss.verifyElem( form );
	
	        if ( !this._form || this._form.nodeName.toUpperCase() != 'FORM' ) {
	            this.log( 'Invalid or nonexistent element passed for form' );
	
	        } else {
	            var self = this;
	            this._opts.autoSubmit = false;
	
	            if ( this._opts.overrideSubmit ) {
	                ss.addEvent( this._form, 'submit', function( e ) {
	                    if ( e.preventDefault ) {
	                        e.preventDefault();
	
	                    } else if ( window.event ) {
	                        window.event.returnValue = false;
	                    }
	
	                    if ( self._validateForm() ) {
	                        self.submit();
	                    }
	                });
	
	                this._form.submit = function() {
	                    if ( self._validateForm() ) {
	                        self.submit();
	                    }
	                };
	            }
	        }
	    },
	
	    /**
	    * Returns number of files currently in queue
	    */
	    getQueueSize: function() {
	        "use strict";
	        return this._queue.length;
	    },
	
	    /**
	    * Remove current file from upload queue, reset props, cycle to next upload
	    */
	    removeCurrent: function( id ) {
	        "use strict";
	
	        if ( id ) {
	            var i = this._queue.length;
	
	            while ( i-- ) {
	                if ( this._queue[i].id === id ) {
	                    this._queue.splice( i, 1 );
	                    break;
	                }
	            }
	
	        } else {
	            this._queue.splice( 0, 1 );
	        }
	
	        this._cycleQueue();
	    },
	
	    /**
	    * Clears Queue so only most recent select file is uploaded
	    */
	    clearQueue: function() {
	        "use strict";
	        this._queue.length = 0;
	    },
	
	    /**
	    * Disables upload functionality
	    */
	    disable: function( _self ) {
	        "use strict";
	
	        var i = this._btns.length,
	            nodeName;
	
	        // _self is always true when disable() is called internally
	        this._manDisabled = !_self || this._manDisabled === true ? true : false;
	        this._disabled = true;
	
	        while ( i-- ) {
	            nodeName = this._btns[i].nodeName.toUpperCase();
	
	            if ( nodeName == 'INPUT' || nodeName == 'BUTTON' ) {
	                this._btns[i].disabled = true;
	            }
	
	            if ( this._opts.disabledClass !== '' ) {
	                ss.addClass( this._btns[i], this._opts.disabledClass );
	            }
	        }
	
	        // Hide file input
	        if ( this._input && this._input.parentNode ) {
	            this._input.parentNode.style.visibility = 'hidden';
	        }
	    },
	
	    /**
	    * Enables upload functionality
	    */
	    enable: function( _self ) {
	        "use strict";
	
	        // _self will always be true when enable() is called internally
	        if ( !_self ) {
	            this._manDisabled = false;
	        }
	
	        // Don't enable uploader if it was manually disabled
	        if ( this._manDisabled === true ) {
	            return;
	        }
	
	        var i = this._btns.length;
	
	        this._disabled = false;
	
	        while ( i-- ) {
	            ss.removeClass( this._btns[i], this._opts.disabledClass );
	            this._btns[i].disabled = false;
	        }
	    },
	
	    /**
	     * Updates invisible button position
	     */
	    updatePosition: function( btn ) {
	        "use strict";
	
	        btn = !btn ? this._btns[0] : btn;
	
	        if ( btn && this._input && this._input.parentNode ) {
	            ss.copyLayout( btn, this._input.parentNode );
	        }
	
	        btn = null;
	    },
	
	    rerouteClicks: function( elem ) {
	        "use strict";
	
	        var self = this;
	
	        // ss.addEvent() returns a function to detach, which
	        // allows us to call elem.off() to remove mouseover listener
	        elem.off = ss.addEvent( elem, 'mouseover', function() {
	            if ( self._disabled ) {
	                return;
	            }
	
	            if ( !self._input ) {
	                self._createInput();
	            }
	
	            self._overBtn = elem;
	            ss.copyLayout( elem, self._input.parentNode );
	            self._input.parentNode.style.visibility = 'visible';
	        });
	
	        if ( self._opts.autoCalibrate && !ss.isVisible( elem ) ) {
	            self.log('Upload button not visible');
	
	            var interval = function() {
	                if ( ss.isVisible( elem ) ) {
	                    self.log('Upload button now visible');
	
	                    window.setTimeout(function() {
	                        self.updatePosition( elem );
	
	                        if ( self._btns.length === 1 ) {
	                            self._input.parentNode.style.visibility = 'hidden';
	                        }
	                    }, 200);
	
	                } else {
	                    window.setTimeout( interval, 500 );
	                }
	            };
	
	            window.setTimeout( interval, 500 );
	        }
	
	        return elem;
	    },
	
	    /**
	    * Validates input and directs to either XHR method or iFrame method
	    */
	    submit: function( _, auto ) {
	        "use strict";
	
	        if ( !auto && this._queue.length < 1 ) {
	            this._opts.onBlankSubmit.call( this );
	            return;
	        }
	
	        if ( this._disabled ||
	            this._active >= this._opts.maxUploads ||
	            this._queue.length < 1 )
	        {
	            return;
	        }
	
	        if ( !this._checkFile( this._queue[0] ) ) {
	            return;
	        }
	
	        // User returned false to cancel upload
	        if ( false === this._opts.onSubmit.call( this, this._queue[0].name, this._queue[0].ext, this._queue[0].btn, this._queue[0].size ) ) {
	            this.removeCurrent( this._queue[0].id );
	            return;
	        }
	
	        // Increment the active upload counter
	        this._active++;
	
	        // Disable uploading if multiple file uploads are not enabled
	        // or if queue is disabled and we've reached max uploads
	        if ( this._opts.multiple === false ||
	            this._opts.queue === false && this._active >= this._opts.maxUploads )
	        {
	            this.disable( true );
	        }
	
	        this._initUpload( this._queue[0] );
	    }
	
	};
	
	ss.IframeUpload = {
	
	    _detachEvents: {},
	
	    _detach: function( id ) {
	        if ( this._detachEvents[ id ] ) {
	            this._detachEvents[ id ]();
	            delete this._detachEvents[ id ];
	        }
	    },
	
	    /**
	    * Accepts a URI string and returns the hostname
	    */
	    _getHost: function( uri ) {
	        var a = document.createElement( 'a' );
	
	        a.href = uri;
	
	        if ( a.hostname ) {
	            return a.hostname.toLowerCase();
	        }
	        return uri;
	    },
	
	    _addFiles: function( file ) {
	        var filename = ss.getFilename( file.value ),
	            ext = ss.getExt( filename );
	
	        if ( false === this._opts.onChange.call( this, filename, ext, this._overBtn, undefined, file ) ) {
	            return false;
	        }
	
	        this._queue.push({
	            id: ss.getUID(),
	            file: file,
	            name: filename,
	            ext: ext,
	            btn: this._overBtn,
	            size: null
	        });
	
	        return true;
	    },
	
	    /**
	    * Handles uploading with iFrame
	    */
	    _uploadIframe: function( fileObj, progBox, sizeBox, progBar, pctBox, abortBtn, removeAbort ) {
	        "use strict";
	
	        var self = this,
	            opts = this._opts,
	            key = ss.getUID(),
	            iframe = ss.getIFrame(),
	            form,
	            url,
	            msgLoaded = false,
	            iframeLoaded = false,
	            cancel;
	
	        if ( opts.noParams === true ) {
	            url = opts.url;
	
	        } else {
	            // If we're using Nginx Upload Progress Module, append upload key to the URL
	            // Also, preserve query string if there is one
	            url = !opts.nginxProgressUrl ?
	                    opts.url :
	                    url + ( ( url.indexOf( '?' ) > -1 ) ? '&' : '?' ) +
	                          encodeURIComponent( opts.nginxProgressHeader ) + '=' + encodeURIComponent( key );
	        }
	
	        form = ss.getForm({
	            action: url,
	            target: iframe.name,
	            method: opts.method
	        });
	
	        opts.onProgress.call( this, 0 );
	
	        if ( pctBox ) {
	            pctBox.innerHTML = '0%';
	        }
	
	        if ( progBar ) {
	            progBar.style.width = '0%';
	        }
	
	        // For CORS, add a listener for the "message" event, which will be
	        // triggered by the Javascript snippet in the server response
	        if ( opts.cors ) {
	            var msgId = ss.getUID();
	
	            self._detachEvents[ msgId ] = ss.addEvent( window, 'message', function( event ) {
	                // Make sure event.origin matches the upload URL
	                if ( self._getHost( event.origin ) != self._getHost( opts.url ) ) {
	                    self.log('Non-matching origin: ' + event.origin);
	                    return;
	                }
	
	                msgLoaded = true;
	                self._detach( msgId );
	                opts.endNonXHR.call( self, fileObj.name, fileObj.btn );
	                self._finish( fileObj,  '', '', event.data, sizeBox, progBox, pctBox, abortBtn, removeAbort );
	            });
	        }
	
	        self._detachEvents[ iframe.id ] = ss.addEvent( iframe, 'load', function() {
	            self._detach( iframe.id );
	
	            if ( opts.sessionProgressUrl ) {
	                form.appendChild( ss.getHidden( opts.sessionProgressName, key ) );
	            }
	
	            // PHP APC upload progress key field must come before the file field
	            else if ( opts.progressUrl ) {
	                form.appendChild( ss.getHidden( opts.keyParamName, key ) );
	            }
	
	            if ( self._form ) {
	                ss.extendObj( opts.data, ss.getFormObj( self._form ) );
	            }
	
	            // Get additional data after startNonXHR() in case setData() was called prior to submitting
	            for ( var prop in opts.data ) {
	                if ( opts.data.hasOwnProperty( prop ) ) {
	                    form.appendChild( ss.getHidden( prop, opts.data[prop] ) );
	                }
	            }
	
	            // Add a field (default name: "XHR_CORS_TRARGETORIGIN") to tell server this is a CORS request
	            // Value of the field is targetOrigin parameter of postMessage(message, targetOrigin)
	            if ( opts.cors ) {
	                form.appendChild( ss.getHidden( opts.corsInputName, window.location.href ) );
	            }
	
	            form.appendChild( fileObj.file );
	
	            self._detachEvents[ fileObj.id ] = ss.addEvent( iframe, 'load', function() {
	                if ( !iframe || !iframe.parentNode || iframeLoaded ) {
	                    return;
	                }
	
	                self._detach( fileObj.id );
	                iframeLoaded = true;
	
	                delete self._progKeys[ key ];
	                delete self._sizeFlags[ key ];
	
	                if ( abortBtn ) {
	                    ss.removeEvent( abortBtn, 'click', cancel );
	                }
	
	                // After a CORS response, we wait briefly for the "message" event to finish,
	                // during which time the msgLoaded var will be set to true, signalling success.
	                // If iframe loads without "message" event, we assume there was an error
	                if ( opts.cors ) {
	                    window.setTimeout(function() {
	                        ss.remove( iframe );
	
	                        // If msgLoaded has not been set to true after "message" event fires, we
	                        // infer that an error must have occurred and respond accordingly
	                        if ( !msgLoaded ) {
	                            self._errorFinish( fileObj, '', '', false, 'error', progBox, sizeBox, pctBox, abortBtn, removeAbort );
	                        }
	
	                        fileObj = opts = key = iframe = sizeBox = progBox = pctBox = abortBtn = removeAbort = null;
	                    }, 600);
	                }
	
	                // Non-CORS upload
	                else {
	                    try {
	                        var doc = iframe.contentDocument ? iframe.contentDocument : iframe.contentWindow.document,
	                            response = doc.body.innerHTML;
	
	                        ss.remove( iframe );
	                        iframe = null;
	
	                        opts.endNonXHR.call( self, fileObj.name, fileObj.btn );
	
	                        // No way to get status and statusText for an iframe so return empty strings
	                        self._finish( fileObj, '', '', response, sizeBox, progBox, pctBox, abortBtn, removeAbort );
	
	                    } catch ( e ) {
	                        self._errorFinish( fileObj, '', e.message, false, 'error', progBox, sizeBox, pctBox, abortBtn, removeAbort );
	                    }
	
	                    fileObj = opts = key = sizeBox = progBox = pctBox = null;
	                }
	            });// end load
	
	            if ( abortBtn ) {
	                cancel = function() {
	                    ss.removeEvent( abortBtn, 'click', cancel );
	
	                    delete self._progKeys[key];
	                    delete self._sizeFlags[key];
	
	                    if ( iframe ) {
	                        iframeLoaded = true;
	                        self._detach( fileObj.id );
	
	                        try {
	                            if ( iframe.contentWindow.document.execCommand ) {
	                                iframe.contentWindow.document.execCommand('Stop');
	                            }
	                        } catch( err ) {}
	
	                        try {
	                            iframe.src = 'javascript'.concat(':false;');
	                        } catch( err ) {}
	
	                        window.setTimeout(function() {
	                            ss.remove( iframe );
	                            iframe = null;
	                        }, 1);
	                    }
	
	                    self.log('Upload aborted');
	                    opts.onAbort.call( self, fileObj.name, fileObj.btn, fileObj.size );
	                    self._last( sizeBox, progBox, pctBox, abortBtn, removeAbort );
	                };
	
	                ss.addEvent( abortBtn, 'click', cancel );
	            }
	
	            self.log( 'Commencing upload using iframe' );
	            form.submit();
	
	            // Remove form and begin next upload
	            window.setTimeout(function() {
	                ss.remove( form );
	                form = null;
	                self.removeCurrent( fileObj.id );
	            }, 1);
	
	            if ( self._hasProgUrl ) {
	                // Add progress key to active key array
	                self._progKeys[key] = 1;
	
	                window.setTimeout( function() {
	                    self._getProg( key, progBar, sizeBox, pctBox, 1 );
	                    progBar = sizeBox = pctBox = null;
	                }, 600 );
	            }
	
	        });// end load
	
	        document.body.appendChild( form );
	        document.body.appendChild( iframe );
	    },
	
	    /**
	    * Retrieves upload progress updates from the server
	    * (For fallback upload progress support)
	    */
	    _getProg: function( key, progBar, sizeBox, pctBox, counter ) {
	        "use strict";
	
	        var self = this,
	            opts = this._opts,
	            time = new Date().getTime(),
	            xhr,
	            url,
	            callback;
	
	        if ( !key ) {
	            return;
	        }
	
	        // Nginx Upload Progress Module
	        if ( opts.nginxProgressUrl ) {
	            url = opts.nginxProgressUrl + '?' +
	                  encodeURIComponent( opts.nginxProgressHeader ) + '=' + encodeURIComponent( key ) +
	                  '&_=' + time;
	        }
	
	        else if ( opts.sessionProgressUrl ) {
	            url = opts.sessionProgressUrl;
	        }
	
	        // PHP APC upload progress
	        else if ( opts.progressUrl ) {
	            url = opts.progressUrl +
	            '?progresskey=' + encodeURIComponent( key ) +
	            '&_=' + time;
	        }
	
	        callback = function() {
	            var response,
	                size,
	                pct,
	                status,
	                statusText;
	
	            try {
	                // XDR doesn't have readyState so we just assume that it finished correctly
	                if ( callback && ( opts.cors || xhr.readyState === 4 ) ) {
	                    callback = undefined;
	                    xhr.onreadystatechange = function() {};
	
	                    try {
	                        statusText = xhr.statusText;
	                        status = xhr.status;
	                    } catch( e ) {
	                        statusText = '';
	                        status = '';
	                    }
	
	                    // XDR also doesn't have status, so just assume that everything is fine
	                    if ( opts.cors || ( status >= 200 && status < 300 ) ) {
	                        response = ss.parseJSON( xhr.responseText );
	
	                        if ( response === false ) {
	                            self.log( 'Error parsing progress response (expecting JSON)' );
	                            return;
	                        }
	
	                        // Handle response if using Nginx Upload Progress Module
	                        if ( opts.nginxProgressUrl ) {
	
	                            if ( response.state == 'uploading' ) {
	                                size = parseInt( response.size, 10 );
	                                if ( size > 0 ) {
	                                    pct = Math.round( ( parseInt( response.received, 10 ) / size ) * 100 );
	                                    size = Math.round( size / 1024 ); // convert to kilobytes
	                                }
	
	                            } else if ( response.state == 'done' ) {
	                                pct = 100;
	
	                            } else if ( response.state == 'error' ) {
	                                self.log( 'Error requesting upload progress: ' + response.status );
	                                return;
	                            }
	                        }
	
	                        // Handle response if using PHP APC
	                        else if ( opts.sessionProgressUrl || opts.progressUrl ) {
	                            if ( response.success === true ) {
	                                size = parseInt( response.size, 10 );
	                                pct = parseInt( response.pct, 10 );
	                            }
	                        }
	
	                        // Update progress bar width
	                        if ( pct ) {
	                            if ( pctBox ) {
	                                pctBox.innerHTML = pct + '%';
	                            }
	
	                            if ( progBar ) {
	                                progBar.style.width = pct + '%';
	                            }
	
	                            opts.onProgress.call( self, pct );
	                        }
	
	                        if ( size && !self._sizeFlags[key] ) {
	                            if ( sizeBox ) {
	                                sizeBox.innerHTML = size + 'K';
	                            }
	
	                            self._sizeFlags[key] = 1;
	                            opts.onUpdateFileSize.call( self, size );
	                        }
	
	                        // Stop attempting progress checks if we keep failing
	                        if ( !pct &&
	                             !size &&
	                             counter >= self._maxFails )
	                        {
	                            counter++;
	                            self.log( 'Failed progress request limit reached. Count: ' + counter );
	                            return;
	                        }
	
	                        // Begin countdown until next progress update check
	                        if ( pct < 100 && self._progKeys[key] ) {
	                            window.setTimeout( function() {
	                                self._getProg( key, progBar, sizeBox, pctBox, counter );
	
	                                key = progBar = sizeBox = pctBox = counter = null;
	                            }, opts.checkProgressInterval );
	                        }
	
	                        // We didn't get a 2xx status so don't continue sending requests
	                    } else {
	                        delete self._progKeys[key];
	                        self.log( 'Error requesting upload progress: ' + status + ' ' + statusText );
	                    }
	
	                    xhr = size = pct = status = statusText = response = null;
	                }
	
	            } catch( e ) {
	                self.log( 'Error requesting upload progress: ' + e.message );
	            }
	        };
	
	        // CORS requests in IE8 and IE9 must use XDomainRequest
	        if ( opts.cors && !opts.sessionProgressUrl ) {
	
	            if ( window.XDomainRequest ) {
	                xhr = new window.XDomainRequest();
	                xhr.open( 'GET', url, true );
	                xhr.onprogress = xhr.ontimeout = function() {};
	                xhr.onload = callback;
	
	                xhr.onerror = function() {
	                    delete self._progKeys[key];
	                    key = null;
	                    self.log('Error requesting upload progress');
	                };
	
	                // IE7 or some other dinosaur -- just give up
	            } else {
	                return;
	            }
	
	        } else {
	            var method = !opts.sessionProgressUrl ? 'GET' : 'POST',
	                headers = {},
	                params;
	
	            xhr = ss.newXHR();
	            xhr.onreadystatechange = callback;
	            xhr.open( method, url, true );
	
	            // PHP session progress updates must be a POST request
	            if ( opts.sessionProgressUrl ) {
	                params = encodeURIComponent( opts.sessionProgressName ) + '=' + encodeURIComponent( key );
	                headers['Content-Type'] = 'application/x-www-form-urlencoded';
	            }
	
	            // Set the upload progress header for Nginx
	            if ( opts.nginxProgressUrl ) {
	                headers[opts.nginxProgressHeader] = key;
	            }
	
	            headers['X-Requested-With'] = 'XMLHttpRequest';
	            headers['Accept'] = 'application/json, text/javascript, */*; q=0.01';
	
	            ss.extendObj( headers, opts.customProgressHeaders );
	
	            for ( var i in headers ) {
	                if ( headers.hasOwnProperty( i ) ) {
	                    if ( opts.encodeHeaders ) {
	                        xhr.setRequestHeader( i, ss.encodeUTF8( headers[ i ] + '' ) );
	
	                    } else {
	                        xhr.setRequestHeader( i, headers[ i ] + '' );
	                    }
	                }
	            }
	
	           xhr.send( ( opts.sessionProgressUrl &&  params ) || null );
	        }
	    },
	
	    _initUpload: function( fileObj ) {
	        if ( false === this._opts.startNonXHR.call( this, fileObj.name, fileObj.btn ) ) {
	
	            if ( this._disabled ) {
	                this.enable( true );
	            }
	
	            this._active--;
	            return;
	        }
	
	        this._hasProgUrl = ( this._opts.progressUrl ||
	                             this._opts.sessionProgressUrl ||
	                             this._opts.nginxProgressUrl ) ?
	                             true : false;
	
	        this._uploadIframe( fileObj, this._progBox, this._sizeBox, this._progBar, this._pctBox, this._abortBtn, this._removeAbort );
	
	        fileObj = this._progBox = this._sizeBox = this._progBar = this._pctBox = this._abortBtn = this._removeAbort = null;
	    }
	};
	
	ss.XhrUpload = {
	
	    _addFiles: function( files ) {
	        var total = files.length,
	            filename,
	            ext,
	            size,
	            i;
	
	        if ( !this._opts.multiple ) {
	            total = 1;
	        }
	
	        for ( i = 0; i < total; i++ ) {
	            filename = ss.getFilename( files[i].name );
	            ext = ss.getExt( filename );
	            size = Math.round( files[i].size / 1024 );
	
	            if ( false === this._opts.onChange.call( this, filename, ext, this._overBtn, size, files[i] ) ) {
	                return false;
	            }
	
	            this._queue.push({
	                id: ss.getUID(),
	                file: files[i],
	                name: filename,
	                ext: ext,
	                btn: this._overBtn,
	                size: size
	            });
	        }
	
	        return true;
	    },
	
	    /**
	    * Handles uploading with XHR
	    */
	    _uploadXhr: function( fileObj, url, params, headers, sizeBox, progBar, progBox, pctBox, abortBtn, removeAbort ) {
	        "use strict";
	
	        var self = this,
	            opts = this._opts,
	            xhr = ss.newXHR(),
	            callback,
	            cancel;
	
	        // Inject file size into size box
	        if ( sizeBox ) {
	            sizeBox.innerHTML = fileObj.size + 'K';
	        }
	
	        // Begin progress bars at 0%
	        if ( pctBox ) {
	            pctBox.innerHTML = '0%';
	        }
	
	        if ( progBar ) {
	            progBar.style.width = '0%';
	        }
	
	        // Borrows heavily from jQuery ajax transport
	        callback = function( _, isAbort ) {
	            var statusText;
	
	            try {
	                // Was never called and is aborted or complete
	                if ( callback && ( isAbort || xhr.readyState === 4 ) ) {
	                    callback = undefined;
	                    xhr.onreadystatechange = function() {};
	
	                    // If it's an abort
	                    if ( isAbort ) {
	                        // Abort it manually if needed
	                        if ( xhr.readyState !== 4 ) {
	                            xhr.abort();
	                        }
	
	                        opts.onAbort.call( self, fileObj.name, fileObj.btn, fileObj.size );
	                        self._last( sizeBox, progBox, pctBox, abortBtn, removeAbort );
	
	                    } else {
	                        if ( abortBtn ) {
	                            ss.removeEvent( abortBtn, 'click', cancel );
	                        }
	
	                        try {
	                            statusText = xhr.statusText;
	                        } catch( e ) {
	                            // We normalize with Webkit giving an empty statusText
	                            statusText = '';
	                        }
	
	                        if ( xhr.status >= 200 && xhr.status < 300 ) {
	                            opts.endXHR.call( self, fileObj.name, fileObj.size, fileObj.btn );
	                            self._finish( fileObj, xhr.status, statusText, xhr.responseText, sizeBox, progBox, pctBox, abortBtn, removeAbort );
	
	                            // We didn't get a 2xx status so throw an error
	                        } else {
	                            self._errorFinish( fileObj, xhr.status, statusText, xhr.responseText, 'error', progBox, sizeBox, pctBox, abortBtn, removeAbort );
	                        }
	                    }
	                }
	
	            }
	            catch ( e ) {
	                if ( !isAbort ) {
	                    self._errorFinish( fileObj, -1, e.message, false, 'error', progBox, sizeBox, pctBox, abortBtn, removeAbort );
	                }
	            }
	        };
	
	        if ( abortBtn ) {
	            cancel = function() {
	                ss.removeEvent( abortBtn, 'click', cancel );
	
	                if ( callback ) {
	                    callback( undefined, true );
	                }
	            };
	
	            ss.addEvent( abortBtn, 'click', cancel );
	        }
	
	        xhr.onreadystatechange = callback;
	        xhr.open( opts.method.toUpperCase(), url, true );
	        xhr.withCredentials = !!opts.withCredentials;
	
	        ss.extendObj( headers, opts.customHeaders );
	
	        for ( var i in headers ) {
	            if ( headers.hasOwnProperty( i ) ) {
	                if ( opts.encodeHeaders ) {
	                    xhr.setRequestHeader( i, ss.encodeUTF8( headers[ i ] + '' ) );
	
	                } else {
	                    xhr.setRequestHeader( i, headers[ i ] + '' );
	                }
	            }
	        }
	
	        ss.addEvent( xhr.upload, 'progress', function( event ) {
	            if ( event.lengthComputable ) {
	                var pct = Math.round( event.loaded / event.total * 100 );
	
	                opts.onProgress.call( self, pct );
	
	                if ( pctBox ) {
	                    pctBox.innerHTML = pct + '%';
	                }
	
	                if ( progBar ) {
	                    progBar.style.width = pct + '%';
	                }
	            }
	        });
	
	        opts.onProgress.call( this, 0 );
	
	        if ( opts.multipart === true ) {
	            var formData = new FormData();
	
	            var hasFile = false;
	
	            for ( var prop in params ) {
	                if ( params.hasOwnProperty( prop ) ) {
	                    if ( prop === opts.name && opts.noParams === true && !self._form ) {
	                        hasFile = true;
	                    }
	                    formData.append( prop, params[prop] );
	                }
	            }
	
	            if ( !hasFile ) {
	                formData.append( opts.name, fileObj.file );
	            }
	
	            this.log( 'Commencing upload using multipart form' );
	            xhr.send( formData );
	
	        } else {
	            this.log( 'Commencing upload using binary stream' );
	            xhr.send( fileObj.file );
	        }
	
	        // Remove file from upload queue and begin next upload
	        this.removeCurrent( fileObj.id );
	    },
	
	    _initUpload: function( fileObj ) {
	        "use strict";
	
	        var params = {},
	            headers = {},
	            url;
	
	        // Call the startXHR() callback and stop upload if it returns false
	        // We call it before _uploadXhr() in case setProgressBar, setPctBox, etc., is called
	        if ( false === this._opts.startXHR.call( this, fileObj.name, fileObj.size, fileObj.btn ) ) {
	
	            if ( this._disabled ) {
	                this.enable( true );
	            }
	
	            this._active--;
	            return;
	        }
	
	        headers['X-Requested-With'] = 'XMLHttpRequest';
	        headers['X-File-Name'] = fileObj.name;
	
	        if ( this._opts.responseType.toLowerCase() == 'json' ) {
	            headers['Accept'] = 'application/json, text/javascript, */*; q=0.01';
	        }
	
	        if ( !this._opts.multipart ) {
	            headers['Content-Type'] = 'application/octet-stream';
	        }
	
	        if ( this._form ) {
	            ss.extendObj( params, ss.getFormObj( this._form ) );
	        }
	
	        // We get the any additional data here after startXHR()
	        ss.extendObj( params, this._opts.data );
	
	        // Build query string while preserving any existing parameters
	        url = this._opts.noParams === true ?
	                this._opts.url :
	                this._opts.url + ( ( this._opts.url.indexOf( '?' ) > -1 ) ? '&' : '?' ) + ss.obj2string( params );
	
	        this._uploadXhr( fileObj, url, params, headers, this._sizeBox, this._progBar, this._progBox, this._pctBox, this._abortBtn, this._removeAbort );
	
	        this._sizeBox = this._progBar = this._progBox = this._pctBox = this._abortBtn = this._removeAbort = null;
	    }
	
	};
	
	ss.DragAndDrop = {
	
	    _dragFileCheck: function( e ) {
	        if ( e.dataTransfer.types ) {
	            for ( var i = 0; i < e.dataTransfer.types.length; i++ ) {
	                if ( e.dataTransfer.types[i] == 'Files' ) {
	                    return true;
	                }
	            }
	        }
	
	        return false;
	    },
	
	    addDropZone: function( elem ) {
	        var self = this,
	            collection = [];
	
	        ss.addStyles( elem, {
	            'zIndex': 16777271
	        });
	
	        elem.ondragenter = function( e ) {
	            e.stopPropagation();
	            e.preventDefault();
	
	            if ( !self._dragFileCheck( e ) ) {
	                return false;
	            }
	
	            if ( collection.length === 0 ) {
	                ss.addClass( this, self._opts.dragClass );
	            }
	
	            if ( ss.indexOf( collection, e.target ) === -1 ) {
	                collection.push( e.target );
	            }
	
	            return false;
	        };
	
	        elem.ondragover = function( e ) {
	            e.stopPropagation();
	            e.preventDefault();
	
	            if ( self._dragFileCheck( e ) ) {
	                e.dataTransfer.dropEffect = 'copy';
	            }
	
	            return false;
	        };
	
	        elem.ondragend = function() {
	            ss.removeClass( this, self._opts.dragClass );
	            return false;
	        };
	
	        elem.ondragleave = function( e ) {
	            ss.arrayDelete( collection, e.target );
	
	            if ( collection.length === 0 ) {
	                ss.removeClass( this, self._opts.dragClass );
	            }
	
	            return false;
	        };
	
	        elem.ondrop = function( e ) {
	            e.stopPropagation();
	            e.preventDefault();
	
	            ss.arrayDelete( collection, e.target );
	
	            if ( collection.length === 0 ) {
	                ss.removeClass( this, self._opts.dragClass );
	            }
	
	            if ( !self._dragFileCheck( e ) ) {
	                return;
	            }
	
	            if ( false !== self._addFiles( e.dataTransfer.files ) ) {
	                self._cycleQueue();
	            }
	        };
	    }
	};
	
	ss.extendObj( ss.SimpleUpload.prototype, {
	
	    _createInput: function() {
	        "use strict";
	
	        var self = this,
	            div = document.createElement( 'div' );
	
	        this._input = document.createElement( 'input' );
	        this._input.type = 'file';
	        this._input.name = this._opts.name;
	
	        // Don't allow multiple file selection in Safari -- it has a nasty bug
	        // http://stackoverflow.com/q/7231054/1091949
	        if ( XhrOk && !isSafari && this._opts.multiple ) {
	            this._input.multiple = true;
	        }
	
	        // Check support for file input accept attribute
	        if ( 'accept' in this._input && this._opts.accept !== '' ) {
	            this._input.accept = this._opts.accept;
	        }
	
	        ss.addStyles( div, {
	            'display' : 'block',
	            'position' : 'absolute',
	            'overflow' : 'hidden',
	            'margin' : 0,
	            'padding' : 0,
	            'opacity' : 0,
	            'direction' : 'ltr',
	            'zIndex': 16777270
	        });
	
	        if ( div.style.opacity !== '0' ) {
	            div.style.filter = 'alpha(opacity=0)';
	        }
	
	        ss.addStyles( this._input, {
	            'position' : 'absolute',
	            'right' : 0,
	            'margin' : 0,
	            'padding' : 0,
	            'fontSize' : '480px',
	            'fontFamily' : 'sans-serif',
	            'cursor' : 'pointer',
	            'height' : '100%',
	            'zIndex': 16777270
	        });
	
	        this._input.turnOff = ss.addEvent( this._input, 'change', function() {
	            if ( !self._input || self._input.value === '' ) {
	                return;
	            }
	
	            if ( false === self._addFiles( XhrOk ? self._input.files : self._input ) ) {
	                return;
	            }
	
	            ss.removeClass( self._overBtn, self._opts.hoverClass );
	            ss.removeClass( self._overBtn, self._opts.focusClass );
	
	            self._killInput();
	
	            // Then create a new file input
	            self._createInput();
	
	            // Submit if autoSubmit option is true
	            if ( self._opts.autoSubmit ) {
	                self.submit();
	            }
	        });
	
	        if ( self._opts.hoverClass !== '' ) {
	            div.mouseOverOff = ss.addEvent( div, 'mouseover', function() {
	                ss.addClass( self._overBtn, self._opts.hoverClass );
	            });
	        }
	
	        div.mouseOutOff = ss.addEvent( div, 'mouseout', function() {
	            self._input.parentNode.style.visibility = 'hidden';
	
	            if ( self._opts.hoverClass !== '' ) {
	                ss.removeClass( self._overBtn, self._opts.hoverClass );
	                ss.removeClass( self._overBtn, self._opts.focusClass );
	            }
	        });
	
	        if ( self._opts.focusClass !== '' ) {
	            this._input.focusOff = ss.addEvent( this._input, 'focus', function() {
	                ss.addClass( self._overBtn, self._opts.focusClass );
	            });
	
	            this._input.blurOff = ss.addEvent( this._input, 'blur', function() {
	                ss.removeClass( self._overBtn, self._opts.focusClass );
	            });
	        }
	
	        div.appendChild( this._input );
	        document.body.appendChild( div );
	        div = null;
	    },
	
	    /**
	    * Final cleanup function after upload ends
	    */
	    _last: function( sizeBox, progBox, pctBox, abortBtn, removeAbort ) {
	        "use strict";
	
	        if ( sizeBox ) {
	           sizeBox.innerHTML = '';
	        }
	
	        if ( pctBox ) {
	            pctBox.innerHTML = '';
	        }
	
	        if ( abortBtn && removeAbort ) {
	            ss.remove( abortBtn );
	        }
	
	        if ( progBox ) {
	            ss.remove( progBox );
	        }
	
	        // Decrement the active upload counter
	        this._active--;
	
	        sizeBox = progBox = pctBox = abortBtn = removeAbort = null;
	
	        if ( this._disabled ) {
	            this.enable( true );
	        }
	
	        // Burn it all down if destroy() was called
	        // We have to do it here after everything is finished to avoid any errors
	        if ( this._destroy &&
	             this._queue.length === 0 &&
	             this._active === 0 )
	        {
	            for ( var prop in this ) {
	                if ( this.hasOwnProperty( prop ) ) {
	                    delete this[ prop ];
	                }
	            }
	
	        // Otherwise just go to the next upload as usual
	        } else {
	            this._cycleQueue();
	        }
	    },
	
	    /**
	    * Completes upload request if an error is detected
	    */
	    _errorFinish: function( fileObj, status, statusText, response, errorType, progBox, sizeBox, pctBox, abortBtn, removeAbort ) {
	        "use strict";
	
	        this.log( 'Upload failed: ' + status + ' ' + statusText );
	        this._opts.onError.call( this, fileObj.name, errorType, status, statusText, response, fileObj.btn, fileObj.size );
	        this._last( sizeBox, progBox, pctBox, abortBtn, removeAbort );
	
	        fileObj = status = statusText = response = errorType = sizeBox = progBox = pctBox = abortBtn = removeAbort = null;
	    },
	
	    /**
	    * Completes upload request if the transfer was successful
	    */
	    _finish: function( fileObj, status, statusText, response, sizeBox, progBox, pctBox, abortBtn, removeAbort ) {
	        "use strict";
	
	        this.log( 'Server response: ' + response );
	
	        if ( this._opts.responseType.toLowerCase() == 'json' ) {
	            response = ss.parseJSON( response );
	
	            if ( response === false ) {
	                this._errorFinish( fileObj, status, statusText, false, 'parseerror', progBox, sizeBox, abortBtn, removeAbort );
	                return;
	            }
	        }
	
	        this._opts.onComplete.call( this, fileObj.name, response, fileObj.btn, fileObj.size );
	        this._last( sizeBox, progBox, pctBox, abortBtn, removeAbort );
	        fileObj = status = statusText = response = sizeBox = progBox = pctBox = abortBtn = removeAbort = null;
	    },
	
	    /**
	    * Verifies that file is allowed
	    * Checks file extension and file size if limits are set
	    */
	    _checkFile: function( fileObj ) {
	        "use strict";
	
	        var extOk = false,
	            i = this._opts.allowedExtensions.length;
	
	        // Only file extension if allowedExtensions is set
	        if ( i > 0 ) {
	            while ( i-- ) {
	                if ( this._opts.allowedExtensions[i].toLowerCase() == fileObj.ext.toLowerCase() ) {
	                    extOk = true;
	                    break;
	                }
	            }
	
	            if ( !extOk ) {
	                this.removeCurrent( fileObj.id );
	                this.log( 'File extension not permitted' );
	                this._opts.onExtError.call( this, fileObj.name, fileObj.ext );
	                return false;
	            }
	        }
	
	        if ( fileObj.size &&
	            this._opts.maxSize !== false &&
	            fileObj.size > this._opts.maxSize )
	        {
	            this.removeCurrent( fileObj.id );
	            this.log( fileObj.name + ' exceeds ' + this._opts.maxSize + 'K limit' );
	            this._opts.onSizeError.call( this, fileObj.name, fileObj.size );
	            return false;
	        }
	
	        fileObj = null;
	
	        return true;
	    },
	
	    _killInput: function() {
	        "use strict";
	
	        if ( !this._input ) {
	            return;
	        }
	
	        if ( this._input.turnOff ) {
	            this._input.turnOff();
	        }
	
	        if ( this._input.focusOff ) {
	            this._input.focusOff();
	        }
	
	        if ( this._input.blurOff ) {
	            this._input.blurOff();
	        }
	
	        if ( this._input.parentNode.mouseOverOff ) {
	            this._input.parentNode.mouseOverOff();
	        }
	
	        ss.remove( this._input.parentNode );
	        delete this._input;
	        this._input = null;
	    },
	
	    /**
	    * Enables uploader and submits next file for upload
	    */
	    _cycleQueue: function() {
	        "use strict";
	
	        if ( this._queue.length > 0 && this._opts.autoSubmit ) {
	            this.submit( undefined, true );
	        }
	    },
	
	    _validateForm: function() {
	        "use strict";
	
	        if ( this._form.checkValidity && !this._form.checkValidity() ) {
	            return false;
	
	        } else {
	            return true;
	        }
	    }
	
	});
	
	if ( XhrOk ) {
	    ss.extendObj( ss.SimpleUpload.prototype, ss.XhrUpload );
	
	} else {
	    ss.extendObj( ss.SimpleUpload.prototype, ss.IframeUpload );
	}
	
	ss.extendObj( ss.SimpleUpload.prototype, ss.DragAndDrop );
	
	return ss;
	
	}));


/***/ },
/* 202 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(203);

/***/ },
/* 203 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var utils = __webpack_require__(204);
	var bind = __webpack_require__(205);
	var Axios = __webpack_require__(206);
	var defaults = __webpack_require__(207);
	
	/**
	 * Create an instance of Axios
	 *
	 * @param {Object} defaultConfig The default config for the instance
	 * @return {Axios} A new instance of Axios
	 */
	function createInstance(defaultConfig) {
	  var context = new Axios(defaultConfig);
	  var instance = bind(Axios.prototype.request, context);
	
	  // Copy axios.prototype to instance
	  utils.extend(instance, Axios.prototype, context);
	
	  // Copy context to instance
	  utils.extend(instance, context);
	
	  return instance;
	}
	
	// Create the default instance to be exported
	var axios = createInstance(defaults);
	
	// Expose Axios class to allow class inheritance
	axios.Axios = Axios;
	
	// Factory for creating new instances
	axios.create = function create(instanceConfig) {
	  return createInstance(utils.merge(defaults, instanceConfig));
	};
	
	// Expose Cancel & CancelToken
	axios.Cancel = __webpack_require__(225);
	axios.CancelToken = __webpack_require__(226);
	axios.isCancel = __webpack_require__(222);
	
	// Expose all/spread
	axios.all = function all(promises) {
	  return Promise.all(promises);
	};
	axios.spread = __webpack_require__(227);
	
	module.exports = axios;
	
	// Allow use of default import syntax in TypeScript
	module.exports.default = axios;


/***/ },
/* 204 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var bind = __webpack_require__(205);
	
	/*global toString:true*/
	
	// utils is a library of generic helper functions non-specific to axios
	
	var toString = Object.prototype.toString;
	
	/**
	 * Determine if a value is an Array
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is an Array, otherwise false
	 */
	function isArray(val) {
	  return toString.call(val) === '[object Array]';
	}
	
	/**
	 * Determine if a value is an ArrayBuffer
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
	 */
	function isArrayBuffer(val) {
	  return toString.call(val) === '[object ArrayBuffer]';
	}
	
	/**
	 * Determine if a value is a FormData
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is an FormData, otherwise false
	 */
	function isFormData(val) {
	  return (typeof FormData !== 'undefined') && (val instanceof FormData);
	}
	
	/**
	 * Determine if a value is a view on an ArrayBuffer
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
	 */
	function isArrayBufferView(val) {
	  var result;
	  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
	    result = ArrayBuffer.isView(val);
	  } else {
	    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);
	  }
	  return result;
	}
	
	/**
	 * Determine if a value is a String
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a String, otherwise false
	 */
	function isString(val) {
	  return typeof val === 'string';
	}
	
	/**
	 * Determine if a value is a Number
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Number, otherwise false
	 */
	function isNumber(val) {
	  return typeof val === 'number';
	}
	
	/**
	 * Determine if a value is undefined
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if the value is undefined, otherwise false
	 */
	function isUndefined(val) {
	  return typeof val === 'undefined';
	}
	
	/**
	 * Determine if a value is an Object
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is an Object, otherwise false
	 */
	function isObject(val) {
	  return val !== null && typeof val === 'object';
	}
	
	/**
	 * Determine if a value is a Date
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Date, otherwise false
	 */
	function isDate(val) {
	  return toString.call(val) === '[object Date]';
	}
	
	/**
	 * Determine if a value is a File
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a File, otherwise false
	 */
	function isFile(val) {
	  return toString.call(val) === '[object File]';
	}
	
	/**
	 * Determine if a value is a Blob
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Blob, otherwise false
	 */
	function isBlob(val) {
	  return toString.call(val) === '[object Blob]';
	}
	
	/**
	 * Determine if a value is a Function
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Function, otherwise false
	 */
	function isFunction(val) {
	  return toString.call(val) === '[object Function]';
	}
	
	/**
	 * Determine if a value is a Stream
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Stream, otherwise false
	 */
	function isStream(val) {
	  return isObject(val) && isFunction(val.pipe);
	}
	
	/**
	 * Determine if a value is a URLSearchParams object
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
	 */
	function isURLSearchParams(val) {
	  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
	}
	
	/**
	 * Trim excess whitespace off the beginning and end of a string
	 *
	 * @param {String} str The String to trim
	 * @returns {String} The String freed of excess whitespace
	 */
	function trim(str) {
	  return str.replace(/^\s*/, '').replace(/\s*$/, '');
	}
	
	/**
	 * Determine if we're running in a standard browser environment
	 *
	 * This allows axios to run in a web worker, and react-native.
	 * Both environments support XMLHttpRequest, but not fully standard globals.
	 *
	 * web workers:
	 *  typeof window -> undefined
	 *  typeof document -> undefined
	 *
	 * react-native:
	 *  typeof document.createElement -> undefined
	 */
	function isStandardBrowserEnv() {
	  return (
	    typeof window !== 'undefined' &&
	    typeof document !== 'undefined' &&
	    typeof document.createElement === 'function'
	  );
	}
	
	/**
	 * Iterate over an Array or an Object invoking a function for each item.
	 *
	 * If `obj` is an Array callback will be called passing
	 * the value, index, and complete array for each item.
	 *
	 * If 'obj' is an Object callback will be called passing
	 * the value, key, and complete object for each property.
	 *
	 * @param {Object|Array} obj The object to iterate
	 * @param {Function} fn The callback to invoke for each item
	 */
	function forEach(obj, fn) {
	  // Don't bother if no value provided
	  if (obj === null || typeof obj === 'undefined') {
	    return;
	  }
	
	  // Force an array if not already something iterable
	  if (typeof obj !== 'object' && !isArray(obj)) {
	    /*eslint no-param-reassign:0*/
	    obj = [obj];
	  }
	
	  if (isArray(obj)) {
	    // Iterate over array values
	    for (var i = 0, l = obj.length; i < l; i++) {
	      fn.call(null, obj[i], i, obj);
	    }
	  } else {
	    // Iterate over object keys
	    for (var key in obj) {
	      if (Object.prototype.hasOwnProperty.call(obj, key)) {
	        fn.call(null, obj[key], key, obj);
	      }
	    }
	  }
	}
	
	/**
	 * Accepts varargs expecting each argument to be an object, then
	 * immutably merges the properties of each object and returns result.
	 *
	 * When multiple objects contain the same key the later object in
	 * the arguments list will take precedence.
	 *
	 * Example:
	 *
	 * ```js
	 * var result = merge({foo: 123}, {foo: 456});
	 * console.log(result.foo); // outputs 456
	 * ```
	 *
	 * @param {Object} obj1 Object to merge
	 * @returns {Object} Result of all merge properties
	 */
	function merge(/* obj1, obj2, obj3, ... */) {
	  var result = {};
	  function assignValue(val, key) {
	    if (typeof result[key] === 'object' && typeof val === 'object') {
	      result[key] = merge(result[key], val);
	    } else {
	      result[key] = val;
	    }
	  }
	
	  for (var i = 0, l = arguments.length; i < l; i++) {
	    forEach(arguments[i], assignValue);
	  }
	  return result;
	}
	
	/**
	 * Extends object a by mutably adding to it the properties of object b.
	 *
	 * @param {Object} a The object to be extended
	 * @param {Object} b The object to copy properties from
	 * @param {Object} thisArg The object to bind function to
	 * @return {Object} The resulting value of object a
	 */
	function extend(a, b, thisArg) {
	  forEach(b, function assignValue(val, key) {
	    if (thisArg && typeof val === 'function') {
	      a[key] = bind(val, thisArg);
	    } else {
	      a[key] = val;
	    }
	  });
	  return a;
	}
	
	module.exports = {
	  isArray: isArray,
	  isArrayBuffer: isArrayBuffer,
	  isFormData: isFormData,
	  isArrayBufferView: isArrayBufferView,
	  isString: isString,
	  isNumber: isNumber,
	  isObject: isObject,
	  isUndefined: isUndefined,
	  isDate: isDate,
	  isFile: isFile,
	  isBlob: isBlob,
	  isFunction: isFunction,
	  isStream: isStream,
	  isURLSearchParams: isURLSearchParams,
	  isStandardBrowserEnv: isStandardBrowserEnv,
	  forEach: forEach,
	  merge: merge,
	  extend: extend,
	  trim: trim
	};


/***/ },
/* 205 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function bind(fn, thisArg) {
	  return function wrap() {
	    var args = new Array(arguments.length);
	    for (var i = 0; i < args.length; i++) {
	      args[i] = arguments[i];
	    }
	    return fn.apply(thisArg, args);
	  };
	};


/***/ },
/* 206 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var defaults = __webpack_require__(207);
	var utils = __webpack_require__(204);
	var InterceptorManager = __webpack_require__(219);
	var dispatchRequest = __webpack_require__(220);
	var isAbsoluteURL = __webpack_require__(223);
	var combineURLs = __webpack_require__(224);
	
	/**
	 * Create a new instance of Axios
	 *
	 * @param {Object} instanceConfig The default config for the instance
	 */
	function Axios(instanceConfig) {
	  this.defaults = instanceConfig;
	  this.interceptors = {
	    request: new InterceptorManager(),
	    response: new InterceptorManager()
	  };
	}
	
	/**
	 * Dispatch a request
	 *
	 * @param {Object} config The config specific for this request (merged with this.defaults)
	 */
	Axios.prototype.request = function request(config) {
	  /*eslint no-param-reassign:0*/
	  // Allow for axios('example/url'[, config]) a la fetch API
	  if (typeof config === 'string') {
	    config = utils.merge({
	      url: arguments[0]
	    }, arguments[1]);
	  }
	
	  config = utils.merge(defaults, this.defaults, { method: 'get' }, config);
	
	  // Support baseURL config
	  if (config.baseURL && !isAbsoluteURL(config.url)) {
	    config.url = combineURLs(config.baseURL, config.url);
	  }
	
	  // Hook up interceptors middleware
	  var chain = [dispatchRequest, undefined];
	  var promise = Promise.resolve(config);
	
	  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
	    chain.unshift(interceptor.fulfilled, interceptor.rejected);
	  });
	
	  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
	    chain.push(interceptor.fulfilled, interceptor.rejected);
	  });
	
	  while (chain.length) {
	    promise = promise.then(chain.shift(), chain.shift());
	  }
	
	  return promise;
	};
	
	// Provide aliases for supported request methods
	utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
	  /*eslint func-names:0*/
	  Axios.prototype[method] = function(url, config) {
	    return this.request(utils.merge(config || {}, {
	      method: method,
	      url: url
	    }));
	  };
	});
	
	utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
	  /*eslint func-names:0*/
	  Axios.prototype[method] = function(url, data, config) {
	    return this.request(utils.merge(config || {}, {
	      method: method,
	      url: url,
	      data: data
	    }));
	  };
	});
	
	module.exports = Axios;


/***/ },
/* 207 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	var utils = __webpack_require__(204);
	var normalizeHeaderName = __webpack_require__(209);
	
	var PROTECTION_PREFIX = /^\)\]\}',?\n/;
	var DEFAULT_CONTENT_TYPE = {
	  'Content-Type': 'application/x-www-form-urlencoded'
	};
	
	function setContentTypeIfUnset(headers, value) {
	  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
	    headers['Content-Type'] = value;
	  }
	}
	
	function getDefaultAdapter() {
	  var adapter;
	  if (typeof XMLHttpRequest !== 'undefined') {
	    // For browsers use XHR adapter
	    adapter = __webpack_require__(210);
	  } else if (typeof process !== 'undefined') {
	    // For node use HTTP adapter
	    adapter = __webpack_require__(210);
	  }
	  return adapter;
	}
	
	var defaults = {
	  adapter: getDefaultAdapter(),
	
	  transformRequest: [function transformRequest(data, headers) {
	    normalizeHeaderName(headers, 'Content-Type');
	    if (utils.isFormData(data) ||
	      utils.isArrayBuffer(data) ||
	      utils.isStream(data) ||
	      utils.isFile(data) ||
	      utils.isBlob(data)
	    ) {
	      return data;
	    }
	    if (utils.isArrayBufferView(data)) {
	      return data.buffer;
	    }
	    if (utils.isURLSearchParams(data)) {
	      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
	      return data.toString();
	    }
	    if (utils.isObject(data)) {
	      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');
	      return JSON.stringify(data);
	    }
	    return data;
	  }],
	
	  transformResponse: [function transformResponse(data) {
	    /*eslint no-param-reassign:0*/
	    if (typeof data === 'string') {
	      data = data.replace(PROTECTION_PREFIX, '');
	      try {
	        data = JSON.parse(data);
	      } catch (e) { /* Ignore */ }
	    }
	    return data;
	  }],
	
	  timeout: 0,
	
	  xsrfCookieName: 'XSRF-TOKEN',
	  xsrfHeaderName: 'X-XSRF-TOKEN',
	
	  maxContentLength: -1,
	
	  validateStatus: function validateStatus(status) {
	    return status >= 200 && status < 300;
	  }
	};
	
	defaults.headers = {
	  common: {
	    'Accept': 'application/json, text/plain, */*'
	  }
	};
	
	utils.forEach(['delete', 'get', 'head'], function forEachMehtodNoData(method) {
	  defaults.headers[method] = {};
	});
	
	utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
	  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
	});
	
	module.exports = defaults;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(208)))

/***/ },
/* 208 */
/***/ function(module, exports) {

	// shim for using process in browser
	var process = module.exports = {};
	
	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.
	
	var cachedSetTimeout;
	var cachedClearTimeout;
	
	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	} ())
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }
	
	
	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }
	
	
	
	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 209 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var utils = __webpack_require__(204);
	
	module.exports = function normalizeHeaderName(headers, normalizedName) {
	  utils.forEach(headers, function processHeader(value, name) {
	    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
	      headers[normalizedName] = value;
	      delete headers[name];
	    }
	  });
	};


/***/ },
/* 210 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var utils = __webpack_require__(204);
	var settle = __webpack_require__(211);
	var buildURL = __webpack_require__(214);
	var parseHeaders = __webpack_require__(215);
	var isURLSameOrigin = __webpack_require__(216);
	var createError = __webpack_require__(212);
	var btoa = (typeof window !== 'undefined' && window.btoa && window.btoa.bind(window)) || __webpack_require__(217);
	
	module.exports = function xhrAdapter(config) {
	  return new Promise(function dispatchXhrRequest(resolve, reject) {
	    var requestData = config.data;
	    var requestHeaders = config.headers;
	
	    if (utils.isFormData(requestData)) {
	      delete requestHeaders['Content-Type']; // Let the browser set it
	    }
	
	    var request = new XMLHttpRequest();
	    var loadEvent = 'onreadystatechange';
	    var xDomain = false;
	
	    // For IE 8/9 CORS support
	    // Only supports POST and GET calls and doesn't returns the response headers.
	    // DON'T do this for testing b/c XMLHttpRequest is mocked, not XDomainRequest.
	    if (("development") !== 'test' &&
	        typeof window !== 'undefined' &&
	        window.XDomainRequest && !('withCredentials' in request) &&
	        !isURLSameOrigin(config.url)) {
	      request = new window.XDomainRequest();
	      loadEvent = 'onload';
	      xDomain = true;
	      request.onprogress = function handleProgress() {};
	      request.ontimeout = function handleTimeout() {};
	    }
	
	    // HTTP basic authentication
	    if (config.auth) {
	      var username = config.auth.username || '';
	      var password = config.auth.password || '';
	      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
	    }
	
	    request.open(config.method.toUpperCase(), buildURL(config.url, config.params, config.paramsSerializer), true);
	
	    // Set the request timeout in MS
	    request.timeout = config.timeout;
	
	    // Listen for ready state
	    request[loadEvent] = function handleLoad() {
	      if (!request || (request.readyState !== 4 && !xDomain)) {
	        return;
	      }
	
	      // The request errored out and we didn't get a response, this will be
	      // handled by onerror instead
	      // With one exception: request that using file: protocol, most browsers
	      // will return status as 0 even though it's a successful request
	      if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
	        return;
	      }
	
	      // Prepare the response
	      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
	      var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;
	      var response = {
	        data: responseData,
	        // IE sends 1223 instead of 204 (https://github.com/mzabriskie/axios/issues/201)
	        status: request.status === 1223 ? 204 : request.status,
	        statusText: request.status === 1223 ? 'No Content' : request.statusText,
	        headers: responseHeaders,
	        config: config,
	        request: request
	      };
	
	      settle(resolve, reject, response);
	
	      // Clean up request
	      request = null;
	    };
	
	    // Handle low level network errors
	    request.onerror = function handleError() {
	      // Real errors are hidden from us by the browser
	      // onerror should only fire if it's a network error
	      reject(createError('Network Error', config));
	
	      // Clean up request
	      request = null;
	    };
	
	    // Handle timeout
	    request.ontimeout = function handleTimeout() {
	      reject(createError('timeout of ' + config.timeout + 'ms exceeded', config, 'ECONNABORTED'));
	
	      // Clean up request
	      request = null;
	    };
	
	    // Add xsrf header
	    // This is only done if running in a standard browser environment.
	    // Specifically not if we're in a web worker, or react-native.
	    if (utils.isStandardBrowserEnv()) {
	      var cookies = __webpack_require__(218);
	
	      // Add xsrf header
	      var xsrfValue = (config.withCredentials || isURLSameOrigin(config.url)) && config.xsrfCookieName ?
	          cookies.read(config.xsrfCookieName) :
	          undefined;
	
	      if (xsrfValue) {
	        requestHeaders[config.xsrfHeaderName] = xsrfValue;
	      }
	    }
	
	    // Add headers to the request
	    if ('setRequestHeader' in request) {
	      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
	        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
	          // Remove Content-Type if data is undefined
	          delete requestHeaders[key];
	        } else {
	          // Otherwise add header to the request
	          request.setRequestHeader(key, val);
	        }
	      });
	    }
	
	    // Add withCredentials to request if needed
	    if (config.withCredentials) {
	      request.withCredentials = true;
	    }
	
	    // Add responseType to request if needed
	    if (config.responseType) {
	      try {
	        request.responseType = config.responseType;
	      } catch (e) {
	        if (request.responseType !== 'json') {
	          throw e;
	        }
	      }
	    }
	
	    // Handle progress if needed
	    if (typeof config.onDownloadProgress === 'function') {
	      request.addEventListener('progress', config.onDownloadProgress);
	    }
	
	    // Not all browsers support upload events
	    if (typeof config.onUploadProgress === 'function' && request.upload) {
	      request.upload.addEventListener('progress', config.onUploadProgress);
	    }
	
	    if (config.cancelToken) {
	      // Handle cancellation
	      config.cancelToken.promise.then(function onCanceled(cancel) {
	        if (!request) {
	          return;
	        }
	
	        request.abort();
	        reject(cancel);
	        // Clean up request
	        request = null;
	      });
	    }
	
	    if (requestData === undefined) {
	      requestData = null;
	    }
	
	    // Send the request
	    request.send(requestData);
	  });
	};


/***/ },
/* 211 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var createError = __webpack_require__(212);
	
	/**
	 * Resolve or reject a Promise based on response status.
	 *
	 * @param {Function} resolve A function that resolves the promise.
	 * @param {Function} reject A function that rejects the promise.
	 * @param {object} response The response.
	 */
	module.exports = function settle(resolve, reject, response) {
	  var validateStatus = response.config.validateStatus;
	  // Note: status is not exposed by XDomainRequest
	  if (!response.status || !validateStatus || validateStatus(response.status)) {
	    resolve(response);
	  } else {
	    reject(createError(
	      'Request failed with status code ' + response.status,
	      response.config,
	      null,
	      response
	    ));
	  }
	};


/***/ },
/* 212 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var enhanceError = __webpack_require__(213);
	
	/**
	 * Create an Error with the specified message, config, error code, and response.
	 *
	 * @param {string} message The error message.
	 * @param {Object} config The config.
	 * @param {string} [code] The error code (for example, 'ECONNABORTED').
	 @ @param {Object} [response] The response.
	 * @returns {Error} The created error.
	 */
	module.exports = function createError(message, config, code, response) {
	  var error = new Error(message);
	  return enhanceError(error, config, code, response);
	};


/***/ },
/* 213 */
/***/ function(module, exports) {

	'use strict';
	
	/**
	 * Update an Error with the specified config, error code, and response.
	 *
	 * @param {Error} error The error to update.
	 * @param {Object} config The config.
	 * @param {string} [code] The error code (for example, 'ECONNABORTED').
	 @ @param {Object} [response] The response.
	 * @returns {Error} The error.
	 */
	module.exports = function enhanceError(error, config, code, response) {
	  error.config = config;
	  if (code) {
	    error.code = code;
	  }
	  error.response = response;
	  return error;
	};


/***/ },
/* 214 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var utils = __webpack_require__(204);
	
	function encode(val) {
	  return encodeURIComponent(val).
	    replace(/%40/gi, '@').
	    replace(/%3A/gi, ':').
	    replace(/%24/g, '$').
	    replace(/%2C/gi, ',').
	    replace(/%20/g, '+').
	    replace(/%5B/gi, '[').
	    replace(/%5D/gi, ']');
	}
	
	/**
	 * Build a URL by appending params to the end
	 *
	 * @param {string} url The base of the url (e.g., http://www.google.com)
	 * @param {object} [params] The params to be appended
	 * @returns {string} The formatted url
	 */
	module.exports = function buildURL(url, params, paramsSerializer) {
	  /*eslint no-param-reassign:0*/
	  if (!params) {
	    return url;
	  }
	
	  var serializedParams;
	  if (paramsSerializer) {
	    serializedParams = paramsSerializer(params);
	  } else if (utils.isURLSearchParams(params)) {
	    serializedParams = params.toString();
	  } else {
	    var parts = [];
	
	    utils.forEach(params, function serialize(val, key) {
	      if (val === null || typeof val === 'undefined') {
	        return;
	      }
	
	      if (utils.isArray(val)) {
	        key = key + '[]';
	      }
	
	      if (!utils.isArray(val)) {
	        val = [val];
	      }
	
	      utils.forEach(val, function parseValue(v) {
	        if (utils.isDate(v)) {
	          v = v.toISOString();
	        } else if (utils.isObject(v)) {
	          v = JSON.stringify(v);
	        }
	        parts.push(encode(key) + '=' + encode(v));
	      });
	    });
	
	    serializedParams = parts.join('&');
	  }
	
	  if (serializedParams) {
	    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
	  }
	
	  return url;
	};


/***/ },
/* 215 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var utils = __webpack_require__(204);
	
	/**
	 * Parse headers into an object
	 *
	 * ```
	 * Date: Wed, 27 Aug 2014 08:58:49 GMT
	 * Content-Type: application/json
	 * Connection: keep-alive
	 * Transfer-Encoding: chunked
	 * ```
	 *
	 * @param {String} headers Headers needing to be parsed
	 * @returns {Object} Headers parsed into an object
	 */
	module.exports = function parseHeaders(headers) {
	  var parsed = {};
	  var key;
	  var val;
	  var i;
	
	  if (!headers) { return parsed; }
	
	  utils.forEach(headers.split('\n'), function parser(line) {
	    i = line.indexOf(':');
	    key = utils.trim(line.substr(0, i)).toLowerCase();
	    val = utils.trim(line.substr(i + 1));
	
	    if (key) {
	      parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
	    }
	  });
	
	  return parsed;
	};


/***/ },
/* 216 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var utils = __webpack_require__(204);
	
	module.exports = (
	  utils.isStandardBrowserEnv() ?
	
	  // Standard browser envs have full support of the APIs needed to test
	  // whether the request URL is of the same origin as current location.
	  (function standardBrowserEnv() {
	    var msie = /(msie|trident)/i.test(navigator.userAgent);
	    var urlParsingNode = document.createElement('a');
	    var originURL;
	
	    /**
	    * Parse a URL to discover it's components
	    *
	    * @param {String} url The URL to be parsed
	    * @returns {Object}
	    */
	    function resolveURL(url) {
	      var href = url;
	
	      if (msie) {
	        // IE needs attribute set twice to normalize properties
	        urlParsingNode.setAttribute('href', href);
	        href = urlParsingNode.href;
	      }
	
	      urlParsingNode.setAttribute('href', href);
	
	      // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
	      return {
	        href: urlParsingNode.href,
	        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
	        host: urlParsingNode.host,
	        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
	        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
	        hostname: urlParsingNode.hostname,
	        port: urlParsingNode.port,
	        pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
	                  urlParsingNode.pathname :
	                  '/' + urlParsingNode.pathname
	      };
	    }
	
	    originURL = resolveURL(window.location.href);
	
	    /**
	    * Determine if a URL shares the same origin as the current location
	    *
	    * @param {String} requestURL The URL to test
	    * @returns {boolean} True if URL shares the same origin, otherwise false
	    */
	    return function isURLSameOrigin(requestURL) {
	      var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
	      return (parsed.protocol === originURL.protocol &&
	            parsed.host === originURL.host);
	    };
	  })() :
	
	  // Non standard browser envs (web workers, react-native) lack needed support.
	  (function nonStandardBrowserEnv() {
	    return function isURLSameOrigin() {
	      return true;
	    };
	  })()
	);


/***/ },
/* 217 */
/***/ function(module, exports) {

	'use strict';
	
	// btoa polyfill for IE<10 courtesy https://github.com/davidchambers/Base64.js
	
	var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
	
	function E() {
	  this.message = 'String contains an invalid character';
	}
	E.prototype = new Error;
	E.prototype.code = 5;
	E.prototype.name = 'InvalidCharacterError';
	
	function btoa(input) {
	  var str = String(input);
	  var output = '';
	  for (
	    // initialize result and counter
	    var block, charCode, idx = 0, map = chars;
	    // if the next str index does not exist:
	    //   change the mapping table to "="
	    //   check if d has no fractional digits
	    str.charAt(idx | 0) || (map = '=', idx % 1);
	    // "8 - idx % 1 * 8" generates the sequence 2, 4, 6, 8
	    output += map.charAt(63 & block >> 8 - idx % 1 * 8)
	  ) {
	    charCode = str.charCodeAt(idx += 3 / 4);
	    if (charCode > 0xFF) {
	      throw new E();
	    }
	    block = block << 8 | charCode;
	  }
	  return output;
	}
	
	module.exports = btoa;


/***/ },
/* 218 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var utils = __webpack_require__(204);
	
	module.exports = (
	  utils.isStandardBrowserEnv() ?
	
	  // Standard browser envs support document.cookie
	  (function standardBrowserEnv() {
	    return {
	      write: function write(name, value, expires, path, domain, secure) {
	        var cookie = [];
	        cookie.push(name + '=' + encodeURIComponent(value));
	
	        if (utils.isNumber(expires)) {
	          cookie.push('expires=' + new Date(expires).toGMTString());
	        }
	
	        if (utils.isString(path)) {
	          cookie.push('path=' + path);
	        }
	
	        if (utils.isString(domain)) {
	          cookie.push('domain=' + domain);
	        }
	
	        if (secure === true) {
	          cookie.push('secure');
	        }
	
	        document.cookie = cookie.join('; ');
	      },
	
	      read: function read(name) {
	        var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
	        return (match ? decodeURIComponent(match[3]) : null);
	      },
	
	      remove: function remove(name) {
	        this.write(name, '', Date.now() - 86400000);
	      }
	    };
	  })() :
	
	  // Non standard browser env (web workers, react-native) lack needed support.
	  (function nonStandardBrowserEnv() {
	    return {
	      write: function write() {},
	      read: function read() { return null; },
	      remove: function remove() {}
	    };
	  })()
	);


/***/ },
/* 219 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var utils = __webpack_require__(204);
	
	function InterceptorManager() {
	  this.handlers = [];
	}
	
	/**
	 * Add a new interceptor to the stack
	 *
	 * @param {Function} fulfilled The function to handle `then` for a `Promise`
	 * @param {Function} rejected The function to handle `reject` for a `Promise`
	 *
	 * @return {Number} An ID used to remove interceptor later
	 */
	InterceptorManager.prototype.use = function use(fulfilled, rejected) {
	  this.handlers.push({
	    fulfilled: fulfilled,
	    rejected: rejected
	  });
	  return this.handlers.length - 1;
	};
	
	/**
	 * Remove an interceptor from the stack
	 *
	 * @param {Number} id The ID that was returned by `use`
	 */
	InterceptorManager.prototype.eject = function eject(id) {
	  if (this.handlers[id]) {
	    this.handlers[id] = null;
	  }
	};
	
	/**
	 * Iterate over all the registered interceptors
	 *
	 * This method is particularly useful for skipping over any
	 * interceptors that may have become `null` calling `eject`.
	 *
	 * @param {Function} fn The function to call for each interceptor
	 */
	InterceptorManager.prototype.forEach = function forEach(fn) {
	  utils.forEach(this.handlers, function forEachHandler(h) {
	    if (h !== null) {
	      fn(h);
	    }
	  });
	};
	
	module.exports = InterceptorManager;


/***/ },
/* 220 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var utils = __webpack_require__(204);
	var transformData = __webpack_require__(221);
	var isCancel = __webpack_require__(222);
	var defaults = __webpack_require__(207);
	
	/**
	 * Throws a `Cancel` if cancellation has been requested.
	 */
	function throwIfCancellationRequested(config) {
	  if (config.cancelToken) {
	    config.cancelToken.throwIfRequested();
	  }
	}
	
	/**
	 * Dispatch a request to the server using the configured adapter.
	 *
	 * @param {object} config The config that is to be used for the request
	 * @returns {Promise} The Promise to be fulfilled
	 */
	module.exports = function dispatchRequest(config) {
	  throwIfCancellationRequested(config);
	
	  // Ensure headers exist
	  config.headers = config.headers || {};
	
	  // Transform request data
	  config.data = transformData(
	    config.data,
	    config.headers,
	    config.transformRequest
	  );
	
	  // Flatten headers
	  config.headers = utils.merge(
	    config.headers.common || {},
	    config.headers[config.method] || {},
	    config.headers || {}
	  );
	
	  utils.forEach(
	    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
	    function cleanHeaderConfig(method) {
	      delete config.headers[method];
	    }
	  );
	
	  var adapter = config.adapter || defaults.adapter;
	
	  return adapter(config).then(function onAdapterResolution(response) {
	    throwIfCancellationRequested(config);
	
	    // Transform response data
	    response.data = transformData(
	      response.data,
	      response.headers,
	      config.transformResponse
	    );
	
	    return response;
	  }, function onAdapterRejection(reason) {
	    if (!isCancel(reason)) {
	      throwIfCancellationRequested(config);
	
	      // Transform response data
	      if (reason && reason.response) {
	        reason.response.data = transformData(
	          reason.response.data,
	          reason.response.headers,
	          config.transformResponse
	        );
	      }
	    }
	
	    return Promise.reject(reason);
	  });
	};


/***/ },
/* 221 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var utils = __webpack_require__(204);
	
	/**
	 * Transform the data for a request or a response
	 *
	 * @param {Object|String} data The data to be transformed
	 * @param {Array} headers The headers for the request or response
	 * @param {Array|Function} fns A single function or Array of functions
	 * @returns {*} The resulting transformed data
	 */
	module.exports = function transformData(data, headers, fns) {
	  /*eslint no-param-reassign:0*/
	  utils.forEach(fns, function transform(fn) {
	    data = fn(data, headers);
	  });
	
	  return data;
	};


/***/ },
/* 222 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function isCancel(value) {
	  return !!(value && value.__CANCEL__);
	};


/***/ },
/* 223 */
/***/ function(module, exports) {

	'use strict';
	
	/**
	 * Determines whether the specified URL is absolute
	 *
	 * @param {string} url The URL to test
	 * @returns {boolean} True if the specified URL is absolute, otherwise false
	 */
	module.exports = function isAbsoluteURL(url) {
	  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
	  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
	  // by any combination of letters, digits, plus, period, or hyphen.
	  return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
	};


/***/ },
/* 224 */
/***/ function(module, exports) {

	'use strict';
	
	/**
	 * Creates a new URL by combining the specified URLs
	 *
	 * @param {string} baseURL The base URL
	 * @param {string} relativeURL The relative URL
	 * @returns {string} The combined URL
	 */
	module.exports = function combineURLs(baseURL, relativeURL) {
	  return baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '');
	};


/***/ },
/* 225 */
/***/ function(module, exports) {

	'use strict';
	
	/**
	 * A `Cancel` is an object that is thrown when an operation is canceled.
	 *
	 * @class
	 * @param {string=} message The message.
	 */
	function Cancel(message) {
	  this.message = message;
	}
	
	Cancel.prototype.toString = function toString() {
	  return 'Cancel' + (this.message ? ': ' + this.message : '');
	};
	
	Cancel.prototype.__CANCEL__ = true;
	
	module.exports = Cancel;


/***/ },
/* 226 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var Cancel = __webpack_require__(225);
	
	/**
	 * A `CancelToken` is an object that can be used to request cancellation of an operation.
	 *
	 * @class
	 * @param {Function} executor The executor function.
	 */
	function CancelToken(executor) {
	  if (typeof executor !== 'function') {
	    throw new TypeError('executor must be a function.');
	  }
	
	  var resolvePromise;
	  this.promise = new Promise(function promiseExecutor(resolve) {
	    resolvePromise = resolve;
	  });
	
	  var token = this;
	  executor(function cancel(message) {
	    if (token.reason) {
	      // Cancellation has already been requested
	      return;
	    }
	
	    token.reason = new Cancel(message);
	    resolvePromise(token.reason);
	  });
	}
	
	/**
	 * Throws a `Cancel` if cancellation has been requested.
	 */
	CancelToken.prototype.throwIfRequested = function throwIfRequested() {
	  if (this.reason) {
	    throw this.reason;
	  }
	};
	
	/**
	 * Returns an object that contains a new `CancelToken` and a function that, when called,
	 * cancels the `CancelToken`.
	 */
	CancelToken.source = function source() {
	  var cancel;
	  var token = new CancelToken(function executor(c) {
	    cancel = c;
	  });
	  return {
	    token: token,
	    cancel: cancel
	  };
	};
	
	module.exports = CancelToken;


/***/ },
/* 227 */
/***/ function(module, exports) {

	'use strict';
	
	/**
	 * Syntactic sugar for invoking a function and expanding an array for arguments.
	 *
	 * Common use case would be to use `Function.prototype.apply`.
	 *
	 *  ```js
	 *  function f(x, y, z) {}
	 *  var args = [1, 2, 3];
	 *  f.apply(null, args);
	 *  ```
	 *
	 * With `spread` this example can be re-written.
	 *
	 *  ```js
	 *  spread(function(x, y, z) {})([1, 2, 3]);
	 *  ```
	 *
	 * @param {Function} callback
	 * @returns {Function}
	 */
	module.exports = function spread(callback) {
	  return function wrap(arr) {
	    return callback.apply(null, arr);
	  };
	};


/***/ },
/* 228 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _classCallCheck2 = __webpack_require__(2);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(20);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(89);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _BaseField2 = __webpack_require__(197);
	
	var _BaseField3 = _interopRequireDefault(_BaseField2);
	
	var _Utils = __webpack_require__(103);
	
	var _Utils2 = _interopRequireDefault(_Utils);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var TextField = function (_BaseField) {
	    (0, _inherits3.default)(TextField, _BaseField);
	
	    function TextField(opts) {
	        (0, _classCallCheck3.default)(this, TextField);
	        return (0, _possibleConstructorReturn3.default)(this, _BaseField.call(this, opts));
	    }
	
	    TextField.prototype.createLocalizedField = function createLocalizedField(lang) {
	        var uid = this.id() + "-" + lang;
	        var fieldEl = document.createElement("input");
	
	        fieldEl.classList.add("composer-field", "textbox");
	        fieldEl.setAttribute("type", "text");
	        fieldEl.setAttribute("id", "text-" + uid);
	        fieldEl.setAttribute("data-lang", lang);
	        if (_Utils2.default.NoLang() !== lang) {
	            fieldEl.setAttribute("title", this.settings.languages[lang]);
	        }
	
	        return fieldEl;
	    };
	
	    return TextField;
	}(_BaseField3.default);
	
	exports.default = TextField;

/***/ },
/* 229 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _classCallCheck2 = __webpack_require__(2);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(20);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(89);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _BaseField2 = __webpack_require__(197);
	
	var _BaseField3 = _interopRequireDefault(_BaseField2);
	
	var _Utils = __webpack_require__(103);
	
	var _Utils2 = _interopRequireDefault(_Utils);
	
	var _tinymce = __webpack_require__(230);
	
	var _tinymce2 = _interopRequireDefault(_tinymce);
	
	__webpack_require__(232);
	
	__webpack_require__(233);
	
	__webpack_require__(235);
	
	__webpack_require__(237);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var RichTextField = function (_BaseField) {
	    (0, _inherits3.default)(RichTextField, _BaseField);
	
	    function RichTextField(opts) {
	        (0, _classCallCheck3.default)(this, RichTextField);
	        return (0, _possibleConstructorReturn3.default)(this, _BaseField.call(this, opts));
	    }
	
	    RichTextField.prototype.getDefaultOptions = function getDefaultOptions() {
	        return {
	            "toolbar": 'undo redo | bold italic underline | alignleft aligncenter alignright | bullist numlist | removeformat | link unlink',
	            "showCode": false,
	            "labels": {
	                "placeHolder": "Enter text here ..."
	            }
	        };
	    };
	
	    RichTextField.prototype.createLocalizedField = function createLocalizedField(lang) {
	
	        var uid = this.id() + "-" + lang;
	        var fieldEl = document.createElement("div");
	
	        fieldEl.classList.add("composer-field", "tinymce");
	        fieldEl.setAttribute("id", "richtext-" + uid);
	        fieldEl.setAttribute("data-lang", lang);
	        if (_Utils2.default.NoLang() !== lang) fieldEl.setAttribute("title", this.settings.languages[lang]);
	
	        return fieldEl;
	    };
	
	    RichTextField.prototype.init = function init() {
	        var _this2 = this;
	
	        for (var _iterator = _BaseField.prototype.getComponents.call(this), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
	            var _ref;
	
	            if (_isArray) {
	                if (_i >= _iterator.length) break;
	                _ref = _iterator[_i++];
	            } else {
	                _i = _iterator.next();
	                if (_i.done) break;
	                _ref = _i.value;
	            }
	
	            var _ref2 = _ref,
	                lang = _ref2[0],
	                el = _ref2[1];
	
	            var uid = this.id() + "-" + lang;
	            var toolbar = this.settings.toolbar;
	            if (toolbar.indexOf("code") < 0) toolbar += this.settings.showCode ? ' | code' : '';
	
	            _tinymce2.default.init({
	                inline: true,
	                statusbar: false,
	                menubar: false,
	                selector: "#richtext-" + uid,
	                skin: true,
	                plugins: ['lists', 'link', 'code'],
	                toolbar: toolbar,
	                init_instance_callback: function init_instance_callback(editor) {
	                    editor.on('Change', function () {
	                        _BaseField.prototype.signalChange.call(_this2);
	                    });
	                }
	            });
	        }
	    };
	
	    RichTextField.prototype.getValueFromLocalizedField = function getValueFromLocalizedField(el, lang) {
	        var uid = this.id() + "-" + lang;
	        return _tinymce2.default.get("richtext-" + uid).getContent();
	    };
	
	    RichTextField.prototype.setValueToLocalizedField = function setValueToLocalizedField(el, value, lang) {
	        var uid = this.id() + "-" + lang;
	        return _tinymce2.default.get("richtext-" + uid).setContent(value);
	    };
	
	    return RichTextField;
	}(_BaseField3.default);
	
	exports.default = RichTextField;

/***/ },
/* 230 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(setImmediate) {/*** IMPORTS FROM imports-loader ***/
	(function() {
	
	// 4.5.0 (2016-11-23)
	
	/**
	 * Compiled inline version. (Library mode)
	 */
	
	/*jshint smarttabs:true, undef:true, latedef:true, curly:true, bitwise:true, camelcase:true */
	/*globals $code */
	
	(function(exports, undefined) {
		"use strict";
	
		var modules = {};
	
		function require(ids, callback) {
			var module, defs = [];
	
			for (var i = 0; i < ids.length; ++i) {
				module = modules[ids[i]] || resolve(ids[i]);
				if (!module) {
					throw 'module definition dependecy not found: ' + ids[i];
				}
	
				defs.push(module);
			}
	
			callback.apply(null, defs);
		}
	
		function define(id, dependencies, definition) {
			if (typeof id !== 'string') {
				throw 'invalid module definition, module id must be defined and be a string';
			}
	
			if (dependencies === undefined) {
				throw 'invalid module definition, dependencies must be specified';
			}
	
			if (definition === undefined) {
				throw 'invalid module definition, definition function must be specified';
			}
	
			require(dependencies, function() {
				modules[id] = definition.apply(null, arguments);
			});
		}
	
		function defined(id) {
			return !!modules[id];
		}
	
		function resolve(id) {
			var target = exports;
			var fragments = id.split(/[.\/]/);
	
			for (var fi = 0; fi < fragments.length; ++fi) {
				if (!target[fragments[fi]]) {
					return;
				}
	
				target = target[fragments[fi]];
			}
	
			return target;
		}
	
		function expose(ids) {
			var i, target, id, fragments, privateModules;
	
			for (i = 0; i < ids.length; i++) {
				target = exports;
				id = ids[i];
				fragments = id.split(/[.\/]/);
	
				for (var fi = 0; fi < fragments.length - 1; ++fi) {
					if (target[fragments[fi]] === undefined) {
						target[fragments[fi]] = {};
					}
	
					target = target[fragments[fi]];
				}
	
				target[fragments[fragments.length - 1]] = modules[id];
			}
			
			// Expose private modules for unit tests
			if (exports.AMDLC_TESTS) {
				privateModules = exports.privateModules || {};
	
				for (id in modules) {
					privateModules[id] = modules[id];
				}
	
				for (i = 0; i < ids.length; i++) {
					delete privateModules[ids[i]];
				}
	
				exports.privateModules = privateModules;
			}
		}
	
	// Included from: js/tinymce/classes/geom/Rect.js
	
	/**
	 * Rect.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Contains various tools for rect/position calculation.
	 *
	 * @class tinymce.geom.Rect
	 */
	define("tinymce/geom/Rect", [
	], function() {
		"use strict";
	
		var min = Math.min, max = Math.max, round = Math.round;
	
		/**
		 * Returns the rect positioned based on the relative position name
		 * to the target rect.
		 *
		 * @method relativePosition
		 * @param {Rect} rect Source rect to modify into a new rect.
		 * @param {Rect} targetRect Rect to move relative to based on the rel option.
		 * @param {String} rel Relative position. For example: tr-bl.
		 */
		function relativePosition(rect, targetRect, rel) {
			var x, y, w, h, targetW, targetH;
	
			x = targetRect.x;
			y = targetRect.y;
			w = rect.w;
			h = rect.h;
			targetW = targetRect.w;
			targetH = targetRect.h;
	
			rel = (rel || '').split('');
	
			if (rel[0] === 'b') {
				y += targetH;
			}
	
			if (rel[1] === 'r') {
				x += targetW;
			}
	
			if (rel[0] === 'c') {
				y += round(targetH / 2);
			}
	
			if (rel[1] === 'c') {
				x += round(targetW / 2);
			}
	
			if (rel[3] === 'b') {
				y -= h;
			}
	
			if (rel[4] === 'r') {
				x -= w;
			}
	
			if (rel[3] === 'c') {
				y -= round(h / 2);
			}
	
			if (rel[4] === 'c') {
				x -= round(w / 2);
			}
	
			return create(x, y, w, h);
		}
	
		/**
		 * Tests various positions to get the most suitable one.
		 *
		 * @method findBestRelativePosition
		 * @param {Rect} rect Rect to use as source.
		 * @param {Rect} targetRect Rect to move relative to.
		 * @param {Rect} constrainRect Rect to constrain within.
		 * @param {Array} rels Array of relative positions to test against.
		 */
		function findBestRelativePosition(rect, targetRect, constrainRect, rels) {
			var pos, i;
	
			for (i = 0; i < rels.length; i++) {
				pos = relativePosition(rect, targetRect, rels[i]);
	
				if (pos.x >= constrainRect.x && pos.x + pos.w <= constrainRect.w + constrainRect.x &&
					pos.y >= constrainRect.y && pos.y + pos.h <= constrainRect.h + constrainRect.y) {
					return rels[i];
				}
			}
	
			return null;
		}
	
		/**
		 * Inflates the rect in all directions.
		 *
		 * @method inflate
		 * @param {Rect} rect Rect to expand.
		 * @param {Number} w Relative width to expand by.
		 * @param {Number} h Relative height to expand by.
		 * @return {Rect} New expanded rect.
		 */
		function inflate(rect, w, h) {
			return create(rect.x - w, rect.y - h, rect.w + w * 2, rect.h + h * 2);
		}
	
		/**
		 * Returns the intersection of the specified rectangles.
		 *
		 * @method intersect
		 * @param {Rect} rect The first rectangle to compare.
		 * @param {Rect} cropRect The second rectangle to compare.
		 * @return {Rect} The intersection of the two rectangles or null if they don't intersect.
		 */
		function intersect(rect, cropRect) {
			var x1, y1, x2, y2;
	
			x1 = max(rect.x, cropRect.x);
			y1 = max(rect.y, cropRect.y);
			x2 = min(rect.x + rect.w, cropRect.x + cropRect.w);
			y2 = min(rect.y + rect.h, cropRect.y + cropRect.h);
	
			if (x2 - x1 < 0 || y2 - y1 < 0) {
				return null;
			}
	
			return create(x1, y1, x2 - x1, y2 - y1);
		}
	
		/**
		 * Returns a rect clamped within the specified clamp rect. This forces the
		 * rect to be inside the clamp rect.
		 *
		 * @method clamp
		 * @param {Rect} rect Rectangle to force within clamp rect.
		 * @param {Rect} clampRect Rectable to force within.
		 * @param {Boolean} fixedSize True/false if size should be fixed.
		 * @return {Rect} Clamped rect.
		 */
		function clamp(rect, clampRect, fixedSize) {
			var underflowX1, underflowY1, overflowX2, overflowY2,
				x1, y1, x2, y2, cx2, cy2;
	
			x1 = rect.x;
			y1 = rect.y;
			x2 = rect.x + rect.w;
			y2 = rect.y + rect.h;
			cx2 = clampRect.x + clampRect.w;
			cy2 = clampRect.y + clampRect.h;
	
			underflowX1 = max(0, clampRect.x - x1);
			underflowY1 = max(0, clampRect.y - y1);
			overflowX2 = max(0, x2 - cx2);
			overflowY2 = max(0, y2 - cy2);
	
			x1 += underflowX1;
			y1 += underflowY1;
	
			if (fixedSize) {
				x2 += underflowX1;
				y2 += underflowY1;
				x1 -= overflowX2;
				y1 -= overflowY2;
			}
	
			x2 -= overflowX2;
			y2 -= overflowY2;
	
			return create(x1, y1, x2 - x1, y2 - y1);
		}
	
		/**
		 * Creates a new rectangle object.
		 *
		 * @method create
		 * @param {Number} x Rectangle x location.
		 * @param {Number} y Rectangle y location.
		 * @param {Number} w Rectangle width.
		 * @param {Number} h Rectangle height.
		 * @return {Rect} New rectangle object.
		 */
		function create(x, y, w, h) {
			return {x: x, y: y, w: w, h: h};
		}
	
		/**
		 * Creates a new rectangle object form a clientRects object.
		 *
		 * @method fromClientRect
		 * @param {ClientRect} clientRect DOM ClientRect object.
		 * @return {Rect} New rectangle object.
		 */
		function fromClientRect(clientRect) {
			return create(clientRect.left, clientRect.top, clientRect.width, clientRect.height);
		}
	
		return {
			inflate: inflate,
			relativePosition: relativePosition,
			findBestRelativePosition: findBestRelativePosition,
			intersect: intersect,
			clamp: clamp,
			create: create,
			fromClientRect: fromClientRect
		};
	});
	
	// Included from: js/tinymce/classes/util/Promise.js
	
	/**
	 * Promise.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * Promise polyfill under MIT license: https://github.com/taylorhakes/promise-polyfill
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/* eslint-disable */
	/* jshint ignore:start */
	
	/**
	 * Modifed to be a feature fill and wrapped as tinymce module.
	 */
	define("tinymce/util/Promise", [], function() {
		if (window.Promise) {
			return window.Promise;
		}
	
		// Use polyfill for setImmediate for performance gains
		var asap = Promise.immediateFn || (typeof setImmediate === 'function' && setImmediate) ||
			function(fn) { setTimeout(fn, 1); };
	
		// Polyfill for Function.prototype.bind
		function bind(fn, thisArg) {
			return function() {
				fn.apply(thisArg, arguments);
			};
		}
	
		var isArray = Array.isArray || function(value) { return Object.prototype.toString.call(value) === "[object Array]"; };
	
		function Promise(fn) {
			if (typeof this !== 'object') throw new TypeError('Promises must be constructed via new');
			if (typeof fn !== 'function') throw new TypeError('not a function');
			this._state = null;
			this._value = null;
			this._deferreds = [];
	
			doResolve(fn, bind(resolve, this), bind(reject, this));
		}
	
		function handle(deferred) {
			var me = this;
			if (this._state === null) {
				this._deferreds.push(deferred);
				return;
			}
			asap(function() {
				var cb = me._state ? deferred.onFulfilled : deferred.onRejected;
				if (cb === null) {
					(me._state ? deferred.resolve : deferred.reject)(me._value);
					return;
				}
				var ret;
				try {
					ret = cb(me._value);
				}
				catch (e) {
					deferred.reject(e);
					return;
				}
				deferred.resolve(ret);
			});
		}
	
		function resolve(newValue) {
			try { //Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
				if (newValue === this) throw new TypeError('A promise cannot be resolved with itself.');
				if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {
					var then = newValue.then;
					if (typeof then === 'function') {
						doResolve(bind(then, newValue), bind(resolve, this), bind(reject, this));
						return;
					}
				}
				this._state = true;
				this._value = newValue;
				finale.call(this);
			} catch (e) { reject.call(this, e); }
		}
	
		function reject(newValue) {
			this._state = false;
			this._value = newValue;
			finale.call(this);
		}
	
		function finale() {
			for (var i = 0, len = this._deferreds.length; i < len; i++) {
				handle.call(this, this._deferreds[i]);
			}
			this._deferreds = null;
		}
	
		function Handler(onFulfilled, onRejected, resolve, reject){
			this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
			this.onRejected = typeof onRejected === 'function' ? onRejected : null;
			this.resolve = resolve;
			this.reject = reject;
		}
	
		/**
		 * Take a potentially misbehaving resolver function and make sure
		 * onFulfilled and onRejected are only called once.
		 *
		 * Makes no guarantees about asynchrony.
		 */
		function doResolve(fn, onFulfilled, onRejected) {
			var done = false;
			try {
				fn(function (value) {
					if (done) return;
					done = true;
					onFulfilled(value);
				}, function (reason) {
					if (done) return;
					done = true;
					onRejected(reason);
				});
			} catch (ex) {
				if (done) return;
				done = true;
				onRejected(ex);
			}
		}
	
		Promise.prototype['catch'] = function (onRejected) {
			return this.then(null, onRejected);
		};
	
		Promise.prototype.then = function(onFulfilled, onRejected) {
			var me = this;
			return new Promise(function(resolve, reject) {
				handle.call(me, new Handler(onFulfilled, onRejected, resolve, reject));
			});
		};
	
		Promise.all = function () {
			var args = Array.prototype.slice.call(arguments.length === 1 && isArray(arguments[0]) ? arguments[0] : arguments);
	
			return new Promise(function (resolve, reject) {
				if (args.length === 0) return resolve([]);
				var remaining = args.length;
				function res(i, val) {
					try {
						if (val && (typeof val === 'object' || typeof val === 'function')) {
							var then = val.then;
							if (typeof then === 'function') {
								then.call(val, function (val) { res(i, val); }, reject);
								return;
							}
						}
						args[i] = val;
						if (--remaining === 0) {
							resolve(args);
						}
					} catch (ex) {
						reject(ex);
					}
				}
				for (var i = 0; i < args.length; i++) {
					res(i, args[i]);
				}
			});
		};
	
		Promise.resolve = function (value) {
			if (value && typeof value === 'object' && value.constructor === Promise) {
				return value;
			}
	
			return new Promise(function (resolve) {
				resolve(value);
			});
		};
	
		Promise.reject = function (value) {
			return new Promise(function (resolve, reject) {
				reject(value);
			});
		};
	
		Promise.race = function (values) {
			return new Promise(function (resolve, reject) {
				for(var i = 0, len = values.length; i < len; i++) {
					values[i].then(resolve, reject);
				}
			});
		};
	
		return Promise;
	});
	
	/* jshint ignore:end */
	/* eslint-enable */
	
	// Included from: js/tinymce/classes/util/Delay.js
	
	/**
	 * Delay.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Utility class for working with delayed actions like setTimeout.
	 *
	 * @class tinymce.util.Delay
	 */
	define("tinymce/util/Delay", [
		"tinymce/util/Promise"
	], function(Promise) {
		var requestAnimationFramePromise;
	
		function requestAnimationFrame(callback, element) {
			var i, requestAnimationFrameFunc = window.requestAnimationFrame, vendors = ['ms', 'moz', 'webkit'];
	
			function featurefill(callback) {
				window.setTimeout(callback, 0);
			}
	
			for (i = 0; i < vendors.length && !requestAnimationFrameFunc; i++) {
				requestAnimationFrameFunc = window[vendors[i] + 'RequestAnimationFrame'];
			}
	
			if (!requestAnimationFrameFunc) {
				requestAnimationFrameFunc = featurefill;
			}
	
			requestAnimationFrameFunc(callback, element);
		}
	
		function wrappedSetTimeout(callback, time) {
			if (typeof time != 'number') {
				time = 0;
			}
	
			return setTimeout(callback, time);
		}
	
		function wrappedSetInterval(callback, time) {
			if (typeof time != 'number') {
				time = 1; // IE 8 needs it to be > 0
			}
	
			return setInterval(callback, time);
		}
	
		function wrappedClearTimeout(id) {
			return clearTimeout(id);
		}
	
		function wrappedClearInterval(id) {
			return clearInterval(id);
		}
	
		function debounce(callback, time) {
			var timer, func;
	
			func = function() {
				var args = arguments;
	
				clearTimeout(timer);
	
				timer = wrappedSetTimeout(function() {
					callback.apply(this, args);
				}, time);
			};
	
			func.stop = function() {
				clearTimeout(timer);
			};
	
			return func;
		}
	
		return {
			/**
			 * Requests an animation frame and fallbacks to a timeout on older browsers.
			 *
			 * @method requestAnimationFrame
			 * @param {function} callback Callback to execute when a new frame is available.
			 * @param {DOMElement} element Optional element to scope it to.
			 */
			requestAnimationFrame: function(callback, element) {
				if (requestAnimationFramePromise) {
					requestAnimationFramePromise.then(callback);
					return;
				}
	
				requestAnimationFramePromise = new Promise(function(resolve) {
					if (!element) {
						element = document.body;
					}
	
					requestAnimationFrame(resolve, element);
				}).then(callback);
			},
	
			/**
			 * Sets a timer in ms and executes the specified callback when the timer runs out.
			 *
			 * @method setTimeout
			 * @param {function} callback Callback to execute when timer runs out.
			 * @param {Number} time Optional time to wait before the callback is executed, defaults to 0.
			 * @return {Number} Timeout id number.
			 */
			setTimeout: wrappedSetTimeout,
	
			/**
			 * Sets an interval timer in ms and executes the specified callback at every interval of that time.
			 *
			 * @method setInterval
			 * @param {function} callback Callback to execute when interval time runs out.
			 * @param {Number} time Optional time to wait before the callback is executed, defaults to 0.
			 * @return {Number} Timeout id number.
			 */
			setInterval: wrappedSetInterval,
	
			/**
			 * Sets an editor timeout it's similar to setTimeout except that it checks if the editor instance is
			 * still alive when the callback gets executed.
			 *
			 * @method setEditorTimeout
			 * @param {tinymce.Editor} editor Editor instance to check the removed state on.
			 * @param {function} callback Callback to execute when timer runs out.
			 * @param {Number} time Optional time to wait before the callback is executed, defaults to 0.
			 * @return {Number} Timeout id number.
			 */
			setEditorTimeout: function(editor, callback, time) {
				return wrappedSetTimeout(function() {
					if (!editor.removed) {
						callback();
					}
				}, time);
			},
	
			/**
			 * Sets an interval timer it's similar to setInterval except that it checks if the editor instance is
			 * still alive when the callback gets executed.
			 *
			 * @method setEditorInterval
			 * @param {function} callback Callback to execute when interval time runs out.
			 * @param {Number} time Optional time to wait before the callback is executed, defaults to 0.
			 * @return {Number} Timeout id number.
			 */
			setEditorInterval: function(editor, callback, time) {
				var timer;
	
				timer = wrappedSetInterval(function() {
					if (!editor.removed) {
						callback();
					} else {
						clearInterval(timer);
					}
				}, time);
	
				return timer;
			},
	
			/**
			 * Creates debounced callback function that only gets executed once within the specified time.
			 *
			 * @method debounce
			 * @param {function} callback Callback to execute when timer finishes.
			 * @param {Number} time Optional time to wait before the callback is executed, defaults to 0.
			 * @return {Function} debounced function callback.
			 */
			debounce: debounce,
	
			// Throttle needs to be debounce due to backwards compatibility.
			throttle: debounce,
	
			/**
			 * Clears an interval timer so it won't execute.
			 *
			 * @method clearInterval
			 * @param {Number} Interval timer id number.
			 */
			clearInterval: wrappedClearInterval,
	
			/**
			 * Clears an timeout timer so it won't execute.
			 *
			 * @method clearTimeout
			 * @param {Number} Timeout timer id number.
			 */
			clearTimeout: wrappedClearTimeout
		};
	});
	
	// Included from: js/tinymce/classes/Env.js
	
	/**
	 * Env.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This class contains various environment constants like browser versions etc.
	 * Normally you don't want to sniff specific browser versions but sometimes you have
	 * to when it's impossible to feature detect. So use this with care.
	 *
	 * @class tinymce.Env
	 * @static
	 */
	define("tinymce/Env", [], function() {
		var nav = navigator, userAgent = nav.userAgent;
		var opera, webkit, ie, ie11, ie12, gecko, mac, iDevice, android, fileApi, phone, tablet, windowsPhone;
	
		function matchMediaQuery(query) {
			return "matchMedia" in window ? matchMedia(query).matches : false;
		}
	
		opera = window.opera && window.opera.buildNumber;
		android = /Android/.test(userAgent);
		webkit = /WebKit/.test(userAgent);
		ie = !webkit && !opera && (/MSIE/gi).test(userAgent) && (/Explorer/gi).test(nav.appName);
		ie = ie && /MSIE (\w+)\./.exec(userAgent)[1];
		ie11 = userAgent.indexOf('Trident/') != -1 && (userAgent.indexOf('rv:') != -1 || nav.appName.indexOf('Netscape') != -1) ? 11 : false;
		ie12 = (userAgent.indexOf('Edge/') != -1 && !ie && !ie11) ? 12 : false;
		ie = ie || ie11 || ie12;
		gecko = !webkit && !ie11 && /Gecko/.test(userAgent);
		mac = userAgent.indexOf('Mac') != -1;
		iDevice = /(iPad|iPhone)/.test(userAgent);
		fileApi = "FormData" in window && "FileReader" in window && "URL" in window && !!URL.createObjectURL;
		phone = matchMediaQuery("only screen and (max-device-width: 480px)") && (android || iDevice);
		tablet = matchMediaQuery("only screen and (min-width: 800px)") && (android || iDevice);
		windowsPhone = userAgent.indexOf('Windows Phone') != -1;
	
		if (ie12) {
			webkit = false;
		}
	
		// Is a iPad/iPhone and not on iOS5 sniff the WebKit version since older iOS WebKit versions
		// says it has contentEditable support but there is no visible caret.
		var contentEditable = !iDevice || fileApi || userAgent.match(/AppleWebKit\/(\d*)/)[1] >= 534;
	
		return {
			/**
			 * Constant that is true if the browser is Opera.
			 *
			 * @property opera
			 * @type Boolean
			 * @final
			 */
			opera: opera,
	
			/**
			 * Constant that is true if the browser is WebKit (Safari/Chrome).
			 *
			 * @property webKit
			 * @type Boolean
			 * @final
			 */
			webkit: webkit,
	
			/**
			 * Constant that is more than zero if the browser is IE.
			 *
			 * @property ie
			 * @type Boolean
			 * @final
			 */
			ie: ie,
	
			/**
			 * Constant that is true if the browser is Gecko.
			 *
			 * @property gecko
			 * @type Boolean
			 * @final
			 */
			gecko: gecko,
	
			/**
			 * Constant that is true if the os is Mac OS.
			 *
			 * @property mac
			 * @type Boolean
			 * @final
			 */
			mac: mac,
	
			/**
			 * Constant that is true if the os is iOS.
			 *
			 * @property iOS
			 * @type Boolean
			 * @final
			 */
			iOS: iDevice,
	
			/**
			 * Constant that is true if the os is android.
			 *
			 * @property android
			 * @type Boolean
			 * @final
			 */
			android: android,
	
			/**
			 * Constant that is true if the browser supports editing.
			 *
			 * @property contentEditable
			 * @type Boolean
			 * @final
			 */
			contentEditable: contentEditable,
	
			/**
			 * Transparent image data url.
			 *
			 * @property transparentSrc
			 * @type Boolean
			 * @final
			 */
			transparentSrc: "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
	
			/**
			 * Returns true/false if the browser can or can't place the caret after a inline block like an image.
			 *
			 * @property noCaretAfter
			 * @type Boolean
			 * @final
			 */
			caretAfter: ie != 8,
	
			/**
			 * Constant that is true if the browser supports native DOM Ranges. IE 9+.
			 *
			 * @property range
			 * @type Boolean
			 */
			range: window.getSelection && "Range" in window,
	
			/**
			 * Returns the IE document mode for non IE browsers this will fake IE 10.
			 *
			 * @property documentMode
			 * @type Number
			 */
			documentMode: ie && !ie12 ? (document.documentMode || 7) : 10,
	
			/**
			 * Constant that is true if the browser has a modern file api.
			 *
			 * @property fileApi
			 * @type Boolean
			 */
			fileApi: fileApi,
	
			/**
			 * Constant that is true if the browser supports contentEditable=false regions.
			 *
			 * @property ceFalse
			 * @type Boolean
			 */
			ceFalse: (ie === false || ie > 8),
	
			/**
			 * Constant if CSP mode is possible or not. Meaning we can't use script urls for the iframe.
			 */
			canHaveCSP: (ie === false || ie > 11),
	
			desktop: !phone && !tablet,
			windowsPhone: windowsPhone
		};
	});
	
	// Included from: js/tinymce/classes/dom/EventUtils.js
	
	/**
	 * EventUtils.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/*jshint loopfunc:true*/
	/*eslint no-loop-func:0 */
	
	/**
	 * This class wraps the browsers native event logic with more convenient methods.
	 *
	 * @class tinymce.dom.EventUtils
	 */
	define("tinymce/dom/EventUtils", [
		"tinymce/util/Delay",
		"tinymce/Env"
	], function(Delay, Env) {
		"use strict";
	
		var eventExpandoPrefix = "mce-data-";
		var mouseEventRe = /^(?:mouse|contextmenu)|click/;
		var deprecated = {
			keyLocation: 1, layerX: 1, layerY: 1, returnValue: 1,
			webkitMovementX: 1, webkitMovementY: 1, keyIdentifier: 1
		};
	
		/**
		 * Binds a native event to a callback on the speified target.
		 */
		function addEvent(target, name, callback, capture) {
			if (target.addEventListener) {
				target.addEventListener(name, callback, capture || false);
			} else if (target.attachEvent) {
				target.attachEvent('on' + name, callback);
			}
		}
	
		/**
		 * Unbinds a native event callback on the specified target.
		 */
		function removeEvent(target, name, callback, capture) {
			if (target.removeEventListener) {
				target.removeEventListener(name, callback, capture || false);
			} else if (target.detachEvent) {
				target.detachEvent('on' + name, callback);
			}
		}
	
		/**
		 * Gets the event target based on shadow dom properties like path and deepPath.
		 */
		function getTargetFromShadowDom(event, defaultTarget) {
			var path, target = defaultTarget;
	
			// When target element is inside Shadow DOM we need to take first element from path
			// otherwise we'll get Shadow Root parent, not actual target element
	
			// Normalize target for WebComponents v0 implementation (in Chrome)
			path = event.path;
			if (path && path.length > 0) {
				target = path[0];
			}
	
			// Normalize target for WebComponents v1 implementation (standard)
			if (event.deepPath) {
				path = event.deepPath();
				if (path && path.length > 0) {
					target = path[0];
				}
			}
	
			return target;
		}
	
		/**
		 * Normalizes a native event object or just adds the event specific methods on a custom event.
		 */
		function fix(originalEvent, data) {
			var name, event = data || {}, undef;
	
			// Dummy function that gets replaced on the delegation state functions
			function returnFalse() {
				return false;
			}
	
			// Dummy function that gets replaced on the delegation state functions
			function returnTrue() {
				return true;
			}
	
			// Copy all properties from the original event
			for (name in originalEvent) {
				// layerX/layerY is deprecated in Chrome and produces a warning
				if (!deprecated[name]) {
					event[name] = originalEvent[name];
				}
			}
	
			// Normalize target IE uses srcElement
			if (!event.target) {
				event.target = event.srcElement || document;
			}
	
			// Experimental shadow dom support
			if (Env.experimentalShadowDom) {
				event.target = getTargetFromShadowDom(originalEvent, event.target);
			}
	
			// Calculate pageX/Y if missing and clientX/Y available
			if (originalEvent && mouseEventRe.test(originalEvent.type) && originalEvent.pageX === undef && originalEvent.clientX !== undef) {
				var eventDoc = event.target.ownerDocument || document;
				var doc = eventDoc.documentElement;
				var body = eventDoc.body;
	
				event.pageX = originalEvent.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) -
					(doc && doc.clientLeft || body && body.clientLeft || 0);
	
				event.pageY = originalEvent.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) -
					(doc && doc.clientTop || body && body.clientTop || 0);
			}
	
			// Add preventDefault method
			event.preventDefault = function() {
				event.isDefaultPrevented = returnTrue;
	
				// Execute preventDefault on the original event object
				if (originalEvent) {
					if (originalEvent.preventDefault) {
						originalEvent.preventDefault();
					} else {
						originalEvent.returnValue = false; // IE
					}
				}
			};
	
			// Add stopPropagation
			event.stopPropagation = function() {
				event.isPropagationStopped = returnTrue;
	
				// Execute stopPropagation on the original event object
				if (originalEvent) {
					if (originalEvent.stopPropagation) {
						originalEvent.stopPropagation();
					} else {
						originalEvent.cancelBubble = true; // IE
					}
				}
			};
	
			// Add stopImmediatePropagation
			event.stopImmediatePropagation = function() {
				event.isImmediatePropagationStopped = returnTrue;
				event.stopPropagation();
			};
	
			// Add event delegation states
			if (!event.isDefaultPrevented) {
				event.isDefaultPrevented = returnFalse;
				event.isPropagationStopped = returnFalse;
				event.isImmediatePropagationStopped = returnFalse;
			}
	
			// Add missing metaKey for IE 8
			if (typeof event.metaKey == 'undefined') {
				event.metaKey = false;
			}
	
			return event;
		}
	
		/**
		 * Bind a DOMContentLoaded event across browsers and executes the callback once the page DOM is initialized.
		 * It will also set/check the domLoaded state of the event_utils instance so ready isn't called multiple times.
		 */
		function bindOnReady(win, callback, eventUtils) {
			var doc = win.document, event = {type: 'ready'};
	
			if (eventUtils.domLoaded) {
				callback(event);
				return;
			}
	
			// Gets called when the DOM is ready
			function readyHandler() {
				if (!eventUtils.domLoaded) {
					eventUtils.domLoaded = true;
					callback(event);
				}
			}
	
			function waitForDomLoaded() {
				// Check complete or interactive state if there is a body
				// element on some iframes IE 8 will produce a null body
				if (doc.readyState === "complete" || (doc.readyState === "interactive" && doc.body)) {
					removeEvent(doc, "readystatechange", waitForDomLoaded);
					readyHandler();
				}
			}
	
			function tryScroll() {
				try {
					// If IE is used, use the trick by Diego Perini licensed under MIT by request to the author.
					// http://javascript.nwbox.com/IEContentLoaded/
					doc.documentElement.doScroll("left");
				} catch (ex) {
					Delay.setTimeout(tryScroll);
					return;
				}
	
				readyHandler();
			}
	
			// Use W3C method
			if (doc.addEventListener) {
				if (doc.readyState === "complete") {
					readyHandler();
				} else {
					addEvent(win, 'DOMContentLoaded', readyHandler);
				}
			} else {
				// Use IE method
				addEvent(doc, "readystatechange", waitForDomLoaded);
	
				// Wait until we can scroll, when we can the DOM is initialized
				if (doc.documentElement.doScroll && win.self === win.top) {
					tryScroll();
				}
			}
	
			// Fallback if any of the above methods should fail for some odd reason
			addEvent(win, 'load', readyHandler);
		}
	
		/**
		 * This class enables you to bind/unbind native events to elements and normalize it's behavior across browsers.
		 */
		function EventUtils() {
			var self = this, events = {}, count, expando, hasFocusIn, hasMouseEnterLeave, mouseEnterLeave;
	
			expando = eventExpandoPrefix + (+new Date()).toString(32);
			hasMouseEnterLeave = "onmouseenter" in document.documentElement;
			hasFocusIn = "onfocusin" in document.documentElement;
			mouseEnterLeave = {mouseenter: 'mouseover', mouseleave: 'mouseout'};
			count = 1;
	
			// State if the DOMContentLoaded was executed or not
			self.domLoaded = false;
			self.events = events;
	
			/**
			 * Executes all event handler callbacks for a specific event.
			 *
			 * @private
			 * @param {Event} evt Event object.
			 * @param {String} id Expando id value to look for.
			 */
			function executeHandlers(evt, id) {
				var callbackList, i, l, callback, container = events[id];
	
				callbackList = container && container[evt.type];
				if (callbackList) {
					for (i = 0, l = callbackList.length; i < l; i++) {
						callback = callbackList[i];
	
						// Check if callback exists might be removed if a unbind is called inside the callback
						if (callback && callback.func.call(callback.scope, evt) === false) {
							evt.preventDefault();
						}
	
						// Should we stop propagation to immediate listeners
						if (evt.isImmediatePropagationStopped()) {
							return;
						}
					}
				}
			}
	
			/**
			 * Binds a callback to an event on the specified target.
			 *
			 * @method bind
			 * @param {Object} target Target node/window or custom object.
			 * @param {String} names Name of the event to bind.
			 * @param {function} callback Callback function to execute when the event occurs.
			 * @param {Object} scope Scope to call the callback function on, defaults to target.
			 * @return {function} Callback function that got bound.
			 */
			self.bind = function(target, names, callback, scope) {
				var id, callbackList, i, name, fakeName, nativeHandler, capture, win = window;
	
				// Native event handler function patches the event and executes the callbacks for the expando
				function defaultNativeHandler(evt) {
					executeHandlers(fix(evt || win.event), id);
				}
	
				// Don't bind to text nodes or comments
				if (!target || target.nodeType === 3 || target.nodeType === 8) {
					return;
				}
	
				// Create or get events id for the target
				if (!target[expando]) {
					id = count++;
					target[expando] = id;
					events[id] = {};
				} else {
					id = target[expando];
				}
	
				// Setup the specified scope or use the target as a default
				scope = scope || target;
	
				// Split names and bind each event, enables you to bind multiple events with one call
				names = names.split(' ');
				i = names.length;
				while (i--) {
					name = names[i];
					nativeHandler = defaultNativeHandler;
					fakeName = capture = false;
	
					// Use ready instead of DOMContentLoaded
					if (name === "DOMContentLoaded") {
						name = "ready";
					}
	
					// DOM is already ready
					if (self.domLoaded && name === "ready" && target.readyState == 'complete') {
						callback.call(scope, fix({type: name}));
						continue;
					}
	
					// Handle mouseenter/mouseleaver
					if (!hasMouseEnterLeave) {
						fakeName = mouseEnterLeave[name];
	
						if (fakeName) {
							nativeHandler = function(evt) {
								var current, related;
	
								current = evt.currentTarget;
								related = evt.relatedTarget;
	
								// Check if related is inside the current target if it's not then the event should
								// be ignored since it's a mouseover/mouseout inside the element
								if (related && current.contains) {
									// Use contains for performance
									related = current.contains(related);
								} else {
									while (related && related !== current) {
										related = related.parentNode;
									}
								}
	
								// Fire fake event
								if (!related) {
									evt = fix(evt || win.event);
									evt.type = evt.type === 'mouseout' ? 'mouseleave' : 'mouseenter';
									evt.target = current;
									executeHandlers(evt, id);
								}
							};
						}
					}
	
					// Fake bubbling of focusin/focusout
					if (!hasFocusIn && (name === "focusin" || name === "focusout")) {
						capture = true;
						fakeName = name === "focusin" ? "focus" : "blur";
						nativeHandler = function(evt) {
							evt = fix(evt || win.event);
							evt.type = evt.type === 'focus' ? 'focusin' : 'focusout';
							executeHandlers(evt, id);
						};
					}
	
					// Setup callback list and bind native event
					callbackList = events[id][name];
					if (!callbackList) {
						events[id][name] = callbackList = [{func: callback, scope: scope}];
						callbackList.fakeName = fakeName;
						callbackList.capture = capture;
						//callbackList.callback = callback;
	
						// Add the nativeHandler to the callback list so that we can later unbind it
						callbackList.nativeHandler = nativeHandler;
	
						// Check if the target has native events support
	
						if (name === "ready") {
							bindOnReady(target, nativeHandler, self);
						} else {
							addEvent(target, fakeName || name, nativeHandler, capture);
						}
					} else {
						if (name === "ready" && self.domLoaded) {
							callback({type: name});
						} else {
							// If it already has an native handler then just push the callback
							callbackList.push({func: callback, scope: scope});
						}
					}
				}
	
				target = callbackList = 0; // Clean memory for IE
	
				return callback;
			};
	
			/**
			 * Unbinds the specified event by name, name and callback or all events on the target.
			 *
			 * @method unbind
			 * @param {Object} target Target node/window or custom object.
			 * @param {String} names Optional event name to unbind.
			 * @param {function} callback Optional callback function to unbind.
			 * @return {EventUtils} Event utils instance.
			 */
			self.unbind = function(target, names, callback) {
				var id, callbackList, i, ci, name, eventMap;
	
				// Don't bind to text nodes or comments
				if (!target || target.nodeType === 3 || target.nodeType === 8) {
					return self;
				}
	
				// Unbind event or events if the target has the expando
				id = target[expando];
				if (id) {
					eventMap = events[id];
	
					// Specific callback
					if (names) {
						names = names.split(' ');
						i = names.length;
						while (i--) {
							name = names[i];
							callbackList = eventMap[name];
	
							// Unbind the event if it exists in the map
							if (callbackList) {
								// Remove specified callback
								if (callback) {
									ci = callbackList.length;
									while (ci--) {
										if (callbackList[ci].func === callback) {
											var nativeHandler = callbackList.nativeHandler;
											var fakeName = callbackList.fakeName, capture = callbackList.capture;
	
											// Clone callbackList since unbind inside a callback would otherwise break the handlers loop
											callbackList = callbackList.slice(0, ci).concat(callbackList.slice(ci + 1));
											callbackList.nativeHandler = nativeHandler;
											callbackList.fakeName = fakeName;
											callbackList.capture = capture;
	
											eventMap[name] = callbackList;
										}
									}
								}
	
								// Remove all callbacks if there isn't a specified callback or there is no callbacks left
								if (!callback || callbackList.length === 0) {
									delete eventMap[name];
									removeEvent(target, callbackList.fakeName || name, callbackList.nativeHandler, callbackList.capture);
								}
							}
						}
					} else {
						// All events for a specific element
						for (name in eventMap) {
							callbackList = eventMap[name];
							removeEvent(target, callbackList.fakeName || name, callbackList.nativeHandler, callbackList.capture);
						}
	
						eventMap = {};
					}
	
					// Check if object is empty, if it isn't then we won't remove the expando map
					for (name in eventMap) {
						return self;
					}
	
					// Delete event object
					delete events[id];
	
					// Remove expando from target
					try {
						// IE will fail here since it can't delete properties from window
						delete target[expando];
					} catch (ex) {
						// IE will set it to null
						target[expando] = null;
					}
				}
	
				return self;
			};
	
			/**
			 * Fires the specified event on the specified target.
			 *
			 * @method fire
			 * @param {Object} target Target node/window or custom object.
			 * @param {String} name Event name to fire.
			 * @param {Object} args Optional arguments to send to the observers.
			 * @return {EventUtils} Event utils instance.
			 */
			self.fire = function(target, name, args) {
				var id;
	
				// Don't bind to text nodes or comments
				if (!target || target.nodeType === 3 || target.nodeType === 8) {
					return self;
				}
	
				// Build event object by patching the args
				args = fix(null, args);
				args.type = name;
				args.target = target;
	
				do {
					// Found an expando that means there is listeners to execute
					id = target[expando];
					if (id) {
						executeHandlers(args, id);
					}
	
					// Walk up the DOM
					target = target.parentNode || target.ownerDocument || target.defaultView || target.parentWindow;
				} while (target && !args.isPropagationStopped());
	
				return self;
			};
	
			/**
			 * Removes all bound event listeners for the specified target. This will also remove any bound
			 * listeners to child nodes within that target.
			 *
			 * @method clean
			 * @param {Object} target Target node/window object.
			 * @return {EventUtils} Event utils instance.
			 */
			self.clean = function(target) {
				var i, children, unbind = self.unbind;
	
				// Don't bind to text nodes or comments
				if (!target || target.nodeType === 3 || target.nodeType === 8) {
					return self;
				}
	
				// Unbind any element on the specified target
				if (target[expando]) {
					unbind(target);
				}
	
				// Target doesn't have getElementsByTagName it's probably a window object then use it's document to find the children
				if (!target.getElementsByTagName) {
					target = target.document;
				}
	
				// Remove events from each child element
				if (target && target.getElementsByTagName) {
					unbind(target);
	
					children = target.getElementsByTagName('*');
					i = children.length;
					while (i--) {
						target = children[i];
	
						if (target[expando]) {
							unbind(target);
						}
					}
				}
	
				return self;
			};
	
			/**
			 * Destroys the event object. Call this on IE to remove memory leaks.
			 */
			self.destroy = function() {
				events = {};
			};
	
			// Legacy function for canceling events
			self.cancel = function(e) {
				if (e) {
					e.preventDefault();
					e.stopImmediatePropagation();
				}
	
				return false;
			};
		}
	
		EventUtils.Event = new EventUtils();
		EventUtils.Event.bind(window, 'ready', function() {});
	
		return EventUtils;
	});
	
	// Included from: js/tinymce/classes/dom/Sizzle.js
	
	/**
	 * Sizzle.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 *
	 * @ignore-file
	 */
	
	/*jshint bitwise:false, expr:true, noempty:false, sub:true, eqnull:true, latedef:false, maxlen:255 */
	/*eslint-disable */
	
	/**
	 * Sizzle CSS Selector Engine v@VERSION
	 * http://sizzlejs.com/
	 *
	 * Copyright 2008, 2014 jQuery Foundation, Inc. and other contributors
	 * Released under the MIT license
	 * http://jquery.org/license
	 *
	 * Date: @DATE
	 */
	define("tinymce/dom/Sizzle", [], function() {
	var i,
		support,
		Expr,
		getText,
		isXML,
		tokenize,
		compile,
		select,
		outermostContext,
		sortInput,
		hasDuplicate,
	
		// Local document vars
		setDocument,
		document,
		docElem,
		documentIsHTML,
		rbuggyQSA,
		rbuggyMatches,
		matches,
		contains,
	
		// Instance-specific data
		expando = "sizzle" + -(new Date()),
		preferredDoc = window.document,
		dirruns = 0,
		done = 0,
		classCache = createCache(),
		tokenCache = createCache(),
		compilerCache = createCache(),
		sortOrder = function( a, b ) {
			if ( a === b ) {
				hasDuplicate = true;
			}
			return 0;
		},
	
		// General-purpose constants
		strundefined = typeof undefined,
		MAX_NEGATIVE = 1 << 31,
	
		// Instance methods
		hasOwn = ({}).hasOwnProperty,
		arr = [],
		pop = arr.pop,
		push_native = arr.push,
		push = arr.push,
		slice = arr.slice,
		// Use a stripped-down indexOf if we can't use a native one
		indexOf = arr.indexOf || function( elem ) {
			var i = 0,
				len = this.length;
			for ( ; i < len; i++ ) {
				if ( this[i] === elem ) {
					return i;
				}
			}
			return -1;
		},
	
		booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
	
		// Regular expressions
	
		// http://www.w3.org/TR/css3-selectors/#whitespace
		whitespace = "[\\x20\\t\\r\\n\\f]",
	
		// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
		identifier = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",
	
		// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
		attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
			// Operator (capture 2)
			"*([*^$|!~]?=)" + whitespace +
			// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
			"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
			"*\\]",
	
		pseudos = ":(" + identifier + ")(?:\\((" +
			// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
			// 1. quoted (capture 3; capture 4 or capture 5)
			"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
			// 2. simple (capture 6)
			"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
			// 3. anything else (capture 2)
			".*" +
			")\\)|)",
	
		// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
		rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),
	
		rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
		rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),
	
		rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),
	
		rpseudo = new RegExp( pseudos ),
		ridentifier = new RegExp( "^" + identifier + "$" ),
	
		matchExpr = {
			"ID": new RegExp( "^#(" + identifier + ")" ),
			"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
			"TAG": new RegExp( "^(" + identifier + "|[*])" ),
			"ATTR": new RegExp( "^" + attributes ),
			"PSEUDO": new RegExp( "^" + pseudos ),
			"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
				"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
				"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
			"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
			// For use in libraries implementing .is()
			// We use this for POS matching in `select`
			"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
				whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
		},
	
		rinputs = /^(?:input|select|textarea|button)$/i,
		rheader = /^h\d$/i,
	
		rnative = /^[^{]+\{\s*\[native \w/,
	
		// Easily-parseable/retrievable ID or TAG or CLASS selectors
		rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
	
		rsibling = /[+~]/,
		rescape = /'|\\/g,
	
		// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
		runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
		funescape = function( _, escaped, escapedWhitespace ) {
			var high = "0x" + escaped - 0x10000;
			// NaN means non-codepoint
			// Support: Firefox<24
			// Workaround erroneous numeric interpretation of +"0x"
			return high !== high || escapedWhitespace ?
				escaped :
				high < 0 ?
					// BMP codepoint
					String.fromCharCode( high + 0x10000 ) :
					// Supplemental Plane codepoint (surrogate pair)
					String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
		};
	
	// Optimize for push.apply( _, NodeList )
	try {
		push.apply(
			(arr = slice.call( preferredDoc.childNodes )),
			preferredDoc.childNodes
		);
		// Support: Android<4.0
		// Detect silently failing push.apply
		arr[ preferredDoc.childNodes.length ].nodeType;
	} catch ( e ) {
		push = { apply: arr.length ?
	
			// Leverage slice if possible
			function( target, els ) {
				push_native.apply( target, slice.call(els) );
			} :
	
			// Support: IE<9
			// Otherwise append directly
			function( target, els ) {
				var j = target.length,
					i = 0;
				// Can't trust NodeList.length
				while ( (target[j++] = els[i++]) ) {}
				target.length = j - 1;
			}
		};
	}
	
	function Sizzle( selector, context, results, seed ) {
		var match, elem, m, nodeType,
			// QSA vars
			i, groups, old, nid, newContext, newSelector;
	
		if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
			setDocument( context );
		}
	
		context = context || document;
		results = results || [];
	
		if ( !selector || typeof selector !== "string" ) {
			return results;
		}
	
		if ( (nodeType = context.nodeType) !== 1 && nodeType !== 9 ) {
			return [];
		}
	
		if ( documentIsHTML && !seed ) {
	
			// Shortcuts
			if ( (match = rquickExpr.exec( selector )) ) {
				// Speed-up: Sizzle("#ID")
				if ( (m = match[1]) ) {
					if ( nodeType === 9 ) {
						elem = context.getElementById( m );
						// Check parentNode to catch when Blackberry 4.6 returns
						// nodes that are no longer in the document (jQuery #6963)
						if ( elem && elem.parentNode ) {
							// Handle the case where IE, Opera, and Webkit return items
							// by name instead of ID
							if ( elem.id === m ) {
								results.push( elem );
								return results;
							}
						} else {
							return results;
						}
					} else {
						// Context is not a document
						if ( context.ownerDocument && (elem = context.ownerDocument.getElementById( m )) &&
							contains( context, elem ) && elem.id === m ) {
							results.push( elem );
							return results;
						}
					}
	
				// Speed-up: Sizzle("TAG")
				} else if ( match[2] ) {
					push.apply( results, context.getElementsByTagName( selector ) );
					return results;
	
				// Speed-up: Sizzle(".CLASS")
				} else if ( (m = match[3]) && support.getElementsByClassName ) {
					push.apply( results, context.getElementsByClassName( m ) );
					return results;
				}
			}
	
			// QSA path
			if ( support.qsa && (!rbuggyQSA || !rbuggyQSA.test( selector )) ) {
				nid = old = expando;
				newContext = context;
				newSelector = nodeType === 9 && selector;
	
				// qSA works strangely on Element-rooted queries
				// We can work around this by specifying an extra ID on the root
				// and working up from there (Thanks to Andrew Dupont for the technique)
				// IE 8 doesn't work on object elements
				if ( nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
					groups = tokenize( selector );
	
					if ( (old = context.getAttribute("id")) ) {
						nid = old.replace( rescape, "\\$&" );
					} else {
						context.setAttribute( "id", nid );
					}
					nid = "[id='" + nid + "'] ";
	
					i = groups.length;
					while ( i-- ) {
						groups[i] = nid + toSelector( groups[i] );
					}
					newContext = rsibling.test( selector ) && testContext( context.parentNode ) || context;
					newSelector = groups.join(",");
				}
	
				if ( newSelector ) {
					try {
						push.apply( results,
							newContext.querySelectorAll( newSelector )
						);
						return results;
					} catch(qsaError) {
					} finally {
						if ( !old ) {
							context.removeAttribute("id");
						}
					}
				}
			}
		}
	
		// All others
		return select( selector.replace( rtrim, "$1" ), context, results, seed );
	}
	
	/**
	 * Create key-value caches of limited size
	 * @returns {Function(string, Object)} Returns the Object data after storing it on itself with
	 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
	 *	deleting the oldest entry
	 */
	function createCache() {
		var keys = [];
	
		function cache( key, value ) {
			// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
			if ( keys.push( key + " " ) > Expr.cacheLength ) {
				// Only keep the most recent entries
				delete cache[ keys.shift() ];
			}
			return (cache[ key + " " ] = value);
		}
		return cache;
	}
	
	/**
	 * Mark a function for special use by Sizzle
	 * @param {Function} fn The function to mark
	 */
	function markFunction( fn ) {
		fn[ expando ] = true;
		return fn;
	}
	
	/**
	 * Support testing using an element
	 * @param {Function} fn Passed the created div and expects a boolean result
	 */
	function assert( fn ) {
		var div = document.createElement("div");
	
		try {
			return !!fn( div );
		} catch (e) {
			return false;
		} finally {
			// Remove from its parent by default
			if ( div.parentNode ) {
				div.parentNode.removeChild( div );
			}
			// release memory in IE
			div = null;
		}
	}
	
	/**
	 * Adds the same handler for all of the specified attrs
	 * @param {String} attrs Pipe-separated list of attributes
	 * @param {Function} handler The method that will be applied
	 */
	function addHandle( attrs, handler ) {
		var arr = attrs.split("|"),
			i = attrs.length;
	
		while ( i-- ) {
			Expr.attrHandle[ arr[i] ] = handler;
		}
	}
	
	/**
	 * Checks document order of two siblings
	 * @param {Element} a
	 * @param {Element} b
	 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
	 */
	function siblingCheck( a, b ) {
		var cur = b && a,
			diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
				( ~b.sourceIndex || MAX_NEGATIVE ) -
				( ~a.sourceIndex || MAX_NEGATIVE );
	
		// Use IE sourceIndex if available on both nodes
		if ( diff ) {
			return diff;
		}
	
		// Check if b follows a
		if ( cur ) {
			while ( (cur = cur.nextSibling) ) {
				if ( cur === b ) {
					return -1;
				}
			}
		}
	
		return a ? 1 : -1;
	}
	
	/**
	 * Returns a function to use in pseudos for input types
	 * @param {String} type
	 */
	function createInputPseudo( type ) {
		return function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === type;
		};
	}
	
	/**
	 * Returns a function to use in pseudos for buttons
	 * @param {String} type
	 */
	function createButtonPseudo( type ) {
		return function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return (name === "input" || name === "button") && elem.type === type;
		};
	}
	
	/**
	 * Returns a function to use in pseudos for positionals
	 * @param {Function} fn
	 */
	function createPositionalPseudo( fn ) {
		return markFunction(function( argument ) {
			argument = +argument;
			return markFunction(function( seed, matches ) {
				var j,
					matchIndexes = fn( [], seed.length, argument ),
					i = matchIndexes.length;
	
				// Match elements found at the specified indexes
				while ( i-- ) {
					if ( seed[ (j = matchIndexes[i]) ] ) {
						seed[j] = !(matches[j] = seed[j]);
					}
				}
			});
		});
	}
	
	/**
	 * Checks a node for validity as a Sizzle context
	 * @param {Element|Object=} context
	 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
	 */
	function testContext( context ) {
		return context && typeof context.getElementsByTagName !== strundefined && context;
	}
	
	// Expose support vars for convenience
	support = Sizzle.support = {};
	
	/**
	 * Detects XML nodes
	 * @param {Element|Object} elem An element or a document
	 * @returns {Boolean} True iff elem is a non-HTML XML node
	 */
	isXML = Sizzle.isXML = function( elem ) {
		// documentElement is verified for cases where it doesn't yet exist
		// (such as loading iframes in IE - #4833)
		var documentElement = elem && (elem.ownerDocument || elem).documentElement;
		return documentElement ? documentElement.nodeName !== "HTML" : false;
	};
	
	/**
	 * Sets document-related variables once based on the current document
	 * @param {Element|Object} [doc] An element or document object to use to set the document
	 * @returns {Object} Returns the current document
	 */
	setDocument = Sizzle.setDocument = function( node ) {
		var hasCompare,
			doc = node ? node.ownerDocument || node : preferredDoc,
			parent = doc.defaultView;
	
		function getTop(win) {
			// Edge throws a lovely Object expected if you try to get top on a detached reference see #2642
			try {
				return win.top;
			} catch (ex) {
				// Ignore
			}
	
			return null;
		}
	
		// If no document and documentElement is available, return
		if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
			return document;
		}
	
		// Set our document
		document = doc;
		docElem = doc.documentElement;
	
		// Support tests
		documentIsHTML = !isXML( doc );
	
		// Support: IE>8
		// If iframe document is assigned to "document" variable and if iframe has been reloaded,
		// IE will throw "permission denied" error when accessing "document" variable, see jQuery #13936
		// IE6-8 do not support the defaultView property so parent will be undefined
		if ( parent && parent !== getTop(parent) ) {
			// IE11 does not have attachEvent, so all must suffer
			if ( parent.addEventListener ) {
				parent.addEventListener( "unload", function() {
					setDocument();
				}, false );
			} else if ( parent.attachEvent ) {
				parent.attachEvent( "onunload", function() {
					setDocument();
				});
			}
		}
	
		/* Attributes
		---------------------------------------------------------------------- */
	
		// Support: IE<8
		// Verify that getAttribute really returns attributes and not properties (excepting IE8 booleans)
		support.attributes = assert(function( div ) {
			div.className = "i";
			return !div.getAttribute("className");
		});
	
		/* getElement(s)By*
		---------------------------------------------------------------------- */
	
		// Check if getElementsByTagName("*") returns only elements
		support.getElementsByTagName = assert(function( div ) {
			div.appendChild( doc.createComment("") );
			return !div.getElementsByTagName("*").length;
		});
	
		// Support: IE<9
		support.getElementsByClassName = rnative.test( doc.getElementsByClassName );
	
		// Support: IE<10
		// Check if getElementById returns elements by name
		// The broken getElementById methods don't pick up programatically-set names,
		// so use a roundabout getElementsByName test
		support.getById = assert(function( div ) {
			docElem.appendChild( div ).id = expando;
			return !doc.getElementsByName || !doc.getElementsByName( expando ).length;
		});
	
		// ID find and filter
		if ( support.getById ) {
			Expr.find["ID"] = function( id, context ) {
				if ( typeof context.getElementById !== strundefined && documentIsHTML ) {
					var m = context.getElementById( id );
					// Check parentNode to catch when Blackberry 4.6 returns
					// nodes that are no longer in the document #6963
					return m && m.parentNode ? [ m ] : [];
				}
			};
			Expr.filter["ID"] = function( id ) {
				var attrId = id.replace( runescape, funescape );
				return function( elem ) {
					return elem.getAttribute("id") === attrId;
				};
			};
		} else {
			// Support: IE6/7
			// getElementById is not reliable as a find shortcut
			delete Expr.find["ID"];
	
			Expr.filter["ID"] =  function( id ) {
				var attrId = id.replace( runescape, funescape );
				return function( elem ) {
					var node = typeof elem.getAttributeNode !== strundefined && elem.getAttributeNode("id");
					return node && node.value === attrId;
				};
			};
		}
	
		// Tag
		Expr.find["TAG"] = support.getElementsByTagName ?
			function( tag, context ) {
				if ( typeof context.getElementsByTagName !== strundefined ) {
					return context.getElementsByTagName( tag );
				}
			} :
			function( tag, context ) {
				var elem,
					tmp = [],
					i = 0,
					results = context.getElementsByTagName( tag );
	
				// Filter out possible comments
				if ( tag === "*" ) {
					while ( (elem = results[i++]) ) {
						if ( elem.nodeType === 1 ) {
							tmp.push( elem );
						}
					}
	
					return tmp;
				}
				return results;
			};
	
		// Class
		Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
			if ( documentIsHTML ) {
				return context.getElementsByClassName( className );
			}
		};
	
		/* QSA/matchesSelector
		---------------------------------------------------------------------- */
	
		// QSA and matchesSelector support
	
		// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
		rbuggyMatches = [];
	
		// qSa(:focus) reports false when true (Chrome 21)
		// We allow this because of a bug in IE8/9 that throws an error
		// whenever `document.activeElement` is accessed on an iframe
		// So, we allow :focus to pass through QSA all the time to avoid the IE error
		// See http://bugs.jquery.com/ticket/13378
		rbuggyQSA = [];
	
		if ( (support.qsa = rnative.test( doc.querySelectorAll )) ) {
			// Build QSA regex
			// Regex strategy adopted from Diego Perini
			assert(function( div ) {
				// Select is set to empty string on purpose
				// This is to test IE's treatment of not explicitly
				// setting a boolean content attribute,
				// since its presence should be enough
				// http://bugs.jquery.com/ticket/12359
				div.innerHTML = "<select msallowcapture=''><option selected=''></option></select>";
	
				// Support: IE8, Opera 11-12.16
				// Nothing should be selected when empty strings follow ^= or $= or *=
				// The test attribute must be unknown in Opera but "safe" for WinRT
				// http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
				if ( div.querySelectorAll("[msallowcapture^='']").length ) {
					rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
				}
	
				// Support: IE8
				// Boolean attributes and "value" are not treated correctly
				if ( !div.querySelectorAll("[selected]").length ) {
					rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
				}
	
				// Webkit/Opera - :checked should return selected option elements
				// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
				// IE8 throws error here and will not see later tests
				if ( !div.querySelectorAll(":checked").length ) {
					rbuggyQSA.push(":checked");
				}
			});
	
			assert(function( div ) {
				// Support: Windows 8 Native Apps
				// The type and name attributes are restricted during .innerHTML assignment
				var input = doc.createElement("input");
				input.setAttribute( "type", "hidden" );
				div.appendChild( input ).setAttribute( "name", "D" );
	
				// Support: IE8
				// Enforce case-sensitivity of name attribute
				if ( div.querySelectorAll("[name=d]").length ) {
					rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
				}
	
				// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
				// IE8 throws error here and will not see later tests
				if ( !div.querySelectorAll(":enabled").length ) {
					rbuggyQSA.push( ":enabled", ":disabled" );
				}
	
				// Opera 10-11 does not throw on post-comma invalid pseudos
				div.querySelectorAll("*,:x");
				rbuggyQSA.push(",.*:");
			});
		}
	
		if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
			docElem.webkitMatchesSelector ||
			docElem.mozMatchesSelector ||
			docElem.oMatchesSelector ||
			docElem.msMatchesSelector) )) ) {
	
			assert(function( div ) {
				// Check to see if it's possible to do matchesSelector
				// on a disconnected node (IE 9)
				support.disconnectedMatch = matches.call( div, "div" );
	
				// This should fail with an exception
				// Gecko does not error, returns false instead
				matches.call( div, "[s!='']:x" );
				rbuggyMatches.push( "!=", pseudos );
			});
		}
	
		rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
		rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );
	
		/* Contains
		---------------------------------------------------------------------- */
		hasCompare = rnative.test( docElem.compareDocumentPosition );
	
		// Element contains another
		// Purposefully does not implement inclusive descendent
		// As in, an element does not contain itself
		contains = hasCompare || rnative.test( docElem.contains ) ?
			function( a, b ) {
				var adown = a.nodeType === 9 ? a.documentElement : a,
					bup = b && b.parentNode;
				return a === bup || !!( bup && bup.nodeType === 1 && (
					adown.contains ?
						adown.contains( bup ) :
						a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
				));
			} :
			function( a, b ) {
				if ( b ) {
					while ( (b = b.parentNode) ) {
						if ( b === a ) {
							return true;
						}
					}
				}
				return false;
			};
	
		/* Sorting
		---------------------------------------------------------------------- */
	
		// Document order sorting
		sortOrder = hasCompare ?
		function( a, b ) {
	
			// Flag for duplicate removal
			if ( a === b ) {
				hasDuplicate = true;
				return 0;
			}
	
			// Sort on method existence if only one input has compareDocumentPosition
			var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
			if ( compare ) {
				return compare;
			}
	
			// Calculate position if both inputs belong to the same document
			compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
				a.compareDocumentPosition( b ) :
	
				// Otherwise we know they are disconnected
				1;
	
			// Disconnected nodes
			if ( compare & 1 ||
				(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {
	
				// Choose the first element that is related to our preferred document
				if ( a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
					return -1;
				}
				if ( b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
					return 1;
				}
	
				// Maintain original order
				return sortInput ?
					( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :
					0;
			}
	
			return compare & 4 ? -1 : 1;
		} :
		function( a, b ) {
			// Exit early if the nodes are identical
			if ( a === b ) {
				hasDuplicate = true;
				return 0;
			}
	
			var cur,
				i = 0,
				aup = a.parentNode,
				bup = b.parentNode,
				ap = [ a ],
				bp = [ b ];
	
			// Parentless nodes are either documents or disconnected
			if ( !aup || !bup ) {
				return a === doc ? -1 :
					b === doc ? 1 :
					aup ? -1 :
					bup ? 1 :
					sortInput ?
					( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :
					0;
	
			// If the nodes are siblings, we can do a quick check
			} else if ( aup === bup ) {
				return siblingCheck( a, b );
			}
	
			// Otherwise we need full lists of their ancestors for comparison
			cur = a;
			while ( (cur = cur.parentNode) ) {
				ap.unshift( cur );
			}
			cur = b;
			while ( (cur = cur.parentNode) ) {
				bp.unshift( cur );
			}
	
			// Walk down the tree looking for a discrepancy
			while ( ap[i] === bp[i] ) {
				i++;
			}
	
			return i ?
				// Do a sibling check if the nodes have a common ancestor
				siblingCheck( ap[i], bp[i] ) :
	
				// Otherwise nodes in our document sort first
				ap[i] === preferredDoc ? -1 :
				bp[i] === preferredDoc ? 1 :
				0;
		};
	
		return doc;
	};
	
	Sizzle.matches = function( expr, elements ) {
		return Sizzle( expr, null, null, elements );
	};
	
	Sizzle.matchesSelector = function( elem, expr ) {
		// Set document vars if needed
		if ( ( elem.ownerDocument || elem ) !== document ) {
			setDocument( elem );
		}
	
		// Make sure that attribute selectors are quoted
		expr = expr.replace( rattributeQuotes, "='$1']" );
	
		if ( support.matchesSelector && documentIsHTML &&
			( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
			( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {
	
			try {
				var ret = matches.call( elem, expr );
	
				// IE 9's matchesSelector returns false on disconnected nodes
				if ( ret || support.disconnectedMatch ||
						// As well, disconnected nodes are said to be in a document
						// fragment in IE 9
						elem.document && elem.document.nodeType !== 11 ) {
					return ret;
				}
			} catch(e) {}
		}
	
		return Sizzle( expr, document, null, [ elem ] ).length > 0;
	};
	
	Sizzle.contains = function( context, elem ) {
		// Set document vars if needed
		if ( ( context.ownerDocument || context ) !== document ) {
			setDocument( context );
		}
		return contains( context, elem );
	};
	
	Sizzle.attr = function( elem, name ) {
		// Set document vars if needed
		if ( ( elem.ownerDocument || elem ) !== document ) {
			setDocument( elem );
		}
	
		var fn = Expr.attrHandle[ name.toLowerCase() ],
			// Don't get fooled by Object.prototype properties (jQuery #13807)
			val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
				fn( elem, name, !documentIsHTML ) :
				undefined;
	
		return val !== undefined ?
			val :
			support.attributes || !documentIsHTML ?
				elem.getAttribute( name ) :
				(val = elem.getAttributeNode(name)) && val.specified ?
					val.value :
					null;
	};
	
	Sizzle.error = function( msg ) {
		throw new Error( "Syntax error, unrecognized expression: " + msg );
	};
	
	/**
	 * Document sorting and removing duplicates
	 * @param {ArrayLike} results
	 */
	Sizzle.uniqueSort = function( results ) {
		var elem,
			duplicates = [],
			j = 0,
			i = 0;
	
		// Unless we *know* we can detect duplicates, assume their presence
		hasDuplicate = !support.detectDuplicates;
		sortInput = !support.sortStable && results.slice( 0 );
		results.sort( sortOrder );
	
		if ( hasDuplicate ) {
			while ( (elem = results[i++]) ) {
				if ( elem === results[ i ] ) {
					j = duplicates.push( i );
				}
			}
			while ( j-- ) {
				results.splice( duplicates[ j ], 1 );
			}
		}
	
		// Clear input after sorting to release objects
		// See https://github.com/jquery/sizzle/pull/225
		sortInput = null;
	
		return results;
	};
	
	/**
	 * Utility function for retrieving the text value of an array of DOM nodes
	 * @param {Array|Element} elem
	 */
	getText = Sizzle.getText = function( elem ) {
		var node,
			ret = "",
			i = 0,
			nodeType = elem.nodeType;
	
		if ( !nodeType ) {
			// If no nodeType, this is expected to be an array
			while ( (node = elem[i++]) ) {
				// Do not traverse comment nodes
				ret += getText( node );
			}
		} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
			// Use textContent for elements
			// innerText usage removed for consistency of new lines (jQuery #11153)
			if ( typeof elem.textContent === "string" ) {
				return elem.textContent;
			} else {
				// Traverse its children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
					ret += getText( elem );
				}
			}
		} else if ( nodeType === 3 || nodeType === 4 ) {
			return elem.nodeValue;
		}
		// Do not include comment or processing instruction nodes
	
		return ret;
	};
	
	Expr = Sizzle.selectors = {
	
		// Can be adjusted by the user
		cacheLength: 50,
	
		createPseudo: markFunction,
	
		match: matchExpr,
	
		attrHandle: {},
	
		find: {},
	
		relative: {
			">": { dir: "parentNode", first: true },
			" ": { dir: "parentNode" },
			"+": { dir: "previousSibling", first: true },
			"~": { dir: "previousSibling" }
		},
	
		preFilter: {
			"ATTR": function( match ) {
				match[1] = match[1].replace( runescape, funescape );
	
				// Move the given value to match[3] whether quoted or unquoted
				match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );
	
				if ( match[2] === "~=" ) {
					match[3] = " " + match[3] + " ";
				}
	
				return match.slice( 0, 4 );
			},
	
			"CHILD": function( match ) {
				/* matches from matchExpr["CHILD"]
					1 type (only|nth|...)
					2 what (child|of-type)
					3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
					4 xn-component of xn+y argument ([+-]?\d*n|)
					5 sign of xn-component
					6 x of xn-component
					7 sign of y-component
					8 y of y-component
				*/
				match[1] = match[1].toLowerCase();
	
				if ( match[1].slice( 0, 3 ) === "nth" ) {
					// nth-* requires argument
					if ( !match[3] ) {
						Sizzle.error( match[0] );
					}
	
					// numeric x and y parameters for Expr.filter.CHILD
					// remember that false/true cast respectively to 0/1
					match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
					match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );
	
				// other types prohibit arguments
				} else if ( match[3] ) {
					Sizzle.error( match[0] );
				}
	
				return match;
			},
	
			"PSEUDO": function( match ) {
				var excess,
					unquoted = !match[6] && match[2];
	
				if ( matchExpr["CHILD"].test( match[0] ) ) {
					return null;
				}
	
				// Accept quoted arguments as-is
				if ( match[3] ) {
					match[2] = match[4] || match[5] || "";
	
				// Strip excess characters from unquoted arguments
				} else if ( unquoted && rpseudo.test( unquoted ) &&
					// Get excess from tokenize (recursively)
					(excess = tokenize( unquoted, true )) &&
					// advance to the next closing parenthesis
					(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {
	
					// excess is a negative index
					match[0] = match[0].slice( 0, excess );
					match[2] = unquoted.slice( 0, excess );
				}
	
				// Return only captures needed by the pseudo filter method (type and argument)
				return match.slice( 0, 3 );
			}
		},
	
		filter: {
	
			"TAG": function( nodeNameSelector ) {
				var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
				return nodeNameSelector === "*" ?
					function() { return true; } :
					function( elem ) {
						return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
					};
			},
	
			"CLASS": function( className ) {
				var pattern = classCache[ className + " " ];
	
				return pattern ||
					(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
					classCache( className, function( elem ) {
						return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== strundefined && elem.getAttribute("class") || "" );
					});
			},
	
			"ATTR": function( name, operator, check ) {
				return function( elem ) {
					var result = Sizzle.attr( elem, name );
	
					if ( result == null ) {
						return operator === "!=";
					}
					if ( !operator ) {
						return true;
					}
	
					result += "";
	
					return operator === "=" ? result === check :
						operator === "!=" ? result !== check :
						operator === "^=" ? check && result.indexOf( check ) === 0 :
						operator === "*=" ? check && result.indexOf( check ) > -1 :
						operator === "$=" ? check && result.slice( -check.length ) === check :
						operator === "~=" ? ( " " + result + " " ).indexOf( check ) > -1 :
						operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
						false;
				};
			},
	
			"CHILD": function( type, what, argument, first, last ) {
				var simple = type.slice( 0, 3 ) !== "nth",
					forward = type.slice( -4 ) !== "last",
					ofType = what === "of-type";
	
				return first === 1 && last === 0 ?
	
					// Shortcut for :nth-*(n)
					function( elem ) {
						return !!elem.parentNode;
					} :
	
					function( elem, context, xml ) {
						var cache, outerCache, node, diff, nodeIndex, start,
							dir = simple !== forward ? "nextSibling" : "previousSibling",
							parent = elem.parentNode,
							name = ofType && elem.nodeName.toLowerCase(),
							useCache = !xml && !ofType;
	
						if ( parent ) {
	
							// :(first|last|only)-(child|of-type)
							if ( simple ) {
								while ( dir ) {
									node = elem;
									while ( (node = node[ dir ]) ) {
										if ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) {
											return false;
										}
									}
									// Reverse direction for :only-* (if we haven't yet done so)
									start = dir = type === "only" && !start && "nextSibling";
								}
								return true;
							}
	
							start = [ forward ? parent.firstChild : parent.lastChild ];
	
							// non-xml :nth-child(...) stores cache data on `parent`
							if ( forward && useCache ) {
								// Seek `elem` from a previously-cached index
								outerCache = parent[ expando ] || (parent[ expando ] = {});
								cache = outerCache[ type ] || [];
								nodeIndex = cache[0] === dirruns && cache[1];
								diff = cache[0] === dirruns && cache[2];
								node = nodeIndex && parent.childNodes[ nodeIndex ];
	
								while ( (node = ++nodeIndex && node && node[ dir ] ||
	
									// Fallback to seeking `elem` from the start
									(diff = nodeIndex = 0) || start.pop()) ) {
	
									// When found, cache indexes on `parent` and break
									if ( node.nodeType === 1 && ++diff && node === elem ) {
										outerCache[ type ] = [ dirruns, nodeIndex, diff ];
										break;
									}
								}
	
							// Use previously-cached element index if available
							} else if ( useCache && (cache = (elem[ expando ] || (elem[ expando ] = {}))[ type ]) && cache[0] === dirruns ) {
								diff = cache[1];
	
							// xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)
							} else {
								// Use the same loop as above to seek `elem` from the start
								while ( (node = ++nodeIndex && node && node[ dir ] ||
									(diff = nodeIndex = 0) || start.pop()) ) {
	
									if ( ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) && ++diff ) {
										// Cache the index of each encountered element
										if ( useCache ) {
											(node[ expando ] || (node[ expando ] = {}))[ type ] = [ dirruns, diff ];
										}
	
										if ( node === elem ) {
											break;
										}
									}
								}
							}
	
							// Incorporate the offset, then check against cycle size
							diff -= last;
							return diff === first || ( diff % first === 0 && diff / first >= 0 );
						}
					};
			},
	
			"PSEUDO": function( pseudo, argument ) {
				// pseudo-class names are case-insensitive
				// http://www.w3.org/TR/selectors/#pseudo-classes
				// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
				// Remember that setFilters inherits from pseudos
				var args,
					fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
						Sizzle.error( "unsupported pseudo: " + pseudo );
	
				// The user may use createPseudo to indicate that
				// arguments are needed to create the filter function
				// just as Sizzle does
				if ( fn[ expando ] ) {
					return fn( argument );
				}
	
				// But maintain support for old signatures
				if ( fn.length > 1 ) {
					args = [ pseudo, pseudo, "", argument ];
					return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
						markFunction(function( seed, matches ) {
							var idx,
								matched = fn( seed, argument ),
								i = matched.length;
							while ( i-- ) {
								idx = indexOf.call( seed, matched[i] );
								seed[ idx ] = !( matches[ idx ] = matched[i] );
							}
						}) :
						function( elem ) {
							return fn( elem, 0, args );
						};
				}
	
				return fn;
			}
		},
	
		pseudos: {
			// Potentially complex pseudos
			"not": markFunction(function( selector ) {
				// Trim the selector passed to compile
				// to avoid treating leading and trailing
				// spaces as combinators
				var input = [],
					results = [],
					matcher = compile( selector.replace( rtrim, "$1" ) );
	
				return matcher[ expando ] ?
					markFunction(function( seed, matches, context, xml ) {
						var elem,
							unmatched = matcher( seed, null, xml, [] ),
							i = seed.length;
	
						// Match elements unmatched by `matcher`
						while ( i-- ) {
							if ( (elem = unmatched[i]) ) {
								seed[i] = !(matches[i] = elem);
							}
						}
					}) :
					function( elem, context, xml ) {
						input[0] = elem;
						matcher( input, null, xml, results );
						return !results.pop();
					};
			}),
	
			"has": markFunction(function( selector ) {
				return function( elem ) {
					return Sizzle( selector, elem ).length > 0;
				};
			}),
	
			"contains": markFunction(function( text ) {
				text = text.replace( runescape, funescape );
				return function( elem ) {
					return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
				};
			}),
	
			// "Whether an element is represented by a :lang() selector
			// is based solely on the element's language value
			// being equal to the identifier C,
			// or beginning with the identifier C immediately followed by "-".
			// The matching of C against the element's language value is performed case-insensitively.
			// The identifier C does not have to be a valid language name."
			// http://www.w3.org/TR/selectors/#lang-pseudo
			"lang": markFunction( function( lang ) {
				// lang value must be a valid identifier
				if ( !ridentifier.test(lang || "") ) {
					Sizzle.error( "unsupported lang: " + lang );
				}
				lang = lang.replace( runescape, funescape ).toLowerCase();
				return function( elem ) {
					var elemLang;
					do {
						if ( (elemLang = documentIsHTML ?
							elem.lang :
							elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {
	
							elemLang = elemLang.toLowerCase();
							return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
						}
					} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
					return false;
				};
			}),
	
			// Miscellaneous
			"target": function( elem ) {
				var hash = window.location && window.location.hash;
				return hash && hash.slice( 1 ) === elem.id;
			},
	
			"root": function( elem ) {
				return elem === docElem;
			},
	
			"focus": function( elem ) {
				return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
			},
	
			// Boolean properties
			"enabled": function( elem ) {
				return elem.disabled === false;
			},
	
			"disabled": function( elem ) {
				return elem.disabled === true;
			},
	
			"checked": function( elem ) {
				// In CSS3, :checked should return both checked and selected elements
				// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
				var nodeName = elem.nodeName.toLowerCase();
				return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
			},
	
			"selected": function( elem ) {
				// Accessing this property makes selected-by-default
				// options in Safari work properly
				if ( elem.parentNode ) {
					elem.parentNode.selectedIndex;
				}
	
				return elem.selected === true;
			},
	
			// Contents
			"empty": function( elem ) {
				// http://www.w3.org/TR/selectors/#empty-pseudo
				// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
				//   but not by others (comment: 8; processing instruction: 7; etc.)
				// nodeType < 6 works because attributes (2) do not appear as children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
					if ( elem.nodeType < 6 ) {
						return false;
					}
				}
				return true;
			},
	
			"parent": function( elem ) {
				return !Expr.pseudos["empty"]( elem );
			},
	
			// Element/input types
			"header": function( elem ) {
				return rheader.test( elem.nodeName );
			},
	
			"input": function( elem ) {
				return rinputs.test( elem.nodeName );
			},
	
			"button": function( elem ) {
				var name = elem.nodeName.toLowerCase();
				return name === "input" && elem.type === "button" || name === "button";
			},
	
			"text": function( elem ) {
				var attr;
				return elem.nodeName.toLowerCase() === "input" &&
					elem.type === "text" &&
	
					// Support: IE<8
					// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
					( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
			},
	
			// Position-in-collection
			"first": createPositionalPseudo(function() {
				return [ 0 ];
			}),
	
			"last": createPositionalPseudo(function( matchIndexes, length ) {
				return [ length - 1 ];
			}),
	
			"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
				return [ argument < 0 ? argument + length : argument ];
			}),
	
			"even": createPositionalPseudo(function( matchIndexes, length ) {
				var i = 0;
				for ( ; i < length; i += 2 ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),
	
			"odd": createPositionalPseudo(function( matchIndexes, length ) {
				var i = 1;
				for ( ; i < length; i += 2 ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),
	
			"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
				var i = argument < 0 ? argument + length : argument;
				for ( ; --i >= 0; ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),
	
			"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
				var i = argument < 0 ? argument + length : argument;
				for ( ; ++i < length; ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			})
		}
	};
	
	Expr.pseudos["nth"] = Expr.pseudos["eq"];
	
	// Add button/input type pseudos
	for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
		Expr.pseudos[ i ] = createInputPseudo( i );
	}
	for ( i in { submit: true, reset: true } ) {
		Expr.pseudos[ i ] = createButtonPseudo( i );
	}
	
	// Easy API for creating new setFilters
	function setFilters() {}
	setFilters.prototype = Expr.filters = Expr.pseudos;
	Expr.setFilters = new setFilters();
	
	tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
		var matched, match, tokens, type,
			soFar, groups, preFilters,
			cached = tokenCache[ selector + " " ];
	
		if ( cached ) {
			return parseOnly ? 0 : cached.slice( 0 );
		}
	
		soFar = selector;
		groups = [];
		preFilters = Expr.preFilter;
	
		while ( soFar ) {
	
			// Comma and first run
			if ( !matched || (match = rcomma.exec( soFar )) ) {
				if ( match ) {
					// Don't consume trailing commas as valid
					soFar = soFar.slice( match[0].length ) || soFar;
				}
				groups.push( (tokens = []) );
			}
	
			matched = false;
	
			// Combinators
			if ( (match = rcombinators.exec( soFar )) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					// Cast descendant combinators to space
					type: match[0].replace( rtrim, " " )
				});
				soFar = soFar.slice( matched.length );
			}
	
			// Filters
			for ( type in Expr.filter ) {
				if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
					(match = preFilters[ type ]( match ))) ) {
					matched = match.shift();
					tokens.push({
						value: matched,
						type: type,
						matches: match
					});
					soFar = soFar.slice( matched.length );
				}
			}
	
			if ( !matched ) {
				break;
			}
		}
	
		// Return the length of the invalid excess
		// if we're just parsing
		// Otherwise, throw an error or return tokens
		return parseOnly ?
			soFar.length :
			soFar ?
				Sizzle.error( selector ) :
				// Cache the tokens
				tokenCache( selector, groups ).slice( 0 );
	};
	
	function toSelector( tokens ) {
		var i = 0,
			len = tokens.length,
			selector = "";
		for ( ; i < len; i++ ) {
			selector += tokens[i].value;
		}
		return selector;
	}
	
	function addCombinator( matcher, combinator, base ) {
		var dir = combinator.dir,
			checkNonElements = base && dir === "parentNode",
			doneName = done++;
	
		return combinator.first ?
			// Check against closest ancestor/preceding element
			function( elem, context, xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						return matcher( elem, context, xml );
					}
				}
			} :
	
			// Check against all ancestor/preceding elements
			function( elem, context, xml ) {
				var oldCache, outerCache,
					newCache = [ dirruns, doneName ];
	
				// We can't set arbitrary data on XML nodes, so they don't benefit from dir caching
				if ( xml ) {
					while ( (elem = elem[ dir ]) ) {
						if ( elem.nodeType === 1 || checkNonElements ) {
							if ( matcher( elem, context, xml ) ) {
								return true;
							}
						}
					}
				} else {
					while ( (elem = elem[ dir ]) ) {
						if ( elem.nodeType === 1 || checkNonElements ) {
							outerCache = elem[ expando ] || (elem[ expando ] = {});
							if ( (oldCache = outerCache[ dir ]) &&
								oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {
	
								// Assign to newCache so results back-propagate to previous elements
								return (newCache[ 2 ] = oldCache[ 2 ]);
							} else {
								// Reuse newcache so results back-propagate to previous elements
								outerCache[ dir ] = newCache;
	
								// A match means we're done; a fail means we have to keep checking
								if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
									return true;
								}
							}
						}
					}
				}
			};
	}
	
	function elementMatcher( matchers ) {
		return matchers.length > 1 ?
			function( elem, context, xml ) {
				var i = matchers.length;
				while ( i-- ) {
					if ( !matchers[i]( elem, context, xml ) ) {
						return false;
					}
				}
				return true;
			} :
			matchers[0];
	}
	
	function multipleContexts( selector, contexts, results ) {
		var i = 0,
			len = contexts.length;
		for ( ; i < len; i++ ) {
			Sizzle( selector, contexts[i], results );
		}
		return results;
	}
	
	function condense( unmatched, map, filter, context, xml ) {
		var elem,
			newUnmatched = [],
			i = 0,
			len = unmatched.length,
			mapped = map != null;
	
		for ( ; i < len; i++ ) {
			if ( (elem = unmatched[i]) ) {
				if ( !filter || filter( elem, context, xml ) ) {
					newUnmatched.push( elem );
					if ( mapped ) {
						map.push( i );
					}
				}
			}
		}
	
		return newUnmatched;
	}
	
	function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
		if ( postFilter && !postFilter[ expando ] ) {
			postFilter = setMatcher( postFilter );
		}
		if ( postFinder && !postFinder[ expando ] ) {
			postFinder = setMatcher( postFinder, postSelector );
		}
		return markFunction(function( seed, results, context, xml ) {
			var temp, i, elem,
				preMap = [],
				postMap = [],
				preexisting = results.length,
	
				// Get initial elements from seed or context
				elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),
	
				// Prefilter to get matcher input, preserving a map for seed-results synchronization
				matcherIn = preFilter && ( seed || !selector ) ?
					condense( elems, preMap, preFilter, context, xml ) :
					elems,
	
				matcherOut = matcher ?
					// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
					postFinder || ( seed ? preFilter : preexisting || postFilter ) ?
	
						// ...intermediate processing is necessary
						[] :
	
						// ...otherwise use results directly
						results :
					matcherIn;
	
			// Find primary matches
			if ( matcher ) {
				matcher( matcherIn, matcherOut, context, xml );
			}
	
			// Apply postFilter
			if ( postFilter ) {
				temp = condense( matcherOut, postMap );
				postFilter( temp, [], context, xml );
	
				// Un-match failing elements by moving them back to matcherIn
				i = temp.length;
				while ( i-- ) {
					if ( (elem = temp[i]) ) {
						matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
					}
				}
			}
	
			if ( seed ) {
				if ( postFinder || preFilter ) {
					if ( postFinder ) {
						// Get the final matcherOut by condensing this intermediate into postFinder contexts
						temp = [];
						i = matcherOut.length;
						while ( i-- ) {
							if ( (elem = matcherOut[i]) ) {
								// Restore matcherIn since elem is not yet a final match
								temp.push( (matcherIn[i] = elem) );
							}
						}
						postFinder( null, (matcherOut = []), temp, xml );
					}
	
					// Move matched elements from seed to results to keep them synchronized
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) &&
							(temp = postFinder ? indexOf.call( seed, elem ) : preMap[i]) > -1 ) {
	
							seed[temp] = !(results[temp] = elem);
						}
					}
				}
	
			// Add elements to results, through postFinder if defined
			} else {
				matcherOut = condense(
					matcherOut === results ?
						matcherOut.splice( preexisting, matcherOut.length ) :
						matcherOut
				);
				if ( postFinder ) {
					postFinder( null, results, matcherOut, xml );
				} else {
					push.apply( results, matcherOut );
				}
			}
		});
	}
	
	function matcherFromTokens( tokens ) {
		var checkContext, matcher, j,
			len = tokens.length,
			leadingRelative = Expr.relative[ tokens[0].type ],
			implicitRelative = leadingRelative || Expr.relative[" "],
			i = leadingRelative ? 1 : 0,
	
			// The foundational matcher ensures that elements are reachable from top-level context(s)
			matchContext = addCombinator( function( elem ) {
				return elem === checkContext;
			}, implicitRelative, true ),
			matchAnyContext = addCombinator( function( elem ) {
				return indexOf.call( checkContext, elem ) > -1;
			}, implicitRelative, true ),
			matchers = [ function( elem, context, xml ) {
				return ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
					(checkContext = context).nodeType ?
						matchContext( elem, context, xml ) :
						matchAnyContext( elem, context, xml ) );
			} ];
	
		for ( ; i < len; i++ ) {
			if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
				matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
			} else {
				matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );
	
				// Return special upon seeing a positional matcher
				if ( matcher[ expando ] ) {
					// Find the next relative operator (if any) for proper handling
					j = ++i;
					for ( ; j < len; j++ ) {
						if ( Expr.relative[ tokens[j].type ] ) {
							break;
						}
					}
					return setMatcher(
						i > 1 && elementMatcher( matchers ),
						i > 1 && toSelector(
							// If the preceding token was a descendant combinator, insert an implicit any-element `*`
							tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
						).replace( rtrim, "$1" ),
						matcher,
						i < j && matcherFromTokens( tokens.slice( i, j ) ),
						j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
						j < len && toSelector( tokens )
					);
				}
				matchers.push( matcher );
			}
		}
	
		return elementMatcher( matchers );
	}
	
	function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
		var bySet = setMatchers.length > 0,
			byElement = elementMatchers.length > 0,
			superMatcher = function( seed, context, xml, results, outermost ) {
				var elem, j, matcher,
					matchedCount = 0,
					i = "0",
					unmatched = seed && [],
					setMatched = [],
					contextBackup = outermostContext,
					// We must always have either seed elements or outermost context
					elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
					// Use integer dirruns iff this is the outermost matcher
					dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
					len = elems.length;
	
				if ( outermost ) {
					outermostContext = context !== document && context;
				}
	
				// Add elements passing elementMatchers directly to results
				// Keep `i` a string if there are no elements so `matchedCount` will be "00" below
				// Support: IE<9, Safari
				// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
				for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
					if ( byElement && elem ) {
						j = 0;
						while ( (matcher = elementMatchers[j++]) ) {
							if ( matcher( elem, context, xml ) ) {
								results.push( elem );
								break;
							}
						}
						if ( outermost ) {
							dirruns = dirrunsUnique;
						}
					}
	
					// Track unmatched elements for set filters
					if ( bySet ) {
						// They will have gone through all possible matchers
						if ( (elem = !matcher && elem) ) {
							matchedCount--;
						}
	
						// Lengthen the array for every element, matched or not
						if ( seed ) {
							unmatched.push( elem );
						}
					}
				}
	
				// Apply set filters to unmatched elements
				matchedCount += i;
				if ( bySet && i !== matchedCount ) {
					j = 0;
					while ( (matcher = setMatchers[j++]) ) {
						matcher( unmatched, setMatched, context, xml );
					}
	
					if ( seed ) {
						// Reintegrate element matches to eliminate the need for sorting
						if ( matchedCount > 0 ) {
							while ( i-- ) {
								if ( !(unmatched[i] || setMatched[i]) ) {
									setMatched[i] = pop.call( results );
								}
							}
						}
	
						// Discard index placeholder values to get only actual matches
						setMatched = condense( setMatched );
					}
	
					// Add matches to results
					push.apply( results, setMatched );
	
					// Seedless set matches succeeding multiple successful matchers stipulate sorting
					if ( outermost && !seed && setMatched.length > 0 &&
						( matchedCount + setMatchers.length ) > 1 ) {
	
						Sizzle.uniqueSort( results );
					}
				}
	
				// Override manipulation of globals by nested matchers
				if ( outermost ) {
					dirruns = dirrunsUnique;
					outermostContext = contextBackup;
				}
	
				return unmatched;
			};
	
		return bySet ?
			markFunction( superMatcher ) :
			superMatcher;
	}
	
	compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
		var i,
			setMatchers = [],
			elementMatchers = [],
			cached = compilerCache[ selector + " " ];
	
		if ( !cached ) {
			// Generate a function of recursive functions that can be used to check each element
			if ( !match ) {
				match = tokenize( selector );
			}
			i = match.length;
			while ( i-- ) {
				cached = matcherFromTokens( match[i] );
				if ( cached[ expando ] ) {
					setMatchers.push( cached );
				} else {
					elementMatchers.push( cached );
				}
			}
	
			// Cache the compiled function
			cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );
	
			// Save selector and tokenization
			cached.selector = selector;
		}
		return cached;
	};
	
	/**
	 * A low-level selection function that works with Sizzle's compiled
	 *  selector functions
	 * @param {String|Function} selector A selector or a pre-compiled
	 *  selector function built with Sizzle.compile
	 * @param {Element} context
	 * @param {Array} [results]
	 * @param {Array} [seed] A set of elements to match against
	 */
	select = Sizzle.select = function( selector, context, results, seed ) {
		var i, tokens, token, type, find,
			compiled = typeof selector === "function" && selector,
			match = !seed && tokenize( (selector = compiled.selector || selector) );
	
		results = results || [];
	
		// Try to minimize operations if there is no seed and only one group
		if ( match.length === 1 ) {
	
			// Take a shortcut and set the context if the root selector is an ID
			tokens = match[0] = match[0].slice( 0 );
			if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
					support.getById && context.nodeType === 9 && documentIsHTML &&
					Expr.relative[ tokens[1].type ] ) {
	
				context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
				if ( !context ) {
					return results;
	
				// Precompiled matchers will still verify ancestry, so step up a level
				} else if ( compiled ) {
					context = context.parentNode;
				}
	
				selector = selector.slice( tokens.shift().value.length );
			}
	
			// Fetch a seed set for right-to-left matching
			i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
			while ( i-- ) {
				token = tokens[i];
	
				// Abort if we hit a combinator
				if ( Expr.relative[ (type = token.type) ] ) {
					break;
				}
				if ( (find = Expr.find[ type ]) ) {
					// Search, expanding context for leading sibling combinators
					if ( (seed = find(
						token.matches[0].replace( runescape, funescape ),
						rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
					)) ) {
	
						// If seed is empty or no tokens remain, we can return early
						tokens.splice( i, 1 );
						selector = seed.length && toSelector( tokens );
						if ( !selector ) {
							push.apply( results, seed );
							return results;
						}
	
						break;
					}
				}
			}
		}
	
		// Compile and execute a filtering function if one is not provided
		// Provide `match` to avoid retokenization if we modified the selector above
		( compiled || compile( selector, match ) )(
			seed,
			context,
			!documentIsHTML,
			results,
			rsibling.test( selector ) && testContext( context.parentNode ) || context
		);
		return results;
	};
	
	// One-time assignments
	
	// Sort stability
	support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;
	
	// Support: Chrome 14-35+
	// Always assume duplicates if they aren't passed to the comparison function
	support.detectDuplicates = !!hasDuplicate;
	
	// Initialize against the default document
	setDocument();
	
	// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
	// Detached nodes confoundingly follow *each other*
	support.sortDetached = assert(function( div1 ) {
		// Should return 1, but returns 4 (following)
		return div1.compareDocumentPosition( document.createElement("div") ) & 1;
	});
	
	// Support: IE<8
	// Prevent attribute/property "interpolation"
	// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
	if ( !assert(function( div ) {
		div.innerHTML = "<a href='#'></a>";
		return div.firstChild.getAttribute("href") === "#" ;
	}) ) {
		addHandle( "type|href|height|width", function( elem, name, isXML ) {
			if ( !isXML ) {
				return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
			}
		});
	}
	
	// Support: IE<9
	// Use defaultValue in place of getAttribute("value")
	if ( !support.attributes || !assert(function( div ) {
		div.innerHTML = "<input/>";
		div.firstChild.setAttribute( "value", "" );
		return div.firstChild.getAttribute( "value" ) === "";
	}) ) {
		addHandle( "value", function( elem, name, isXML ) {
			if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
				return elem.defaultValue;
			}
		});
	}
	
	// Support: IE<9
	// Use getAttributeNode to fetch booleans when getAttribute lies
	if ( !assert(function( div ) {
		return div.getAttribute("disabled") == null;
	}) ) {
		addHandle( booleans, function( elem, name, isXML ) {
			var val;
			if ( !isXML ) {
				return elem[ name ] === true ? name.toLowerCase() :
						(val = elem.getAttributeNode( name )) && val.specified ?
						val.value :
					null;
			}
		});
	}
	
	// EXPOSE
	return Sizzle;
	});
	
	/*eslint-enable */
	
	// Included from: js/tinymce/classes/util/Arr.js
	
	/**
	 * Arr.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Array utility class.
	 *
	 * @private
	 * @class tinymce.util.Arr
	 */
	define("tinymce/util/Arr", [], function() {
		var isArray = Array.isArray || function(obj) {
			return Object.prototype.toString.call(obj) === "[object Array]";
		};
	
		function toArray(obj) {
			var array = obj, i, l;
	
			if (!isArray(obj)) {
				array = [];
				for (i = 0, l = obj.length; i < l; i++) {
					array[i] = obj[i];
				}
			}
	
			return array;
		}
	
		function each(o, cb, s) {
			var n, l;
	
			if (!o) {
				return 0;
			}
	
			s = s || o;
	
			if (o.length !== undefined) {
				// Indexed arrays, needed for Safari
				for (n = 0, l = o.length; n < l; n++) {
					if (cb.call(s, o[n], n, o) === false) {
						return 0;
					}
				}
			} else {
				// Hashtables
				for (n in o) {
					if (o.hasOwnProperty(n)) {
						if (cb.call(s, o[n], n, o) === false) {
							return 0;
						}
					}
				}
			}
	
			return 1;
		}
	
		function map(array, callback) {
			var out = [];
	
			each(array, function(item, index) {
				out.push(callback(item, index, array));
			});
	
			return out;
		}
	
		function filter(a, f) {
			var o = [];
	
			each(a, function(v, index) {
				if (!f || f(v, index, a)) {
					o.push(v);
				}
			});
	
			return o;
		}
	
		function indexOf(a, v) {
			var i, l;
	
			if (a) {
				for (i = 0, l = a.length; i < l; i++) {
					if (a[i] === v) {
						return i;
					}
				}
			}
	
			return -1;
		}
	
		function reduce(collection, iteratee, accumulator, thisArg) {
			var i = 0;
	
			if (arguments.length < 3) {
				accumulator = collection[0];
			}
	
			for (; i < collection.length; i++) {
				accumulator = iteratee.call(thisArg, accumulator, collection[i], i);
			}
	
			return accumulator;
		}
	
		function findIndex(array, predicate, thisArg) {
			var i, l;
	
			for (i = 0, l = array.length; i < l; i++) {
				if (predicate.call(thisArg, array[i], i, array)) {
					return i;
				}
			}
	
			return -1;
		}
	
		function find(array, predicate, thisArg) {
			var idx = findIndex(array, predicate, thisArg);
	
			if (idx !== -1) {
				return array[idx];
			}
	
			return undefined;
		}
	
		function last(collection) {
			return collection[collection.length - 1];
		}
	
		return {
			isArray: isArray,
			toArray: toArray,
			each: each,
			map: map,
			filter: filter,
			indexOf: indexOf,
			reduce: reduce,
			findIndex: findIndex,
			find: find,
			last: last
		};
	});
	
	// Included from: js/tinymce/classes/util/Tools.js
	
	/**
	 * Tools.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This class contains various utlity functions. These are also exposed
	 * directly on the tinymce namespace.
	 *
	 * @class tinymce.util.Tools
	 */
	define("tinymce/util/Tools", [
		"tinymce/Env",
		"tinymce/util/Arr"
	], function(Env, Arr) {
		/**
		 * Removes whitespace from the beginning and end of a string.
		 *
		 * @method trim
		 * @param {String} s String to remove whitespace from.
		 * @return {String} New string with removed whitespace.
		 */
		var whiteSpaceRegExp = /^\s*|\s*$/g;
	
		function trim(str) {
			return (str === null || str === undefined) ? '' : ("" + str).replace(whiteSpaceRegExp, '');
		}
	
		/**
		 * Checks if a object is of a specific type for example an array.
		 *
		 * @method is
		 * @param {Object} obj Object to check type of.
		 * @param {string} type Optional type to check for.
		 * @return {Boolean} true/false if the object is of the specified type.
		 */
		function is(obj, type) {
			if (!type) {
				return obj !== undefined;
			}
	
			if (type == 'array' && Arr.isArray(obj)) {
				return true;
			}
	
			return typeof obj == type;
		}
	
		/**
		 * Makes a name/object map out of an array with names.
		 *
		 * @method makeMap
		 * @param {Array/String} items Items to make map out of.
		 * @param {String} delim Optional delimiter to split string by.
		 * @param {Object} map Optional map to add items to.
		 * @return {Object} Name/value map of items.
		 */
		function makeMap(items, delim, map) {
			var i;
	
			items = items || [];
			delim = delim || ',';
	
			if (typeof items == "string") {
				items = items.split(delim);
			}
	
			map = map || {};
	
			i = items.length;
			while (i--) {
				map[items[i]] = {};
			}
	
			return map;
		}
	
		/**
		 * JavaScript does not protect hasOwnProperty method, so it is possible to overwrite it. This is
		 * object independent version.
		 *
		 * @param {Object} obj
		 * @param {String} prop
		 * @returns {Boolean}
		 */
		function hasOwnProperty(obj, prop) {
			return Object.prototype.hasOwnProperty.call(obj, prop);
		}
	
		/**
		 * Creates a class, subclass or static singleton.
		 * More details on this method can be found in the Wiki.
		 *
		 * @method create
		 * @param {String} s Class name, inheritance and prefix.
		 * @param {Object} p Collection of methods to add to the class.
		 * @param {Object} root Optional root object defaults to the global window object.
		 * @example
		 * // Creates a basic class
		 * tinymce.create('tinymce.somepackage.SomeClass', {
		 *     SomeClass: function() {
		 *         // Class constructor
		 *     },
		 *
		 *     method: function() {
		 *         // Some method
		 *     }
		 * });
		 *
		 * // Creates a basic subclass class
		 * tinymce.create('tinymce.somepackage.SomeSubClass:tinymce.somepackage.SomeClass', {
		 *     SomeSubClass: function() {
		 *         // Class constructor
		 *         this.parent(); // Call parent constructor
		 *     },
		 *
		 *     method: function() {
		 *         // Some method
		 *         this.parent(); // Call parent method
		 *     },
		 *
		 *     'static': {
		 *         staticMethod: function() {
		 *             // Static method
		 *         }
		 *     }
		 * });
		 *
		 * // Creates a singleton/static class
		 * tinymce.create('static tinymce.somepackage.SomeSingletonClass', {
		 *     method: function() {
		 *         // Some method
		 *     }
		 * });
		 */
		function create(s, p, root) {
			var self = this, sp, ns, cn, scn, c, de = 0;
	
			// Parse : <prefix> <class>:<super class>
			s = /^((static) )?([\w.]+)(:([\w.]+))?/.exec(s);
			cn = s[3].match(/(^|\.)(\w+)$/i)[2]; // Class name
	
			// Create namespace for new class
			ns = self.createNS(s[3].replace(/\.\w+$/, ''), root);
	
			// Class already exists
			if (ns[cn]) {
				return;
			}
	
			// Make pure static class
			if (s[2] == 'static') {
				ns[cn] = p;
	
				if (this.onCreate) {
					this.onCreate(s[2], s[3], ns[cn]);
				}
	
				return;
			}
	
			// Create default constructor
			if (!p[cn]) {
				p[cn] = function() {};
				de = 1;
			}
	
			// Add constructor and methods
			ns[cn] = p[cn];
			self.extend(ns[cn].prototype, p);
	
			// Extend
			if (s[5]) {
				sp = self.resolve(s[5]).prototype;
				scn = s[5].match(/\.(\w+)$/i)[1]; // Class name
	
				// Extend constructor
				c = ns[cn];
				if (de) {
					// Add passthrough constructor
					ns[cn] = function() {
						return sp[scn].apply(this, arguments);
					};
				} else {
					// Add inherit constructor
					ns[cn] = function() {
						this.parent = sp[scn];
						return c.apply(this, arguments);
					};
				}
				ns[cn].prototype[cn] = ns[cn];
	
				// Add super methods
				self.each(sp, function(f, n) {
					ns[cn].prototype[n] = sp[n];
				});
	
				// Add overridden methods
				self.each(p, function(f, n) {
					// Extend methods if needed
					if (sp[n]) {
						ns[cn].prototype[n] = function() {
							this.parent = sp[n];
							return f.apply(this, arguments);
						};
					} else {
						if (n != cn) {
							ns[cn].prototype[n] = f;
						}
					}
				});
			}
	
			// Add static methods
			/*jshint sub:true*/
			/*eslint dot-notation:0*/
			self.each(p['static'], function(f, n) {
				ns[cn][n] = f;
			});
		}
	
		function extend(obj, ext) {
			var i, l, name, args = arguments, value;
	
			for (i = 1, l = args.length; i < l; i++) {
				ext = args[i];
				for (name in ext) {
					if (ext.hasOwnProperty(name)) {
						value = ext[name];
	
						if (value !== undefined) {
							obj[name] = value;
						}
					}
				}
			}
	
			return obj;
		}
	
		/**
		 * Executed the specified function for each item in a object tree.
		 *
		 * @method walk
		 * @param {Object} o Object tree to walk though.
		 * @param {function} f Function to call for each item.
		 * @param {String} n Optional name of collection inside the objects to walk for example childNodes.
		 * @param {String} s Optional scope to execute the function in.
		 */
		function walk(o, f, n, s) {
			s = s || this;
	
			if (o) {
				if (n) {
					o = o[n];
				}
	
				Arr.each(o, function(o, i) {
					if (f.call(s, o, i, n) === false) {
						return false;
					}
	
					walk(o, f, n, s);
				});
			}
		}
	
		/**
		 * Creates a namespace on a specific object.
		 *
		 * @method createNS
		 * @param {String} n Namespace to create for example a.b.c.d.
		 * @param {Object} o Optional object to add namespace to, defaults to window.
		 * @return {Object} New namespace object the last item in path.
		 * @example
		 * // Create some namespace
		 * tinymce.createNS('tinymce.somepackage.subpackage');
		 *
		 * // Add a singleton
		 * var tinymce.somepackage.subpackage.SomeSingleton = {
		 *     method: function() {
		 *         // Some method
		 *     }
		 * };
		 */
		function createNS(n, o) {
			var i, v;
	
			o = o || window;
	
			n = n.split('.');
			for (i = 0; i < n.length; i++) {
				v = n[i];
	
				if (!o[v]) {
					o[v] = {};
				}
	
				o = o[v];
			}
	
			return o;
		}
	
		/**
		 * Resolves a string and returns the object from a specific structure.
		 *
		 * @method resolve
		 * @param {String} n Path to resolve for example a.b.c.d.
		 * @param {Object} o Optional object to search though, defaults to window.
		 * @return {Object} Last object in path or null if it couldn't be resolved.
		 * @example
		 * // Resolve a path into an object reference
		 * var obj = tinymce.resolve('a.b.c.d');
		 */
		function resolve(n, o) {
			var i, l;
	
			o = o || window;
	
			n = n.split('.');
			for (i = 0, l = n.length; i < l; i++) {
				o = o[n[i]];
	
				if (!o) {
					break;
				}
			}
	
			return o;
		}
	
		/**
		 * Splits a string but removes the whitespace before and after each value.
		 *
		 * @method explode
		 * @param {string} s String to split.
		 * @param {string} d Delimiter to split by.
		 * @example
		 * // Split a string into an array with a,b,c
		 * var arr = tinymce.explode('a, b,   c');
		 */
		function explode(s, d) {
			if (!s || is(s, 'array')) {
				return s;
			}
	
			return Arr.map(s.split(d || ','), trim);
		}
	
		function _addCacheSuffix(url) {
			var cacheSuffix = Env.cacheSuffix;
	
			if (cacheSuffix) {
				url += (url.indexOf('?') === -1 ? '?' : '&') + cacheSuffix;
			}
	
			return url;
		}
	
		return {
			trim: trim,
	
			/**
			 * Returns true/false if the object is an array or not.
			 *
			 * @method isArray
			 * @param {Object} obj Object to check.
			 * @return {boolean} true/false state if the object is an array or not.
			 */
			isArray: Arr.isArray,
	
			is: is,
	
			/**
			 * Converts the specified object into a real JavaScript array.
			 *
			 * @method toArray
			 * @param {Object} obj Object to convert into array.
			 * @return {Array} Array object based in input.
			 */
			toArray: Arr.toArray,
			makeMap: makeMap,
	
			/**
			 * Performs an iteration of all items in a collection such as an object or array. This method will execure the
			 * callback function for each item in the collection, if the callback returns false the iteration will terminate.
			 * The callback has the following format: cb(value, key_or_index).
			 *
			 * @method each
			 * @param {Object} o Collection to iterate.
			 * @param {function} cb Callback function to execute for each item.
			 * @param {Object} s Optional scope to execute the callback in.
			 * @example
			 * // Iterate an array
			 * tinymce.each([1,2,3], function(v, i) {
			 *     console.debug("Value: " + v + ", Index: " + i);
			 * });
			 *
			 * // Iterate an object
			 * tinymce.each({a: 1, b: 2, c: 3], function(v, k) {
			 *     console.debug("Value: " + v + ", Key: " + k);
			 * });
			 */
			each: Arr.each,
	
			/**
			 * Creates a new array by the return value of each iteration function call. This enables you to convert
			 * one array list into another.
			 *
			 * @method map
			 * @param {Array} array Array of items to iterate.
			 * @param {function} callback Function to call for each item. It's return value will be the new value.
			 * @return {Array} Array with new values based on function return values.
			 */
			map: Arr.map,
	
			/**
			 * Filters out items from the input array by calling the specified function for each item.
			 * If the function returns false the item will be excluded if it returns true it will be included.
			 *
			 * @method grep
			 * @param {Array} a Array of items to loop though.
			 * @param {function} f Function to call for each item. Include/exclude depends on it's return value.
			 * @return {Array} New array with values imported and filtered based in input.
			 * @example
			 * // Filter out some items, this will return an array with 4 and 5
			 * var items = tinymce.grep([1,2,3,4,5], function(v) {return v > 3;});
			 */
			grep: Arr.filter,
	
			/**
			 * Returns an index of the item or -1 if item is not present in the array.
			 *
			 * @method inArray
			 * @param {any} item Item to search for.
			 * @param {Array} arr Array to search in.
			 * @return {Number} index of the item or -1 if item was not found.
			 */
			inArray: Arr.indexOf,
	
			hasOwn: hasOwnProperty,
	
			extend: extend,
			create: create,
			walk: walk,
			createNS: createNS,
			resolve: resolve,
			explode: explode,
			_addCacheSuffix: _addCacheSuffix
		};
	});
	
	// Included from: js/tinymce/classes/dom/DomQuery.js
	
	/**
	 * DomQuery.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This class mimics most of the jQuery API:
	 *
	 * This is whats currently implemented:
	 * - Utility functions
	 * - DOM traversial
	 * - DOM manipulation
	 * - Event binding
	 *
	 * This is not currently implemented:
	 * - Dimension
	 * - Ajax
	 * - Animation
	 * - Advanced chaining
	 *
	 * @example
	 * var $ = tinymce.dom.DomQuery;
	 * $('p').attr('attr', 'value').addClass('class');
	 *
	 * @class tinymce.dom.DomQuery
	 */
	define("tinymce/dom/DomQuery", [
		"tinymce/dom/EventUtils",
		"tinymce/dom/Sizzle",
		"tinymce/util/Tools",
		"tinymce/Env"
	], function(EventUtils, Sizzle, Tools, Env) {
		var doc = document, push = Array.prototype.push, slice = Array.prototype.slice;
		var rquickExpr = /^(?:[^#<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/;
		var Event = EventUtils.Event, undef;
		var skipUniques = Tools.makeMap('children,contents,next,prev');
	
		function isDefined(obj) {
			return typeof obj !== 'undefined';
		}
	
		function isString(obj) {
			return typeof obj === 'string';
		}
	
		function isWindow(obj) {
			return obj && obj == obj.window;
		}
	
		function createFragment(html, fragDoc) {
			var frag, node, container;
	
			fragDoc = fragDoc || doc;
			container = fragDoc.createElement('div');
			frag = fragDoc.createDocumentFragment();
			container.innerHTML = html;
	
			while ((node = container.firstChild)) {
				frag.appendChild(node);
			}
	
			return frag;
		}
	
		function domManipulate(targetNodes, sourceItem, callback, reverse) {
			var i;
	
			if (isString(sourceItem)) {
				sourceItem = createFragment(sourceItem, getElementDocument(targetNodes[0]));
			} else if (sourceItem.length && !sourceItem.nodeType) {
				sourceItem = DomQuery.makeArray(sourceItem);
	
				if (reverse) {
					for (i = sourceItem.length - 1; i >= 0; i--) {
						domManipulate(targetNodes, sourceItem[i], callback, reverse);
					}
				} else {
					for (i = 0; i < sourceItem.length; i++) {
						domManipulate(targetNodes, sourceItem[i], callback, reverse);
					}
				}
	
				return targetNodes;
			}
	
			if (sourceItem.nodeType) {
				i = targetNodes.length;
				while (i--) {
					callback.call(targetNodes[i], sourceItem);
				}
			}
	
			return targetNodes;
		}
	
		function hasClass(node, className) {
			return node && className && (' ' + node.className + ' ').indexOf(' ' + className + ' ') !== -1;
		}
	
		function wrap(elements, wrapper, all) {
			var lastParent, newWrapper;
	
			wrapper = DomQuery(wrapper)[0];
	
			elements.each(function() {
				var self = this;
	
				if (!all || lastParent != self.parentNode) {
					lastParent = self.parentNode;
					newWrapper = wrapper.cloneNode(false);
					self.parentNode.insertBefore(newWrapper, self);
					newWrapper.appendChild(self);
				} else {
					newWrapper.appendChild(self);
				}
			});
	
			return elements;
		}
	
		var numericCssMap = Tools.makeMap('fillOpacity fontWeight lineHeight opacity orphans widows zIndex zoom', ' ');
		var booleanMap = Tools.makeMap('checked compact declare defer disabled ismap multiple nohref noshade nowrap readonly selected', ' ');
		var propFix = {
			'for': 'htmlFor',
			'class': 'className',
			'readonly': 'readOnly'
		};
		var cssFix = {
			'float': 'cssFloat'
		};
	
		var attrHooks = {}, cssHooks = {};
	
		function DomQuery(selector, context) {
			/*eslint new-cap:0 */
			return new DomQuery.fn.init(selector, context);
		}
	
		function inArray(item, array) {
			var i;
	
			if (array.indexOf) {
				return array.indexOf(item);
			}
	
			i = array.length;
			while (i--) {
				if (array[i] === item) {
					return i;
				}
			}
	
			return -1;
		}
	
		var whiteSpaceRegExp = /^\s*|\s*$/g;
	
		function trim(str) {
			return (str === null || str === undef) ? '' : ("" + str).replace(whiteSpaceRegExp, '');
		}
	
		function each(obj, callback) {
			var length, key, i, undef, value;
	
			if (obj) {
				length = obj.length;
	
				if (length === undef) {
					// Loop object items
					for (key in obj) {
						if (obj.hasOwnProperty(key)) {
							value = obj[key];
							if (callback.call(value, key, value) === false) {
								break;
							}
						}
					}
				} else {
					// Loop array items
					for (i = 0; i < length; i++) {
						value = obj[i];
						if (callback.call(value, i, value) === false) {
							break;
						}
					}
				}
			}
	
			return obj;
		}
	
		function grep(array, callback) {
			var out = [];
	
			each(array, function(i, item) {
				if (callback(item, i)) {
					out.push(item);
				}
			});
	
			return out;
		}
	
		function getElementDocument(element) {
			if (!element) {
				return doc;
			}
	
			if (element.nodeType == 9) {
				return element;
			}
	
			return element.ownerDocument;
		}
	
		DomQuery.fn = DomQuery.prototype = {
			constructor: DomQuery,
	
			/**
			 * Selector for the current set.
			 *
			 * @property selector
			 * @type String
			 */
			selector: "",
	
			/**
			 * Context used to create the set.
			 *
			 * @property context
			 * @type Element
			 */
			context: null,
	
			/**
			 * Number of items in the current set.
			 *
			 * @property length
			 * @type Number
			 */
			length: 0,
	
			/**
			 * Constructs a new DomQuery instance with the specified selector or context.
			 *
			 * @constructor
			 * @method init
			 * @param {String/Array/DomQuery} selector Optional CSS selector/Array or array like object or HTML string.
			 * @param {Document/Element} context Optional context to search in.
			 */
			init: function(selector, context) {
				var self = this, match, node;
	
				if (!selector) {
					return self;
				}
	
				if (selector.nodeType) {
					self.context = self[0] = selector;
					self.length = 1;
	
					return self;
				}
	
				if (context && context.nodeType) {
					self.context = context;
				} else {
					if (context) {
						return DomQuery(selector).attr(context);
					}
	
					self.context = context = document;
				}
	
				if (isString(selector)) {
					self.selector = selector;
	
					if (selector.charAt(0) === "<" && selector.charAt(selector.length - 1) === ">" && selector.length >= 3) {
						match = [null, selector, null];
					} else {
						match = rquickExpr.exec(selector);
					}
	
					if (match) {
						if (match[1]) {
							node = createFragment(selector, getElementDocument(context)).firstChild;
	
							while (node) {
								push.call(self, node);
								node = node.nextSibling;
							}
						} else {
							node = getElementDocument(context).getElementById(match[2]);
	
							if (!node) {
								return self;
							}
	
							if (node.id !== match[2]) {
								return self.find(selector);
							}
	
							self.length = 1;
							self[0] = node;
						}
					} else {
						return DomQuery(context).find(selector);
					}
				} else {
					this.add(selector, false);
				}
	
				return self;
			},
	
			/**
			 * Converts the current set to an array.
			 *
			 * @method toArray
			 * @return {Array} Array of all nodes in set.
			 */
			toArray: function() {
				return Tools.toArray(this);
			},
	
			/**
			 * Adds new nodes to the set.
			 *
			 * @method add
			 * @param {Array/tinymce.dom.DomQuery} items Array of all nodes to add to set.
			 * @param {Boolean} sort Optional sort flag that enables sorting of elements.
			 * @return {tinymce.dom.DomQuery} New instance with nodes added.
			 */
			add: function(items, sort) {
				var self = this, nodes, i;
	
				if (isString(items)) {
					return self.add(DomQuery(items));
				}
	
				if (sort !== false) {
					nodes = DomQuery.unique(self.toArray().concat(DomQuery.makeArray(items)));
					self.length = nodes.length;
					for (i = 0; i < nodes.length; i++) {
						self[i] = nodes[i];
					}
				} else {
					push.apply(self, DomQuery.makeArray(items));
				}
	
				return self;
			},
	
			/**
			 * Sets/gets attributes on the elements in the current set.
			 *
			 * @method attr
			 * @param {String/Object} name Name of attribute to get or an object with attributes to set.
			 * @param {String} value Optional value to set.
			 * @return {tinymce.dom.DomQuery/String} Current set or the specified attribute when only the name is specified.
			 */
			attr: function(name, value) {
				var self = this, hook;
	
				if (typeof name === "object") {
					each(name, function(name, value) {
						self.attr(name, value);
					});
				} else if (isDefined(value)) {
					this.each(function() {
						var hook;
	
						if (this.nodeType === 1) {
							hook = attrHooks[name];
							if (hook && hook.set) {
								hook.set(this, value);
								return;
							}
	
							if (value === null) {
								this.removeAttribute(name, 2);
							} else {
								this.setAttribute(name, value, 2);
							}
						}
					});
				} else {
					if (self[0] && self[0].nodeType === 1) {
						hook = attrHooks[name];
						if (hook && hook.get) {
							return hook.get(self[0], name);
						}
	
						if (booleanMap[name]) {
							return self.prop(name) ? name : undef;
						}
	
						value = self[0].getAttribute(name, 2);
	
						if (value === null) {
							value = undef;
						}
					}
	
					return value;
				}
	
				return self;
			},
	
			/**
			 * Removes attributse on the elements in the current set.
			 *
			 * @method removeAttr
			 * @param {String/Object} name Name of attribute to remove.
			 * @return {tinymce.dom.DomQuery/String} Current set.
			 */
			removeAttr: function(name) {
				return this.attr(name, null);
			},
	
			/**
			 * Sets/gets properties on the elements in the current set.
			 *
			 * @method attr
			 * @param {String/Object} name Name of property to get or an object with properties to set.
			 * @param {String} value Optional value to set.
			 * @return {tinymce.dom.DomQuery/String} Current set or the specified property when only the name is specified.
			 */
			prop: function(name, value) {
				var self = this;
	
				name = propFix[name] || name;
	
				if (typeof name === "object") {
					each(name, function(name, value) {
						self.prop(name, value);
					});
				} else if (isDefined(value)) {
					this.each(function() {
						if (this.nodeType == 1) {
							this[name] = value;
						}
					});
				} else {
					if (self[0] && self[0].nodeType && name in self[0]) {
						return self[0][name];
					}
	
					return value;
				}
	
				return self;
			},
	
			/**
			 * Sets/gets styles on the elements in the current set.
			 *
			 * @method css
			 * @param {String/Object} name Name of style to get or an object with styles to set.
			 * @param {String} value Optional value to set.
			 * @return {tinymce.dom.DomQuery/String} Current set or the specified style when only the name is specified.
			 */
			css: function(name, value) {
				var self = this, elm, hook;
	
				function camel(name) {
					return name.replace(/-(\D)/g, function(a, b) {
						return b.toUpperCase();
					});
				}
	
				function dashed(name) {
					return name.replace(/[A-Z]/g, function(a) {
						return '-' + a;
					});
				}
	
				if (typeof name === "object") {
					each(name, function(name, value) {
						self.css(name, value);
					});
				} else {
					if (isDefined(value)) {
						name = camel(name);
	
						// Default px suffix on these
						if (typeof value === 'number' && !numericCssMap[name]) {
							value += 'px';
						}
	
						self.each(function() {
							var style = this.style;
	
							hook = cssHooks[name];
							if (hook && hook.set) {
								hook.set(this, value);
								return;
							}
	
							try {
								this.style[cssFix[name] || name] = value;
							} catch (ex) {
								// Ignore
							}
	
							if (value === null || value === '') {
								if (style.removeProperty) {
									style.removeProperty(dashed(name));
								} else {
									style.removeAttribute(name);
								}
							}
						});
					} else {
						elm = self[0];
	
						hook = cssHooks[name];
						if (hook && hook.get) {
							return hook.get(elm);
						}
	
						if (elm.ownerDocument.defaultView) {
							try {
								return elm.ownerDocument.defaultView.getComputedStyle(elm, null).getPropertyValue(dashed(name));
							} catch (ex) {
								return undef;
							}
						} else if (elm.currentStyle) {
							return elm.currentStyle[camel(name)];
						}
					}
				}
	
				return self;
			},
	
			/**
			 * Removes all nodes in set from the document.
			 *
			 * @method remove
			 * @return {tinymce.dom.DomQuery} Current set with the removed nodes.
			 */
			remove: function() {
				var self = this, node, i = this.length;
	
				while (i--) {
					node = self[i];
					Event.clean(node);
	
					if (node.parentNode) {
						node.parentNode.removeChild(node);
					}
				}
	
				return this;
			},
	
			/**
			 * Empties all elements in set.
			 *
			 * @method empty
			 * @return {tinymce.dom.DomQuery} Current set with the empty nodes.
			 */
			empty: function() {
				var self = this, node, i = this.length;
	
				while (i--) {
					node = self[i];
					while (node.firstChild) {
						node.removeChild(node.firstChild);
					}
				}
	
				return this;
			},
	
			/**
			 * Sets or gets the HTML of the current set or first set node.
			 *
			 * @method html
			 * @param {String} value Optional innerHTML value to set on each element.
			 * @return {tinymce.dom.DomQuery/String} Current set or the innerHTML of the first element.
			 */
			html: function(value) {
				var self = this, i;
	
				if (isDefined(value)) {
					i = self.length;
	
					try {
						while (i--) {
							self[i].innerHTML = value;
						}
					} catch (ex) {
						// Workaround for "Unknown runtime error" when DIV is added to P on IE
						DomQuery(self[i]).empty().append(value);
					}
	
					return self;
				}
	
				return self[0] ? self[0].innerHTML : '';
			},
	
			/**
			 * Sets or gets the text of the current set or first set node.
			 *
			 * @method text
			 * @param {String} value Optional innerText value to set on each element.
			 * @return {tinymce.dom.DomQuery/String} Current set or the innerText of the first element.
			 */
			text: function(value) {
				var self = this, i;
	
				if (isDefined(value)) {
					i = self.length;
					while (i--) {
						if ("innerText" in self[i]) {
							self[i].innerText = value;
						} else {
							self[0].textContent = value;
						}
					}
	
					return self;
				}
	
				return self[0] ? (self[0].innerText || self[0].textContent) : '';
			},
	
			/**
			 * Appends the specified node/html or node set to the current set nodes.
			 *
			 * @method append
			 * @param {String/Element/Array/tinymce.dom.DomQuery} content Content to append to each element in set.
			 * @return {tinymce.dom.DomQuery} Current set.
			 */
			append: function() {
				return domManipulate(this, arguments, function(node) {
					// Either element or Shadow Root
					if (this.nodeType === 1 || (this.host && this.host.nodeType === 1)) {
						this.appendChild(node);
					}
				});
			},
	
			/**
			 * Prepends the specified node/html or node set to the current set nodes.
			 *
			 * @method prepend
			 * @param {String/Element/Array/tinymce.dom.DomQuery} content Content to prepend to each element in set.
			 * @return {tinymce.dom.DomQuery} Current set.
			 */
			prepend: function() {
				return domManipulate(this, arguments, function(node) {
					// Either element or Shadow Root
					if (this.nodeType === 1 || (this.host && this.host.nodeType === 1)) {
						this.insertBefore(node, this.firstChild);
					}
				}, true);
			},
	
			/**
			 * Adds the specified elements before current set nodes.
			 *
			 * @method before
			 * @param {String/Element/Array/tinymce.dom.DomQuery} content Content to add before to each element in set.
			 * @return {tinymce.dom.DomQuery} Current set.
			 */
			before: function() {
				var self = this;
	
				if (self[0] && self[0].parentNode) {
					return domManipulate(self, arguments, function(node) {
						this.parentNode.insertBefore(node, this);
					});
				}
	
				return self;
			},
	
			/**
			 * Adds the specified elements after current set nodes.
			 *
			 * @method after
			 * @param {String/Element/Array/tinymce.dom.DomQuery} content Content to add after to each element in set.
			 * @return {tinymce.dom.DomQuery} Current set.
			 */
			after: function() {
				var self = this;
	
				if (self[0] && self[0].parentNode) {
					return domManipulate(self, arguments, function(node) {
						this.parentNode.insertBefore(node, this.nextSibling);
					}, true);
				}
	
				return self;
			},
	
			/**
			 * Appends the specified set nodes to the specified selector/instance.
			 *
			 * @method appendTo
			 * @param {String/Element/Array/tinymce.dom.DomQuery} val Item to append the current set to.
			 * @return {tinymce.dom.DomQuery} Current set with the appended nodes.
			 */
			appendTo: function(val) {
				DomQuery(val).append(this);
	
				return this;
			},
	
			/**
			 * Prepends the specified set nodes to the specified selector/instance.
			 *
			 * @method prependTo
			 * @param {String/Element/Array/tinymce.dom.DomQuery} val Item to prepend the current set to.
			 * @return {tinymce.dom.DomQuery} Current set with the prepended nodes.
			 */
			prependTo: function(val) {
				DomQuery(val).prepend(this);
	
				return this;
			},
	
			/**
			 * Replaces the nodes in set with the specified content.
			 *
			 * @method replaceWith
			 * @param {String/Element/Array/tinymce.dom.DomQuery} content Content to replace nodes with.
			 * @return {tinymce.dom.DomQuery} Set with replaced nodes.
			 */
			replaceWith: function(content) {
				return this.before(content).remove();
			},
	
			/**
			 * Wraps all elements in set with the specified wrapper.
			 *
			 * @method wrap
			 * @param {String/Element/Array/tinymce.dom.DomQuery} content Content to wrap nodes with.
			 * @return {tinymce.dom.DomQuery} Set with wrapped nodes.
			 */
			wrap: function(content) {
				return wrap(this, content);
			},
	
			/**
			 * Wraps all nodes in set with the specified wrapper. If the nodes are siblings all of them
			 * will be wrapped in the same wrapper.
			 *
			 * @method wrapAll
			 * @param {String/Element/Array/tinymce.dom.DomQuery} content Content to wrap nodes with.
			 * @return {tinymce.dom.DomQuery} Set with wrapped nodes.
			 */
			wrapAll: function(content) {
				return wrap(this, content, true);
			},
	
			/**
			 * Wraps all elements inner contents in set with the specified wrapper.
			 *
			 * @method wrapInner
			 * @param {String/Element/Array/tinymce.dom.DomQuery} content Content to wrap nodes with.
			 * @return {tinymce.dom.DomQuery} Set with wrapped nodes.
			 */
			wrapInner: function(content) {
				this.each(function() {
					DomQuery(this).contents().wrapAll(content);
				});
	
				return this;
			},
	
			/**
			 * Unwraps all elements by removing the parent element of each item in set.
			 *
			 * @method unwrap
			 * @return {tinymce.dom.DomQuery} Set with unwrapped nodes.
			 */
			unwrap: function() {
				return this.parent().each(function() {
					DomQuery(this).replaceWith(this.childNodes);
				});
			},
	
			/**
			 * Clones all nodes in set.
			 *
			 * @method clone
			 * @return {tinymce.dom.DomQuery} Set with cloned nodes.
			 */
			clone: function() {
				var result = [];
	
				this.each(function() {
					result.push(this.cloneNode(true));
				});
	
				return DomQuery(result);
			},
	
			/**
			 * Adds the specified class name to the current set elements.
			 *
			 * @method addClass
			 * @param {String} className Class name to add.
			 * @return {tinymce.dom.DomQuery} Current set.
			 */
			addClass: function(className) {
				return this.toggleClass(className, true);
			},
	
			/**
			 * Removes the specified class name to the current set elements.
			 *
			 * @method removeClass
			 * @param {String} className Class name to remove.
			 * @return {tinymce.dom.DomQuery} Current set.
			 */
			removeClass: function(className) {
				return this.toggleClass(className, false);
			},
	
			/**
			 * Toggles the specified class name on the current set elements.
			 *
			 * @method toggleClass
			 * @param {String} className Class name to add/remove.
			 * @param {Boolean} state Optional state to toggle on/off.
			 * @return {tinymce.dom.DomQuery} Current set.
			 */
			toggleClass: function(className, state) {
				var self = this;
	
				// Functions are not supported
				if (typeof className != 'string') {
					return self;
				}
	
				if (className.indexOf(' ') !== -1) {
					each(className.split(' '), function() {
						self.toggleClass(this, state);
					});
				} else {
					self.each(function(index, node) {
						var existingClassName, classState;
	
						classState = hasClass(node, className);
						if (classState !== state) {
							existingClassName = node.className;
	
							if (classState) {
								node.className = trim((" " + existingClassName + " ").replace(' ' + className + ' ', ' '));
							} else {
								node.className += existingClassName ? ' ' + className : className;
							}
						}
					});
				}
	
				return self;
			},
	
			/**
			 * Returns true/false if the first item in set has the specified class.
			 *
			 * @method hasClass
			 * @param {String} className Class name to check for.
			 * @return {Boolean} True/false if the set has the specified class.
			 */
			hasClass: function(className) {
				return hasClass(this[0], className);
			},
	
			/**
			 * Executes the callback function for each item DomQuery collection. If you return false in the
			 * callback it will break the loop.
			 *
			 * @method each
			 * @param {function} callback Callback function to execute for each item.
			 * @return {tinymce.dom.DomQuery} Current set.
			 */
			each: function(callback) {
				return each(this, callback);
			},
	
			/**
			 * Binds an event with callback function to the elements in set.
			 *
			 * @method on
			 * @param {String} name Name of the event to bind.
			 * @param {function} callback Callback function to execute when the event occurs.
			 * @return {tinymce.dom.DomQuery} Current set.
			 */
			on: function(name, callback) {
				return this.each(function() {
					Event.bind(this, name, callback);
				});
			},
	
			/**
			 * Unbinds an event with callback function to the elements in set.
			 *
			 * @method off
			 * @param {String} name Optional name of the event to bind.
			 * @param {function} callback Optional callback function to execute when the event occurs.
			 * @return {tinymce.dom.DomQuery} Current set.
			 */
			off: function(name, callback) {
				return this.each(function() {
					Event.unbind(this, name, callback);
				});
			},
	
			/**
			 * Triggers the specified event by name or event object.
			 *
			 * @method trigger
			 * @param {String/Object} name Name of the event to trigger or event object.
			 * @return {tinymce.dom.DomQuery} Current set.
			 */
			trigger: function(name) {
				return this.each(function() {
					if (typeof name == 'object') {
						Event.fire(this, name.type, name);
					} else {
						Event.fire(this, name);
					}
				});
			},
	
			/**
			 * Shows all elements in set.
			 *
			 * @method show
			 * @return {tinymce.dom.DomQuery} Current set.
			 */
			show: function() {
				return this.css('display', '');
			},
	
			/**
			 * Hides all elements in set.
			 *
			 * @method hide
			 * @return {tinymce.dom.DomQuery} Current set.
			 */
			hide: function() {
				return this.css('display', 'none');
			},
	
			/**
			 * Slices the current set.
			 *
			 * @method slice
			 * @param {Number} start Start index to slice at.
			 * @param {Number} end Optional end index to end slice at.
			 * @return {tinymce.dom.DomQuery} Sliced set.
			 */
			slice: function() {
				return new DomQuery(slice.apply(this, arguments));
			},
	
			/**
			 * Makes the set equal to the specified index.
			 *
			 * @method eq
			 * @param {Number} index Index to set it equal to.
			 * @return {tinymce.dom.DomQuery} Single item set.
			 */
			eq: function(index) {
				return index === -1 ? this.slice(index) : this.slice(index, +index + 1);
			},
	
			/**
			 * Makes the set equal to first element in set.
			 *
			 * @method first
			 * @return {tinymce.dom.DomQuery} Single item set.
			 */
			first: function() {
				return this.eq(0);
			},
	
			/**
			 * Makes the set equal to last element in set.
			 *
			 * @method last
			 * @return {tinymce.dom.DomQuery} Single item set.
			 */
			last: function() {
				return this.eq(-1);
			},
	
			/**
			 * Finds elements by the specified selector for each element in set.
			 *
			 * @method find
			 * @param {String} selector Selector to find elements by.
			 * @return {tinymce.dom.DomQuery} Set with matches elements.
			 */
			find: function(selector) {
				var i, l, ret = [];
	
				for (i = 0, l = this.length; i < l; i++) {
					DomQuery.find(selector, this[i], ret);
				}
	
				return DomQuery(ret);
			},
	
			/**
			 * Filters the current set with the specified selector.
			 *
			 * @method filter
			 * @param {String/function} selector Selector to filter elements by.
			 * @return {tinymce.dom.DomQuery} Set with filtered elements.
			 */
			filter: function(selector) {
				if (typeof selector == 'function') {
					return DomQuery(grep(this.toArray(), function(item, i) {
						return selector(i, item);
					}));
				}
	
				return DomQuery(DomQuery.filter(selector, this.toArray()));
			},
	
			/**
			 * Gets the current node or any parent matching the specified selector.
			 *
			 * @method closest
			 * @param {String/Element/tinymce.dom.DomQuery} selector Selector or element to find.
			 * @return {tinymce.dom.DomQuery} Set with closest elements.
			 */
			closest: function(selector) {
				var result = [];
	
				if (selector instanceof DomQuery) {
					selector = selector[0];
				}
	
				this.each(function(i, node) {
					while (node) {
						if (typeof selector == 'string' && DomQuery(node).is(selector)) {
							result.push(node);
							break;
						} else if (node == selector) {
							result.push(node);
							break;
						}
	
						node = node.parentNode;
					}
				});
	
				return DomQuery(result);
			},
	
			/**
			 * Returns the offset of the first element in set or sets the top/left css properties of all elements in set.
			 *
			 * @method offset
			 * @param {Object} offset Optional offset object to set on each item.
			 * @return {Object/tinymce.dom.DomQuery} Returns the first element offset or the current set if you specified an offset.
			 */
			offset: function(offset) {
				var elm, doc, docElm;
				var x = 0, y = 0, pos;
	
				if (!offset) {
					elm = this[0];
	
					if (elm) {
						doc = elm.ownerDocument;
						docElm = doc.documentElement;
	
						if (elm.getBoundingClientRect) {
							pos = elm.getBoundingClientRect();
							x = pos.left + (docElm.scrollLeft || doc.body.scrollLeft) - docElm.clientLeft;
							y = pos.top + (docElm.scrollTop || doc.body.scrollTop) - docElm.clientTop;
						}
					}
	
					return {
						left: x,
						top: y
					};
				}
	
				return this.css(offset);
			},
	
			push: push,
			sort: [].sort,
			splice: [].splice
		};
	
		// Static members
		Tools.extend(DomQuery, {
			/**
			 * Extends the specified object with one or more objects.
			 *
			 * @static
			 * @method extend
			 * @param {Object} target Target object to extend with new items.
			 * @param {Object..} object Object to extend the target with.
			 * @return {Object} Extended input object.
			 */
			extend: Tools.extend,
	
			/**
			 * Creates an array out of an array like object.
			 *
			 * @static
			 * @method makeArray
			 * @param {Object} object Object to convert to array.
			 * @return {Array} Array produced from object.
			 */
			makeArray: function(object) {
				if (isWindow(object) || object.nodeType) {
					return [object];
				}
	
				return Tools.toArray(object);
			},
	
			/**
			 * Returns the index of the specified item inside the array.
			 *
			 * @static
			 * @method inArray
			 * @param {Object} item Item to look for.
			 * @param {Array} array Array to look for item in.
			 * @return {Number} Index of the item or -1.
			 */
			inArray: inArray,
	
			/**
			 * Returns true/false if the specified object is an array or not.
			 *
			 * @static
			 * @method isArray
			 * @param {Object} array Object to check if it's an array or not.
			 * @return {Boolean} True/false if the object is an array.
			 */
			isArray: Tools.isArray,
	
			/**
			 * Executes the callback function for each item in array/object. If you return false in the
			 * callback it will break the loop.
			 *
			 * @static
			 * @method each
			 * @param {Object} obj Object to iterate.
			 * @param {function} callback Callback function to execute for each item.
			 */
			each: each,
	
			/**
			 * Removes whitespace from the beginning and end of a string.
			 *
			 * @static
			 * @method trim
			 * @param {String} str String to remove whitespace from.
			 * @return {String} New string with removed whitespace.
			 */
			trim: trim,
	
			/**
			 * Filters out items from the input array by calling the specified function for each item.
			 * If the function returns false the item will be excluded if it returns true it will be included.
			 *
			 * @static
			 * @method grep
			 * @param {Array} array Array of items to loop though.
			 * @param {function} callback Function to call for each item. Include/exclude depends on it's return value.
			 * @return {Array} New array with values imported and filtered based in input.
			 * @example
			 * // Filter out some items, this will return an array with 4 and 5
			 * var items = DomQuery.grep([1, 2, 3, 4, 5], function(v) {return v > 3;});
			 */
			grep: grep,
	
			// Sizzle
			find: Sizzle,
			expr: Sizzle.selectors,
			unique: Sizzle.uniqueSort,
			text: Sizzle.getText,
			contains: Sizzle.contains,
			filter: function(expr, elems, not) {
				var i = elems.length;
	
				if (not) {
					expr = ":not(" + expr + ")";
				}
	
				while (i--) {
					if (elems[i].nodeType != 1) {
						elems.splice(i, 1);
					}
				}
	
				if (elems.length === 1) {
					elems = DomQuery.find.matchesSelector(elems[0], expr) ? [elems[0]] : [];
				} else {
					elems = DomQuery.find.matches(expr, elems);
				}
	
				return elems;
			}
		});
	
		function dir(el, prop, until) {
			var matched = [], cur = el[prop];
	
			if (typeof until != 'string' && until instanceof DomQuery) {
				until = until[0];
			}
	
			while (cur && cur.nodeType !== 9) {
				if (until !== undefined) {
					if (cur === until) {
						break;
					}
	
					if (typeof until == 'string' && DomQuery(cur).is(until)) {
						break;
					}
				}
	
				if (cur.nodeType === 1) {
					matched.push(cur);
				}
	
				cur = cur[prop];
			}
	
			return matched;
		}
	
		function sibling(node, siblingName, nodeType, until) {
			var result = [];
	
			if (until instanceof DomQuery) {
				until = until[0];
			}
	
			for (; node; node = node[siblingName]) {
				if (nodeType && node.nodeType !== nodeType) {
					continue;
				}
	
				if (until !== undefined) {
					if (node === until) {
						break;
					}
	
					if (typeof until == 'string' && DomQuery(node).is(until)) {
						break;
					}
				}
	
				result.push(node);
			}
	
			return result;
		}
	
		function firstSibling(node, siblingName, nodeType) {
			for (node = node[siblingName]; node; node = node[siblingName]) {
				if (node.nodeType == nodeType) {
					return node;
				}
			}
	
			return null;
		}
	
		each({
			/**
			 * Returns a new collection with the parent of each item in current collection matching the optional selector.
			 *
			 * @method parent
			 * @param {Element/tinymce.dom.DomQuery} node Node to match parents against.
			 * @return {tinymce.dom.DomQuery} New DomQuery instance with all matching parents.
			 */
			parent: function(node) {
				var parent = node.parentNode;
	
				return parent && parent.nodeType !== 11 ? parent : null;
			},
	
			/**
			 * Returns a new collection with the all the parents of each item in current collection matching the optional selector.
			 *
			 * @method parents
			 * @param {Element/tinymce.dom.DomQuery} node Node to match parents against.
			 * @return {tinymce.dom.DomQuery} New DomQuery instance with all matching parents.
			 */
			parents: function(node) {
				return dir(node, "parentNode");
			},
	
			/**
			 * Returns a new collection with next sibling of each item in current collection matching the optional selector.
			 *
			 * @method next
			 * @param {Element/tinymce.dom.DomQuery} node Node to match the next element against.
			 * @return {tinymce.dom.DomQuery} New DomQuery instance with all matching elements.
			 */
			next: function(node) {
				return firstSibling(node, 'nextSibling', 1);
			},
	
			/**
			 * Returns a new collection with previous sibling of each item in current collection matching the optional selector.
			 *
			 * @method prev
			 * @param {Element/tinymce.dom.DomQuery} node Node to match the previous element against.
			 * @return {tinymce.dom.DomQuery} New DomQuery instance with all matching elements.
			 */
			prev: function(node) {
				return firstSibling(node, 'previousSibling', 1);
			},
	
			/**
			 * Returns all child elements matching the optional selector.
			 *
			 * @method children
			 * @param {Element/tinymce.dom.DomQuery} node Node to match the elements against.
			 * @return {tinymce.dom.DomQuery} New DomQuery instance with all matching elements.
			 */
			children: function(node) {
				return sibling(node.firstChild, 'nextSibling', 1);
			},
	
			/**
			 * Returns all child nodes matching the optional selector.
			 *
			 * @method contents
			 * @param {Element/tinymce.dom.DomQuery} node Node to get the contents of.
			 * @return {tinymce.dom.DomQuery} New DomQuery instance with all matching elements.
			 */
			contents: function(node) {
				return Tools.toArray((node.nodeName === "iframe" ? node.contentDocument || node.contentWindow.document : node).childNodes);
			}
		}, function(name, fn) {
			DomQuery.fn[name] = function(selector) {
				var self = this, result = [];
	
				self.each(function() {
					var nodes = fn.call(result, this, selector, result);
	
					if (nodes) {
						if (DomQuery.isArray(nodes)) {
							result.push.apply(result, nodes);
						} else {
							result.push(nodes);
						}
					}
				});
	
				// If traversing on multiple elements we might get the same elements twice
				if (this.length > 1) {
					if (!skipUniques[name]) {
						result = DomQuery.unique(result);
					}
	
					if (name.indexOf('parents') === 0) {
						result = result.reverse();
					}
				}
	
				result = DomQuery(result);
	
				if (selector) {
					return result.filter(selector);
				}
	
				return result;
			};
		});
	
		each({
			/**
			 * Returns a new collection with the all the parents until the matching selector/element
			 * of each item in current collection matching the optional selector.
			 *
			 * @method parentsUntil
			 * @param {Element/tinymce.dom.DomQuery} node Node to find parent of.
			 * @param {String/Element/tinymce.dom.DomQuery} until Until the matching selector or element.
			 * @return {tinymce.dom.DomQuery} New DomQuery instance with all matching parents.
			 */
			parentsUntil: function(node, until) {
				return dir(node, "parentNode", until);
			},
	
			/**
			 * Returns a new collection with all next siblings of each item in current collection matching the optional selector.
			 *
			 * @method nextUntil
			 * @param {Element/tinymce.dom.DomQuery} node Node to find next siblings on.
			 * @param {String/Element/tinymce.dom.DomQuery} until Until the matching selector or element.
			 * @return {tinymce.dom.DomQuery} New DomQuery instance with all matching elements.
			 */
			nextUntil: function(node, until) {
				return sibling(node, 'nextSibling', 1, until).slice(1);
			},
	
			/**
			 * Returns a new collection with all previous siblings of each item in current collection matching the optional selector.
			 *
			 * @method prevUntil
			 * @param {Element/tinymce.dom.DomQuery} node Node to find previous siblings on.
			 * @param {String/Element/tinymce.dom.DomQuery} until Until the matching selector or element.
			 * @return {tinymce.dom.DomQuery} New DomQuery instance with all matching elements.
			 */
			prevUntil: function(node, until) {
				return sibling(node, 'previousSibling', 1, until).slice(1);
			}
		}, function(name, fn) {
			DomQuery.fn[name] = function(selector, filter) {
				var self = this, result = [];
	
				self.each(function() {
					var nodes = fn.call(result, this, selector, result);
	
					if (nodes) {
						if (DomQuery.isArray(nodes)) {
							result.push.apply(result, nodes);
						} else {
							result.push(nodes);
						}
					}
				});
	
				// If traversing on multiple elements we might get the same elements twice
				if (this.length > 1) {
					result = DomQuery.unique(result);
	
					if (name.indexOf('parents') === 0 || name === 'prevUntil') {
						result = result.reverse();
					}
				}
	
				result = DomQuery(result);
	
				if (filter) {
					return result.filter(filter);
				}
	
				return result;
			};
		});
	
		/**
		 * Returns true/false if the current set items matches the selector.
		 *
		 * @method is
		 * @param {String} selector Selector to match the elements against.
		 * @return {Boolean} True/false if the current set matches the selector.
		 */
		DomQuery.fn.is = function(selector) {
			return !!selector && this.filter(selector).length > 0;
		};
	
		DomQuery.fn.init.prototype = DomQuery.fn;
	
		DomQuery.overrideDefaults = function(callback) {
			var defaults;
	
			function sub(selector, context) {
				defaults = defaults || callback();
	
				if (arguments.length === 0) {
					selector = defaults.element;
				}
	
				if (!context) {
					context = defaults.context;
				}
	
				return new sub.fn.init(selector, context);
			}
	
			DomQuery.extend(sub, this);
	
			return sub;
		};
	
		function appendHooks(targetHooks, prop, hooks) {
			each(hooks, function(name, func) {
				targetHooks[name] = targetHooks[name] || {};
				targetHooks[name][prop] = func;
			});
		}
	
		if (Env.ie && Env.ie < 8) {
			appendHooks(attrHooks, 'get', {
				maxlength: function(elm) {
					var value = elm.maxLength;
	
					if (value === 0x7fffffff) {
						return undef;
					}
	
					return value;
				},
	
				size: function(elm) {
					var value = elm.size;
	
					if (value === 20) {
						return undef;
					}
	
					return value;
				},
	
				'class': function(elm) {
					return elm.className;
				},
	
				style: function(elm) {
					var value = elm.style.cssText;
	
					if (value.length === 0) {
						return undef;
					}
	
					return value;
				}
			});
	
			appendHooks(attrHooks, 'set', {
				'class': function(elm, value) {
					elm.className = value;
				},
	
				style: function(elm, value) {
					elm.style.cssText = value;
				}
			});
		}
	
		if (Env.ie && Env.ie < 9) {
			/*jshint sub:true */
			/*eslint dot-notation: 0*/
			cssFix['float'] = 'styleFloat';
	
			appendHooks(cssHooks, 'set', {
				opacity: function(elm, value) {
					var style = elm.style;
	
					if (value === null || value === '') {
						style.removeAttribute('filter');
					} else {
						style.zoom = 1;
						style.filter = 'alpha(opacity=' + (value * 100) + ')';
					}
				}
			});
		}
	
		DomQuery.attrHooks = attrHooks;
		DomQuery.cssHooks = cssHooks;
	
		return DomQuery;
	});
	
	// Included from: js/tinymce/classes/html/Styles.js
	
	/**
	 * Styles.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This class is used to parse CSS styles it also compresses styles to reduce the output size.
	 *
	 * @example
	 * var Styles = new tinymce.html.Styles({
	 *    url_converter: function(url) {
	 *       return url;
	 *    }
	 * });
	 *
	 * styles = Styles.parse('border: 1px solid red');
	 * styles.color = 'red';
	 *
	 * console.log(new tinymce.html.StyleSerializer().serialize(styles));
	 *
	 * @class tinymce.html.Styles
	 * @version 3.4
	 */
	define("tinymce/html/Styles", [], function() {
		return function(settings, schema) {
			/*jshint maxlen:255 */
			/*eslint max-len:0 */
			var rgbRegExp = /rgb\s*\(\s*([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)\s*\)/gi,
				urlOrStrRegExp = /(?:url(?:(?:\(\s*\"([^\"]+)\"\s*\))|(?:\(\s*\'([^\']+)\'\s*\))|(?:\(\s*([^)\s]+)\s*\))))|(?:\'([^\']+)\')|(?:\"([^\"]+)\")/gi,
				styleRegExp = /\s*([^:]+):\s*([^;]+);?/g,
				trimRightRegExp = /\s+$/,
				i, encodingLookup = {}, encodingItems, validStyles, invalidStyles, invisibleChar = '\uFEFF';
	
			settings = settings || {};
	
			if (schema) {
				validStyles = schema.getValidStyles();
				invalidStyles = schema.getInvalidStyles();
			}
	
			encodingItems = ('\\" \\\' \\; \\: ; : ' + invisibleChar).split(' ');
			for (i = 0; i < encodingItems.length; i++) {
				encodingLookup[encodingItems[i]] = invisibleChar + i;
				encodingLookup[invisibleChar + i] = encodingItems[i];
			}
	
			function toHex(match, r, g, b) {
				function hex(val) {
					val = parseInt(val, 10).toString(16);
	
					return val.length > 1 ? val : '0' + val; // 0 -> 00
				}
	
				return '#' + hex(r) + hex(g) + hex(b);
			}
	
			return {
				/**
				 * Parses the specified RGB color value and returns a hex version of that color.
				 *
				 * @method toHex
				 * @param {String} color RGB string value like rgb(1,2,3)
				 * @return {String} Hex version of that RGB value like #FF00FF.
				 */
				toHex: function(color) {
					return color.replace(rgbRegExp, toHex);
				},
	
				/**
				 * Parses the specified style value into an object collection. This parser will also
				 * merge and remove any redundant items that browsers might have added. It will also convert non hex
				 * colors to hex values. Urls inside the styles will also be converted to absolute/relative based on settings.
				 *
				 * @method parse
				 * @param {String} css Style value to parse for example: border:1px solid red;.
				 * @return {Object} Object representation of that style like {border: '1px solid red'}
				 */
				parse: function(css) {
					var styles = {}, matches, name, value, isEncoded, urlConverter = settings.url_converter;
					var urlConverterScope = settings.url_converter_scope || this;
	
					function compress(prefix, suffix, noJoin) {
						var top, right, bottom, left;
	
						top = styles[prefix + '-top' + suffix];
						if (!top) {
							return;
						}
	
						right = styles[prefix + '-right' + suffix];
						if (!right) {
							return;
						}
	
						bottom = styles[prefix + '-bottom' + suffix];
						if (!bottom) {
							return;
						}
	
						left = styles[prefix + '-left' + suffix];
						if (!left) {
							return;
						}
	
						var box = [top, right, bottom, left];
						i = box.length - 1;
						while (i--) {
							if (box[i] !== box[i + 1]) {
								break;
							}
						}
	
						if (i > -1 && noJoin) {
							return;
						}
	
						styles[prefix + suffix] = i == -1 ? box[0] : box.join(' ');
						delete styles[prefix + '-top' + suffix];
						delete styles[prefix + '-right' + suffix];
						delete styles[prefix + '-bottom' + suffix];
						delete styles[prefix + '-left' + suffix];
					}
	
					/**
					 * Checks if the specific style can be compressed in other words if all border-width are equal.
					 */
					function canCompress(key) {
						var value = styles[key], i;
	
						if (!value) {
							return;
						}
	
						value = value.split(' ');
						i = value.length;
						while (i--) {
							if (value[i] !== value[0]) {
								return false;
							}
						}
	
						styles[key] = value[0];
	
						return true;
					}
	
					/**
					 * Compresses multiple styles into one style.
					 */
					function compress2(target, a, b, c) {
						if (!canCompress(a)) {
							return;
						}
	
						if (!canCompress(b)) {
							return;
						}
	
						if (!canCompress(c)) {
							return;
						}
	
						// Compress
						styles[target] = styles[a] + ' ' + styles[b] + ' ' + styles[c];
						delete styles[a];
						delete styles[b];
						delete styles[c];
					}
	
					// Encodes the specified string by replacing all \" \' ; : with _<num>
					function encode(str) {
						isEncoded = true;
	
						return encodingLookup[str];
					}
	
					// Decodes the specified string by replacing all _<num> with it's original value \" \' etc
					// It will also decode the \" \' if keep_slashes is set to fale or omitted
					function decode(str, keep_slashes) {
						if (isEncoded) {
							str = str.replace(/\uFEFF[0-9]/g, function(str) {
								return encodingLookup[str];
							});
						}
	
						if (!keep_slashes) {
							str = str.replace(/\\([\'\";:])/g, "$1");
						}
	
						return str;
					}
	
					function decodeSingleHexSequence(escSeq) {
						return String.fromCharCode(parseInt(escSeq.slice(1), 16));
					}
	
					function decodeHexSequences(value) {
						return value.replace(/\\[0-9a-f]+/gi, decodeSingleHexSequence);
					}
	
					function processUrl(match, url, url2, url3, str, str2) {
						str = str || str2;
	
						if (str) {
							str = decode(str);
	
							// Force strings into single quote format
							return "'" + str.replace(/\'/g, "\\'") + "'";
						}
	
						url = decode(url || url2 || url3);
	
						if (!settings.allow_script_urls) {
							var scriptUrl = url.replace(/[\s\r\n]+/g, '');
	
							if (/(java|vb)script:/i.test(scriptUrl)) {
								return "";
							}
	
							if (!settings.allow_svg_data_urls && /^data:image\/svg/i.test(scriptUrl)) {
								return "";
							}
						}
	
						// Convert the URL to relative/absolute depending on config
						if (urlConverter) {
							url = urlConverter.call(urlConverterScope, url, 'style');
						}
	
						// Output new URL format
						return "url('" + url.replace(/\'/g, "\\'") + "')";
					}
	
					if (css) {
						css = css.replace(/[\u0000-\u001F]/g, '');
	
						// Encode \" \' % and ; and : inside strings so they don't interfere with the style parsing
						css = css.replace(/\\[\"\';:\uFEFF]/g, encode).replace(/\"[^\"]+\"|\'[^\']+\'/g, function(str) {
							return str.replace(/[;:]/g, encode);
						});
	
						// Parse styles
						while ((matches = styleRegExp.exec(css))) {
							styleRegExp.lastIndex = matches.index + matches[0].length;
							name = matches[1].replace(trimRightRegExp, '').toLowerCase();
							value = matches[2].replace(trimRightRegExp, '');
	
							if (name && value) {
								// Decode escaped sequences like \65 -> e
								name = decodeHexSequences(name);
								value = decodeHexSequences(value);
	
								// Skip properties with double quotes and sequences like \" \' in their names
								// See 'mXSS Attacks: Attacking well-secured Web-Applications by using innerHTML Mutations'
								// https://cure53.de/fp170.pdf
								if (name.indexOf(invisibleChar) !== -1 || name.indexOf('"') !== -1) {
									continue;
								}
	
								// Don't allow behavior name or expression/comments within the values
								if (!settings.allow_script_urls && (name == "behavior" || /expression\s*\(|\/\*|\*\//.test(value))) {
									continue;
								}
	
								// Opera will produce 700 instead of bold in their style values
								if (name === 'font-weight' && value === '700') {
									value = 'bold';
								} else if (name === 'color' || name === 'background-color') { // Lowercase colors like RED
									value = value.toLowerCase();
								}
	
								// Convert RGB colors to HEX
								value = value.replace(rgbRegExp, toHex);
	
								// Convert URLs and force them into url('value') format
								value = value.replace(urlOrStrRegExp, processUrl);
								styles[name] = isEncoded ? decode(value, true) : value;
							}
						}
						// Compress the styles to reduce it's size for example IE will expand styles
						compress("border", "", true);
						compress("border", "-width");
						compress("border", "-color");
						compress("border", "-style");
						compress("padding", "");
						compress("margin", "");
						compress2('border', 'border-width', 'border-style', 'border-color');
	
						// Remove pointless border, IE produces these
						if (styles.border === 'medium none') {
							delete styles.border;
						}
	
						// IE 11 will produce a border-image: none when getting the style attribute from <p style="border: 1px solid red"></p>
						// So let us assume it shouldn't be there
						if (styles['border-image'] === 'none') {
							delete styles['border-image'];
						}
					}
	
					return styles;
				},
	
				/**
				 * Serializes the specified style object into a string.
				 *
				 * @method serialize
				 * @param {Object} styles Object to serialize as string for example: {border: '1px solid red'}
				 * @param {String} elementName Optional element name, if specified only the styles that matches the schema will be serialized.
				 * @return {String} String representation of the style object for example: border: 1px solid red.
				 */
				serialize: function(styles, elementName) {
					var css = '', name, value;
	
					function serializeStyles(name) {
						var styleList, i, l, value;
	
						styleList = validStyles[name];
						if (styleList) {
							for (i = 0, l = styleList.length; i < l; i++) {
								name = styleList[i];
								value = styles[name];
	
								if (value) {
									css += (css.length > 0 ? ' ' : '') + name + ': ' + value + ';';
								}
							}
						}
					}
	
					function isValid(name, elementName) {
						var styleMap;
	
						styleMap = invalidStyles['*'];
						if (styleMap && styleMap[name]) {
							return false;
						}
	
						styleMap = invalidStyles[elementName];
						if (styleMap && styleMap[name]) {
							return false;
						}
	
						return true;
					}
	
					// Serialize styles according to schema
					if (elementName && validStyles) {
						// Serialize global styles and element specific styles
						serializeStyles('*');
						serializeStyles(elementName);
					} else {
						// Output the styles in the order they are inside the object
						for (name in styles) {
							value = styles[name];
	
							if (value && (!invalidStyles || isValid(name, elementName))) {
								css += (css.length > 0 ? ' ' : '') + name + ': ' + value + ';';
							}
						}
					}
	
					return css;
				}
			};
		};
	});
	
	// Included from: js/tinymce/classes/dom/TreeWalker.js
	
	/**
	 * TreeWalker.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * TreeWalker class enables you to walk the DOM in a linear manner.
	 *
	 * @class tinymce.dom.TreeWalker
	 * @example
	 * var walker = new tinymce.dom.TreeWalker(startNode);
	 *
	 * do {
	 *     console.log(walker.current());
	 * } while (walker.next());
	 */
	define("tinymce/dom/TreeWalker", [], function() {
		/**
		 * Constructs a new TreeWalker instance.
		 *
		 * @constructor
		 * @method TreeWalker
		 * @param {Node} startNode Node to start walking from.
		 * @param {node} rootNode Optional root node to never walk out of.
		 */
		return function(startNode, rootNode) {
			var node = startNode;
	
			function findSibling(node, startName, siblingName, shallow) {
				var sibling, parent;
	
				if (node) {
					// Walk into nodes if it has a start
					if (!shallow && node[startName]) {
						return node[startName];
					}
	
					// Return the sibling if it has one
					if (node != rootNode) {
						sibling = node[siblingName];
						if (sibling) {
							return sibling;
						}
	
						// Walk up the parents to look for siblings
						for (parent = node.parentNode; parent && parent != rootNode; parent = parent.parentNode) {
							sibling = parent[siblingName];
							if (sibling) {
								return sibling;
							}
						}
					}
				}
			}
	
			function findPreviousNode(node, startName, siblingName, shallow) {
				var sibling, parent, child;
	
				if (node) {
					sibling = node[siblingName];
					if (rootNode && sibling === rootNode) {
						return;
					}
	
					if (sibling) {
						if (!shallow) {
							// Walk up the parents to look for siblings
							for (child = sibling[startName]; child; child = child[startName]) {
								if (!child[startName]) {
									return child;
								}
							}
						}
	
						return sibling;
					}
	
					parent = node.parentNode;
					if (parent && parent !== rootNode) {
						return parent;
					}
				}
			}
	
			/**
			 * Returns the current node.
			 *
			 * @method current
			 * @return {Node} Current node where the walker is.
			 */
			this.current = function() {
				return node;
			};
	
			/**
			 * Walks to the next node in tree.
			 *
			 * @method next
			 * @return {Node} Current node where the walker is after moving to the next node.
			 */
			this.next = function(shallow) {
				node = findSibling(node, 'firstChild', 'nextSibling', shallow);
				return node;
			};
	
			/**
			 * Walks to the previous node in tree.
			 *
			 * @method prev
			 * @return {Node} Current node where the walker is after moving to the previous node.
			 */
			this.prev = function(shallow) {
				node = findSibling(node, 'lastChild', 'previousSibling', shallow);
				return node;
			};
	
			this.prev2 = function(shallow) {
				node = findPreviousNode(node, 'lastChild', 'previousSibling', shallow);
				return node;
			};
		};
	});
	
	// Included from: js/tinymce/classes/dom/Range.js
	
	/**
	 * Range.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Old IE Range.
	 *
	 * @private
	 * @class tinymce.dom.Range
	 */
	define("tinymce/dom/Range", [
		"tinymce/util/Tools"
	], function(Tools) {
		// Range constructor
		function Range(dom) {
			var self = this,
				doc = dom.doc,
				EXTRACT = 0,
				CLONE = 1,
				DELETE = 2,
				TRUE = true,
				FALSE = false,
				START_OFFSET = 'startOffset',
				START_CONTAINER = 'startContainer',
				END_CONTAINER = 'endContainer',
				END_OFFSET = 'endOffset',
				extend = Tools.extend,
				nodeIndex = dom.nodeIndex;
	
			function createDocumentFragment() {
				return doc.createDocumentFragment();
			}
	
			function setStart(n, o) {
				_setEndPoint(TRUE, n, o);
			}
	
			function setEnd(n, o) {
				_setEndPoint(FALSE, n, o);
			}
	
			function setStartBefore(n) {
				setStart(n.parentNode, nodeIndex(n));
			}
	
			function setStartAfter(n) {
				setStart(n.parentNode, nodeIndex(n) + 1);
			}
	
			function setEndBefore(n) {
				setEnd(n.parentNode, nodeIndex(n));
			}
	
			function setEndAfter(n) {
				setEnd(n.parentNode, nodeIndex(n) + 1);
			}
	
			function collapse(ts) {
				if (ts) {
					self[END_CONTAINER] = self[START_CONTAINER];
					self[END_OFFSET] = self[START_OFFSET];
				} else {
					self[START_CONTAINER] = self[END_CONTAINER];
					self[START_OFFSET] = self[END_OFFSET];
				}
	
				self.collapsed = TRUE;
			}
	
			function selectNode(n) {
				setStartBefore(n);
				setEndAfter(n);
			}
	
			function selectNodeContents(n) {
				setStart(n, 0);
				setEnd(n, n.nodeType === 1 ? n.childNodes.length : n.nodeValue.length);
			}
	
			function compareBoundaryPoints(h, r) {
				var sc = self[START_CONTAINER], so = self[START_OFFSET], ec = self[END_CONTAINER], eo = self[END_OFFSET],
				rsc = r.startContainer, rso = r.startOffset, rec = r.endContainer, reo = r.endOffset;
	
				// Check START_TO_START
				if (h === 0) {
					return _compareBoundaryPoints(sc, so, rsc, rso);
				}
	
				// Check START_TO_END
				if (h === 1) {
					return _compareBoundaryPoints(ec, eo, rsc, rso);
				}
	
				// Check END_TO_END
				if (h === 2) {
					return _compareBoundaryPoints(ec, eo, rec, reo);
				}
	
				// Check END_TO_START
				if (h === 3) {
					return _compareBoundaryPoints(sc, so, rec, reo);
				}
			}
	
			function deleteContents() {
				_traverse(DELETE);
			}
	
			function extractContents() {
				return _traverse(EXTRACT);
			}
	
			function cloneContents() {
				return _traverse(CLONE);
			}
	
			function insertNode(n) {
				var startContainer = this[START_CONTAINER],
					startOffset = this[START_OFFSET], nn, o;
	
				// Node is TEXT_NODE or CDATA
				if ((startContainer.nodeType === 3 || startContainer.nodeType === 4) && startContainer.nodeValue) {
					if (!startOffset) {
						// At the start of text
						startContainer.parentNode.insertBefore(n, startContainer);
					} else if (startOffset >= startContainer.nodeValue.length) {
						// At the end of text
						dom.insertAfter(n, startContainer);
					} else {
						// Middle, need to split
						nn = startContainer.splitText(startOffset);
						startContainer.parentNode.insertBefore(n, nn);
					}
				} else {
					// Insert element node
					if (startContainer.childNodes.length > 0) {
						o = startContainer.childNodes[startOffset];
					}
	
					if (o) {
						startContainer.insertBefore(n, o);
					} else {
						if (startContainer.nodeType == 3) {
							dom.insertAfter(n, startContainer);
						} else {
							startContainer.appendChild(n);
						}
					}
				}
			}
	
			function surroundContents(n) {
				var f = self.extractContents();
	
				self.insertNode(n);
				n.appendChild(f);
				self.selectNode(n);
			}
	
			function cloneRange() {
				return extend(new Range(dom), {
					startContainer: self[START_CONTAINER],
					startOffset: self[START_OFFSET],
					endContainer: self[END_CONTAINER],
					endOffset: self[END_OFFSET],
					collapsed: self.collapsed,
					commonAncestorContainer: self.commonAncestorContainer
				});
			}
	
			// Private methods
	
			function _getSelectedNode(container, offset) {
				var child;
	
				// TEXT_NODE
				if (container.nodeType == 3) {
					return container;
				}
	
				if (offset < 0) {
					return container;
				}
	
				child = container.firstChild;
				while (child && offset > 0) {
					--offset;
					child = child.nextSibling;
				}
	
				if (child) {
					return child;
				}
	
				return container;
			}
	
			function _isCollapsed() {
				return (self[START_CONTAINER] == self[END_CONTAINER] && self[START_OFFSET] == self[END_OFFSET]);
			}
	
			function _compareBoundaryPoints(containerA, offsetA, containerB, offsetB) {
				var c, offsetC, n, cmnRoot, childA, childB;
	
				// In the first case the boundary-points have the same container. A is before B
				// if its offset is less than the offset of B, A is equal to B if its offset is
				// equal to the offset of B, and A is after B if its offset is greater than the
				// offset of B.
				if (containerA == containerB) {
					if (offsetA == offsetB) {
						return 0; // equal
					}
	
					if (offsetA < offsetB) {
						return -1; // before
					}
	
					return 1; // after
				}
	
				// In the second case a child node C of the container of A is an ancestor
				// container of B. In this case, A is before B if the offset of A is less than or
				// equal to the index of the child node C and A is after B otherwise.
				c = containerB;
				while (c && c.parentNode != containerA) {
					c = c.parentNode;
				}
	
				if (c) {
					offsetC = 0;
					n = containerA.firstChild;
	
					while (n != c && offsetC < offsetA) {
						offsetC++;
						n = n.nextSibling;
					}
	
					if (offsetA <= offsetC) {
						return -1; // before
					}
	
					return 1; // after
				}
	
				// In the third case a child node C of the container of B is an ancestor container
				// of A. In this case, A is before B if the index of the child node C is less than
				// the offset of B and A is after B otherwise.
				c = containerA;
				while (c && c.parentNode != containerB) {
					c = c.parentNode;
				}
	
				if (c) {
					offsetC = 0;
					n = containerB.firstChild;
	
					while (n != c && offsetC < offsetB) {
						offsetC++;
						n = n.nextSibling;
					}
	
					if (offsetC < offsetB) {
						return -1; // before
					}
	
					return 1; // after
				}
	
				// In the fourth case, none of three other cases hold: the containers of A and B
				// are siblings or descendants of sibling nodes. In this case, A is before B if
				// the container of A is before the container of B in a pre-order traversal of the
				// Ranges' context tree and A is after B otherwise.
				cmnRoot = dom.findCommonAncestor(containerA, containerB);
				childA = containerA;
	
				while (childA && childA.parentNode != cmnRoot) {
					childA = childA.parentNode;
				}
	
				if (!childA) {
					childA = cmnRoot;
				}
	
				childB = containerB;
				while (childB && childB.parentNode != cmnRoot) {
					childB = childB.parentNode;
				}
	
				if (!childB) {
					childB = cmnRoot;
				}
	
				if (childA == childB) {
					return 0; // equal
				}
	
				n = cmnRoot.firstChild;
				while (n) {
					if (n == childA) {
						return -1; // before
					}
	
					if (n == childB) {
						return 1; // after
					}
	
					n = n.nextSibling;
				}
			}
	
			function _setEndPoint(st, n, o) {
				var ec, sc;
	
				if (st) {
					self[START_CONTAINER] = n;
					self[START_OFFSET] = o;
				} else {
					self[END_CONTAINER] = n;
					self[END_OFFSET] = o;
				}
	
				// If one boundary-point of a Range is set to have a root container
				// other than the current one for the Range, the Range is collapsed to
				// the new position. This enforces the restriction that both boundary-
				// points of a Range must have the same root container.
				ec = self[END_CONTAINER];
				while (ec.parentNode) {
					ec = ec.parentNode;
				}
	
				sc = self[START_CONTAINER];
				while (sc.parentNode) {
					sc = sc.parentNode;
				}
	
				if (sc == ec) {
					// The start position of a Range is guaranteed to never be after the
					// end position. To enforce this restriction, if the start is set to
					// be at a position after the end, the Range is collapsed to that
					// position.
					if (_compareBoundaryPoints(self[START_CONTAINER], self[START_OFFSET], self[END_CONTAINER], self[END_OFFSET]) > 0) {
						self.collapse(st);
					}
				} else {
					self.collapse(st);
				}
	
				self.collapsed = _isCollapsed();
				self.commonAncestorContainer = dom.findCommonAncestor(self[START_CONTAINER], self[END_CONTAINER]);
			}
	
			function _traverse(how) {
				var c, endContainerDepth = 0, startContainerDepth = 0, p, depthDiff, startNode, endNode, sp, ep;
	
				if (self[START_CONTAINER] == self[END_CONTAINER]) {
					return _traverseSameContainer(how);
				}
	
				for (c = self[END_CONTAINER], p = c.parentNode; p; c = p, p = p.parentNode) {
					if (p == self[START_CONTAINER]) {
						return _traverseCommonStartContainer(c, how);
					}
	
					++endContainerDepth;
				}
	
				for (c = self[START_CONTAINER], p = c.parentNode; p; c = p, p = p.parentNode) {
					if (p == self[END_CONTAINER]) {
						return _traverseCommonEndContainer(c, how);
					}
	
					++startContainerDepth;
				}
	
				depthDiff = startContainerDepth - endContainerDepth;
	
				startNode = self[START_CONTAINER];
				while (depthDiff > 0) {
					startNode = startNode.parentNode;
					depthDiff--;
				}
	
				endNode = self[END_CONTAINER];
				while (depthDiff < 0) {
					endNode = endNode.parentNode;
					depthDiff++;
				}
	
				// ascend the ancestor hierarchy until we have a common parent.
				for (sp = startNode.parentNode, ep = endNode.parentNode; sp != ep; sp = sp.parentNode, ep = ep.parentNode) {
					startNode = sp;
					endNode = ep;
				}
	
				return _traverseCommonAncestors(startNode, endNode, how);
			}
	
			function _traverseSameContainer(how) {
				var frag, s, sub, n, cnt, sibling, xferNode, start, len;
	
				if (how != DELETE) {
					frag = createDocumentFragment();
				}
	
				// If selection is empty, just return the fragment
				if (self[START_OFFSET] == self[END_OFFSET]) {
					return frag;
				}
	
				// Text node needs special case handling
				if (self[START_CONTAINER].nodeType == 3) { // TEXT_NODE
					// get the substring
					s = self[START_CONTAINER].nodeValue;
					sub = s.substring(self[START_OFFSET], self[END_OFFSET]);
	
					// set the original text node to its new value
					if (how != CLONE) {
						n = self[START_CONTAINER];
						start = self[START_OFFSET];
						len = self[END_OFFSET] - self[START_OFFSET];
	
						if (start === 0 && len >= n.nodeValue.length - 1) {
							n.parentNode.removeChild(n);
						} else {
							n.deleteData(start, len);
						}
	
						// Nothing is partially selected, so collapse to start point
						self.collapse(TRUE);
					}
	
					if (how == DELETE) {
						return;
					}
	
					if (sub.length > 0) {
						frag.appendChild(doc.createTextNode(sub));
					}
	
					return frag;
				}
	
				// Copy nodes between the start/end offsets.
				n = _getSelectedNode(self[START_CONTAINER], self[START_OFFSET]);
				cnt = self[END_OFFSET] - self[START_OFFSET];
	
				while (n && cnt > 0) {
					sibling = n.nextSibling;
					xferNode = _traverseFullySelected(n, how);
	
					if (frag) {
						frag.appendChild(xferNode);
					}
	
					--cnt;
					n = sibling;
				}
	
				// Nothing is partially selected, so collapse to start point
				if (how != CLONE) {
					self.collapse(TRUE);
				}
	
				return frag;
			}
	
			function _traverseCommonStartContainer(endAncestor, how) {
				var frag, n, endIdx, cnt, sibling, xferNode;
	
				if (how != DELETE) {
					frag = createDocumentFragment();
				}
	
				n = _traverseRightBoundary(endAncestor, how);
	
				if (frag) {
					frag.appendChild(n);
				}
	
				endIdx = nodeIndex(endAncestor);
				cnt = endIdx - self[START_OFFSET];
	
				if (cnt <= 0) {
					// Collapse to just before the endAncestor, which
					// is partially selected.
					if (how != CLONE) {
						self.setEndBefore(endAncestor);
						self.collapse(FALSE);
					}
	
					return frag;
				}
	
				n = endAncestor.previousSibling;
				while (cnt > 0) {
					sibling = n.previousSibling;
					xferNode = _traverseFullySelected(n, how);
	
					if (frag) {
						frag.insertBefore(xferNode, frag.firstChild);
					}
	
					--cnt;
					n = sibling;
				}
	
				// Collapse to just before the endAncestor, which
				// is partially selected.
				if (how != CLONE) {
					self.setEndBefore(endAncestor);
					self.collapse(FALSE);
				}
	
				return frag;
			}
	
			function _traverseCommonEndContainer(startAncestor, how) {
				var frag, startIdx, n, cnt, sibling, xferNode;
	
				if (how != DELETE) {
					frag = createDocumentFragment();
				}
	
				n = _traverseLeftBoundary(startAncestor, how);
				if (frag) {
					frag.appendChild(n);
				}
	
				startIdx = nodeIndex(startAncestor);
				++startIdx; // Because we already traversed it
	
				cnt = self[END_OFFSET] - startIdx;
				n = startAncestor.nextSibling;
				while (n && cnt > 0) {
					sibling = n.nextSibling;
					xferNode = _traverseFullySelected(n, how);
	
					if (frag) {
						frag.appendChild(xferNode);
					}
	
					--cnt;
					n = sibling;
				}
	
				if (how != CLONE) {
					self.setStartAfter(startAncestor);
					self.collapse(TRUE);
				}
	
				return frag;
			}
	
			function _traverseCommonAncestors(startAncestor, endAncestor, how) {
				var n, frag, startOffset, endOffset, cnt, sibling, nextSibling;
	
				if (how != DELETE) {
					frag = createDocumentFragment();
				}
	
				n = _traverseLeftBoundary(startAncestor, how);
				if (frag) {
					frag.appendChild(n);
				}
	
				startOffset = nodeIndex(startAncestor);
				endOffset = nodeIndex(endAncestor);
				++startOffset;
	
				cnt = endOffset - startOffset;
				sibling = startAncestor.nextSibling;
	
				while (cnt > 0) {
					nextSibling = sibling.nextSibling;
					n = _traverseFullySelected(sibling, how);
	
					if (frag) {
						frag.appendChild(n);
					}
	
					sibling = nextSibling;
					--cnt;
				}
	
				n = _traverseRightBoundary(endAncestor, how);
	
				if (frag) {
					frag.appendChild(n);
				}
	
				if (how != CLONE) {
					self.setStartAfter(startAncestor);
					self.collapse(TRUE);
				}
	
				return frag;
			}
	
			function _traverseRightBoundary(root, how) {
				var next = _getSelectedNode(self[END_CONTAINER], self[END_OFFSET] - 1), parent, clonedParent;
				var prevSibling, clonedChild, clonedGrandParent, isFullySelected = next != self[END_CONTAINER];
	
				if (next == root) {
					return _traverseNode(next, isFullySelected, FALSE, how);
				}
	
				parent = next.parentNode;
				clonedParent = _traverseNode(parent, FALSE, FALSE, how);
	
				while (parent) {
					while (next) {
						prevSibling = next.previousSibling;
						clonedChild = _traverseNode(next, isFullySelected, FALSE, how);
	
						if (how != DELETE) {
							clonedParent.insertBefore(clonedChild, clonedParent.firstChild);
						}
	
						isFullySelected = TRUE;
						next = prevSibling;
					}
	
					if (parent == root) {
						return clonedParent;
					}
	
					next = parent.previousSibling;
					parent = parent.parentNode;
	
					clonedGrandParent = _traverseNode(parent, FALSE, FALSE, how);
	
					if (how != DELETE) {
						clonedGrandParent.appendChild(clonedParent);
					}
	
					clonedParent = clonedGrandParent;
				}
			}
	
			function _traverseLeftBoundary(root, how) {
				var next = _getSelectedNode(self[START_CONTAINER], self[START_OFFSET]), isFullySelected = next != self[START_CONTAINER];
				var parent, clonedParent, nextSibling, clonedChild, clonedGrandParent;
	
				if (next == root) {
					return _traverseNode(next, isFullySelected, TRUE, how);
				}
	
				parent = next.parentNode;
				clonedParent = _traverseNode(parent, FALSE, TRUE, how);
	
				while (parent) {
					while (next) {
						nextSibling = next.nextSibling;
						clonedChild = _traverseNode(next, isFullySelected, TRUE, how);
	
						if (how != DELETE) {
							clonedParent.appendChild(clonedChild);
						}
	
						isFullySelected = TRUE;
						next = nextSibling;
					}
	
					if (parent == root) {
						return clonedParent;
					}
	
					next = parent.nextSibling;
					parent = parent.parentNode;
	
					clonedGrandParent = _traverseNode(parent, FALSE, TRUE, how);
	
					if (how != DELETE) {
						clonedGrandParent.appendChild(clonedParent);
					}
	
					clonedParent = clonedGrandParent;
				}
			}
	
			function _traverseNode(n, isFullySelected, isLeft, how) {
				var txtValue, newNodeValue, oldNodeValue, offset, newNode;
	
				if (isFullySelected) {
					return _traverseFullySelected(n, how);
				}
	
				// TEXT_NODE
				if (n.nodeType == 3) {
					txtValue = n.nodeValue;
	
					if (isLeft) {
						offset = self[START_OFFSET];
						newNodeValue = txtValue.substring(offset);
						oldNodeValue = txtValue.substring(0, offset);
					} else {
						offset = self[END_OFFSET];
						newNodeValue = txtValue.substring(0, offset);
						oldNodeValue = txtValue.substring(offset);
					}
	
					if (how != CLONE) {
						n.nodeValue = oldNodeValue;
					}
	
					if (how == DELETE) {
						return;
					}
	
					newNode = dom.clone(n, FALSE);
					newNode.nodeValue = newNodeValue;
	
					return newNode;
				}
	
				if (how == DELETE) {
					return;
				}
	
				return dom.clone(n, FALSE);
			}
	
			function _traverseFullySelected(n, how) {
				if (how != DELETE) {
					return how == CLONE ? dom.clone(n, TRUE) : n;
				}
	
				n.parentNode.removeChild(n);
			}
	
			function toStringIE() {
				return dom.create('body', null, cloneContents()).outerText;
			}
	
			extend(self, {
				// Initial states
				startContainer: doc,
				startOffset: 0,
				endContainer: doc,
				endOffset: 0,
				collapsed: TRUE,
				commonAncestorContainer: doc,
	
				// Range constants
				START_TO_START: 0,
				START_TO_END: 1,
				END_TO_END: 2,
				END_TO_START: 3,
	
				// Public methods
				setStart: setStart,
				setEnd: setEnd,
				setStartBefore: setStartBefore,
				setStartAfter: setStartAfter,
				setEndBefore: setEndBefore,
				setEndAfter: setEndAfter,
				collapse: collapse,
				selectNode: selectNode,
				selectNodeContents: selectNodeContents,
				compareBoundaryPoints: compareBoundaryPoints,
				deleteContents: deleteContents,
				extractContents: extractContents,
				cloneContents: cloneContents,
				insertNode: insertNode,
				surroundContents: surroundContents,
				cloneRange: cloneRange,
				toStringIE: toStringIE
			});
	
			return self;
		}
	
		// Older IE versions doesn't let you override toString by it's constructor so we have to stick it in the prototype
		Range.prototype.toString = function() {
			return this.toStringIE();
		};
	
		return Range;
	});
	
	// Included from: js/tinymce/classes/html/Entities.js
	
	/**
	 * Entities.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/*jshint bitwise:false */
	/*eslint no-bitwise:0 */
	
	/**
	 * Entity encoder class.
	 *
	 * @class tinymce.html.Entities
	 * @static
	 * @version 3.4
	 */
	define("tinymce/html/Entities", [
		"tinymce/util/Tools"
	], function(Tools) {
		var makeMap = Tools.makeMap;
	
		var namedEntities, baseEntities, reverseEntities,
			attrsCharsRegExp = /[&<>\"\u0060\u007E-\uD7FF\uE000-\uFFEF]|[\uD800-\uDBFF][\uDC00-\uDFFF]/g,
			textCharsRegExp = /[<>&\u007E-\uD7FF\uE000-\uFFEF]|[\uD800-\uDBFF][\uDC00-\uDFFF]/g,
			rawCharsRegExp = /[<>&\"\']/g,
			entityRegExp = /&#([a-z0-9]+);?|&([a-z0-9]+);/gi,
			asciiMap = {
				128: "\u20AC", 130: "\u201A", 131: "\u0192", 132: "\u201E", 133: "\u2026", 134: "\u2020",
				135: "\u2021", 136: "\u02C6", 137: "\u2030", 138: "\u0160", 139: "\u2039", 140: "\u0152",
				142: "\u017D", 145: "\u2018", 146: "\u2019", 147: "\u201C", 148: "\u201D", 149: "\u2022",
				150: "\u2013", 151: "\u2014", 152: "\u02DC", 153: "\u2122", 154: "\u0161", 155: "\u203A",
				156: "\u0153", 158: "\u017E", 159: "\u0178"
			};
	
		// Raw entities
		baseEntities = {
			'\"': '&quot;', // Needs to be escaped since the YUI compressor would otherwise break the code
			"'": '&#39;',
			'<': '&lt;',
			'>': '&gt;',
			'&': '&amp;',
			'\u0060': '&#96;'
		};
	
		// Reverse lookup table for raw entities
		reverseEntities = {
			'&lt;': '<',
			'&gt;': '>',
			'&amp;': '&',
			'&quot;': '"',
			'&apos;': "'"
		};
	
		// Decodes text by using the browser
		function nativeDecode(text) {
			var elm;
	
			elm = document.createElement("div");
			elm.innerHTML = text;
	
			return elm.textContent || elm.innerText || text;
		}
	
		// Build a two way lookup table for the entities
		function buildEntitiesLookup(items, radix) {
			var i, chr, entity, lookup = {};
	
			if (items) {
				items = items.split(',');
				radix = radix || 10;
	
				// Build entities lookup table
				for (i = 0; i < items.length; i += 2) {
					chr = String.fromCharCode(parseInt(items[i], radix));
	
					// Only add non base entities
					if (!baseEntities[chr]) {
						entity = '&' + items[i + 1] + ';';
						lookup[chr] = entity;
						lookup[entity] = chr;
					}
				}
	
				return lookup;
			}
		}
	
		// Unpack entities lookup where the numbers are in radix 32 to reduce the size
		namedEntities = buildEntitiesLookup(
			'50,nbsp,51,iexcl,52,cent,53,pound,54,curren,55,yen,56,brvbar,57,sect,58,uml,59,copy,' +
			'5a,ordf,5b,laquo,5c,not,5d,shy,5e,reg,5f,macr,5g,deg,5h,plusmn,5i,sup2,5j,sup3,5k,acute,' +
			'5l,micro,5m,para,5n,middot,5o,cedil,5p,sup1,5q,ordm,5r,raquo,5s,frac14,5t,frac12,5u,frac34,' +
			'5v,iquest,60,Agrave,61,Aacute,62,Acirc,63,Atilde,64,Auml,65,Aring,66,AElig,67,Ccedil,' +
			'68,Egrave,69,Eacute,6a,Ecirc,6b,Euml,6c,Igrave,6d,Iacute,6e,Icirc,6f,Iuml,6g,ETH,6h,Ntilde,' +
			'6i,Ograve,6j,Oacute,6k,Ocirc,6l,Otilde,6m,Ouml,6n,times,6o,Oslash,6p,Ugrave,6q,Uacute,' +
			'6r,Ucirc,6s,Uuml,6t,Yacute,6u,THORN,6v,szlig,70,agrave,71,aacute,72,acirc,73,atilde,74,auml,' +
			'75,aring,76,aelig,77,ccedil,78,egrave,79,eacute,7a,ecirc,7b,euml,7c,igrave,7d,iacute,7e,icirc,' +
			'7f,iuml,7g,eth,7h,ntilde,7i,ograve,7j,oacute,7k,ocirc,7l,otilde,7m,ouml,7n,divide,7o,oslash,' +
			'7p,ugrave,7q,uacute,7r,ucirc,7s,uuml,7t,yacute,7u,thorn,7v,yuml,ci,fnof,sh,Alpha,si,Beta,' +
			'sj,Gamma,sk,Delta,sl,Epsilon,sm,Zeta,sn,Eta,so,Theta,sp,Iota,sq,Kappa,sr,Lambda,ss,Mu,' +
			'st,Nu,su,Xi,sv,Omicron,t0,Pi,t1,Rho,t3,Sigma,t4,Tau,t5,Upsilon,t6,Phi,t7,Chi,t8,Psi,' +
			't9,Omega,th,alpha,ti,beta,tj,gamma,tk,delta,tl,epsilon,tm,zeta,tn,eta,to,theta,tp,iota,' +
			'tq,kappa,tr,lambda,ts,mu,tt,nu,tu,xi,tv,omicron,u0,pi,u1,rho,u2,sigmaf,u3,sigma,u4,tau,' +
			'u5,upsilon,u6,phi,u7,chi,u8,psi,u9,omega,uh,thetasym,ui,upsih,um,piv,812,bull,816,hellip,' +
			'81i,prime,81j,Prime,81u,oline,824,frasl,88o,weierp,88h,image,88s,real,892,trade,89l,alefsym,' +
			'8cg,larr,8ch,uarr,8ci,rarr,8cj,darr,8ck,harr,8dl,crarr,8eg,lArr,8eh,uArr,8ei,rArr,8ej,dArr,' +
			'8ek,hArr,8g0,forall,8g2,part,8g3,exist,8g5,empty,8g7,nabla,8g8,isin,8g9,notin,8gb,ni,8gf,prod,' +
			'8gh,sum,8gi,minus,8gn,lowast,8gq,radic,8gt,prop,8gu,infin,8h0,ang,8h7,and,8h8,or,8h9,cap,8ha,cup,' +
			'8hb,int,8hk,there4,8hs,sim,8i5,cong,8i8,asymp,8j0,ne,8j1,equiv,8j4,le,8j5,ge,8k2,sub,8k3,sup,8k4,' +
			'nsub,8k6,sube,8k7,supe,8kl,oplus,8kn,otimes,8l5,perp,8m5,sdot,8o8,lceil,8o9,rceil,8oa,lfloor,8ob,' +
			'rfloor,8p9,lang,8pa,rang,9ea,loz,9j0,spades,9j3,clubs,9j5,hearts,9j6,diams,ai,OElig,aj,oelig,b0,' +
			'Scaron,b1,scaron,bo,Yuml,m6,circ,ms,tilde,802,ensp,803,emsp,809,thinsp,80c,zwnj,80d,zwj,80e,lrm,' +
			'80f,rlm,80j,ndash,80k,mdash,80o,lsquo,80p,rsquo,80q,sbquo,80s,ldquo,80t,rdquo,80u,bdquo,810,dagger,' +
			'811,Dagger,81g,permil,81p,lsaquo,81q,rsaquo,85c,euro', 32);
	
		var Entities = {
			/**
			 * Encodes the specified string using raw entities. This means only the required XML base entities will be encoded.
			 *
			 * @method encodeRaw
			 * @param {String} text Text to encode.
			 * @param {Boolean} attr Optional flag to specify if the text is attribute contents.
			 * @return {String} Entity encoded text.
			 */
			encodeRaw: function(text, attr) {
				return text.replace(attr ? attrsCharsRegExp : textCharsRegExp, function(chr) {
					return baseEntities[chr] || chr;
				});
			},
	
			/**
			 * Encoded the specified text with both the attributes and text entities. This function will produce larger text contents
			 * since it doesn't know if the context is within a attribute or text node. This was added for compatibility
			 * and is exposed as the DOMUtils.encode function.
			 *
			 * @method encodeAllRaw
			 * @param {String} text Text to encode.
			 * @return {String} Entity encoded text.
			 */
			encodeAllRaw: function(text) {
				return ('' + text).replace(rawCharsRegExp, function(chr) {
					return baseEntities[chr] || chr;
				});
			},
	
			/**
			 * Encodes the specified string using numeric entities. The core entities will be
			 * encoded as named ones but all non lower ascii characters will be encoded into numeric entities.
			 *
			 * @method encodeNumeric
			 * @param {String} text Text to encode.
			 * @param {Boolean} attr Optional flag to specify if the text is attribute contents.
			 * @return {String} Entity encoded text.
			 */
			encodeNumeric: function(text, attr) {
				return text.replace(attr ? attrsCharsRegExp : textCharsRegExp, function(chr) {
					// Multi byte sequence convert it to a single entity
					if (chr.length > 1) {
						return '&#' + (((chr.charCodeAt(0) - 0xD800) * 0x400) + (chr.charCodeAt(1) - 0xDC00) + 0x10000) + ';';
					}
	
					return baseEntities[chr] || '&#' + chr.charCodeAt(0) + ';';
				});
			},
	
			/**
			 * Encodes the specified string using named entities. The core entities will be encoded
			 * as named ones but all non lower ascii characters will be encoded into named entities.
			 *
			 * @method encodeNamed
			 * @param {String} text Text to encode.
			 * @param {Boolean} attr Optional flag to specify if the text is attribute contents.
			 * @param {Object} entities Optional parameter with entities to use.
			 * @return {String} Entity encoded text.
			 */
			encodeNamed: function(text, attr, entities) {
				entities = entities || namedEntities;
	
				return text.replace(attr ? attrsCharsRegExp : textCharsRegExp, function(chr) {
					return baseEntities[chr] || entities[chr] || chr;
				});
			},
	
			/**
			 * Returns an encode function based on the name(s) and it's optional entities.
			 *
			 * @method getEncodeFunc
			 * @param {String} name Comma separated list of encoders for example named,numeric.
			 * @param {String} entities Optional parameter with entities to use instead of the built in set.
			 * @return {function} Encode function to be used.
			 */
			getEncodeFunc: function(name, entities) {
				entities = buildEntitiesLookup(entities) || namedEntities;
	
				function encodeNamedAndNumeric(text, attr) {
					return text.replace(attr ? attrsCharsRegExp : textCharsRegExp, function(chr) {
						return baseEntities[chr] || entities[chr] || '&#' + chr.charCodeAt(0) + ';' || chr;
					});
				}
	
				function encodeCustomNamed(text, attr) {
					return Entities.encodeNamed(text, attr, entities);
				}
	
				// Replace + with , to be compatible with previous TinyMCE versions
				name = makeMap(name.replace(/\+/g, ','));
	
				// Named and numeric encoder
				if (name.named && name.numeric) {
					return encodeNamedAndNumeric;
				}
	
				// Named encoder
				if (name.named) {
					// Custom names
					if (entities) {
						return encodeCustomNamed;
					}
	
					return Entities.encodeNamed;
				}
	
				// Numeric
				if (name.numeric) {
					return Entities.encodeNumeric;
				}
	
				// Raw encoder
				return Entities.encodeRaw;
			},
	
			/**
			 * Decodes the specified string, this will replace entities with raw UTF characters.
			 *
			 * @method decode
			 * @param {String} text Text to entity decode.
			 * @return {String} Entity decoded string.
			 */
			decode: function(text) {
				return text.replace(entityRegExp, function(all, numeric) {
					if (numeric) {
						if (numeric.charAt(0).toLowerCase() === 'x') {
							numeric = parseInt(numeric.substr(1), 16);
						} else {
							numeric = parseInt(numeric, 10);
						}
	
						// Support upper UTF
						if (numeric > 0xFFFF) {
							numeric -= 0x10000;
	
							return String.fromCharCode(0xD800 + (numeric >> 10), 0xDC00 + (numeric & 0x3FF));
						}
	
						return asciiMap[numeric] || String.fromCharCode(numeric);
					}
	
					return reverseEntities[all] || namedEntities[all] || nativeDecode(all);
				});
			}
		};
	
		return Entities;
	});
	
	// Included from: js/tinymce/classes/dom/StyleSheetLoader.js
	
	/**
	 * StyleSheetLoader.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This class handles loading of external stylesheets and fires events when these are loaded.
	 *
	 * @class tinymce.dom.StyleSheetLoader
	 * @private
	 */
	define("tinymce/dom/StyleSheetLoader", [
		"tinymce/util/Tools",
		"tinymce/util/Delay"
	], function(Tools, Delay) {
		"use strict";
	
		return function(document, settings) {
			var idCount = 0, loadedStates = {}, maxLoadTime;
	
			settings = settings || {};
			maxLoadTime = settings.maxLoadTime || 5000;
	
			function appendToHead(node) {
				document.getElementsByTagName('head')[0].appendChild(node);
			}
	
			/**
			 * Loads the specified css style sheet file and call the loadedCallback once it's finished loading.
			 *
			 * @method load
			 * @param {String} url Url to be loaded.
			 * @param {Function} loadedCallback Callback to be executed when loaded.
			 * @param {Function} errorCallback Callback to be executed when failed loading.
			 */
			function load(url, loadedCallback, errorCallback) {
				var link, style, startTime, state;
	
				function passed() {
					var callbacks = state.passed, i = callbacks.length;
	
					while (i--) {
						callbacks[i]();
					}
	
					state.status = 2;
					state.passed = [];
					state.failed = [];
				}
	
				function failed() {
					var callbacks = state.failed, i = callbacks.length;
	
					while (i--) {
						callbacks[i]();
					}
	
					state.status = 3;
					state.passed = [];
					state.failed = [];
				}
	
				// Sniffs for older WebKit versions that have the link.onload but a broken one
				function isOldWebKit() {
					var webKitChunks = navigator.userAgent.match(/WebKit\/(\d*)/);
					return !!(webKitChunks && webKitChunks[1] < 536);
				}
	
				// Calls the waitCallback until the test returns true or the timeout occurs
				function wait(testCallback, waitCallback) {
					if (!testCallback()) {
						// Wait for timeout
						if ((new Date().getTime()) - startTime < maxLoadTime) {
							Delay.setTimeout(waitCallback);
						} else {
							failed();
						}
					}
				}
	
				// Workaround for WebKit that doesn't properly support the onload event for link elements
				// Or WebKit that fires the onload event before the StyleSheet is added to the document
				function waitForWebKitLinkLoaded() {
					wait(function() {
						var styleSheets = document.styleSheets, styleSheet, i = styleSheets.length, owner;
	
						while (i--) {
							styleSheet = styleSheets[i];
							owner = styleSheet.ownerNode ? styleSheet.ownerNode : styleSheet.owningElement;
							if (owner && owner.id === link.id) {
								passed();
								return true;
							}
						}
					}, waitForWebKitLinkLoaded);
				}
	
				// Workaround for older Geckos that doesn't have any onload event for StyleSheets
				function waitForGeckoLinkLoaded() {
					wait(function() {
						try {
							// Accessing the cssRules will throw an exception until the CSS file is loaded
							var cssRules = style.sheet.cssRules;
							passed();
							return !!cssRules;
						} catch (ex) {
							// Ignore
						}
					}, waitForGeckoLinkLoaded);
				}
	
				url = Tools._addCacheSuffix(url);
	
				if (!loadedStates[url]) {
					state = {
						passed: [],
						failed: []
					};
	
					loadedStates[url] = state;
				} else {
					state = loadedStates[url];
				}
	
				if (loadedCallback) {
					state.passed.push(loadedCallback);
				}
	
				if (errorCallback) {
					state.failed.push(errorCallback);
				}
	
				// Is loading wait for it to pass
				if (state.status == 1) {
					return;
				}
	
				// Has finished loading and was success
				if (state.status == 2) {
					passed();
					return;
				}
	
				// Has finished loading and was a failure
				if (state.status == 3) {
					failed();
					return;
				}
	
				// Start loading
				state.status = 1;
				link = document.createElement('link');
				link.rel = 'stylesheet';
				link.type = 'text/css';
				link.id = 'u' + (idCount++);
				link.async = false;
				link.defer = false;
				startTime = new Date().getTime();
	
				// Feature detect onload on link element and sniff older webkits since it has an broken onload event
				if ("onload" in link && !isOldWebKit()) {
					link.onload = waitForWebKitLinkLoaded;
					link.onerror = failed;
				} else {
					// Sniff for old Firefox that doesn't support the onload event on link elements
					// TODO: Remove this in the future when everyone uses modern browsers
					if (navigator.userAgent.indexOf("Firefox") > 0) {
						style = document.createElement('style');
						style.textContent = '@import "' + url + '"';
						waitForGeckoLinkLoaded();
						appendToHead(style);
						return;
					}
	
					// Use the id owner on older webkits
					waitForWebKitLinkLoaded();
				}
	
				appendToHead(link);
				link.href = url;
			}
	
			this.load = load;
		};
	});
	
	// Included from: js/tinymce/classes/dom/DOMUtils.js
	
	/**
	 * DOMUtils.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Utility class for various DOM manipulation and retrieval functions.
	 *
	 * @class tinymce.dom.DOMUtils
	 * @example
	 * // Add a class to an element by id in the page
	 * tinymce.DOM.addClass('someid', 'someclass');
	 *
	 * // Add a class to an element by id inside the editor
	 * tinymce.activeEditor.dom.addClass('someid', 'someclass');
	 */
	define("tinymce/dom/DOMUtils", [
		"tinymce/dom/Sizzle",
		"tinymce/dom/DomQuery",
		"tinymce/html/Styles",
		"tinymce/dom/EventUtils",
		"tinymce/dom/TreeWalker",
		"tinymce/dom/Range",
		"tinymce/html/Entities",
		"tinymce/Env",
		"tinymce/util/Tools",
		"tinymce/dom/StyleSheetLoader"
	], function(Sizzle, $, Styles, EventUtils, TreeWalker, Range, Entities, Env, Tools, StyleSheetLoader) {
		// Shorten names
		var each = Tools.each, is = Tools.is, grep = Tools.grep, trim = Tools.trim;
		var isIE = Env.ie;
		var simpleSelectorRe = /^([a-z0-9],?)+$/i;
		var whiteSpaceRegExp = /^[ \t\r\n]*$/;
	
		function setupAttrHooks(domUtils, settings) {
			var attrHooks = {}, keepValues = settings.keep_values, keepUrlHook;
	
			keepUrlHook = {
				set: function($elm, value, name) {
					if (settings.url_converter) {
						value = settings.url_converter.call(settings.url_converter_scope || domUtils, value, name, $elm[0]);
					}
	
					$elm.attr('data-mce-' + name, value).attr(name, value);
				},
	
				get: function($elm, name) {
					return $elm.attr('data-mce-' + name) || $elm.attr(name);
				}
			};
	
			attrHooks = {
				style: {
					set: function($elm, value) {
						if (value !== null && typeof value === 'object') {
							$elm.css(value);
							return;
						}
	
						if (keepValues) {
							$elm.attr('data-mce-style', value);
						}
	
						$elm.attr('style', value);
					},
	
					get: function($elm) {
						var value = $elm.attr('data-mce-style') || $elm.attr('style');
	
						value = domUtils.serializeStyle(domUtils.parseStyle(value), $elm[0].nodeName);
	
						return value;
					}
				}
			};
	
			if (keepValues) {
				attrHooks.href = attrHooks.src = keepUrlHook;
			}
	
			return attrHooks;
		}
	
		function updateInternalStyleAttr(domUtils, $elm) {
			var value = $elm.attr('style');
	
			value = domUtils.serializeStyle(domUtils.parseStyle(value), $elm[0].nodeName);
	
			if (!value) {
				value = null;
			}
	
			$elm.attr('data-mce-style', value);
		}
	
		function nodeIndex(node, normalized) {
			var idx = 0, lastNodeType, nodeType;
	
			if (node) {
				for (lastNodeType = node.nodeType, node = node.previousSibling; node; node = node.previousSibling) {
					nodeType = node.nodeType;
	
					// Normalize text nodes
					if (normalized && nodeType == 3) {
						if (nodeType == lastNodeType || !node.nodeValue.length) {
							continue;
						}
					}
					idx++;
					lastNodeType = nodeType;
				}
			}
	
			return idx;
		}
	
		/**
		 * Constructs a new DOMUtils instance. Consult the Wiki for more details on settings etc for this class.
		 *
		 * @constructor
		 * @method DOMUtils
		 * @param {Document} doc Document reference to bind the utility class to.
		 * @param {settings} settings Optional settings collection.
		 */
		function DOMUtils(doc, settings) {
			var self = this, blockElementsMap;
	
			self.doc = doc;
			self.win = window;
			self.files = {};
			self.counter = 0;
			self.stdMode = !isIE || doc.documentMode >= 8;
			self.boxModel = !isIE || doc.compatMode == "CSS1Compat" || self.stdMode;
			self.styleSheetLoader = new StyleSheetLoader(doc);
			self.boundEvents = [];
			self.settings = settings = settings || {};
			self.schema = settings.schema;
			self.styles = new Styles({
				url_converter: settings.url_converter,
				url_converter_scope: settings.url_converter_scope
			}, settings.schema);
	
			self.fixDoc(doc);
			self.events = settings.ownEvents ? new EventUtils(settings.proxy) : EventUtils.Event;
			self.attrHooks = setupAttrHooks(self, settings);
			blockElementsMap = settings.schema ? settings.schema.getBlockElements() : {};
			self.$ = $.overrideDefaults(function() {
				return {
					context: doc,
					element: self.getRoot()
				};
			});
	
			/**
			 * Returns true/false if the specified element is a block element or not.
			 *
			 * @method isBlock
			 * @param {Node/String} node Element/Node to check.
			 * @return {Boolean} True/False state if the node is a block element or not.
			 */
			self.isBlock = function(node) {
				// Fix for #5446
				if (!node) {
					return false;
				}
	
				// This function is called in module pattern style since it might be executed with the wrong this scope
				var type = node.nodeType;
	
				// If it's a node then check the type and use the nodeName
				if (type) {
					return !!(type === 1 && blockElementsMap[node.nodeName]);
				}
	
				return !!blockElementsMap[node];
			};
		}
	
		DOMUtils.prototype = {
			$$: function(elm) {
				if (typeof elm == 'string') {
					elm = this.get(elm);
				}
	
				return this.$(elm);
			},
	
			root: null,
	
			fixDoc: function(doc) {
				var settings = this.settings, name;
	
				if (isIE && settings.schema) {
					// Add missing HTML 4/5 elements to IE
					('abbr article aside audio canvas ' +
					'details figcaption figure footer ' +
					'header hgroup mark menu meter nav ' +
					'output progress section summary ' +
					'time video').replace(/\w+/g, function(name) {
						doc.createElement(name);
					});
	
					// Create all custom elements
					for (name in settings.schema.getCustomElements()) {
						doc.createElement(name);
					}
				}
			},
	
			clone: function(node, deep) {
				var self = this, clone, doc;
	
				// TODO: Add feature detection here in the future
				if (!isIE || node.nodeType !== 1 || deep) {
					return node.cloneNode(deep);
				}
	
				doc = self.doc;
	
				// Make a HTML5 safe shallow copy
				if (!deep) {
					clone = doc.createElement(node.nodeName);
	
					// Copy attribs
					each(self.getAttribs(node), function(attr) {
						self.setAttrib(clone, attr.nodeName, self.getAttrib(node, attr.nodeName));
					});
	
					return clone;
				}
	
				return clone.firstChild;
			},
	
			/**
			 * Returns the root node of the document. This is normally the body but might be a DIV. Parents like getParent will not
			 * go above the point of this root node.
			 *
			 * @method getRoot
			 * @return {Element} Root element for the utility class.
			 */
			getRoot: function() {
				var self = this;
	
				return self.settings.root_element || self.doc.body;
			},
	
			/**
			 * Returns the viewport of the window.
			 *
			 * @method getViewPort
			 * @param {Window} win Optional window to get viewport of.
			 * @return {Object} Viewport object with fields x, y, w and h.
			 */
			getViewPort: function(win) {
				var doc, rootElm;
	
				win = !win ? this.win : win;
				doc = win.document;
				rootElm = this.boxModel ? doc.documentElement : doc.body;
	
				// Returns viewport size excluding scrollbars
				return {
					x: win.pageXOffset || rootElm.scrollLeft,
					y: win.pageYOffset || rootElm.scrollTop,
					w: win.innerWidth || rootElm.clientWidth,
					h: win.innerHeight || rootElm.clientHeight
				};
			},
	
			/**
			 * Returns the rectangle for a specific element.
			 *
			 * @method getRect
			 * @param {Element/String} elm Element object or element ID to get rectangle from.
			 * @return {object} Rectangle for specified element object with x, y, w, h fields.
			 */
			getRect: function(elm) {
				var self = this, pos, size;
	
				elm = self.get(elm);
				pos = self.getPos(elm);
				size = self.getSize(elm);
	
				return {
					x: pos.x, y: pos.y,
					w: size.w, h: size.h
				};
			},
	
			/**
			 * Returns the size dimensions of the specified element.
			 *
			 * @method getSize
			 * @param {Element/String} elm Element object or element ID to get rectangle from.
			 * @return {object} Rectangle for specified element object with w, h fields.
			 */
			getSize: function(elm) {
				var self = this, w, h;
	
				elm = self.get(elm);
				w = self.getStyle(elm, 'width');
				h = self.getStyle(elm, 'height');
	
				// Non pixel value, then force offset/clientWidth
				if (w.indexOf('px') === -1) {
					w = 0;
				}
	
				// Non pixel value, then force offset/clientWidth
				if (h.indexOf('px') === -1) {
					h = 0;
				}
	
				return {
					w: parseInt(w, 10) || elm.offsetWidth || elm.clientWidth,
					h: parseInt(h, 10) || elm.offsetHeight || elm.clientHeight
				};
			},
	
			/**
			 * Returns a node by the specified selector function. This function will
			 * loop through all parent nodes and call the specified function for each node.
			 * If the function then returns true indicating that it has found what it was looking for, the loop execution will then end
			 * and the node it found will be returned.
			 *
			 * @method getParent
			 * @param {Node/String} node DOM node to search parents on or ID string.
			 * @param {function} selector Selection function or CSS selector to execute on each node.
			 * @param {Node} root Optional root element, never go below this point.
			 * @return {Node} DOM Node or null if it wasn't found.
			 */
			getParent: function(node, selector, root) {
				return this.getParents(node, selector, root, false);
			},
	
			/**
			 * Returns a node list of all parents matching the specified selector function or pattern.
			 * If the function then returns true indicating that it has found what it was looking for and that node will be collected.
			 *
			 * @method getParents
			 * @param {Node/String} node DOM node to search parents on or ID string.
			 * @param {function} selector Selection function to execute on each node or CSS pattern.
			 * @param {Node} root Optional root element, never go below this point.
			 * @return {Array} Array of nodes or null if it wasn't found.
			 */
			getParents: function(node, selector, root, collect) {
				var self = this, selectorVal, result = [];
	
				node = self.get(node);
				collect = collect === undefined;
	
				// Default root on inline mode
				root = root || (self.getRoot().nodeName != 'BODY' ? self.getRoot().parentNode : null);
	
				// Wrap node name as func
				if (is(selector, 'string')) {
					selectorVal = selector;
	
					if (selector === '*') {
						selector = function(node) {
							return node.nodeType == 1;
						};
					} else {
						selector = function(node) {
							return self.is(node, selectorVal);
						};
					}
				}
	
				while (node) {
					if (node == root || !node.nodeType || node.nodeType === 9) {
						break;
					}
	
					if (!selector || selector(node)) {
						if (collect) {
							result.push(node);
						} else {
							return node;
						}
					}
	
					node = node.parentNode;
				}
	
				return collect ? result : null;
			},
	
			/**
			 * Returns the specified element by ID or the input element if it isn't a string.
			 *
			 * @method get
			 * @param {String/Element} n Element id to look for or element to just pass though.
			 * @return {Element} Element matching the specified id or null if it wasn't found.
			 */
			get: function(elm) {
				var name;
	
				if (elm && this.doc && typeof elm == 'string') {
					name = elm;
					elm = this.doc.getElementById(elm);
	
					// IE and Opera returns meta elements when they match the specified input ID, but getElementsByName seems to do the trick
					if (elm && elm.id !== name) {
						return this.doc.getElementsByName(name)[1];
					}
				}
	
				return elm;
			},
	
			/**
			 * Returns the next node that matches selector or function
			 *
			 * @method getNext
			 * @param {Node} node Node to find siblings from.
			 * @param {String/function} selector Selector CSS expression or function.
			 * @return {Node} Next node item matching the selector or null if it wasn't found.
			 */
			getNext: function(node, selector) {
				return this._findSib(node, selector, 'nextSibling');
			},
	
			/**
			 * Returns the previous node that matches selector or function
			 *
			 * @method getPrev
			 * @param {Node} node Node to find siblings from.
			 * @param {String/function} selector Selector CSS expression or function.
			 * @return {Node} Previous node item matching the selector or null if it wasn't found.
			 */
			getPrev: function(node, selector) {
				return this._findSib(node, selector, 'previousSibling');
			},
	
			// #ifndef jquery
	
			/**
			 * Selects specific elements by a CSS level 3 pattern. For example "div#a1 p.test".
			 * This function is optimized for the most common patterns needed in TinyMCE but it also performs well enough
			 * on more complex patterns.
			 *
			 * @method select
			 * @param {String} selector CSS level 3 pattern to select/find elements by.
			 * @param {Object} scope Optional root element/scope element to search in.
			 * @return {Array} Array with all matched elements.
			 * @example
			 * // Adds a class to all paragraphs in the currently active editor
			 * tinymce.activeEditor.dom.addClass(tinymce.activeEditor.dom.select('p'), 'someclass');
			 *
			 * // Adds a class to all spans that have the test class in the currently active editor
			 * tinymce.activeEditor.dom.addClass(tinymce.activeEditor.dom.select('span.test'), 'someclass')
			 */
			select: function(selector, scope) {
				var self = this;
	
				/*eslint new-cap:0 */
				return Sizzle(selector, self.get(scope) || self.settings.root_element || self.doc, []);
			},
	
			/**
			 * Returns true/false if the specified element matches the specified css pattern.
			 *
			 * @method is
			 * @param {Node/NodeList} elm DOM node to match or an array of nodes to match.
			 * @param {String} selector CSS pattern to match the element against.
			 */
			is: function(elm, selector) {
				var i;
	
				// If it isn't an array then try to do some simple selectors instead of Sizzle for to boost performance
				if (elm.length === undefined) {
					// Simple all selector
					if (selector === '*') {
						return elm.nodeType == 1;
					}
	
					// Simple selector just elements
					if (simpleSelectorRe.test(selector)) {
						selector = selector.toLowerCase().split(/,/);
						elm = elm.nodeName.toLowerCase();
	
						for (i = selector.length - 1; i >= 0; i--) {
							if (selector[i] == elm) {
								return true;
							}
						}
	
						return false;
					}
				}
	
				// Is non element
				if (elm.nodeType && elm.nodeType != 1) {
					return false;
				}
	
				var elms = elm.nodeType ? [elm] : elm;
	
				/*eslint new-cap:0 */
				return Sizzle(selector, elms[0].ownerDocument || elms[0], null, elms).length > 0;
			},
	
			// #endif
	
			/**
			 * Adds the specified element to another element or elements.
			 *
			 * @method add
			 * @param {String/Element/Array} parentElm Element id string, DOM node element or array of ids or elements to add to.
			 * @param {String/Element} name Name of new element to add or existing element to add.
			 * @param {Object} attrs Optional object collection with arguments to add to the new element(s).
			 * @param {String} html Optional inner HTML contents to add for each element.
			 * @param {Boolean} create Optional flag if the element should be created or added.
			 * @return {Element/Array} Element that got created, or an array of created elements if multiple input elements
			 * were passed in.
			 * @example
			 * // Adds a new paragraph to the end of the active editor
			 * tinymce.activeEditor.dom.add(tinymce.activeEditor.getBody(), 'p', {title: 'my title'}, 'Some content');
			 */
			add: function(parentElm, name, attrs, html, create) {
				var self = this;
	
				return this.run(parentElm, function(parentElm) {
					var newElm;
	
					newElm = is(name, 'string') ? self.doc.createElement(name) : name;
					self.setAttribs(newElm, attrs);
	
					if (html) {
						if (html.nodeType) {
							newElm.appendChild(html);
						} else {
							self.setHTML(newElm, html);
						}
					}
	
					return !create ? parentElm.appendChild(newElm) : newElm;
				});
			},
	
			/**
			 * Creates a new element.
			 *
			 * @method create
			 * @param {String} name Name of new element.
			 * @param {Object} attrs Optional object name/value collection with element attributes.
			 * @param {String} html Optional HTML string to set as inner HTML of the element.
			 * @return {Element} HTML DOM node element that got created.
			 * @example
			 * // Adds an element where the caret/selection is in the active editor
			 * var el = tinymce.activeEditor.dom.create('div', {id: 'test', 'class': 'myclass'}, 'some content');
			 * tinymce.activeEditor.selection.setNode(el);
			 */
			create: function(name, attrs, html) {
				return this.add(this.doc.createElement(name), name, attrs, html, 1);
			},
	
			/**
			 * Creates HTML string for element. The element will be closed unless an empty inner HTML string is passed in.
			 *
			 * @method createHTML
			 * @param {String} name Name of new element.
			 * @param {Object} attrs Optional object name/value collection with element attributes.
			 * @param {String} html Optional HTML string to set as inner HTML of the element.
			 * @return {String} String with new HTML element, for example: <a href="#">test</a>.
			 * @example
			 * // Creates a html chunk and inserts it at the current selection/caret location
			 * tinymce.activeEditor.selection.setContent(tinymce.activeEditor.dom.createHTML('a', {href: 'test.html'}, 'some line'));
			 */
			createHTML: function(name, attrs, html) {
				var outHtml = '', key;
	
				outHtml += '<' + name;
	
				for (key in attrs) {
					if (attrs.hasOwnProperty(key) && attrs[key] !== null && typeof attrs[key] != 'undefined') {
						outHtml += ' ' + key + '="' + this.encode(attrs[key]) + '"';
					}
				}
	
				// A call to tinymce.is doesn't work for some odd reason on IE9 possible bug inside their JS runtime
				if (typeof html != "undefined") {
					return outHtml + '>' + html + '</' + name + '>';
				}
	
				return outHtml + ' />';
			},
	
			/**
			 * Creates a document fragment out of the specified HTML string.
			 *
			 * @method createFragment
			 * @param {String} html Html string to create fragment from.
			 * @return {DocumentFragment} Document fragment node.
			 */
			createFragment: function(html) {
				var frag, node, doc = this.doc, container;
	
				container = doc.createElement("div");
				frag = doc.createDocumentFragment();
	
				if (html) {
					container.innerHTML = html;
				}
	
				while ((node = container.firstChild)) {
					frag.appendChild(node);
				}
	
				return frag;
			},
	
			/**
			 * Removes/deletes the specified element(s) from the DOM.
			 *
			 * @method remove
			 * @param {String/Element/Array} node ID of element or DOM element object or array containing multiple elements/ids.
			 * @param {Boolean} keepChildren Optional state to keep children or not. If set to true all children will be
			 * placed at the location of the removed element.
			 * @return {Element/Array} HTML DOM element that got removed, or an array of removed elements if multiple input elements
			 * were passed in.
			 * @example
			 * // Removes all paragraphs in the active editor
			 * tinymce.activeEditor.dom.remove(tinymce.activeEditor.dom.select('p'));
			 *
			 * // Removes an element by id in the document
			 * tinymce.DOM.remove('mydiv');
			 */
			remove: function(node, keepChildren) {
				node = this.$$(node);
	
				if (keepChildren) {
					node.each(function() {
						var child;
	
						while ((child = this.firstChild)) {
							if (child.nodeType == 3 && child.data.length === 0) {
								this.removeChild(child);
							} else {
								this.parentNode.insertBefore(child, this);
							}
						}
					}).remove();
				} else {
					node.remove();
				}
	
				return node.length > 1 ? node.toArray() : node[0];
			},
	
			/**
			 * Sets the CSS style value on a HTML element. The name can be a camelcase string
			 * or the CSS style name like background-color.
			 *
			 * @method setStyle
			 * @param {String/Element/Array} elm HTML element/Array of elements to set CSS style value on.
			 * @param {String} name Name of the style value to set.
			 * @param {String} value Value to set on the style.
			 * @example
			 * // Sets a style value on all paragraphs in the currently active editor
			 * tinymce.activeEditor.dom.setStyle(tinymce.activeEditor.dom.select('p'), 'background-color', 'red');
			 *
			 * // Sets a style value to an element by id in the current document
			 * tinymce.DOM.setStyle('mydiv', 'background-color', 'red');
			 */
			setStyle: function(elm, name, value) {
				elm = this.$$(elm).css(name, value);
	
				if (this.settings.update_styles) {
					updateInternalStyleAttr(this, elm);
				}
			},
	
			/**
			 * Returns the current style or runtime/computed value of an element.
			 *
			 * @method getStyle
			 * @param {String/Element} elm HTML element or element id string to get style from.
			 * @param {String} name Style name to return.
			 * @param {Boolean} computed Computed style.
			 * @return {String} Current style or computed style value of an element.
			 */
			getStyle: function(elm, name, computed) {
				elm = this.$$(elm);
	
				if (computed) {
					return elm.css(name);
				}
	
				// Camelcase it, if needed
				name = name.replace(/-(\D)/g, function(a, b) {
					return b.toUpperCase();
				});
	
				if (name == 'float') {
					name = Env.ie && Env.ie < 12 ? 'styleFloat' : 'cssFloat';
				}
	
				return elm[0] && elm[0].style ? elm[0].style[name] : undefined;
			},
	
			/**
			 * Sets multiple styles on the specified element(s).
			 *
			 * @method setStyles
			 * @param {Element/String/Array} elm DOM element, element id string or array of elements/ids to set styles on.
			 * @param {Object} styles Name/Value collection of style items to add to the element(s).
			 * @example
			 * // Sets styles on all paragraphs in the currently active editor
			 * tinymce.activeEditor.dom.setStyles(tinymce.activeEditor.dom.select('p'), {'background-color': 'red', 'color': 'green'});
			 *
			 * // Sets styles to an element by id in the current document
			 * tinymce.DOM.setStyles('mydiv', {'background-color': 'red', 'color': 'green'});
			 */
			setStyles: function(elm, styles) {
				elm = this.$$(elm).css(styles);
	
				if (this.settings.update_styles) {
					updateInternalStyleAttr(this, elm);
				}
			},
	
			/**
			 * Removes all attributes from an element or elements.
			 *
			 * @method removeAllAttribs
			 * @param {Element/String/Array} e DOM element, element id string or array of elements/ids to remove attributes from.
			 */
			removeAllAttribs: function(e) {
				return this.run(e, function(e) {
					var i, attrs = e.attributes;
					for (i = attrs.length - 1; i >= 0; i--) {
						e.removeAttributeNode(attrs.item(i));
					}
				});
			},
	
			/**
			 * Sets the specified attribute of an element or elements.
			 *
			 * @method setAttrib
			 * @param {Element/String/Array} elm DOM element, element id string or array of elements/ids to set attribute on.
			 * @param {String} name Name of attribute to set.
			 * @param {String} value Value to set on the attribute - if this value is falsy like null, 0 or '' it will remove
			 * the attribute instead.
			 * @example
			 * // Sets class attribute on all paragraphs in the active editor
			 * tinymce.activeEditor.dom.setAttrib(tinymce.activeEditor.dom.select('p'), 'class', 'myclass');
			 *
			 * // Sets class attribute on a specific element in the current page
			 * tinymce.dom.setAttrib('mydiv', 'class', 'myclass');
			 */
			setAttrib: function(elm, name, value) {
				var self = this, originalValue, hook, settings = self.settings;
	
				if (value === '') {
					value = null;
				}
	
				elm = self.$$(elm);
				originalValue = elm.attr(name);
	
				if (!elm.length) {
					return;
				}
	
				hook = self.attrHooks[name];
				if (hook && hook.set) {
					hook.set(elm, value, name);
				} else {
					elm.attr(name, value);
				}
	
				if (originalValue != value && settings.onSetAttrib) {
					settings.onSetAttrib({
						attrElm: elm,
						attrName: name,
						attrValue: value
					});
				}
			},
	
			/**
			 * Sets two or more specified attributes of an element or elements.
			 *
			 * @method setAttribs
			 * @param {Element/String/Array} elm DOM element, element id string or array of elements/ids to set attributes on.
			 * @param {Object} attrs Name/Value collection of attribute items to add to the element(s).
			 * @example
			 * // Sets class and title attributes on all paragraphs in the active editor
			 * tinymce.activeEditor.dom.setAttribs(tinymce.activeEditor.dom.select('p'), {'class': 'myclass', title: 'some title'});
			 *
			 * // Sets class and title attributes on a specific element in the current page
			 * tinymce.DOM.setAttribs('mydiv', {'class': 'myclass', title: 'some title'});
			 */
			setAttribs: function(elm, attrs) {
				var self = this;
	
				self.$$(elm).each(function(i, node) {
					each(attrs, function(value, name) {
						self.setAttrib(node, name, value);
					});
				});
			},
	
			/**
			 * Returns the specified attribute by name.
			 *
			 * @method getAttrib
			 * @param {String/Element} elm Element string id or DOM element to get attribute from.
			 * @param {String} name Name of attribute to get.
			 * @param {String} defaultVal Optional default value to return if the attribute didn't exist.
			 * @return {String} Attribute value string, default value or null if the attribute wasn't found.
			 */
			getAttrib: function(elm, name, defaultVal) {
				var self = this, hook, value;
	
				elm = self.$$(elm);
	
				if (elm.length) {
					hook = self.attrHooks[name];
	
					if (hook && hook.get) {
						value = hook.get(elm, name);
					} else {
						value = elm.attr(name);
					}
				}
	
				if (typeof value == 'undefined') {
					value = defaultVal || '';
				}
	
				return value;
			},
	
			/**
			 * Returns the absolute x, y position of a node. The position will be returned in an object with x, y fields.
			 *
			 * @method getPos
			 * @param {Element/String} elm HTML element or element id to get x, y position from.
			 * @param {Element} rootElm Optional root element to stop calculations at.
			 * @return {object} Absolute position of the specified element object with x, y fields.
			 */
			getPos: function(elm, rootElm) {
				var self = this, x = 0, y = 0, offsetParent, doc = self.doc, body = doc.body, pos;
	
				elm = self.get(elm);
				rootElm = rootElm || body;
	
				if (elm) {
					// Use getBoundingClientRect if it exists since it's faster than looping offset nodes
					// Fallback to offsetParent calculations if the body isn't static better since it stops at the body root
					if (rootElm === body && elm.getBoundingClientRect && $(body).css('position') === 'static') {
						pos = elm.getBoundingClientRect();
						rootElm = self.boxModel ? doc.documentElement : body;
	
						// Add scroll offsets from documentElement or body since IE with the wrong box model will use d.body and so do WebKit
						// Also remove the body/documentelement clientTop/clientLeft on IE 6, 7 since they offset the position
						x = pos.left + (doc.documentElement.scrollLeft || body.scrollLeft) - rootElm.clientLeft;
						y = pos.top + (doc.documentElement.scrollTop || body.scrollTop) - rootElm.clientTop;
	
						return {x: x, y: y};
					}
	
					offsetParent = elm;
					while (offsetParent && offsetParent != rootElm && offsetParent.nodeType) {
						x += offsetParent.offsetLeft || 0;
						y += offsetParent.offsetTop || 0;
						offsetParent = offsetParent.offsetParent;
					}
	
					offsetParent = elm.parentNode;
					while (offsetParent && offsetParent != rootElm && offsetParent.nodeType) {
						x -= offsetParent.scrollLeft || 0;
						y -= offsetParent.scrollTop || 0;
						offsetParent = offsetParent.parentNode;
					}
				}
	
				return {x: x, y: y};
			},
	
			/**
			 * Parses the specified style value into an object collection. This parser will also
			 * merge and remove any redundant items that browsers might have added. It will also convert non-hex
			 * colors to hex values. Urls inside the styles will also be converted to absolute/relative based on settings.
			 *
			 * @method parseStyle
			 * @param {String} cssText Style value to parse, for example: border:1px solid red;.
			 * @return {Object} Object representation of that style, for example: {border: '1px solid red'}
			 */
			parseStyle: function(cssText) {
				return this.styles.parse(cssText);
			},
	
			/**
			 * Serializes the specified style object into a string.
			 *
			 * @method serializeStyle
			 * @param {Object} styles Object to serialize as string, for example: {border: '1px solid red'}
			 * @param {String} name Optional element name.
			 * @return {String} String representation of the style object, for example: border: 1px solid red.
			 */
			serializeStyle: function(styles, name) {
				return this.styles.serialize(styles, name);
			},
	
			/**
			 * Adds a style element at the top of the document with the specified cssText content.
			 *
			 * @method addStyle
			 * @param {String} cssText CSS Text style to add to top of head of document.
			 */
			addStyle: function(cssText) {
				var self = this, doc = self.doc, head, styleElm;
	
				// Prevent inline from loading the same styles twice
				if (self !== DOMUtils.DOM && doc === document) {
					var addedStyles = DOMUtils.DOM.addedStyles;
	
					addedStyles = addedStyles || [];
					if (addedStyles[cssText]) {
						return;
					}
	
					addedStyles[cssText] = true;
					DOMUtils.DOM.addedStyles = addedStyles;
				}
	
				// Create style element if needed
				styleElm = doc.getElementById('mceDefaultStyles');
				if (!styleElm) {
					styleElm = doc.createElement('style');
					styleElm.id = 'mceDefaultStyles';
					styleElm.type = 'text/css';
	
					head = doc.getElementsByTagName('head')[0];
					if (head.firstChild) {
						head.insertBefore(styleElm, head.firstChild);
					} else {
						head.appendChild(styleElm);
					}
				}
	
				// Append style data to old or new style element
				if (styleElm.styleSheet) {
					styleElm.styleSheet.cssText += cssText;
				} else {
					styleElm.appendChild(doc.createTextNode(cssText));
				}
			},
	
			/**
			 * Imports/loads the specified CSS file into the document bound to the class.
			 *
			 * @method loadCSS
			 * @param {String} url URL to CSS file to load.
			 * @example
			 * // Loads a CSS file dynamically into the current document
			 * tinymce.DOM.loadCSS('somepath/some.css');
			 *
			 * // Loads a CSS file into the currently active editor instance
			 * tinymce.activeEditor.dom.loadCSS('somepath/some.css');
			 *
			 * // Loads a CSS file into an editor instance by id
			 * tinymce.get('someid').dom.loadCSS('somepath/some.css');
			 *
			 * // Loads multiple CSS files into the current document
			 * tinymce.DOM.loadCSS('somepath/some.css,somepath/someother.css');
			 */
			loadCSS: function(url) {
				var self = this, doc = self.doc, head;
	
				// Prevent inline from loading the same CSS file twice
				if (self !== DOMUtils.DOM && doc === document) {
					DOMUtils.DOM.loadCSS(url);
					return;
				}
	
				if (!url) {
					url = '';
				}
	
				head = doc.getElementsByTagName('head')[0];
	
				each(url.split(','), function(url) {
					var link;
	
					url = Tools._addCacheSuffix(url);
	
					if (self.files[url]) {
						return;
					}
	
					self.files[url] = true;
					link = self.create('link', {rel: 'stylesheet', href: url});
	
					// IE 8 has a bug where dynamically loading stylesheets would produce a 1 item remaining bug
					// This fix seems to resolve that issue by recalcing the document once a stylesheet finishes loading
					// It's ugly but it seems to work fine.
					if (isIE && doc.documentMode && doc.recalc) {
						link.onload = function() {
							if (doc.recalc) {
								doc.recalc();
							}
	
							link.onload = null;
						};
					}
	
					head.appendChild(link);
				});
			},
	
			/**
			 * Adds a class to the specified element or elements.
			 *
			 * @method addClass
			 * @param {String/Element/Array} elm Element ID string or DOM element or array with elements or IDs.
			 * @param {String} cls Class name to add to each element.
			 * @return {String/Array} String with new class value or array with new class values for all elements.
			 * @example
			 * // Adds a class to all paragraphs in the active editor
			 * tinymce.activeEditor.dom.addClass(tinymce.activeEditor.dom.select('p'), 'myclass');
			 *
			 * // Adds a class to a specific element in the current page
			 * tinymce.DOM.addClass('mydiv', 'myclass');
			 */
			addClass: function(elm, cls) {
				this.$$(elm).addClass(cls);
			},
	
			/**
			 * Removes a class from the specified element or elements.
			 *
			 * @method removeClass
			 * @param {String/Element/Array} elm Element ID string or DOM element or array with elements or IDs.
			 * @param {String} cls Class name to remove from each element.
			 * @return {String/Array} String of remaining class name(s), or an array of strings if multiple input elements
			 * were passed in.
			 * @example
			 * // Removes a class from all paragraphs in the active editor
			 * tinymce.activeEditor.dom.removeClass(tinymce.activeEditor.dom.select('p'), 'myclass');
			 *
			 * // Removes a class from a specific element in the current page
			 * tinymce.DOM.removeClass('mydiv', 'myclass');
			 */
			removeClass: function(elm, cls) {
				this.toggleClass(elm, cls, false);
			},
	
			/**
			 * Returns true if the specified element has the specified class.
			 *
			 * @method hasClass
			 * @param {String/Element} elm HTML element or element id string to check CSS class on.
			 * @param {String} cls CSS class to check for.
			 * @return {Boolean} true/false if the specified element has the specified class.
			 */
			hasClass: function(elm, cls) {
				return this.$$(elm).hasClass(cls);
			},
	
			/**
			 * Toggles the specified class on/off.
			 *
			 * @method toggleClass
			 * @param {Element} elm Element to toggle class on.
			 * @param {[type]} cls Class to toggle on/off.
			 * @param {[type]} state Optional state to set.
			 */
			toggleClass: function(elm, cls, state) {
				this.$$(elm).toggleClass(cls, state).each(function() {
					if (this.className === '') {
						$(this).attr('class', null);
					}
				});
			},
	
			/**
			 * Shows the specified element(s) by ID by setting the "display" style.
			 *
			 * @method show
			 * @param {String/Element/Array} elm ID of DOM element or DOM element or array with elements or IDs to show.
			 */
			show: function(elm) {
				this.$$(elm).show();
			},
	
			/**
			 * Hides the specified element(s) by ID by setting the "display" style.
			 *
			 * @method hide
			 * @param {String/Element/Array} elm ID of DOM element or DOM element or array with elements or IDs to hide.
			 * @example
			 * // Hides an element by id in the document
			 * tinymce.DOM.hide('myid');
			 */
			hide: function(elm) {
				this.$$(elm).hide();
			},
	
			/**
			 * Returns true/false if the element is hidden or not by checking the "display" style.
			 *
			 * @method isHidden
			 * @param {String/Element} elm Id or element to check display state on.
			 * @return {Boolean} true/false if the element is hidden or not.
			 */
			isHidden: function(elm) {
				return this.$$(elm).css('display') == 'none';
			},
	
			/**
			 * Returns a unique id. This can be useful when generating elements on the fly.
			 * This method will not check if the element already exists.
			 *
			 * @method uniqueId
			 * @param {String} prefix Optional prefix to add in front of all ids - defaults to "mce_".
			 * @return {String} Unique id.
			 */
			uniqueId: function(prefix) {
				return (!prefix ? 'mce_' : prefix) + (this.counter++);
			},
	
			/**
			 * Sets the specified HTML content inside the element or elements. The HTML will first be processed. This means
			 * URLs will get converted, hex color values fixed etc. Check processHTML for details.
			 *
			 * @method setHTML
			 * @param {Element/String/Array} elm DOM element, element id string or array of elements/ids to set HTML inside of.
			 * @param {String} html HTML content to set as inner HTML of the element.
			 * @example
			 * // Sets the inner HTML of all paragraphs in the active editor
			 * tinymce.activeEditor.dom.setHTML(tinymce.activeEditor.dom.select('p'), 'some inner html');
			 *
			 * // Sets the inner HTML of an element by id in the document
			 * tinymce.DOM.setHTML('mydiv', 'some inner html');
			 */
			setHTML: function(elm, html) {
				elm = this.$$(elm);
	
				if (isIE) {
					elm.each(function(i, target) {
						if (target.canHaveHTML === false) {
							return;
						}
	
						// Remove all child nodes, IE keeps empty text nodes in DOM
						while (target.firstChild) {
							target.removeChild(target.firstChild);
						}
	
						try {
							// IE will remove comments from the beginning
							// unless you padd the contents with something
							target.innerHTML = '<br>' + html;
							target.removeChild(target.firstChild);
						} catch (ex) {
							// IE sometimes produces an unknown runtime error on innerHTML if it's a div inside a p
							$('<div></div>').html('<br>' + html).contents().slice(1).appendTo(target);
						}
	
						return html;
					});
				} else {
					elm.html(html);
				}
			},
	
			/**
			 * Returns the outer HTML of an element.
			 *
			 * @method getOuterHTML
			 * @param {String/Element} elm Element ID or element object to get outer HTML from.
			 * @return {String} Outer HTML string.
			 * @example
			 * tinymce.DOM.getOuterHTML(editorElement);
			 * tinymce.activeEditor.getOuterHTML(tinymce.activeEditor.getBody());
			 */
			getOuterHTML: function(elm) {
				elm = this.get(elm);
	
				// Older FF doesn't have outerHTML 3.6 is still used by some orgaizations
				return elm.nodeType == 1 && "outerHTML" in elm ? elm.outerHTML : $('<div></div>').append($(elm).clone()).html();
			},
	
			/**
			 * Sets the specified outer HTML on an element or elements.
			 *
			 * @method setOuterHTML
			 * @param {Element/String/Array} elm DOM element, element id string or array of elements/ids to set outer HTML on.
			 * @param {Object} html HTML code to set as outer value for the element.
			 * @example
			 * // Sets the outer HTML of all paragraphs in the active editor
			 * tinymce.activeEditor.dom.setOuterHTML(tinymce.activeEditor.dom.select('p'), '<div>some html</div>');
			 *
			 * // Sets the outer HTML of an element by id in the document
			 * tinymce.DOM.setOuterHTML('mydiv', '<div>some html</div>');
			 */
			setOuterHTML: function(elm, html) {
				var self = this;
	
				self.$$(elm).each(function() {
					try {
						// Older FF doesn't have outerHTML 3.6 is still used by some organizations
						if ("outerHTML" in this) {
							this.outerHTML = html;
							return;
						}
					} catch (ex) {
						// Ignore
					}
	
					// OuterHTML for IE it sometimes produces an "unknown runtime error"
					self.remove($(this).html(html), true);
				});
			},
	
			/**
			 * Entity decodes a string. This method decodes any HTML entities, such as &aring;.
			 *
			 * @method decode
			 * @param {String} s String to decode entities on.
			 * @return {String} Entity decoded string.
			 */
			decode: Entities.decode,
	
			/**
			 * Entity encodes a string. This method encodes the most common entities, such as <>"&.
			 *
			 * @method encode
			 * @param {String} text String to encode with entities.
			 * @return {String} Entity encoded string.
			 */
			encode: Entities.encodeAllRaw,
	
			/**
			 * Inserts an element after the reference element.
			 *
			 * @method insertAfter
			 * @param {Element} node Element to insert after the reference.
			 * @param {Element/String/Array} referenceNode Reference element, element id or array of elements to insert after.
			 * @return {Element/Array} Element that got added or an array with elements.
			 */
			insertAfter: function(node, referenceNode) {
				referenceNode = this.get(referenceNode);
	
				return this.run(node, function(node) {
					var parent, nextSibling;
	
					parent = referenceNode.parentNode;
					nextSibling = referenceNode.nextSibling;
	
					if (nextSibling) {
						parent.insertBefore(node, nextSibling);
					} else {
						parent.appendChild(node);
					}
	
					return node;
				});
			},
	
			/**
			 * Replaces the specified element or elements with the new element specified. The new element will
			 * be cloned if multiple input elements are passed in.
			 *
			 * @method replace
			 * @param {Element} newElm New element to replace old ones with.
			 * @param {Element/String/Array} oldElm Element DOM node, element id or array of elements or ids to replace.
			 * @param {Boolean} keepChildren Optional keep children state, if set to true child nodes from the old object will be added
			 * to new ones.
			 */
			replace: function(newElm, oldElm, keepChildren) {
				var self = this;
	
				return self.run(oldElm, function(oldElm) {
					if (is(oldElm, 'array')) {
						newElm = newElm.cloneNode(true);
					}
	
					if (keepChildren) {
						each(grep(oldElm.childNodes), function(node) {
							newElm.appendChild(node);
						});
					}
	
					return oldElm.parentNode.replaceChild(newElm, oldElm);
				});
			},
	
			/**
			 * Renames the specified element and keeps its attributes and children.
			 *
			 * @method rename
			 * @param {Element} elm Element to rename.
			 * @param {String} name Name of the new element.
			 * @return {Element} New element or the old element if it needed renaming.
			 */
			rename: function(elm, name) {
				var self = this, newElm;
	
				if (elm.nodeName != name.toUpperCase()) {
					// Rename block element
					newElm = self.create(name);
	
					// Copy attribs to new block
					each(self.getAttribs(elm), function(attrNode) {
						self.setAttrib(newElm, attrNode.nodeName, self.getAttrib(elm, attrNode.nodeName));
					});
	
					// Replace block
					self.replace(newElm, elm, 1);
				}
	
				return newElm || elm;
			},
	
			/**
			 * Find the common ancestor of two elements. This is a shorter method than using the DOM Range logic.
			 *
			 * @method findCommonAncestor
			 * @param {Element} a Element to find common ancestor of.
			 * @param {Element} b Element to find common ancestor of.
			 * @return {Element} Common ancestor element of the two input elements.
			 */
			findCommonAncestor: function(a, b) {
				var ps = a, pe;
	
				while (ps) {
					pe = b;
	
					while (pe && ps != pe) {
						pe = pe.parentNode;
					}
	
					if (ps == pe) {
						break;
					}
	
					ps = ps.parentNode;
				}
	
				if (!ps && a.ownerDocument) {
					return a.ownerDocument.documentElement;
				}
	
				return ps;
			},
	
			/**
			 * Parses the specified RGB color value and returns a hex version of that color.
			 *
			 * @method toHex
			 * @param {String} rgbVal RGB string value like rgb(1,2,3)
			 * @return {String} Hex version of that RGB value like #FF00FF.
			 */
			toHex: function(rgbVal) {
				return this.styles.toHex(Tools.trim(rgbVal));
			},
	
			/**
			 * Executes the specified function on the element by id or dom element node or array of elements/id.
			 *
			 * @method run
			 * @param {String/Element/Array} elm ID or DOM element object or array with ids or elements.
			 * @param {function} func Function to execute for each item.
			 * @param {Object} scope Optional scope to execute the function in.
			 * @return {Object/Array} Single object, or an array of objects if multiple input elements were passed in.
			 */
			run: function(elm, func, scope) {
				var self = this, result;
	
				if (typeof elm === 'string') {
					elm = self.get(elm);
				}
	
				if (!elm) {
					return false;
				}
	
				scope = scope || this;
				if (!elm.nodeType && (elm.length || elm.length === 0)) {
					result = [];
	
					each(elm, function(elm, i) {
						if (elm) {
							if (typeof elm == 'string') {
								elm = self.get(elm);
							}
	
							result.push(func.call(scope, elm, i));
						}
					});
	
					return result;
				}
	
				return func.call(scope, elm);
			},
	
			/**
			 * Returns a NodeList with attributes for the element.
			 *
			 * @method getAttribs
			 * @param {HTMLElement/string} elm Element node or string id to get attributes from.
			 * @return {NodeList} NodeList with attributes.
			 */
			getAttribs: function(elm) {
				var attrs;
	
				elm = this.get(elm);
	
				if (!elm) {
					return [];
				}
	
				if (isIE) {
					attrs = [];
	
					// Object will throw exception in IE
					if (elm.nodeName == 'OBJECT') {
						return elm.attributes;
					}
	
					// IE doesn't keep the selected attribute if you clone option elements
					if (elm.nodeName === 'OPTION' && this.getAttrib(elm, 'selected')) {
						attrs.push({specified: 1, nodeName: 'selected'});
					}
	
					// It's crazy that this is faster in IE but it's because it returns all attributes all the time
					var attrRegExp = /<\/?[\w:\-]+ ?|=[\"][^\"]+\"|=\'[^\']+\'|=[\w\-]+|>/gi;
					elm.cloneNode(false).outerHTML.replace(attrRegExp, '').replace(/[\w:\-]+/gi, function(a) {
						attrs.push({specified: 1, nodeName: a});
					});
	
					return attrs;
				}
	
				return elm.attributes;
			},
	
			/**
			 * Returns true/false if the specified node is to be considered empty or not.
			 *
			 * @example
			 * tinymce.DOM.isEmpty(node, {img: true});
			 * @method isEmpty
			 * @param {Object} elements Optional name/value object with elements that are automatically treated as non-empty elements.
			 * @return {Boolean} true/false if the node is empty or not.
			 */
			isEmpty: function(node, elements) {
				var self = this, i, attributes, type, walker, name, brCount = 0;
	
				node = node.firstChild;
				if (node) {
					walker = new TreeWalker(node, node.parentNode);
					elements = elements || (self.schema ? self.schema.getNonEmptyElements() : null);
	
					do {
						type = node.nodeType;
	
						if (type === 1) {
							// Ignore bogus elements
							var bogusVal = node.getAttribute('data-mce-bogus');
							if (bogusVal) {
								node = walker.next(bogusVal === 'all');
								continue;
							}
	
							// Keep empty elements like <img />
							name = node.nodeName.toLowerCase();
							if (elements && elements[name]) {
								// Ignore single BR elements in blocks like <p><br /></p> or <p><span><br /></span></p>
								if (name === 'br') {
									brCount++;
									node = walker.next();
									continue;
								}
	
								return false;
							}
	
							// Keep elements with data-bookmark attributes or name attribute like <a name="1"></a>
							attributes = self.getAttribs(node);
							i = attributes.length;
							while (i--) {
								name = attributes[i].nodeName;
								if (name === "name" || name === 'data-mce-bookmark') {
									return false;
								}
							}
						}
	
						// Keep comment nodes
						if (type == 8) {
							return false;
						}
	
						// Keep non whitespace text nodes
						if ((type === 3 && !whiteSpaceRegExp.test(node.nodeValue))) {
							return false;
						}
	
						node = walker.next();
					} while (node);
				}
	
				return brCount <= 1;
			},
	
			/**
			 * Creates a new DOM Range object. This will use the native DOM Range API if it's
			 * available. If it's not, it will fall back to the custom TinyMCE implementation.
			 *
			 * @method createRng
			 * @return {DOMRange} DOM Range object.
			 * @example
			 * var rng = tinymce.DOM.createRng();
			 * alert(rng.startContainer + "," + rng.startOffset);
			 */
			createRng: function() {
				var doc = this.doc;
	
				return doc.createRange ? doc.createRange() : new Range(this);
			},
	
			/**
			 * Returns the index of the specified node within its parent.
			 *
			 * @method nodeIndex
			 * @param {Node} node Node to look for.
			 * @param {boolean} normalized Optional true/false state if the index is what it would be after a normalization.
			 * @return {Number} Index of the specified node.
			 */
			nodeIndex: nodeIndex,
	
			/**
			 * Splits an element into two new elements and places the specified split
			 * element or elements between the new ones. For example splitting the paragraph at the bold element in
			 * this example <p>abc<b>abc</b>123</p> would produce <p>abc</p><b>abc</b><p>123</p>.
			 *
			 * @method split
			 * @param {Element} parentElm Parent element to split.
			 * @param {Element} splitElm Element to split at.
			 * @param {Element} replacementElm Optional replacement element to replace the split element with.
			 * @return {Element} Returns the split element or the replacement element if that is specified.
			 */
			split: function(parentElm, splitElm, replacementElm) {
				var self = this, r = self.createRng(), bef, aft, pa;
	
				// W3C valid browsers tend to leave empty nodes to the left/right side of the contents - this makes sense
				// but we don't want that in our code since it serves no purpose for the end user
				// For example splitting this html at the bold element:
				//   <p>text 1<span><b>CHOP</b></span>text 2</p>
				// would produce:
				//   <p>text 1<span></span></p><b>CHOP</b><p><span></span>text 2</p>
				// this function will then trim off empty edges and produce:
				//   <p>text 1</p><b>CHOP</b><p>text 2</p>
				function trimNode(node) {
					var i, children = node.childNodes, type = node.nodeType;
	
					function surroundedBySpans(node) {
						var previousIsSpan = node.previousSibling && node.previousSibling.nodeName == 'SPAN';
						var nextIsSpan = node.nextSibling && node.nextSibling.nodeName == 'SPAN';
						return previousIsSpan && nextIsSpan;
					}
	
					if (type == 1 && node.getAttribute('data-mce-type') == 'bookmark') {
						return;
					}
	
					for (i = children.length - 1; i >= 0; i--) {
						trimNode(children[i]);
					}
	
					if (type != 9) {
						// Keep non whitespace text nodes
						if (type == 3 && node.nodeValue.length > 0) {
							// If parent element isn't a block or there isn't any useful contents for example "<p>   </p>"
							// Also keep text nodes with only spaces if surrounded by spans.
							// eg. "<p><span>a</span> <span>b</span></p>" should keep space between a and b
							var trimmedLength = trim(node.nodeValue).length;
							if (!self.isBlock(node.parentNode) || trimmedLength > 0 || trimmedLength === 0 && surroundedBySpans(node)) {
								return;
							}
						} else if (type == 1) {
							// If the only child is a bookmark then move it up
							children = node.childNodes;
	
							// TODO fix this complex if
							if (children.length == 1 && children[0] && children[0].nodeType == 1 &&
								children[0].getAttribute('data-mce-type') == 'bookmark') {
								node.parentNode.insertBefore(children[0], node);
							}
	
							// Keep non empty elements or img, hr etc
							if (children.length || /^(br|hr|input|img)$/i.test(node.nodeName)) {
								return;
							}
						}
	
						self.remove(node);
					}
	
					return node;
				}
	
				if (parentElm && splitElm) {
					// Get before chunk
					r.setStart(parentElm.parentNode, self.nodeIndex(parentElm));
					r.setEnd(splitElm.parentNode, self.nodeIndex(splitElm));
					bef = r.extractContents();
	
					// Get after chunk
					r = self.createRng();
					r.setStart(splitElm.parentNode, self.nodeIndex(splitElm) + 1);
					r.setEnd(parentElm.parentNode, self.nodeIndex(parentElm) + 1);
					aft = r.extractContents();
	
					// Insert before chunk
					pa = parentElm.parentNode;
					pa.insertBefore(trimNode(bef), parentElm);
	
					// Insert middle chunk
					if (replacementElm) {
						pa.insertBefore(replacementElm, parentElm);
						//pa.replaceChild(replacementElm, splitElm);
					} else {
						pa.insertBefore(splitElm, parentElm);
					}
	
					// Insert after chunk
					pa.insertBefore(trimNode(aft), parentElm);
					self.remove(parentElm);
	
					return replacementElm || splitElm;
				}
			},
	
			/**
			 * Adds an event handler to the specified object.
			 *
			 * @method bind
			 * @param {Element/Document/Window/Array} target Target element to bind events to.
			 * handler to or an array of elements/ids/documents.
			 * @param {String} name Name of event handler to add, for example: click.
			 * @param {function} func Function to execute when the event occurs.
			 * @param {Object} scope Optional scope to execute the function in.
			 * @return {function} Function callback handler the same as the one passed in.
			 */
			bind: function(target, name, func, scope) {
				var self = this;
	
				if (Tools.isArray(target)) {
					var i = target.length;
	
					while (i--) {
						target[i] = self.bind(target[i], name, func, scope);
					}
	
					return target;
				}
	
				// Collect all window/document events bound by editor instance
				if (self.settings.collect && (target === self.doc || target === self.win)) {
					self.boundEvents.push([target, name, func, scope]);
				}
	
				return self.events.bind(target, name, func, scope || self);
			},
	
			/**
			 * Removes the specified event handler by name and function from an element or collection of elements.
			 *
			 * @method unbind
			 * @param {Element/Document/Window/Array} target Target element to unbind events on.
			 * @param {String} name Event handler name, for example: "click"
			 * @param {function} func Function to remove.
			 * @return {bool/Array} Bool state of true if the handler was removed, or an array of states if multiple input elements
			 * were passed in.
			 */
			unbind: function(target, name, func) {
				var self = this, i;
	
				if (Tools.isArray(target)) {
					i = target.length;
	
					while (i--) {
						target[i] = self.unbind(target[i], name, func);
					}
	
					return target;
				}
	
				// Remove any bound events matching the input
				if (self.boundEvents && (target === self.doc || target === self.win)) {
					i = self.boundEvents.length;
	
					while (i--) {
						var item = self.boundEvents[i];
	
						if (target == item[0] && (!name || name == item[1]) && (!func || func == item[2])) {
							this.events.unbind(item[0], item[1], item[2]);
						}
					}
				}
	
				return this.events.unbind(target, name, func);
			},
	
			/**
			 * Fires the specified event name with object on target.
			 *
			 * @method fire
			 * @param {Node/Document/Window} target Target element or object to fire event on.
			 * @param {String} name Name of the event to fire.
			 * @param {Object} evt Event object to send.
			 * @return {Event} Event object.
			 */
			fire: function(target, name, evt) {
				return this.events.fire(target, name, evt);
			},
	
			// Returns the content editable state of a node
			getContentEditable: function(node) {
				var contentEditable;
	
				// Check type
				if (!node || node.nodeType != 1) {
					return null;
				}
	
				// Check for fake content editable
				contentEditable = node.getAttribute("data-mce-contenteditable");
				if (contentEditable && contentEditable !== "inherit") {
					return contentEditable;
				}
	
				// Check for real content editable
				return node.contentEditable !== "inherit" ? node.contentEditable : null;
			},
	
			getContentEditableParent: function(node) {
				var root = this.getRoot(), state = null;
	
				for (; node && node !== root; node = node.parentNode) {
					state = this.getContentEditable(node);
	
					if (state !== null) {
						break;
					}
				}
	
				return state;
			},
	
			/**
			 * Destroys all internal references to the DOM to solve IE leak issues.
			 *
			 * @method destroy
			 */
			destroy: function() {
				var self = this;
	
				// Unbind all events bound to window/document by editor instance
				if (self.boundEvents) {
					var i = self.boundEvents.length;
	
					while (i--) {
						var item = self.boundEvents[i];
						this.events.unbind(item[0], item[1], item[2]);
					}
	
					self.boundEvents = null;
				}
	
				// Restore sizzle document to window.document
				// Since the current document might be removed producing "Permission denied" on IE see #6325
				if (Sizzle.setDocument) {
					Sizzle.setDocument();
				}
	
				self.win = self.doc = self.root = self.events = self.frag = null;
			},
	
			isChildOf: function(node, parent) {
				while (node) {
					if (parent === node) {
						return true;
					}
	
					node = node.parentNode;
				}
	
				return false;
			},
	
			// #ifdef debug
	
			dumpRng: function(r) {
				return (
					'startContainer: ' + r.startContainer.nodeName +
					', startOffset: ' + r.startOffset +
					', endContainer: ' + r.endContainer.nodeName +
					', endOffset: ' + r.endOffset
				);
			},
	
			// #endif
	
			_findSib: function(node, selector, name) {
				var self = this, func = selector;
	
				if (node) {
					// If expression make a function of it using is
					if (typeof func == 'string') {
						func = function(node) {
							return self.is(node, selector);
						};
					}
	
					// Loop all siblings
					for (node = node[name]; node; node = node[name]) {
						if (func(node)) {
							return node;
						}
					}
				}
	
				return null;
			}
		};
	
		/**
		 * Instance of DOMUtils for the current document.
		 *
		 * @static
		 * @property DOM
		 * @type tinymce.dom.DOMUtils
		 * @example
		 * // Example of how to add a class to some element by id
		 * tinymce.DOM.addClass('someid', 'someclass');
		 */
		DOMUtils.DOM = new DOMUtils(document);
		DOMUtils.nodeIndex = nodeIndex;
	
		return DOMUtils;
	});
	
	// Included from: js/tinymce/classes/dom/ScriptLoader.js
	
	/**
	 * ScriptLoader.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/*globals console*/
	
	/**
	 * This class handles asynchronous/synchronous loading of JavaScript files it will execute callbacks
	 * when various items gets loaded. This class is useful to load external JavaScript files.
	 *
	 * @class tinymce.dom.ScriptLoader
	 * @example
	 * // Load a script from a specific URL using the global script loader
	 * tinymce.ScriptLoader.load('somescript.js');
	 *
	 * // Load a script using a unique instance of the script loader
	 * var scriptLoader = new tinymce.dom.ScriptLoader();
	 *
	 * scriptLoader.load('somescript.js');
	 *
	 * // Load multiple scripts
	 * var scriptLoader = new tinymce.dom.ScriptLoader();
	 *
	 * scriptLoader.add('somescript1.js');
	 * scriptLoader.add('somescript2.js');
	 * scriptLoader.add('somescript3.js');
	 *
	 * scriptLoader.loadQueue(function() {
	 *    alert('All scripts are now loaded.');
	 * });
	 */
	define("tinymce/dom/ScriptLoader", [
		"tinymce/dom/DOMUtils",
		"tinymce/util/Tools"
	], function(DOMUtils, Tools) {
		var DOM = DOMUtils.DOM;
		var each = Tools.each, grep = Tools.grep;
	
		function ScriptLoader() {
			var QUEUED = 0,
				LOADING = 1,
				LOADED = 2,
				states = {},
				queue = [],
				scriptLoadedCallbacks = {},
				queueLoadedCallbacks = [],
				loading = 0,
				undef;
	
			/**
			 * Loads a specific script directly without adding it to the load queue.
			 *
			 * @method load
			 * @param {String} url Absolute URL to script to add.
			 * @param {function} callback Optional callback function to execute ones this script gets loaded.
			 */
			function loadScript(url, callback) {
				var dom = DOM, elm, id;
	
				// Execute callback when script is loaded
				function done() {
					dom.remove(id);
	
					if (elm) {
						elm.onreadystatechange = elm.onload = elm = null;
					}
	
					callback();
				}
	
				function error() {
					/*eslint no-console:0 */
	
					// Report the error so it's easier for people to spot loading errors
					if (typeof console !== "undefined" && console.log) {
						console.log("Failed to load: " + url);
					}
	
					// We can't mark it as done if there is a load error since
					// A) We don't want to produce 404 errors on the server and
					// B) the onerror event won't fire on all browsers.
					// done();
				}
	
				id = dom.uniqueId();
	
				// Create new script element
				elm = document.createElement('script');
				elm.id = id;
				elm.type = 'text/javascript';
				elm.src = Tools._addCacheSuffix(url);
	
				// Seems that onreadystatechange works better on IE 10 onload seems to fire incorrectly
				if ("onreadystatechange" in elm) {
					elm.onreadystatechange = function() {
						if (/loaded|complete/.test(elm.readyState)) {
							done();
						}
					};
				} else {
					elm.onload = done;
				}
	
				// Add onerror event will get fired on some browsers but not all of them
				elm.onerror = error;
	
				// Add script to document
				(document.getElementsByTagName('head')[0] || document.body).appendChild(elm);
			}
	
			/**
			 * Returns true/false if a script has been loaded or not.
			 *
			 * @method isDone
			 * @param {String} url URL to check for.
			 * @return {Boolean} true/false if the URL is loaded.
			 */
			this.isDone = function(url) {
				return states[url] == LOADED;
			};
	
			/**
			 * Marks a specific script to be loaded. This can be useful if a script got loaded outside
			 * the script loader or to skip it from loading some script.
			 *
			 * @method markDone
			 * @param {string} url Absolute URL to the script to mark as loaded.
			 */
			this.markDone = function(url) {
				states[url] = LOADED;
			};
	
			/**
			 * Adds a specific script to the load queue of the script loader.
			 *
			 * @method add
			 * @param {String} url Absolute URL to script to add.
			 * @param {function} callback Optional callback function to execute ones this script gets loaded.
			 * @param {Object} scope Optional scope to execute callback in.
			 */
			this.add = this.load = function(url, callback, scope) {
				var state = states[url];
	
				// Add url to load queue
				if (state == undef) {
					queue.push(url);
					states[url] = QUEUED;
				}
	
				if (callback) {
					// Store away callback for later execution
					if (!scriptLoadedCallbacks[url]) {
						scriptLoadedCallbacks[url] = [];
					}
	
					scriptLoadedCallbacks[url].push({
						func: callback,
						scope: scope || this
					});
				}
			};
	
			this.remove = function(url) {
				delete states[url];
				delete scriptLoadedCallbacks[url];
			};
	
			/**
			 * Starts the loading of the queue.
			 *
			 * @method loadQueue
			 * @param {function} callback Optional callback to execute when all queued items are loaded.
			 * @param {Object} scope Optional scope to execute the callback in.
			 */
			this.loadQueue = function(callback, scope) {
				this.loadScripts(queue, callback, scope);
			};
	
			/**
			 * Loads the specified queue of files and executes the callback ones they are loaded.
			 * This method is generally not used outside this class but it might be useful in some scenarios.
			 *
			 * @method loadScripts
			 * @param {Array} scripts Array of queue items to load.
			 * @param {function} callback Optional callback to execute ones all items are loaded.
			 * @param {Object} scope Optional scope to execute callback in.
			 */
			this.loadScripts = function(scripts, callback, scope) {
				var loadScripts;
	
				function execScriptLoadedCallbacks(url) {
					// Execute URL callback functions
					each(scriptLoadedCallbacks[url], function(callback) {
						callback.func.call(callback.scope);
					});
	
					scriptLoadedCallbacks[url] = undef;
				}
	
				queueLoadedCallbacks.push({
					func: callback,
					scope: scope || this
				});
	
				loadScripts = function() {
					var loadingScripts = grep(scripts);
	
					// Current scripts has been handled
					scripts.length = 0;
	
					// Load scripts that needs to be loaded
					each(loadingScripts, function(url) {
						// Script is already loaded then execute script callbacks directly
						if (states[url] == LOADED) {
							execScriptLoadedCallbacks(url);
							return;
						}
	
						// Is script not loading then start loading it
						if (states[url] != LOADING) {
							states[url] = LOADING;
							loading++;
	
							loadScript(url, function() {
								states[url] = LOADED;
								loading--;
	
								execScriptLoadedCallbacks(url);
	
								// Load more scripts if they where added by the recently loaded script
								loadScripts();
							});
						}
					});
	
					// No scripts are currently loading then execute all pending queue loaded callbacks
					if (!loading) {
						each(queueLoadedCallbacks, function(callback) {
							callback.func.call(callback.scope);
						});
	
						queueLoadedCallbacks.length = 0;
					}
				};
	
				loadScripts();
			};
		}
	
		ScriptLoader.ScriptLoader = new ScriptLoader();
	
		return ScriptLoader;
	});
	
	// Included from: js/tinymce/classes/AddOnManager.js
	
	/**
	 * AddOnManager.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This class handles the loading of themes/plugins or other add-ons and their language packs.
	 *
	 * @class tinymce.AddOnManager
	 */
	define("tinymce/AddOnManager", [
		"tinymce/dom/ScriptLoader",
		"tinymce/util/Tools"
	], function(ScriptLoader, Tools) {
		var each = Tools.each;
	
		function AddOnManager() {
			var self = this;
	
			self.items = [];
			self.urls = {};
			self.lookup = {};
		}
	
		AddOnManager.prototype = {
			/**
			 * Returns the specified add on by the short name.
			 *
			 * @method get
			 * @param {String} name Add-on to look for.
			 * @return {tinymce.Theme/tinymce.Plugin} Theme or plugin add-on instance or undefined.
			 */
			get: function(name) {
				if (this.lookup[name]) {
					return this.lookup[name].instance;
				}
	
				return undefined;
			},
	
			dependencies: function(name) {
				var result;
	
				if (this.lookup[name]) {
					result = this.lookup[name].dependencies;
				}
	
				return result || [];
			},
	
			/**
			 * Loads a language pack for the specified add-on.
			 *
			 * @method requireLangPack
			 * @param {String} name Short name of the add-on.
			 * @param {String} languages Optional comma or space separated list of languages to check if it matches the name.
			 */
			requireLangPack: function(name, languages) {
				var language = AddOnManager.language;
	
				if (language && AddOnManager.languageLoad !== false) {
					if (languages) {
						languages = ',' + languages + ',';
	
						// Load short form sv.js or long form sv_SE.js
						if (languages.indexOf(',' + language.substr(0, 2) + ',') != -1) {
							language = language.substr(0, 2);
						} else if (languages.indexOf(',' + language + ',') == -1) {
							return;
						}
					}
	
					ScriptLoader.ScriptLoader.add(this.urls[name] + '/langs/' + language + '.js');
				}
			},
	
			/**
			 * Adds a instance of the add-on by it's short name.
			 *
			 * @method add
			 * @param {String} id Short name/id for the add-on.
			 * @param {tinymce.Theme/tinymce.Plugin} addOn Theme or plugin to add.
			 * @return {tinymce.Theme/tinymce.Plugin} The same theme or plugin instance that got passed in.
			 * @example
			 * // Create a simple plugin
			 * tinymce.create('tinymce.plugins.TestPlugin', {
			 *   TestPlugin: function(ed, url) {
			 *   ed.on('click', function(e) {
			 *      ed.windowManager.alert('Hello World!');
			 *   });
			 *   }
			 * });
			 *
			 * // Register plugin using the add method
			 * tinymce.PluginManager.add('test', tinymce.plugins.TestPlugin);
			 *
			 * // Initialize TinyMCE
			 * tinymce.init({
			 *  ...
			 *  plugins: '-test' // Init the plugin but don't try to load it
			 * });
			 */
			add: function(id, addOn, dependencies) {
				this.items.push(addOn);
				this.lookup[id] = {instance: addOn, dependencies: dependencies};
	
				return addOn;
			},
	
			remove: function(name) {
				delete this.urls[name];
				delete this.lookup[name];
			},
	
			createUrl: function(baseUrl, dep) {
				if (typeof dep === "object") {
					return dep;
				}
	
				return {prefix: baseUrl.prefix, resource: dep, suffix: baseUrl.suffix};
			},
	
			/**
			 * Add a set of components that will make up the add-on. Using the url of the add-on name as the base url.
			 * This should be used in development mode.  A new compressor/javascript munger process will ensure that the
			 * components are put together into the plugin.js file and compressed correctly.
			 *
			 * @method addComponents
			 * @param {String} pluginName name of the plugin to load scripts from (will be used to get the base url for the plugins).
			 * @param {Array} scripts Array containing the names of the scripts to load.
			 */
			addComponents: function(pluginName, scripts) {
				var pluginUrl = this.urls[pluginName];
	
				each(scripts, function(script) {
					ScriptLoader.ScriptLoader.add(pluginUrl + "/" + script);
				});
			},
	
			/**
			 * Loads an add-on from a specific url.
			 *
			 * @method load
			 * @param {String} name Short name of the add-on that gets loaded.
			 * @param {String} addOnUrl URL to the add-on that will get loaded.
			 * @param {function} callback Optional callback to execute ones the add-on is loaded.
			 * @param {Object} scope Optional scope to execute the callback in.
			 * @example
			 * // Loads a plugin from an external URL
			 * tinymce.PluginManager.load('myplugin', '/some/dir/someplugin/plugin.js');
			 *
			 * // Initialize TinyMCE
			 * tinymce.init({
			 *  ...
			 *  plugins: '-myplugin' // Don't try to load it again
			 * });
			 */
			load: function(name, addOnUrl, callback, scope) {
				var self = this, url = addOnUrl;
	
				function loadDependencies() {
					var dependencies = self.dependencies(name);
	
					each(dependencies, function(dep) {
						var newUrl = self.createUrl(addOnUrl, dep);
	
						self.load(newUrl.resource, newUrl, undefined, undefined);
					});
	
					if (callback) {
						if (scope) {
							callback.call(scope);
						} else {
							callback.call(ScriptLoader);
						}
					}
				}
	
				if (self.urls[name]) {
					return;
				}
	
				if (typeof addOnUrl === "object") {
					url = addOnUrl.prefix + addOnUrl.resource + addOnUrl.suffix;
				}
	
				if (url.indexOf('/') !== 0 && url.indexOf('://') == -1) {
					url = AddOnManager.baseURL + '/' + url;
				}
	
				self.urls[name] = url.substring(0, url.lastIndexOf('/'));
	
				if (self.lookup[name]) {
					loadDependencies();
				} else {
					ScriptLoader.ScriptLoader.add(url, loadDependencies, scope);
				}
			}
		};
	
		AddOnManager.PluginManager = new AddOnManager();
		AddOnManager.ThemeManager = new AddOnManager();
	
		return AddOnManager;
	});
	
	/**
	 * TinyMCE theme class.
	 *
	 * @class tinymce.Theme
	 */
	
	/**
	 * This method is responsible for rendering/generating the overall user interface with toolbars, buttons, iframe containers etc.
	 *
	 * @method renderUI
	 * @param {Object} obj Object parameter containing the targetNode DOM node that will be replaced visually with an editor instance.
	 * @return {Object} an object with items like iframeContainer, editorContainer, sizeContainer, deltaWidth, deltaHeight.
	 */
	
	/**
	 * Plugin base class, this is a pseudo class that describes how a plugin is to be created for TinyMCE. The methods below are all optional.
	 *
	 * @class tinymce.Plugin
	 * @example
	 * tinymce.PluginManager.add('example', function(editor, url) {
	 *     // Add a button that opens a window
	 *     editor.addButton('example', {
	 *         text: 'My button',
	 *         icon: false,
	 *         onclick: function() {
	 *             // Open window
	 *             editor.windowManager.open({
	 *                 title: 'Example plugin',
	 *                 body: [
	 *                     {type: 'textbox', name: 'title', label: 'Title'}
	 *                 ],
	 *                 onsubmit: function(e) {
	 *                     // Insert content when the window form is submitted
	 *                     editor.insertContent('Title: ' + e.data.title);
	 *                 }
	 *             });
	 *         }
	 *     });
	 *
	 *     // Adds a menu item to the tools menu
	 *     editor.addMenuItem('example', {
	 *         text: 'Example plugin',
	 *         context: 'tools',
	 *         onclick: function() {
	 *             // Open window with a specific url
	 *             editor.windowManager.open({
	 *                 title: 'TinyMCE site',
	 *                 url: 'http://www.tinymce.com',
	 *                 width: 800,
	 *                 height: 600,
	 *                 buttons: [{
	 *                     text: 'Close',
	 *                     onclick: 'close'
	 *                 }]
	 *             });
	 *         }
	 *     });
	 * });
	 */
	
	// Included from: js/tinymce/classes/dom/NodeType.js
	
	/**
	 * NodeType.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Contains various node validation functions.
	 *
	 * @private
	 * @class tinymce.dom.NodeType
	 */
	define("tinymce/dom/NodeType", [], function() {
		function isNodeType(type) {
			return function(node) {
				return !!node && node.nodeType == type;
			};
		}
	
		var isElement = isNodeType(1);
	
		function matchNodeNames(names) {
			names = names.toLowerCase().split(' ');
	
			return function(node) {
				var i, name;
	
				if (node && node.nodeType) {
					name = node.nodeName.toLowerCase();
	
					for (i = 0; i < names.length; i++) {
						if (name === names[i]) {
							return true;
						}
					}
				}
	
				return false;
			};
		}
	
		function matchStyleValues(name, values) {
			values = values.toLowerCase().split(' ');
	
			return function(node) {
				var i, cssValue;
	
				if (isElement(node)) {
					for (i = 0; i < values.length; i++) {
						cssValue = getComputedStyle(node, null).getPropertyValue(name);
						if (cssValue === values[i]) {
							return true;
						}
					}
				}
	
				return false;
			};
		}
	
		function hasPropValue(propName, propValue) {
			return function(node) {
				return isElement(node) && node[propName] === propValue;
			};
		}
	
		function hasAttributeValue(attrName, attrValue) {
			return function(node) {
				return isElement(node) && node.getAttribute(attrName) === attrValue;
			};
		}
	
		function isBogus(node) {
			return isElement(node) && node.hasAttribute('data-mce-bogus');
		}
	
		function hasContentEditableState(value) {
			return function(node) {
				if (isElement(node)) {
					if (node.contentEditable === value) {
						return true;
					}
	
					if (node.getAttribute('data-mce-contenteditable') === value) {
						return true;
					}
				}
	
				return false;
			};
		}
	
		return {
			isText: isNodeType(3),
			isElement: isElement,
			isComment: isNodeType(8),
			isBr: matchNodeNames('br'),
			isContentEditableTrue: hasContentEditableState('true'),
			isContentEditableFalse: hasContentEditableState('false'),
			matchNodeNames: matchNodeNames,
			hasPropValue: hasPropValue,
			hasAttributeValue: hasAttributeValue,
			matchStyleValues: matchStyleValues,
			isBogus: isBogus
		};
	});
	
	// Included from: js/tinymce/classes/text/Zwsp.js
	
	/**
	 * Zwsp.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Utility functions for working with zero width space
	 * characters used as character containers etc.
	 *
	 * @private
	 * @class tinymce.text.Zwsp
	 * @example
	 * var isZwsp = Zwsp.isZwsp('\uFEFF');
	 * var abc = Zwsp.trim('a\uFEFFc');
	 */
	define("tinymce/text/Zwsp", [], function() {
		var ZWSP = '\uFEFF';
	
		function isZwsp(chr) {
			return chr == ZWSP;
		}
	
		function trim(str) {
			return str.replace(new RegExp(ZWSP, 'g'), '');
		}
	
		return {
			isZwsp: isZwsp,
			ZWSP: ZWSP,
			trim: trim
		};
	});
	
	// Included from: js/tinymce/classes/caret/CaretContainer.js
	
	/**
	 * CaretContainer.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This module handles caret containers. A caret container is a node that
	 * holds the caret for positional purposes.
	 *
	 * @private
	 * @class tinymce.caret.CaretContainer
	 */
	define("tinymce/caret/CaretContainer", [
		"tinymce/dom/NodeType",
		"tinymce/text/Zwsp"
	], function(NodeType, Zwsp) {
		var isElement = NodeType.isElement,
			isText = NodeType.isText;
	
		function isCaretContainerBlock(node) {
			if (isText(node)) {
				node = node.parentNode;
			}
	
			return isElement(node) && node.hasAttribute('data-mce-caret');
		}
	
		function isCaretContainerInline(node) {
			return isText(node) && Zwsp.isZwsp(node.data);
		}
	
		function isCaretContainer(node) {
			return isCaretContainerBlock(node) || isCaretContainerInline(node);
		}
	
		function removeNode(node) {
			var parentNode = node.parentNode;
			if (parentNode) {
				parentNode.removeChild(node);
			}
		}
	
		function getNodeValue(node) {
			try {
				return node.nodeValue;
			} catch (ex) {
				// IE sometimes produces "Invalid argument" on nodes
				return "";
			}
		}
	
		function setNodeValue(node, text) {
			if (text.length === 0) {
				removeNode(node);
			} else {
				node.nodeValue = text;
			}
		}
	
		function insertInline(node, before) {
			var doc, sibling, textNode, parentNode;
	
			doc = node.ownerDocument;
			textNode = doc.createTextNode(Zwsp.ZWSP);
			parentNode = node.parentNode;
	
			if (!before) {
				sibling = node.nextSibling;
				if (isText(sibling)) {
					if (isCaretContainer(sibling)) {
						return sibling;
					}
	
					if (startsWithCaretContainer(sibling)) {
						sibling.splitText(1);
						return sibling;
					}
				}
	
				if (node.nextSibling) {
					parentNode.insertBefore(textNode, node.nextSibling);
				} else {
					parentNode.appendChild(textNode);
				}
			} else {
				sibling = node.previousSibling;
				if (isText(sibling)) {
					if (isCaretContainer(sibling)) {
						return sibling;
					}
	
					if (endsWithCaretContainer(sibling)) {
						return sibling.splitText(sibling.data.length - 1);
					}
				}
	
				parentNode.insertBefore(textNode, node);
			}
	
			return textNode;
		}
	
		function createBogusBr() {
			var br = document.createElement('br');
			br.setAttribute('data-mce-bogus', '1');
			return br;
		}
	
		function insertBlock(blockName, node, before) {
			var doc, blockNode, parentNode;
	
			doc = node.ownerDocument;
			blockNode = doc.createElement(blockName);
			blockNode.setAttribute('data-mce-caret', before ? 'before' : 'after');
			blockNode.setAttribute('data-mce-bogus', 'all');
			blockNode.appendChild(createBogusBr());
			parentNode = node.parentNode;
	
			if (!before) {
				if (node.nextSibling) {
					parentNode.insertBefore(blockNode, node.nextSibling);
				} else {
					parentNode.appendChild(blockNode);
				}
			} else {
				parentNode.insertBefore(blockNode, node);
			}
	
			return blockNode;
		}
	
		function hasContent(node) {
			return node.firstChild !== node.lastChild || !NodeType.isBr(node.firstChild);
		}
	
		function remove(caretContainerNode) {
			if (isElement(caretContainerNode) && isCaretContainer(caretContainerNode)) {
				if (hasContent(caretContainerNode)) {
					caretContainerNode.removeAttribute('data-mce-caret');
				} else {
					removeNode(caretContainerNode);
				}
			}
	
			if (isText(caretContainerNode)) {
				var text = Zwsp.trim(getNodeValue(caretContainerNode));
				setNodeValue(caretContainerNode, text);
			}
		}
	
		function startsWithCaretContainer(node) {
			return isText(node) && node.data[0] == Zwsp.ZWSP;
		}
	
		function endsWithCaretContainer(node) {
			return isText(node) && node.data[node.data.length - 1] == Zwsp.ZWSP;
		}
	
		function trimBogusBr(elm) {
			var brs = elm.getElementsByTagName('br');
			var lastBr = brs[brs.length - 1];
			if (NodeType.isBogus(lastBr)) {
				lastBr.parentNode.removeChild(lastBr);
			}
		}
	
		function showCaretContainerBlock(caretContainer) {
			if (caretContainer && caretContainer.hasAttribute('data-mce-caret')) {
				trimBogusBr(caretContainer);
				caretContainer.removeAttribute('data-mce-caret');
				caretContainer.removeAttribute('data-mce-bogus');
				caretContainer.removeAttribute('style');
				caretContainer.removeAttribute('_moz_abspos');
				return caretContainer;
			}
	
			return null;
		}
	
		return {
			isCaretContainer: isCaretContainer,
			isCaretContainerBlock: isCaretContainerBlock,
			isCaretContainerInline: isCaretContainerInline,
			showCaretContainerBlock: showCaretContainerBlock,
			insertInline: insertInline,
			insertBlock: insertBlock,
			hasContent: hasContent,
			remove: remove,
			startsWithCaretContainer: startsWithCaretContainer,
			endsWithCaretContainer: endsWithCaretContainer
		};
	});
	
	// Included from: js/tinymce/classes/dom/RangeUtils.js
	
	/**
	 * RangeUtils.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This class contains a few utility methods for ranges.
	 *
	 * @class tinymce.dom.RangeUtils
	 */
	define("tinymce/dom/RangeUtils", [
		"tinymce/util/Tools",
		"tinymce/dom/TreeWalker",
		"tinymce/dom/NodeType",
		"tinymce/dom/Range",
		"tinymce/caret/CaretContainer"
	], function(Tools, TreeWalker, NodeType, Range, CaretContainer) {
		var each = Tools.each,
			isContentEditableTrue = NodeType.isContentEditableTrue,
			isContentEditableFalse = NodeType.isContentEditableFalse,
			isCaretContainer = CaretContainer.isCaretContainer;
	
		function hasCeProperty(node) {
			return isContentEditableTrue(node) || isContentEditableFalse(node);
		}
	
		function getEndChild(container, index) {
			var childNodes = container.childNodes;
	
			index--;
	
			if (index > childNodes.length - 1) {
				index = childNodes.length - 1;
			} else if (index < 0) {
				index = 0;
			}
	
			return childNodes[index] || container;
		}
	
		function findParent(node, rootNode, predicate) {
			while (node && node !== rootNode) {
				if (predicate(node)) {
					return node;
				}
	
				node = node.parentNode;
			}
	
			return null;
		}
	
		function hasParent(node, rootNode, predicate) {
			return findParent(node, rootNode, predicate) !== null;
		}
	
		function isFormatterCaret(node) {
			return node.id === '_mce_caret';
		}
	
		function isCeFalseCaretContainer(node, rootNode) {
			return isCaretContainer(node) && hasParent(node, rootNode, isFormatterCaret) === false;
		}
	
		function RangeUtils(dom) {
			/**
			 * Walks the specified range like object and executes the callback for each sibling collection it finds.
			 *
			 * @private
			 * @method walk
			 * @param {Object} rng Range like object.
			 * @param {function} callback Callback function to execute for each sibling collection.
			 */
			this.walk = function(rng, callback) {
				var startContainer = rng.startContainer,
					startOffset = rng.startOffset,
					endContainer = rng.endContainer,
					endOffset = rng.endOffset,
					ancestor, startPoint,
					endPoint, node, parent, siblings, nodes;
	
				// Handle table cell selection the table plugin enables
				// you to fake select table cells and perform formatting actions on them
				nodes = dom.select('td[data-mce-selected],th[data-mce-selected]');
				if (nodes.length > 0) {
					each(nodes, function(node) {
						callback([node]);
					});
	
					return;
				}
	
				/**
				 * Excludes start/end text node if they are out side the range
				 *
				 * @private
				 * @param {Array} nodes Nodes to exclude items from.
				 * @return {Array} Array with nodes excluding the start/end container if needed.
				 */
				function exclude(nodes) {
					var node;
	
					// First node is excluded
					node = nodes[0];
					if (node.nodeType === 3 && node === startContainer && startOffset >= node.nodeValue.length) {
						nodes.splice(0, 1);
					}
	
					// Last node is excluded
					node = nodes[nodes.length - 1];
					if (endOffset === 0 && nodes.length > 0 && node === endContainer && node.nodeType === 3) {
						nodes.splice(nodes.length - 1, 1);
					}
	
					return nodes;
				}
	
				/**
				 * Collects siblings
				 *
				 * @private
				 * @param {Node} node Node to collect siblings from.
				 * @param {String} name Name of the sibling to check for.
				 * @param {Node} end_node
				 * @return {Array} Array of collected siblings.
				 */
				function collectSiblings(node, name, end_node) {
					var siblings = [];
	
					for (; node && node != end_node; node = node[name]) {
						siblings.push(node);
					}
	
					return siblings;
				}
	
				/**
				 * Find an end point this is the node just before the common ancestor root.
				 *
				 * @private
				 * @param {Node} node Node to start at.
				 * @param {Node} root Root/ancestor element to stop just before.
				 * @return {Node} Node just before the root element.
				 */
				function findEndPoint(node, root) {
					do {
						if (node.parentNode == root) {
							return node;
						}
	
						node = node.parentNode;
					} while (node);
				}
	
				function walkBoundary(start_node, end_node, next) {
					var siblingName = next ? 'nextSibling' : 'previousSibling';
	
					for (node = start_node, parent = node.parentNode; node && node != end_node; node = parent) {
						parent = node.parentNode;
						siblings = collectSiblings(node == start_node ? node : node[siblingName], siblingName);
	
						if (siblings.length) {
							if (!next) {
								siblings.reverse();
							}
	
							callback(exclude(siblings));
						}
					}
				}
	
				// If index based start position then resolve it
				if (startContainer.nodeType == 1 && startContainer.hasChildNodes()) {
					startContainer = startContainer.childNodes[startOffset];
				}
	
				// If index based end position then resolve it
				if (endContainer.nodeType == 1 && endContainer.hasChildNodes()) {
					endContainer = getEndChild(endContainer, endOffset);
				}
	
				// Same container
				if (startContainer == endContainer) {
					return callback(exclude([startContainer]));
				}
	
				// Find common ancestor and end points
				ancestor = dom.findCommonAncestor(startContainer, endContainer);
	
				// Process left side
				for (node = startContainer; node; node = node.parentNode) {
					if (node === endContainer) {
						return walkBoundary(startContainer, ancestor, true);
					}
	
					if (node === ancestor) {
						break;
					}
				}
	
				// Process right side
				for (node = endContainer; node; node = node.parentNode) {
					if (node === startContainer) {
						return walkBoundary(endContainer, ancestor);
					}
	
					if (node === ancestor) {
						break;
					}
				}
	
				// Find start/end point
				startPoint = findEndPoint(startContainer, ancestor) || startContainer;
				endPoint = findEndPoint(endContainer, ancestor) || endContainer;
	
				// Walk left leaf
				walkBoundary(startContainer, startPoint, true);
	
				// Walk the middle from start to end point
				siblings = collectSiblings(
					startPoint == startContainer ? startPoint : startPoint.nextSibling,
					'nextSibling',
					endPoint == endContainer ? endPoint.nextSibling : endPoint
				);
	
				if (siblings.length) {
					callback(exclude(siblings));
				}
	
				// Walk right leaf
				walkBoundary(endContainer, endPoint);
			};
	
			/**
			 * Splits the specified range at it's start/end points.
			 *
			 * @private
			 * @param {Range/RangeObject} rng Range to split.
			 * @return {Object} Range position object.
			 */
			this.split = function(rng) {
				var startContainer = rng.startContainer,
					startOffset = rng.startOffset,
					endContainer = rng.endContainer,
					endOffset = rng.endOffset;
	
				function splitText(node, offset) {
					return node.splitText(offset);
				}
	
				// Handle single text node
				if (startContainer == endContainer && startContainer.nodeType == 3) {
					if (startOffset > 0 && startOffset < startContainer.nodeValue.length) {
						endContainer = splitText(startContainer, startOffset);
						startContainer = endContainer.previousSibling;
	
						if (endOffset > startOffset) {
							endOffset = endOffset - startOffset;
							startContainer = endContainer = splitText(endContainer, endOffset).previousSibling;
							endOffset = endContainer.nodeValue.length;
							startOffset = 0;
						} else {
							endOffset = 0;
						}
					}
				} else {
					// Split startContainer text node if needed
					if (startContainer.nodeType == 3 && startOffset > 0 && startOffset < startContainer.nodeValue.length) {
						startContainer = splitText(startContainer, startOffset);
						startOffset = 0;
					}
	
					// Split endContainer text node if needed
					if (endContainer.nodeType == 3 && endOffset > 0 && endOffset < endContainer.nodeValue.length) {
						endContainer = splitText(endContainer, endOffset).previousSibling;
						endOffset = endContainer.nodeValue.length;
					}
				}
	
				return {
					startContainer: startContainer,
					startOffset: startOffset,
					endContainer: endContainer,
					endOffset: endOffset
				};
			};
	
			/**
			 * Normalizes the specified range by finding the closest best suitable caret location.
			 *
			 * @private
			 * @param {Range} rng Range to normalize.
			 * @return {Boolean} True/false if the specified range was normalized or not.
			 */
			this.normalize = function(rng) {
				var normalized, collapsed;
	
				function normalizeEndPoint(start) {
					var container, offset, walker, body = dom.getRoot(), node, nonEmptyElementsMap;
					var directionLeft, isAfterNode;
	
					function isTableCell(node) {
						return node && /^(TD|TH|CAPTION)$/.test(node.nodeName);
					}
	
					function hasBrBeforeAfter(node, left) {
						var walker = new TreeWalker(node, dom.getParent(node.parentNode, dom.isBlock) || body);
	
						while ((node = walker[left ? 'prev' : 'next']())) {
							if (node.nodeName === "BR") {
								return true;
							}
						}
					}
	
					function hasContentEditableFalseParent(node) {
						while (node && node != body) {
							if (isContentEditableFalse(node)) {
								return true;
							}
	
							node = node.parentNode;
						}
	
						return false;
					}
	
					function isPrevNode(node, name) {
						return node.previousSibling && node.previousSibling.nodeName == name;
					}
	
					// Walks the dom left/right to find a suitable text node to move the endpoint into
					// It will only walk within the current parent block or body and will stop if it hits a block or a BR/IMG
					function findTextNodeRelative(left, startNode) {
						var walker, lastInlineElement, parentBlockContainer;
	
						startNode = startNode || container;
						parentBlockContainer = dom.getParent(startNode.parentNode, dom.isBlock) || body;
	
						// Lean left before the BR element if it's the only BR within a block element. Gecko bug: #6680
						// This: <p><br>|</p> becomes <p>|<br></p>
						if (left && startNode.nodeName == 'BR' && isAfterNode && dom.isEmpty(parentBlockContainer)) {
							container = startNode.parentNode;
							offset = dom.nodeIndex(startNode);
							normalized = true;
							return;
						}
	
						// Walk left until we hit a text node we can move to or a block/br/img
						walker = new TreeWalker(startNode, parentBlockContainer);
						while ((node = walker[left ? 'prev' : 'next']())) {
							// Break if we hit a non content editable node
							if (dom.getContentEditableParent(node) === "false" || isCeFalseCaretContainer(node, dom.getRoot())) {
								return;
							}
	
							// Found text node that has a length
							if (node.nodeType === 3 && node.nodeValue.length > 0) {
								container = node;
								offset = left ? node.nodeValue.length : 0;
								normalized = true;
								return;
							}
	
							// Break if we find a block or a BR/IMG/INPUT etc
							if (dom.isBlock(node) || nonEmptyElementsMap[node.nodeName.toLowerCase()]) {
								return;
							}
	
							lastInlineElement = node;
						}
	
						// Only fetch the last inline element when in caret mode for now
						if (collapsed && lastInlineElement) {
							container = lastInlineElement;
							normalized = true;
							offset = 0;
						}
					}
	
					container = rng[(start ? 'start' : 'end') + 'Container'];
					offset = rng[(start ? 'start' : 'end') + 'Offset'];
					isAfterNode = container.nodeType == 1 && offset === container.childNodes.length;
					nonEmptyElementsMap = dom.schema.getNonEmptyElements();
					directionLeft = start;
	
					if (isCaretContainer(container)) {
						return;
					}
	
					if (container.nodeType == 1 && offset > container.childNodes.length - 1) {
						directionLeft = false;
					}
	
					// If the container is a document move it to the body element
					if (container.nodeType === 9) {
						container = dom.getRoot();
						offset = 0;
					}
	
					// If the container is body try move it into the closest text node or position
					if (container === body) {
						// If start is before/after a image, table etc
						if (directionLeft) {
							node = container.childNodes[offset > 0 ? offset - 1 : 0];
							if (node) {
								if (isCaretContainer(node)) {
									return;
								}
	
								if (nonEmptyElementsMap[node.nodeName] || node.nodeName == "TABLE") {
									return;
								}
							}
						}
	
						// Resolve the index
						if (container.hasChildNodes()) {
							offset = Math.min(!directionLeft && offset > 0 ? offset - 1 : offset, container.childNodes.length - 1);
							container = container.childNodes[offset];
							offset = 0;
	
							// Don't normalize non collapsed selections like <p>[a</p><table></table>]
							if (!collapsed && container === body.lastChild && container.nodeName === 'TABLE') {
								return;
							}
	
							if (hasContentEditableFalseParent(container) || isCaretContainer(container)) {
								return;
							}
	
							// Don't walk into elements that doesn't have any child nodes like a IMG
							if (container.hasChildNodes() && !/TABLE/.test(container.nodeName)) {
								// Walk the DOM to find a text node to place the caret at or a BR
								node = container;
								walker = new TreeWalker(container, body);
	
								do {
									if (isContentEditableFalse(node) || isCaretContainer(node)) {
										normalized = false;
										break;
									}
	
									// Found a text node use that position
									if (node.nodeType === 3 && node.nodeValue.length > 0) {
										offset = directionLeft ? 0 : node.nodeValue.length;
										container = node;
										normalized = true;
										break;
									}
	
									// Found a BR/IMG element that we can place the caret before
									if (nonEmptyElementsMap[node.nodeName.toLowerCase()] && !isTableCell(node)) {
										offset = dom.nodeIndex(node);
										container = node.parentNode;
	
										// Put caret after image when moving the end point
										if (node.nodeName == "IMG" && !directionLeft) {
											offset++;
										}
	
										normalized = true;
										break;
									}
								} while ((node = (directionLeft ? walker.next() : walker.prev())));
							}
						}
					}
	
					// Lean the caret to the left if possible
					if (collapsed) {
						// So this: <b>x</b><i>|x</i>
						// Becomes: <b>x|</b><i>x</i>
						// Seems that only gecko has issues with this
						if (container.nodeType === 3 && offset === 0) {
							findTextNodeRelative(true);
						}
	
						// Lean left into empty inline elements when the caret is before a BR
						// So this: <i><b></b><i>|<br></i>
						// Becomes: <i><b>|</b><i><br></i>
						// Seems that only gecko has issues with this.
						// Special edge case for <p><a>x</a>|<br></p> since we don't want <p><a>x|</a><br></p>
						if (container.nodeType === 1) {
							node = container.childNodes[offset];
	
							// Offset is after the containers last child
							// then use the previous child for normalization
							if (!node) {
								node = container.childNodes[offset - 1];
							}
	
							if (node && node.nodeName === 'BR' && !isPrevNode(node, 'A') &&
								!hasBrBeforeAfter(node) && !hasBrBeforeAfter(node, true)) {
								findTextNodeRelative(true, node);
							}
						}
					}
	
					// Lean the start of the selection right if possible
					// So this: x[<b>x]</b>
					// Becomes: x<b>[x]</b>
					if (directionLeft && !collapsed && container.nodeType === 3 && offset === container.nodeValue.length) {
						findTextNodeRelative(false);
					}
	
					// Set endpoint if it was normalized
					if (normalized) {
						rng['set' + (start ? 'Start' : 'End')](container, offset);
					}
				}
	
				collapsed = rng.collapsed;
	
				normalizeEndPoint(true);
	
				if (!collapsed) {
					normalizeEndPoint();
				}
	
				// If it was collapsed then make sure it still is
				if (normalized && collapsed) {
					rng.collapse(true);
				}
	
				return normalized;
			};
		}
	
		/**
		 * Compares two ranges and checks if they are equal.
		 *
		 * @static
		 * @method compareRanges
		 * @param {DOMRange} rng1 First range to compare.
		 * @param {DOMRange} rng2 First range to compare.
		 * @return {Boolean} true/false if the ranges are equal.
		 */
		RangeUtils.compareRanges = function(rng1, rng2) {
			if (rng1 && rng2) {
				// Compare native IE ranges
				if (rng1.item || rng1.duplicate) {
					// Both are control ranges and the selected element matches
					if (rng1.item && rng2.item && rng1.item(0) === rng2.item(0)) {
						return true;
					}
	
					// Both are text ranges and the range matches
					if (rng1.isEqual && rng2.isEqual && rng2.isEqual(rng1)) {
						return true;
					}
				} else {
					// Compare w3c ranges
					return rng1.startContainer == rng2.startContainer && rng1.startOffset == rng2.startOffset;
				}
			}
	
			return false;
		};
	
		/**
		 * Finds the closest selection rect tries to get the range from that.
		 */
		function findClosestIeRange(clientX, clientY, doc) {
			var element, rng, rects;
	
			element = doc.elementFromPoint(clientX, clientY);
			rng = doc.body.createTextRange();
	
			if (!element || element.tagName == 'HTML') {
				element = doc.body;
			}
	
			rng.moveToElementText(element);
			rects = Tools.toArray(rng.getClientRects());
	
			rects = rects.sort(function(a, b) {
				a = Math.abs(Math.max(a.top - clientY, a.bottom - clientY));
				b = Math.abs(Math.max(b.top - clientY, b.bottom - clientY));
	
				return a - b;
			});
	
			if (rects.length > 0) {
				clientY = (rects[0].bottom + rects[0].top) / 2;
	
				try {
					rng.moveToPoint(clientX, clientY);
					rng.collapse(true);
	
					return rng;
				} catch (ex) {
					// At least we tried
				}
			}
	
			return null;
		}
	
		function moveOutOfContentEditableFalse(rng, rootNode) {
			var parentElement = rng && rng.parentElement ? rng.parentElement() : null;
			return isContentEditableFalse(findParent(parentElement, rootNode, hasCeProperty)) ? null : rng;
		}
	
		/**
		 * Gets the caret range for the given x/y location.
		 *
		 * @static
		 * @method getCaretRangeFromPoint
		 * @param {Number} clientX X coordinate for range
		 * @param {Number} clientY Y coordinate for range
		 * @param {Document} doc Document that x/y are relative to
		 * @returns {Range} caret range
		 */
		RangeUtils.getCaretRangeFromPoint = function(clientX, clientY, doc) {
			var rng, point;
	
			if (doc.caretPositionFromPoint) {
				point = doc.caretPositionFromPoint(clientX, clientY);
				rng = doc.createRange();
				rng.setStart(point.offsetNode, point.offset);
				rng.collapse(true);
			} else if (doc.caretRangeFromPoint) {
				rng = doc.caretRangeFromPoint(clientX, clientY);
			} else if (doc.body.createTextRange) {
				rng = doc.body.createTextRange();
	
				try {
					rng.moveToPoint(clientX, clientY);
					rng.collapse(true);
				} catch (ex) {
					rng = findClosestIeRange(clientX, clientY, doc);
				}
	
				return moveOutOfContentEditableFalse(rng, doc.body);
			}
	
			return rng;
		};
	
		RangeUtils.getSelectedNode = function(range) {
			var startContainer = range.startContainer,
				startOffset = range.startOffset;
	
			if (startContainer.hasChildNodes() && range.endOffset == startOffset + 1) {
				return startContainer.childNodes[startOffset];
			}
	
			return null;
		};
	
		RangeUtils.getNode = function(container, offset) {
			if (container.nodeType == 1 && container.hasChildNodes()) {
				if (offset >= container.childNodes.length) {
					offset = container.childNodes.length - 1;
				}
	
				container = container.childNodes[offset];
			}
	
			return container;
		};
	
		return RangeUtils;
	});
	
	// Included from: js/tinymce/classes/NodeChange.js
	
	/**
	 * NodeChange.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This class handles the nodechange event dispatching both manual and through selection change events.
	 *
	 * @class tinymce.NodeChange
	 * @private
	 */
	define("tinymce/NodeChange", [
		"tinymce/dom/RangeUtils",
		"tinymce/Env",
		"tinymce/util/Delay"
	], function(RangeUtils, Env, Delay) {
		return function(editor) {
			var lastRng, lastPath = [];
	
			/**
			 * Returns true/false if the current element path has been changed or not.
			 *
			 * @private
			 * @return {Boolean} True if the element path is the same false if it's not.
			 */
			function isSameElementPath(startElm) {
				var i, currentPath;
	
				currentPath = editor.$(startElm).parentsUntil(editor.getBody()).add(startElm);
				if (currentPath.length === lastPath.length) {
					for (i = currentPath.length; i >= 0; i--) {
						if (currentPath[i] !== lastPath[i]) {
							break;
						}
					}
	
					if (i === -1) {
						lastPath = currentPath;
						return true;
					}
				}
	
				lastPath = currentPath;
	
				return false;
			}
	
			// Gecko doesn't support the "selectionchange" event
			if (!('onselectionchange' in editor.getDoc())) {
				editor.on('NodeChange Click MouseUp KeyUp Focus', function(e) {
					var nativeRng, fakeRng;
	
					// Since DOM Ranges mutate on modification
					// of the DOM we need to clone it's contents
					nativeRng = editor.selection.getRng();
					fakeRng = {
						startContainer: nativeRng.startContainer,
						startOffset: nativeRng.startOffset,
						endContainer: nativeRng.endContainer,
						endOffset: nativeRng.endOffset
					};
	
					// Always treat nodechange as a selectionchange since applying
					// formatting to the current range wouldn't update the range but it's parent
					if (e.type == 'nodechange' || !RangeUtils.compareRanges(fakeRng, lastRng)) {
						editor.fire('SelectionChange');
					}
	
					lastRng = fakeRng;
				});
			}
	
			// IE has a bug where it fires a selectionchange on right click that has a range at the start of the body
			// When the contextmenu event fires the selection is located at the right location
			editor.on('contextmenu', function() {
				editor.fire('SelectionChange');
			});
	
			// Selection change is delayed ~200ms on IE when you click inside the current range
			editor.on('SelectionChange', function() {
				var startElm = editor.selection.getStart(true);
	
				// IE 8 will fire a selectionchange event with an incorrect selection
				// when focusing out of table cells. Click inside cell -> toolbar = Invalid SelectionChange event
				if (!Env.range && editor.selection.isCollapsed()) {
					return;
				}
	
				if (!isSameElementPath(startElm) && editor.dom.isChildOf(startElm, editor.getBody())) {
					editor.nodeChanged({selectionChange: true});
				}
			});
	
			// Fire an extra nodeChange on mouseup for compatibility reasons
			editor.on('MouseUp', function(e) {
				if (!e.isDefaultPrevented()) {
					// Delay nodeChanged call for WebKit edge case issue where the range
					// isn't updated until after you click outside a selected image
					if (editor.selection.getNode().nodeName == 'IMG') {
						Delay.setEditorTimeout(editor, function() {
							editor.nodeChanged();
						});
					} else {
						editor.nodeChanged();
					}
				}
			});
	
			/**
			 * Dispatches out a onNodeChange event to all observers. This method should be called when you
			 * need to update the UI states or element path etc.
			 *
			 * @method nodeChanged
			 * @param {Object} args Optional args to pass to NodeChange event handlers.
			 */
			this.nodeChanged = function(args) {
				var selection = editor.selection, node, parents, root;
	
				// Fix for bug #1896577 it seems that this can not be fired while the editor is loading
				if (editor.initialized && selection && !editor.settings.disable_nodechange && !editor.readonly) {
					// Get start node
					root = editor.getBody();
					node = selection.getStart() || root;
	
					// Make sure the node is within the editor root or is the editor root
					if (node.ownerDocument != editor.getDoc() || !editor.dom.isChildOf(node, root)) {
						node = root;
					}
	
					// Edge case for <p>|<img></p>
					if (node.nodeName == 'IMG' && selection.isCollapsed()) {
						node = node.parentNode;
					}
	
					// Get parents and add them to object
					parents = [];
					editor.dom.getParent(node, function(node) {
						if (node === root) {
							return true;
						}
	
						parents.push(node);
					});
	
					args = args || {};
					args.element = node;
					args.parents = parents;
	
					editor.fire('NodeChange', args);
				}
			};
		};
	});
	
	// Included from: js/tinymce/classes/html/Node.js
	
	/**
	 * Node.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This class is a minimalistic implementation of a DOM like node used by the DomParser class.
	 *
	 * @example
	 * var node = new tinymce.html.Node('strong', 1);
	 * someRoot.append(node);
	 *
	 * @class tinymce.html.Node
	 * @version 3.4
	 */
	define("tinymce/html/Node", [], function() {
		var whiteSpaceRegExp = /^[ \t\r\n]*$/, typeLookup = {
			'#text': 3,
			'#comment': 8,
			'#cdata': 4,
			'#pi': 7,
			'#doctype': 10,
			'#document-fragment': 11
		};
	
		// Walks the tree left/right
		function walk(node, root_node, prev) {
			var sibling, parent, startName = prev ? 'lastChild' : 'firstChild', siblingName = prev ? 'prev' : 'next';
	
			// Walk into nodes if it has a start
			if (node[startName]) {
				return node[startName];
			}
	
			// Return the sibling if it has one
			if (node !== root_node) {
				sibling = node[siblingName];
	
				if (sibling) {
					return sibling;
				}
	
				// Walk up the parents to look for siblings
				for (parent = node.parent; parent && parent !== root_node; parent = parent.parent) {
					sibling = parent[siblingName];
	
					if (sibling) {
						return sibling;
					}
				}
			}
		}
	
		/**
		 * Constructs a new Node instance.
		 *
		 * @constructor
		 * @method Node
		 * @param {String} name Name of the node type.
		 * @param {Number} type Numeric type representing the node.
		 */
		function Node(name, type) {
			this.name = name;
			this.type = type;
	
			if (type === 1) {
				this.attributes = [];
				this.attributes.map = {};
			}
		}
	
		Node.prototype = {
			/**
			 * Replaces the current node with the specified one.
			 *
			 * @example
			 * someNode.replace(someNewNode);
			 *
			 * @method replace
			 * @param {tinymce.html.Node} node Node to replace the current node with.
			 * @return {tinymce.html.Node} The old node that got replaced.
			 */
			replace: function(node) {
				var self = this;
	
				if (node.parent) {
					node.remove();
				}
	
				self.insert(node, self);
				self.remove();
	
				return self;
			},
	
			/**
			 * Gets/sets or removes an attribute by name.
			 *
			 * @example
			 * someNode.attr("name", "value"); // Sets an attribute
			 * console.log(someNode.attr("name")); // Gets an attribute
			 * someNode.attr("name", null); // Removes an attribute
			 *
			 * @method attr
			 * @param {String} name Attribute name to set or get.
			 * @param {String} value Optional value to set.
			 * @return {String/tinymce.html.Node} String or undefined on a get operation or the current node on a set operation.
			 */
			attr: function(name, value) {
				var self = this, attrs, i, undef;
	
				if (typeof name !== "string") {
					for (i in name) {
						self.attr(i, name[i]);
					}
	
					return self;
				}
	
				if ((attrs = self.attributes)) {
					if (value !== undef) {
						// Remove attribute
						if (value === null) {
							if (name in attrs.map) {
								delete attrs.map[name];
	
								i = attrs.length;
								while (i--) {
									if (attrs[i].name === name) {
										attrs = attrs.splice(i, 1);
										return self;
									}
								}
							}
	
							return self;
						}
	
						// Set attribute
						if (name in attrs.map) {
							// Set attribute
							i = attrs.length;
							while (i--) {
								if (attrs[i].name === name) {
									attrs[i].value = value;
									break;
								}
							}
						} else {
							attrs.push({name: name, value: value});
						}
	
						attrs.map[name] = value;
	
						return self;
					}
	
					return attrs.map[name];
				}
			},
	
			/**
			 * Does a shallow clones the node into a new node. It will also exclude id attributes since
			 * there should only be one id per document.
			 *
			 * @example
			 * var clonedNode = node.clone();
			 *
			 * @method clone
			 * @return {tinymce.html.Node} New copy of the original node.
			 */
			clone: function() {
				var self = this, clone = new Node(self.name, self.type), i, l, selfAttrs, selfAttr, cloneAttrs;
	
				// Clone element attributes
				if ((selfAttrs = self.attributes)) {
					cloneAttrs = [];
					cloneAttrs.map = {};
	
					for (i = 0, l = selfAttrs.length; i < l; i++) {
						selfAttr = selfAttrs[i];
	
						// Clone everything except id
						if (selfAttr.name !== 'id') {
							cloneAttrs[cloneAttrs.length] = {name: selfAttr.name, value: selfAttr.value};
							cloneAttrs.map[selfAttr.name] = selfAttr.value;
						}
					}
	
					clone.attributes = cloneAttrs;
				}
	
				clone.value = self.value;
				clone.shortEnded = self.shortEnded;
	
				return clone;
			},
	
			/**
			 * Wraps the node in in another node.
			 *
			 * @example
			 * node.wrap(wrapperNode);
			 *
			 * @method wrap
			 */
			wrap: function(wrapper) {
				var self = this;
	
				self.parent.insert(wrapper, self);
				wrapper.append(self);
	
				return self;
			},
	
			/**
			 * Unwraps the node in other words it removes the node but keeps the children.
			 *
			 * @example
			 * node.unwrap();
			 *
			 * @method unwrap
			 */
			unwrap: function() {
				var self = this, node, next;
	
				for (node = self.firstChild; node;) {
					next = node.next;
					self.insert(node, self, true);
					node = next;
				}
	
				self.remove();
			},
	
			/**
			 * Removes the node from it's parent.
			 *
			 * @example
			 * node.remove();
			 *
			 * @method remove
			 * @return {tinymce.html.Node} Current node that got removed.
			 */
			remove: function() {
				var self = this, parent = self.parent, next = self.next, prev = self.prev;
	
				if (parent) {
					if (parent.firstChild === self) {
						parent.firstChild = next;
	
						if (next) {
							next.prev = null;
						}
					} else {
						prev.next = next;
					}
	
					if (parent.lastChild === self) {
						parent.lastChild = prev;
	
						if (prev) {
							prev.next = null;
						}
					} else {
						next.prev = prev;
					}
	
					self.parent = self.next = self.prev = null;
				}
	
				return self;
			},
	
			/**
			 * Appends a new node as a child of the current node.
			 *
			 * @example
			 * node.append(someNode);
			 *
			 * @method append
			 * @param {tinymce.html.Node} node Node to append as a child of the current one.
			 * @return {tinymce.html.Node} The node that got appended.
			 */
			append: function(node) {
				var self = this, last;
	
				if (node.parent) {
					node.remove();
				}
	
				last = self.lastChild;
				if (last) {
					last.next = node;
					node.prev = last;
					self.lastChild = node;
				} else {
					self.lastChild = self.firstChild = node;
				}
	
				node.parent = self;
	
				return node;
			},
	
			/**
			 * Inserts a node at a specific position as a child of the current node.
			 *
			 * @example
			 * parentNode.insert(newChildNode, oldChildNode);
			 *
			 * @method insert
			 * @param {tinymce.html.Node} node Node to insert as a child of the current node.
			 * @param {tinymce.html.Node} ref_node Reference node to set node before/after.
			 * @param {Boolean} before Optional state to insert the node before the reference node.
			 * @return {tinymce.html.Node} The node that got inserted.
			 */
			insert: function(node, ref_node, before) {
				var parent;
	
				if (node.parent) {
					node.remove();
				}
	
				parent = ref_node.parent || this;
	
				if (before) {
					if (ref_node === parent.firstChild) {
						parent.firstChild = node;
					} else {
						ref_node.prev.next = node;
					}
	
					node.prev = ref_node.prev;
					node.next = ref_node;
					ref_node.prev = node;
				} else {
					if (ref_node === parent.lastChild) {
						parent.lastChild = node;
					} else {
						ref_node.next.prev = node;
					}
	
					node.next = ref_node.next;
					node.prev = ref_node;
					ref_node.next = node;
				}
	
				node.parent = parent;
	
				return node;
			},
	
			/**
			 * Get all children by name.
			 *
			 * @method getAll
			 * @param {String} name Name of the child nodes to collect.
			 * @return {Array} Array with child nodes matchin the specified name.
			 */
			getAll: function(name) {
				var self = this, node, collection = [];
	
				for (node = self.firstChild; node; node = walk(node, self)) {
					if (node.name === name) {
						collection.push(node);
					}
				}
	
				return collection;
			},
	
			/**
			 * Removes all children of the current node.
			 *
			 * @method empty
			 * @return {tinymce.html.Node} The current node that got cleared.
			 */
			empty: function() {
				var self = this, nodes, i, node;
	
				// Remove all children
				if (self.firstChild) {
					nodes = [];
	
					// Collect the children
					for (node = self.firstChild; node; node = walk(node, self)) {
						nodes.push(node);
					}
	
					// Remove the children
					i = nodes.length;
					while (i--) {
						node = nodes[i];
						node.parent = node.firstChild = node.lastChild = node.next = node.prev = null;
					}
				}
	
				self.firstChild = self.lastChild = null;
	
				return self;
			},
	
			/**
			 * Returns true/false if the node is to be considered empty or not.
			 *
			 * @example
			 * node.isEmpty({img: true});
			 * @method isEmpty
			 * @param {Object} elements Name/value object with elements that are automatically treated as non empty elements.
			 * @return {Boolean} true/false if the node is empty or not.
			 */
			isEmpty: function(elements) {
				var self = this, node = self.firstChild, i, name;
	
				if (node) {
					do {
						if (node.type === 1) {
							// Ignore bogus elements
							if (node.attributes.map['data-mce-bogus']) {
								continue;
							}
	
							// Keep empty elements like <img />
							if (elements[node.name]) {
								return false;
							}
	
							// Keep bookmark nodes and name attribute like <a name="1"></a>
							i = node.attributes.length;
							while (i--) {
								name = node.attributes[i].name;
								if (name === "name" || name.indexOf('data-mce-bookmark') === 0) {
									return false;
								}
							}
						}
	
						// Keep comments
						if (node.type === 8) {
							return false;
						}
	
						// Keep non whitespace text nodes
						if ((node.type === 3 && !whiteSpaceRegExp.test(node.value))) {
							return false;
						}
					} while ((node = walk(node, self)));
				}
	
				return true;
			},
	
			/**
			 * Walks to the next or previous node and returns that node or null if it wasn't found.
			 *
			 * @method walk
			 * @param {Boolean} prev Optional previous node state defaults to false.
			 * @return {tinymce.html.Node} Node that is next to or previous of the current node.
			 */
			walk: function(prev) {
				return walk(this, null, prev);
			}
		};
	
		/**
		 * Creates a node of a specific type.
		 *
		 * @static
		 * @method create
		 * @param {String} name Name of the node type to create for example "b" or "#text".
		 * @param {Object} attrs Name/value collection of attributes that will be applied to elements.
		 */
		Node.create = function(name, attrs) {
			var node, attrName;
	
			// Create node
			node = new Node(name, typeLookup[name] || 1);
	
			// Add attributes if needed
			if (attrs) {
				for (attrName in attrs) {
					node.attr(attrName, attrs[attrName]);
				}
			}
	
			return node;
		};
	
		return Node;
	});
	
	// Included from: js/tinymce/classes/html/Schema.js
	
	/**
	 * Schema.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Schema validator class.
	 *
	 * @class tinymce.html.Schema
	 * @example
	 *  if (tinymce.activeEditor.schema.isValidChild('p', 'span'))
	 *    alert('span is valid child of p.');
	 *
	 *  if (tinymce.activeEditor.schema.getElementRule('p'))
	 *    alert('P is a valid element.');
	 *
	 * @class tinymce.html.Schema
	 * @version 3.4
	 */
	define("tinymce/html/Schema", [
		"tinymce/util/Tools"
	], function(Tools) {
		var mapCache = {}, dummyObj = {};
		var makeMap = Tools.makeMap, each = Tools.each, extend = Tools.extend, explode = Tools.explode, inArray = Tools.inArray;
	
		function split(items, delim) {
			items = Tools.trim(items);
			return items ? items.split(delim || ' ') : [];
		}
	
		/**
		 * Builds a schema lookup table
		 *
		 * @private
		 * @param {String} type html4, html5 or html5-strict schema type.
		 * @return {Object} Schema lookup table.
		 */
		function compileSchema(type) {
			var schema = {}, globalAttributes, blockContent;
			var phrasingContent, flowContent, html4BlockContent, html4PhrasingContent;
	
			function add(name, attributes, children) {
				var ni, attributesOrder, element;
	
				function arrayToMap(array, obj) {
					var map = {}, i, l;
	
					for (i = 0, l = array.length; i < l; i++) {
						map[array[i]] = obj || {};
					}
	
					return map;
				}
	
				children = children || [];
				attributes = attributes || "";
	
				if (typeof children === "string") {
					children = split(children);
				}
	
				name = split(name);
				ni = name.length;
				while (ni--) {
					attributesOrder = split([globalAttributes, attributes].join(' '));
	
					element = {
						attributes: arrayToMap(attributesOrder),
						attributesOrder: attributesOrder,
						children: arrayToMap(children, dummyObj)
					};
	
					schema[name[ni]] = element;
				}
			}
	
			function addAttrs(name, attributes) {
				var ni, schemaItem, i, l;
	
				name = split(name);
				ni = name.length;
				attributes = split(attributes);
				while (ni--) {
					schemaItem = schema[name[ni]];
					for (i = 0, l = attributes.length; i < l; i++) {
						schemaItem.attributes[attributes[i]] = {};
						schemaItem.attributesOrder.push(attributes[i]);
					}
				}
			}
	
			// Use cached schema
			if (mapCache[type]) {
				return mapCache[type];
			}
	
			// Attributes present on all elements
			globalAttributes = "id accesskey class dir lang style tabindex title";
	
			// Event attributes can be opt-in/opt-out
			/*eventAttributes = split("onabort onblur oncancel oncanplay oncanplaythrough onchange onclick onclose oncontextmenu oncuechange " +
			 "ondblclick ondrag ondragend ondragenter ondragleave ondragover ondragstart ondrop ondurationchange onemptied onended " +
			 "onerror onfocus oninput oninvalid onkeydown onkeypress onkeyup onload onloadeddata onloadedmetadata onloadstart " +
			 "onmousedown onmousemove onmouseout onmouseover onmouseup onmousewheel onpause onplay onplaying onprogress onratechange " +
			 "onreset onscroll onseeked onseeking onseeking onselect onshow onstalled onsubmit onsuspend ontimeupdate onvolumechange " +
			 "onwaiting"
			 );*/
	
			// Block content elements
			blockContent =
				"address blockquote div dl fieldset form h1 h2 h3 h4 h5 h6 hr menu ol p pre table ul";
	
			// Phrasing content elements from the HTML5 spec (inline)
			phrasingContent =
				"a abbr b bdo br button cite code del dfn em embed i iframe img input ins kbd " +
				"label map noscript object q s samp script select small span strong sub sup " +
				"textarea u var #text #comment"
			;
	
			// Add HTML5 items to globalAttributes, blockContent, phrasingContent
			if (type != "html4") {
				globalAttributes += " contenteditable contextmenu draggable dropzone " +
					"hidden spellcheck translate";
				blockContent += " article aside details dialog figure header footer hgroup section nav";
				phrasingContent += " audio canvas command datalist mark meter output picture " +
					"progress time wbr video ruby bdi keygen";
			}
	
			// Add HTML4 elements unless it's html5-strict
			if (type != "html5-strict") {
				globalAttributes += " xml:lang";
	
				html4PhrasingContent = "acronym applet basefont big font strike tt";
				phrasingContent = [phrasingContent, html4PhrasingContent].join(' ');
	
				each(split(html4PhrasingContent), function(name) {
					add(name, "", phrasingContent);
				});
	
				html4BlockContent = "center dir isindex noframes";
				blockContent = [blockContent, html4BlockContent].join(' ');
	
				// Flow content elements from the HTML5 spec (block+inline)
				flowContent = [blockContent, phrasingContent].join(' ');
	
				each(split(html4BlockContent), function(name) {
					add(name, "", flowContent);
				});
			}
	
			// Flow content elements from the HTML5 spec (block+inline)
			flowContent = flowContent || [blockContent, phrasingContent].join(" ");
	
			// HTML4 base schema TODO: Move HTML5 specific attributes to HTML5 specific if statement
			// Schema items <element name>, <specific attributes>, <children ..>
			add("html", "manifest", "head body");
			add("head", "", "base command link meta noscript script style title");
			add("title hr noscript br");
			add("base", "href target");
			add("link", "href rel media hreflang type sizes hreflang");
			add("meta", "name http-equiv content charset");
			add("style", "media type scoped");
			add("script", "src async defer type charset");
			add("body", "onafterprint onbeforeprint onbeforeunload onblur onerror onfocus " +
			"onhashchange onload onmessage onoffline ononline onpagehide onpageshow " +
			"onpopstate onresize onscroll onstorage onunload", flowContent);
			add("address dt dd div caption", "", flowContent);
			add("h1 h2 h3 h4 h5 h6 pre p abbr code var samp kbd sub sup i b u bdo span legend em strong small s cite dfn", "", phrasingContent);
			add("blockquote", "cite", flowContent);
			add("ol", "reversed start type", "li");
			add("ul", "", "li");
			add("li", "value", flowContent);
			add("dl", "", "dt dd");
			add("a", "href target rel media hreflang type", phrasingContent);
			add("q", "cite", phrasingContent);
			add("ins del", "cite datetime", flowContent);
			add("img", "src sizes srcset alt usemap ismap width height");
			add("iframe", "src name width height", flowContent);
			add("embed", "src type width height");
			add("object", "data type typemustmatch name usemap form width height", [flowContent, "param"].join(' '));
			add("param", "name value");
			add("map", "name", [flowContent, "area"].join(' '));
			add("area", "alt coords shape href target rel media hreflang type");
			add("table", "border", "caption colgroup thead tfoot tbody tr" + (type == "html4" ? " col" : ""));
			add("colgroup", "span", "col");
			add("col", "span");
			add("tbody thead tfoot", "", "tr");
			add("tr", "", "td th");
			add("td", "colspan rowspan headers", flowContent);
			add("th", "colspan rowspan headers scope abbr", flowContent);
			add("form", "accept-charset action autocomplete enctype method name novalidate target", flowContent);
			add("fieldset", "disabled form name", [flowContent, "legend"].join(' '));
			add("label", "form for", phrasingContent);
			add("input", "accept alt autocomplete checked dirname disabled form formaction formenctype formmethod formnovalidate " +
					"formtarget height list max maxlength min multiple name pattern readonly required size src step type value width"
			);
			add("button", "disabled form formaction formenctype formmethod formnovalidate formtarget name type value",
				type == "html4" ? flowContent : phrasingContent);
			add("select", "disabled form multiple name required size", "option optgroup");
			add("optgroup", "disabled label", "option");
			add("option", "disabled label selected value");
			add("textarea", "cols dirname disabled form maxlength name readonly required rows wrap");
			add("menu", "type label", [flowContent, "li"].join(' '));
			add("noscript", "", flowContent);
	
			// Extend with HTML5 elements
			if (type != "html4") {
				add("wbr");
				add("ruby", "", [phrasingContent, "rt rp"].join(' '));
				add("figcaption", "", flowContent);
				add("mark rt rp summary bdi", "", phrasingContent);
				add("canvas", "width height", flowContent);
				add("video", "src crossorigin poster preload autoplay mediagroup loop " +
					"muted controls width height buffered", [flowContent, "track source"].join(' '));
				add("audio", "src crossorigin preload autoplay mediagroup loop muted controls " +
					"buffered volume", [flowContent, "track source"].join(' '));
				add("picture", "", "img source");
				add("source", "src srcset type media sizes");
				add("track", "kind src srclang label default");
				add("datalist", "", [phrasingContent, "option"].join(' '));
				add("article section nav aside header footer", "", flowContent);
				add("hgroup", "", "h1 h2 h3 h4 h5 h6");
				add("figure", "", [flowContent, "figcaption"].join(' '));
				add("time", "datetime", phrasingContent);
				add("dialog", "open", flowContent);
				add("command", "type label icon disabled checked radiogroup command");
				add("output", "for form name", phrasingContent);
				add("progress", "value max", phrasingContent);
				add("meter", "value min max low high optimum", phrasingContent);
				add("details", "open", [flowContent, "summary"].join(' '));
				add("keygen", "autofocus challenge disabled form keytype name");
			}
	
			// Extend with HTML4 attributes unless it's html5-strict
			if (type != "html5-strict") {
				addAttrs("script", "language xml:space");
				addAttrs("style", "xml:space");
				addAttrs("object", "declare classid code codebase codetype archive standby align border hspace vspace");
				addAttrs("embed", "align name hspace vspace");
				addAttrs("param", "valuetype type");
				addAttrs("a", "charset name rev shape coords");
				addAttrs("br", "clear");
				addAttrs("applet", "codebase archive code object alt name width height align hspace vspace");
				addAttrs("img", "name longdesc align border hspace vspace");
				addAttrs("iframe", "longdesc frameborder marginwidth marginheight scrolling align");
				addAttrs("font basefont", "size color face");
				addAttrs("input", "usemap align");
				addAttrs("select", "onchange");
				addAttrs("textarea");
				addAttrs("h1 h2 h3 h4 h5 h6 div p legend caption", "align");
				addAttrs("ul", "type compact");
				addAttrs("li", "type");
				addAttrs("ol dl menu dir", "compact");
				addAttrs("pre", "width xml:space");
				addAttrs("hr", "align noshade size width");
				addAttrs("isindex", "prompt");
				addAttrs("table", "summary width frame rules cellspacing cellpadding align bgcolor");
				addAttrs("col", "width align char charoff valign");
				addAttrs("colgroup", "width align char charoff valign");
				addAttrs("thead", "align char charoff valign");
				addAttrs("tr", "align char charoff valign bgcolor");
				addAttrs("th", "axis align char charoff valign nowrap bgcolor width height");
				addAttrs("form", "accept");
				addAttrs("td", "abbr axis scope align char charoff valign nowrap bgcolor width height");
				addAttrs("tfoot", "align char charoff valign");
				addAttrs("tbody", "align char charoff valign");
				addAttrs("area", "nohref");
				addAttrs("body", "background bgcolor text link vlink alink");
			}
	
			// Extend with HTML5 attributes unless it's html4
			if (type != "html4") {
				addAttrs("input button select textarea", "autofocus");
				addAttrs("input textarea", "placeholder");
				addAttrs("a", "download");
				addAttrs("link script img", "crossorigin");
				addAttrs("iframe", "sandbox seamless allowfullscreen"); // Excluded: srcdoc
			}
	
			// Special: iframe, ruby, video, audio, label
	
			// Delete children of the same name from it's parent
			// For example: form can't have a child of the name form
			each(split('a form meter progress dfn'), function(name) {
				if (schema[name]) {
					delete schema[name].children[name];
				}
			});
	
			// Delete header, footer, sectioning and heading content descendants
			/*each('dt th address', function(name) {
			 delete schema[name].children[name];
			 });*/
	
			// Caption can't have tables
			delete schema.caption.children.table;
	
			// Delete scripts by default due to possible XSS
			delete schema.script;
	
			// TODO: LI:s can only have value if parent is OL
	
			// TODO: Handle transparent elements
			// a ins del canvas map
	
			mapCache[type] = schema;
	
			return schema;
		}
	
		function compileElementMap(value, mode) {
			var styles;
	
			if (value) {
				styles = {};
	
				if (typeof value == 'string') {
					value = {
						'*': value
					};
				}
	
				// Convert styles into a rule list
				each(value, function(value, key) {
					styles[key] = styles[key.toUpperCase()] = mode == 'map' ? makeMap(value, /[, ]/) : explode(value, /[, ]/);
				});
			}
	
			return styles;
		}
	
		/**
		 * Constructs a new Schema instance.
		 *
		 * @constructor
		 * @method Schema
		 * @param {Object} settings Name/value settings object.
		 */
		return function(settings) {
			var self = this, elements = {}, children = {}, patternElements = [], validStyles, invalidStyles, schemaItems;
			var whiteSpaceElementsMap, selfClosingElementsMap, shortEndedElementsMap, boolAttrMap, validClasses;
			var blockElementsMap, nonEmptyElementsMap, moveCaretBeforeOnEnterElementsMap, textBlockElementsMap, textInlineElementsMap;
			var customElementsMap = {}, specialElements = {};
	
			// Creates an lookup table map object for the specified option or the default value
			function createLookupTable(option, default_value, extendWith) {
				var value = settings[option];
	
				if (!value) {
					// Get cached default map or make it if needed
					value = mapCache[option];
	
					if (!value) {
						value = makeMap(default_value, ' ', makeMap(default_value.toUpperCase(), ' '));
						value = extend(value, extendWith);
	
						mapCache[option] = value;
					}
				} else {
					// Create custom map
					value = makeMap(value, /[, ]/, makeMap(value.toUpperCase(), /[, ]/));
				}
	
				return value;
			}
	
			settings = settings || {};
			schemaItems = compileSchema(settings.schema);
	
			// Allow all elements and attributes if verify_html is set to false
			if (settings.verify_html === false) {
				settings.valid_elements = '*[*]';
			}
	
			validStyles = compileElementMap(settings.valid_styles);
			invalidStyles = compileElementMap(settings.invalid_styles, 'map');
			validClasses = compileElementMap(settings.valid_classes, 'map');
	
			// Setup map objects
			whiteSpaceElementsMap = createLookupTable('whitespace_elements', 'pre script noscript style textarea video audio iframe object');
			selfClosingElementsMap = createLookupTable('self_closing_elements', 'colgroup dd dt li option p td tfoot th thead tr');
			shortEndedElementsMap = createLookupTable('short_ended_elements', 'area base basefont br col frame hr img input isindex link ' +
			'meta param embed source wbr track');
			boolAttrMap = createLookupTable('boolean_attributes', 'checked compact declare defer disabled ismap multiple nohref noresize ' +
			'noshade nowrap readonly selected autoplay loop controls');
			nonEmptyElementsMap = createLookupTable('non_empty_elements', 'td th iframe video audio object script', shortEndedElementsMap);
			moveCaretBeforeOnEnterElementsMap = createLookupTable('move_caret_before_on_enter_elements', 'table', nonEmptyElementsMap);
			textBlockElementsMap = createLookupTable('text_block_elements', 'h1 h2 h3 h4 h5 h6 p div address pre form ' +
			'blockquote center dir fieldset header footer article section hgroup aside nav figure');
			blockElementsMap = createLookupTable('block_elements', 'hr table tbody thead tfoot ' +
			'th tr td li ol ul caption dl dt dd noscript menu isindex option ' +
			'datalist select optgroup figcaption', textBlockElementsMap);
			textInlineElementsMap = createLookupTable('text_inline_elements', 'span strong b em i font strike u var cite ' +
			'dfn code mark q sup sub samp');
	
			each((settings.special || 'script noscript style textarea').split(' '), function(name) {
				specialElements[name] = new RegExp('<\/' + name + '[^>]*>', 'gi');
			});
	
			// Converts a wildcard expression string to a regexp for example *a will become /.*a/.
			function patternToRegExp(str) {
				return new RegExp('^' + str.replace(/([?+*])/g, '.$1') + '$');
			}
	
			// Parses the specified valid_elements string and adds to the current rules
			// This function is a bit hard to read since it's heavily optimized for speed
			function addValidElements(validElements) {
				var ei, el, ai, al, matches, element, attr, attrData, elementName, attrName, attrType, attributes, attributesOrder,
					prefix, outputName, globalAttributes, globalAttributesOrder, key, value,
					elementRuleRegExp = /^([#+\-])?([^\[!\/]+)(?:\/([^\[!]+))?(?:(!?)\[([^\]]+)\])?$/,
					attrRuleRegExp = /^([!\-])?(\w+::\w+|[^=:<]+)?(?:([=:<])(.*))?$/,
					hasPatternsRegExp = /[*?+]/;
	
				if (validElements) {
					// Split valid elements into an array with rules
					validElements = split(validElements, ',');
	
					if (elements['@']) {
						globalAttributes = elements['@'].attributes;
						globalAttributesOrder = elements['@'].attributesOrder;
					}
	
					// Loop all rules
					for (ei = 0, el = validElements.length; ei < el; ei++) {
						// Parse element rule
						matches = elementRuleRegExp.exec(validElements[ei]);
						if (matches) {
							// Setup local names for matches
							prefix = matches[1];
							elementName = matches[2];
							outputName = matches[3];
							attrData = matches[5];
	
							// Create new attributes and attributesOrder
							attributes = {};
							attributesOrder = [];
	
							// Create the new element
							element = {
								attributes: attributes,
								attributesOrder: attributesOrder
							};
	
							// Padd empty elements prefix
							if (prefix === '#') {
								element.paddEmpty = true;
							}
	
							// Remove empty elements prefix
							if (prefix === '-') {
								element.removeEmpty = true;
							}
	
							if (matches[4] === '!') {
								element.removeEmptyAttrs = true;
							}
	
							// Copy attributes from global rule into current rule
							if (globalAttributes) {
								for (key in globalAttributes) {
									attributes[key] = globalAttributes[key];
								}
	
								attributesOrder.push.apply(attributesOrder, globalAttributesOrder);
							}
	
							// Attributes defined
							if (attrData) {
								attrData = split(attrData, '|');
								for (ai = 0, al = attrData.length; ai < al; ai++) {
									matches = attrRuleRegExp.exec(attrData[ai]);
									if (matches) {
										attr = {};
										attrType = matches[1];
										attrName = matches[2].replace(/::/g, ':');
										prefix = matches[3];
										value = matches[4];
	
										// Required
										if (attrType === '!') {
											element.attributesRequired = element.attributesRequired || [];
											element.attributesRequired.push(attrName);
											attr.required = true;
										}
	
										// Denied from global
										if (attrType === '-') {
											delete attributes[attrName];
											attributesOrder.splice(inArray(attributesOrder, attrName), 1);
											continue;
										}
	
										// Default value
										if (prefix) {
											// Default value
											if (prefix === '=') {
												element.attributesDefault = element.attributesDefault || [];
												element.attributesDefault.push({name: attrName, value: value});
												attr.defaultValue = value;
											}
	
											// Forced value
											if (prefix === ':') {
												element.attributesForced = element.attributesForced || [];
												element.attributesForced.push({name: attrName, value: value});
												attr.forcedValue = value;
											}
	
											// Required values
											if (prefix === '<') {
												attr.validValues = makeMap(value, '?');
											}
										}
	
										// Check for attribute patterns
										if (hasPatternsRegExp.test(attrName)) {
											element.attributePatterns = element.attributePatterns || [];
											attr.pattern = patternToRegExp(attrName);
											element.attributePatterns.push(attr);
										} else {
											// Add attribute to order list if it doesn't already exist
											if (!attributes[attrName]) {
												attributesOrder.push(attrName);
											}
	
											attributes[attrName] = attr;
										}
									}
								}
							}
	
							// Global rule, store away these for later usage
							if (!globalAttributes && elementName == '@') {
								globalAttributes = attributes;
								globalAttributesOrder = attributesOrder;
							}
	
							// Handle substitute elements such as b/strong
							if (outputName) {
								element.outputName = elementName;
								elements[outputName] = element;
							}
	
							// Add pattern or exact element
							if (hasPatternsRegExp.test(elementName)) {
								element.pattern = patternToRegExp(elementName);
								patternElements.push(element);
							} else {
								elements[elementName] = element;
							}
						}
					}
				}
			}
	
			function setValidElements(validElements) {
				elements = {};
				patternElements = [];
	
				addValidElements(validElements);
	
				each(schemaItems, function(element, name) {
					children[name] = element.children;
				});
			}
	
			// Adds custom non HTML elements to the schema
			function addCustomElements(customElements) {
				var customElementRegExp = /^(~)?(.+)$/;
	
				if (customElements) {
					// Flush cached items since we are altering the default maps
					mapCache.text_block_elements = mapCache.block_elements = null;
	
					each(split(customElements, ','), function(rule) {
						var matches = customElementRegExp.exec(rule),
							inline = matches[1] === '~',
							cloneName = inline ? 'span' : 'div',
							name = matches[2];
	
						children[name] = children[cloneName];
						customElementsMap[name] = cloneName;
	
						// If it's not marked as inline then add it to valid block elements
						if (!inline) {
							blockElementsMap[name.toUpperCase()] = {};
							blockElementsMap[name] = {};
						}
	
						// Add elements clone if needed
						if (!elements[name]) {
							var customRule = elements[cloneName];
	
							customRule = extend({}, customRule);
							delete customRule.removeEmptyAttrs;
							delete customRule.removeEmpty;
	
							elements[name] = customRule;
						}
	
						// Add custom elements at span/div positions
						each(children, function(element, elmName) {
							if (element[cloneName]) {
								children[elmName] = element = extend({}, children[elmName]);
								element[name] = element[cloneName];
							}
						});
					});
				}
			}
	
			// Adds valid children to the schema object
			function addValidChildren(validChildren) {
				var childRuleRegExp = /^([+\-]?)(\w+)\[([^\]]+)\]$/;
	
				// Invalidate the schema cache if the schema is mutated
				mapCache[settings.schema] = null;
	
				if (validChildren) {
					each(split(validChildren, ','), function(rule) {
						var matches = childRuleRegExp.exec(rule), parent, prefix;
	
						if (matches) {
							prefix = matches[1];
	
							// Add/remove items from default
							if (prefix) {
								parent = children[matches[2]];
							} else {
								parent = children[matches[2]] = {'#comment': {}};
							}
	
							parent = children[matches[2]];
	
							each(split(matches[3], '|'), function(child) {
								if (prefix === '-') {
									delete parent[child];
								} else {
									parent[child] = {};
								}
							});
						}
					});
				}
			}
	
			function getElementRule(name) {
				var element = elements[name], i;
	
				// Exact match found
				if (element) {
					return element;
				}
	
				// No exact match then try the patterns
				i = patternElements.length;
				while (i--) {
					element = patternElements[i];
	
					if (element.pattern.test(name)) {
						return element;
					}
				}
			}
	
			if (!settings.valid_elements) {
				// No valid elements defined then clone the elements from the schema spec
				each(schemaItems, function(element, name) {
					elements[name] = {
						attributes: element.attributes,
						attributesOrder: element.attributesOrder
					};
	
					children[name] = element.children;
				});
	
				// Switch these on HTML4
				if (settings.schema != "html5") {
					each(split('strong/b em/i'), function(item) {
						item = split(item, '/');
						elements[item[1]].outputName = item[0];
					});
				}
	
				// Add default alt attribute for images, removed since alt="" is treated as presentational.
				// elements.img.attributesDefault = [{name: 'alt', value: ''}];
	
				// Remove these if they are empty by default
				each(split('ol ul sub sup blockquote span font a table tbody tr strong em b i'), function(name) {
					if (elements[name]) {
						elements[name].removeEmpty = true;
					}
				});
	
				// Padd these by default
				each(split('p h1 h2 h3 h4 h5 h6 th td pre div address caption'), function(name) {
					elements[name].paddEmpty = true;
				});
	
				// Remove these if they have no attributes
				each(split('span'), function(name) {
					elements[name].removeEmptyAttrs = true;
				});
	
				// Remove these by default
				// TODO: Reenable in 4.1
				/*each(split('script style'), function(name) {
				 delete elements[name];
				 });*/
			} else {
				setValidElements(settings.valid_elements);
			}
	
			addCustomElements(settings.custom_elements);
			addValidChildren(settings.valid_children);
			addValidElements(settings.extended_valid_elements);
	
			// Todo: Remove this when we fix list handling to be valid
			addValidChildren('+ol[ul|ol],+ul[ul|ol]');
	
	
			// Some elements are not valid by themselves - require parents
			each({
				dd: 'dl',
				dt: 'dl',
				li: 'ul ol',
				td: 'tr',
				th: 'tr',
				tr: 'tbody thead tfoot',
				tbody: 'table',
				thead: 'table',
				tfoot: 'table',
				legend: 'fieldset',
				area: 'map',
				param: 'video audio object'
			}, function(parents, item) {
				if (elements[item]) {
					elements[item].parentsRequired = split(parents);
				}
			});
	
	
			// Delete invalid elements
			if (settings.invalid_elements) {
				each(explode(settings.invalid_elements), function(item) {
					if (elements[item]) {
						delete elements[item];
					}
				});
			}
	
			// If the user didn't allow span only allow internal spans
			if (!getElementRule('span')) {
				addValidElements('span[!data-mce-type|*]');
			}
	
			/**
			 * Name/value map object with valid parents and children to those parents.
			 *
			 * @example
			 * children = {
			 *    div:{p:{}, h1:{}}
			 * };
			 * @field children
			 * @type Object
			 */
			self.children = children;
	
			/**
			 * Name/value map object with valid styles for each element.
			 *
			 * @method getValidStyles
			 * @type Object
			 */
			self.getValidStyles = function() {
				return validStyles;
			};
	
			/**
			 * Name/value map object with valid styles for each element.
			 *
			 * @method getInvalidStyles
			 * @type Object
			 */
			self.getInvalidStyles = function() {
				return invalidStyles;
			};
	
			/**
			 * Name/value map object with valid classes for each element.
			 *
			 * @method getValidClasses
			 * @type Object
			 */
			self.getValidClasses = function() {
				return validClasses;
			};
	
			/**
			 * Returns a map with boolean attributes.
			 *
			 * @method getBoolAttrs
			 * @return {Object} Name/value lookup map for boolean attributes.
			 */
			self.getBoolAttrs = function() {
				return boolAttrMap;
			};
	
			/**
			 * Returns a map with block elements.
			 *
			 * @method getBlockElements
			 * @return {Object} Name/value lookup map for block elements.
			 */
			self.getBlockElements = function() {
				return blockElementsMap;
			};
	
			/**
			 * Returns a map with text block elements. Such as: p,h1-h6,div,address
			 *
			 * @method getTextBlockElements
			 * @return {Object} Name/value lookup map for block elements.
			 */
			self.getTextBlockElements = function() {
				return textBlockElementsMap;
			};
	
			/**
			 * Returns a map of inline text format nodes for example strong/span or ins.
			 *
			 * @method getTextInlineElements
			 * @return {Object} Name/value lookup map for text format elements.
			 */
			self.getTextInlineElements = function() {
				return textInlineElementsMap;
			};
	
			/**
			 * Returns a map with short ended elements such as BR or IMG.
			 *
			 * @method getShortEndedElements
			 * @return {Object} Name/value lookup map for short ended elements.
			 */
			self.getShortEndedElements = function() {
				return shortEndedElementsMap;
			};
	
			/**
			 * Returns a map with self closing tags such as <li>.
			 *
			 * @method getSelfClosingElements
			 * @return {Object} Name/value lookup map for self closing tags elements.
			 */
			self.getSelfClosingElements = function() {
				return selfClosingElementsMap;
			};
	
			/**
			 * Returns a map with elements that should be treated as contents regardless if it has text
			 * content in them or not such as TD, VIDEO or IMG.
			 *
			 * @method getNonEmptyElements
			 * @return {Object} Name/value lookup map for non empty elements.
			 */
			self.getNonEmptyElements = function() {
				return nonEmptyElementsMap;
			};
	
			/**
			 * Returns a map with elements that the caret should be moved in front of after enter is
			 * pressed
			 *
			 * @method getMoveCaretBeforeOnEnterElements
			 * @return {Object} Name/value lookup map for elements to place the caret in front of.
			 */
			self.getMoveCaretBeforeOnEnterElements = function() {
				return moveCaretBeforeOnEnterElementsMap;
			};
	
			/**
			 * Returns a map with elements where white space is to be preserved like PRE or SCRIPT.
			 *
			 * @method getWhiteSpaceElements
			 * @return {Object} Name/value lookup map for white space elements.
			 */
			self.getWhiteSpaceElements = function() {
				return whiteSpaceElementsMap;
			};
	
			/**
			 * Returns a map with special elements. These are elements that needs to be parsed
			 * in a special way such as script, style, textarea etc. The map object values
			 * are regexps used to find the end of the element.
			 *
			 * @method getSpecialElements
			 * @return {Object} Name/value lookup map for special elements.
			 */
			self.getSpecialElements = function() {
				return specialElements;
			};
	
			/**
			 * Returns true/false if the specified element and it's child is valid or not
			 * according to the schema.
			 *
			 * @method isValidChild
			 * @param {String} name Element name to check for.
			 * @param {String} child Element child to verify.
			 * @return {Boolean} True/false if the element is a valid child of the specified parent.
			 */
			self.isValidChild = function(name, child) {
				var parent = children[name];
	
				return !!(parent && parent[child]);
			};
	
			/**
			 * Returns true/false if the specified element name and optional attribute is
			 * valid according to the schema.
			 *
			 * @method isValid
			 * @param {String} name Name of element to check.
			 * @param {String} attr Optional attribute name to check for.
			 * @return {Boolean} True/false if the element and attribute is valid.
			 */
			self.isValid = function(name, attr) {
				var attrPatterns, i, rule = getElementRule(name);
	
				// Check if it's a valid element
				if (rule) {
					if (attr) {
						// Check if attribute name exists
						if (rule.attributes[attr]) {
							return true;
						}
	
						// Check if attribute matches a regexp pattern
						attrPatterns = rule.attributePatterns;
						if (attrPatterns) {
							i = attrPatterns.length;
							while (i--) {
								if (attrPatterns[i].pattern.test(name)) {
									return true;
								}
							}
						}
					} else {
						return true;
					}
				}
	
				// No match
				return false;
			};
	
			/**
			 * Returns true/false if the specified element is valid or not
			 * according to the schema.
			 *
			 * @method getElementRule
			 * @param {String} name Element name to check for.
			 * @return {Object} Element object or undefined if the element isn't valid.
			 */
			self.getElementRule = getElementRule;
	
			/**
			 * Returns an map object of all custom elements.
			 *
			 * @method getCustomElements
			 * @return {Object} Name/value map object of all custom elements.
			 */
			self.getCustomElements = function() {
				return customElementsMap;
			};
	
			/**
			 * Parses a valid elements string and adds it to the schema. The valid elements
			 * format is for example "element[attr=default|otherattr]".
			 * Existing rules will be replaced with the ones specified, so this extends the schema.
			 *
			 * @method addValidElements
			 * @param {String} valid_elements String in the valid elements format to be parsed.
			 */
			self.addValidElements = addValidElements;
	
			/**
			 * Parses a valid elements string and sets it to the schema. The valid elements
			 * format is for example "element[attr=default|otherattr]".
			 * Existing rules will be replaced with the ones specified, so this extends the schema.
			 *
			 * @method setValidElements
			 * @param {String} valid_elements String in the valid elements format to be parsed.
			 */
			self.setValidElements = setValidElements;
	
			/**
			 * Adds custom non HTML elements to the schema.
			 *
			 * @method addCustomElements
			 * @param {String} custom_elements Comma separated list of custom elements to add.
			 */
			self.addCustomElements = addCustomElements;
	
			/**
			 * Parses a valid children string and adds them to the schema structure. The valid children
			 * format is for example: "element[child1|child2]".
			 *
			 * @method addValidChildren
			 * @param {String} valid_children Valid children elements string to parse
			 */
			self.addValidChildren = addValidChildren;
	
			self.elements = elements;
		};
	});
	
	// Included from: js/tinymce/classes/html/SaxParser.js
	
	/**
	 * SaxParser.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/*eslint max-depth:[2, 9] */
	
	/**
	 * This class parses HTML code using pure JavaScript and executes various events for each item it finds. It will
	 * always execute the events in the right order for tag soup code like <b><p></b></p>. It will also remove elements
	 * and attributes that doesn't fit the schema if the validate setting is enabled.
	 *
	 * @example
	 * var parser = new tinymce.html.SaxParser({
	 *     validate: true,
	 *
	 *     comment: function(text) {
	 *         console.log('Comment:', text);
	 *     },
	 *
	 *     cdata: function(text) {
	 *         console.log('CDATA:', text);
	 *     },
	 *
	 *     text: function(text, raw) {
	 *         console.log('Text:', text, 'Raw:', raw);
	 *     },
	 *
	 *     start: function(name, attrs, empty) {
	 *         console.log('Start:', name, attrs, empty);
	 *     },
	 *
	 *     end: function(name) {
	 *         console.log('End:', name);
	 *     },
	 *
	 *     pi: function(name, text) {
	 *         console.log('PI:', name, text);
	 *     },
	 *
	 *     doctype: function(text) {
	 *         console.log('DocType:', text);
	 *     }
	 * }, schema);
	 * @class tinymce.html.SaxParser
	 * @version 3.4
	 */
	define("tinymce/html/SaxParser", [
		"tinymce/html/Schema",
		"tinymce/html/Entities",
		"tinymce/util/Tools"
	], function(Schema, Entities, Tools) {
		var each = Tools.each;
	
		/**
		 * Returns the index of the end tag for a specific start tag. This can be
		 * used to skip all children of a parent element from being processed.
		 *
		 * @private
		 * @method findEndTag
		 * @param {tinymce.html.Schema} schema Schema instance to use to match short ended elements.
		 * @param {String} html HTML string to find the end tag in.
		 * @param {Number} startIndex Indext to start searching at should be after the start tag.
		 * @return {Number} Index of the end tag.
		 */
		function findEndTag(schema, html, startIndex) {
			var count = 1, index, matches, tokenRegExp, shortEndedElements;
	
			shortEndedElements = schema.getShortEndedElements();
			tokenRegExp = /<([!?\/])?([A-Za-z0-9\-_\:\.]+)((?:\s+[^"\'>]+(?:(?:"[^"]*")|(?:\'[^\']*\')|[^>]*))*|\/|\s+)>/g;
			tokenRegExp.lastIndex = index = startIndex;
	
			while ((matches = tokenRegExp.exec(html))) {
				index = tokenRegExp.lastIndex;
	
				if (matches[1] === '/') { // End element
					count--;
				} else if (!matches[1]) { // Start element
					if (matches[2] in shortEndedElements) {
						continue;
					}
	
					count++;
				}
	
				if (count === 0) {
					break;
				}
			}
	
			return index;
		}
	
		/**
		 * Constructs a new SaxParser instance.
		 *
		 * @constructor
		 * @method SaxParser
		 * @param {Object} settings Name/value collection of settings. comment, cdata, text, start and end are callbacks.
		 * @param {tinymce.html.Schema} schema HTML Schema class to use when parsing.
		 */
		function SaxParser(settings, schema) {
			var self = this;
	
			function noop() {}
	
			settings = settings || {};
			self.schema = schema = schema || new Schema();
	
			if (settings.fix_self_closing !== false) {
				settings.fix_self_closing = true;
			}
	
			// Add handler functions from settings and setup default handlers
			each('comment cdata text start end pi doctype'.split(' '), function(name) {
				if (name) {
					self[name] = settings[name] || noop;
				}
			});
	
			/**
			 * Parses the specified HTML string and executes the callbacks for each item it finds.
			 *
			 * @example
			 * new SaxParser({...}).parse('<b>text</b>');
			 * @method parse
			 * @param {String} html Html string to sax parse.
			 */
			self.parse = function(html) {
				var self = this, matches, index = 0, value, endRegExp, stack = [], attrList, i, text, name;
				var isInternalElement, removeInternalElements, shortEndedElements, fillAttrsMap, isShortEnded;
				var validate, elementRule, isValidElement, attr, attribsValue, validAttributesMap, validAttributePatterns;
				var attributesRequired, attributesDefault, attributesForced;
				var anyAttributesRequired, selfClosing, tokenRegExp, attrRegExp, specialElements, attrValue, idCount = 0;
				var decode = Entities.decode, fixSelfClosing, filteredUrlAttrs = Tools.makeMap('src,href,data,background,formaction,poster');
				var scriptUriRegExp = /((java|vb)script|mhtml):/i, dataUriRegExp = /^data:/i;
	
				function processEndTag(name) {
					var pos, i;
	
					// Find position of parent of the same type
					pos = stack.length;
					while (pos--) {
						if (stack[pos].name === name) {
							break;
						}
					}
	
					// Found parent
					if (pos >= 0) {
						// Close all the open elements
						for (i = stack.length - 1; i >= pos; i--) {
							name = stack[i];
	
							if (name.valid) {
								self.end(name.name);
							}
						}
	
						// Remove the open elements from the stack
						stack.length = pos;
					}
				}
	
				function parseAttribute(match, name, value, val2, val3) {
					var attrRule, i, trimRegExp = /[\s\u0000-\u001F]+/g;
	
					name = name.toLowerCase();
					value = name in fillAttrsMap ? name : decode(value || val2 || val3 || ''); // Handle boolean attribute than value attribute
	
					// Validate name and value pass through all data- attributes
					if (validate && !isInternalElement && name.indexOf('data-') !== 0) {
						attrRule = validAttributesMap[name];
	
						// Find rule by pattern matching
						if (!attrRule && validAttributePatterns) {
							i = validAttributePatterns.length;
							while (i--) {
								attrRule = validAttributePatterns[i];
								if (attrRule.pattern.test(name)) {
									break;
								}
							}
	
							// No rule matched
							if (i === -1) {
								attrRule = null;
							}
						}
	
						// No attribute rule found
						if (!attrRule) {
							return;
						}
	
						// Validate value
						if (attrRule.validValues && !(value in attrRule.validValues)) {
							return;
						}
					}
	
					// Block any javascript: urls or non image data uris
					if (filteredUrlAttrs[name] && !settings.allow_script_urls) {
						var uri = value.replace(trimRegExp, '');
	
						try {
							// Might throw malformed URI sequence
							uri = decodeURIComponent(uri);
						} catch (ex) {
							// Fallback to non UTF-8 decoder
							uri = unescape(uri);
						}
	
						if (scriptUriRegExp.test(uri)) {
							return;
						}
	
						if (!settings.allow_html_data_urls && dataUriRegExp.test(uri) && !/^data:image\//i.test(uri)) {
							return;
						}
					}
	
					// Add attribute to list and map
					attrList.map[name] = value;
					attrList.push({
						name: name,
						value: value
					});
				}
	
				// Precompile RegExps and map objects
				tokenRegExp = new RegExp('<(?:' +
					'(?:!--([\\w\\W]*?)-->)|' + // Comment
					'(?:!\\[CDATA\\[([\\w\\W]*?)\\]\\]>)|' + // CDATA
					'(?:!DOCTYPE([\\w\\W]*?)>)|' + // DOCTYPE
					'(?:\\?([^\\s\\/<>]+) ?([\\w\\W]*?)[?/]>)|' + // PI
					'(?:\\/([^>]+)>)|' + // End element
					'(?:([A-Za-z0-9\\-_\\:\\.]+)((?:\\s+[^"\'>]+(?:(?:"[^"]*")|(?:\'[^\']*\')|[^>]*))*|\\/|\\s+)>)' + // Start element
				')', 'g');
	
				attrRegExp = /([\w:\-]+)(?:\s*=\s*(?:(?:\"((?:[^\"])*)\")|(?:\'((?:[^\'])*)\')|([^>\s]+)))?/g;
	
				// Setup lookup tables for empty elements and boolean attributes
				shortEndedElements = schema.getShortEndedElements();
				selfClosing = settings.self_closing_elements || schema.getSelfClosingElements();
				fillAttrsMap = schema.getBoolAttrs();
				validate = settings.validate;
				removeInternalElements = settings.remove_internals;
				fixSelfClosing = settings.fix_self_closing;
				specialElements = schema.getSpecialElements();
	
				while ((matches = tokenRegExp.exec(html))) {
					// Text
					if (index < matches.index) {
						self.text(decode(html.substr(index, matches.index - index)));
					}
	
					if ((value = matches[6])) { // End element
						value = value.toLowerCase();
	
						// IE will add a ":" in front of elements it doesn't understand like custom elements or HTML5 elements
						if (value.charAt(0) === ':') {
							value = value.substr(1);
						}
	
						processEndTag(value);
					} else if ((value = matches[7])) { // Start element
						value = value.toLowerCase();
	
						// IE will add a ":" in front of elements it doesn't understand like custom elements or HTML5 elements
						if (value.charAt(0) === ':') {
							value = value.substr(1);
						}
	
						isShortEnded = value in shortEndedElements;
	
						// Is self closing tag for example an <li> after an open <li>
						if (fixSelfClosing && selfClosing[value] && stack.length > 0 && stack[stack.length - 1].name === value) {
							processEndTag(value);
						}
	
						// Validate element
						if (!validate || (elementRule = schema.getElementRule(value))) {
							isValidElement = true;
	
							// Grab attributes map and patters when validation is enabled
							if (validate) {
								validAttributesMap = elementRule.attributes;
								validAttributePatterns = elementRule.attributePatterns;
							}
	
							// Parse attributes
							if ((attribsValue = matches[8])) {
								isInternalElement = attribsValue.indexOf('data-mce-type') !== -1; // Check if the element is an internal element
	
								// If the element has internal attributes then remove it if we are told to do so
								if (isInternalElement && removeInternalElements) {
									isValidElement = false;
								}
	
								attrList = [];
								attrList.map = {};
	
								attribsValue.replace(attrRegExp, parseAttribute);
							} else {
								attrList = [];
								attrList.map = {};
							}
	
							// Process attributes if validation is enabled
							if (validate && !isInternalElement) {
								attributesRequired = elementRule.attributesRequired;
								attributesDefault = elementRule.attributesDefault;
								attributesForced = elementRule.attributesForced;
								anyAttributesRequired = elementRule.removeEmptyAttrs;
	
								// Check if any attribute exists
								if (anyAttributesRequired && !attrList.length) {
									isValidElement = false;
								}
	
								// Handle forced attributes
								if (attributesForced) {
									i = attributesForced.length;
									while (i--) {
										attr = attributesForced[i];
										name = attr.name;
										attrValue = attr.value;
	
										if (attrValue === '{$uid}') {
											attrValue = 'mce_' + idCount++;
										}
	
										attrList.map[name] = attrValue;
										attrList.push({name: name, value: attrValue});
									}
								}
	
								// Handle default attributes
								if (attributesDefault) {
									i = attributesDefault.length;
									while (i--) {
										attr = attributesDefault[i];
										name = attr.name;
	
										if (!(name in attrList.map)) {
											attrValue = attr.value;
	
											if (attrValue === '{$uid}') {
												attrValue = 'mce_' + idCount++;
											}
	
											attrList.map[name] = attrValue;
											attrList.push({name: name, value: attrValue});
										}
									}
								}
	
								// Handle required attributes
								if (attributesRequired) {
									i = attributesRequired.length;
									while (i--) {
										if (attributesRequired[i] in attrList.map) {
											break;
										}
									}
	
									// None of the required attributes where found
									if (i === -1) {
										isValidElement = false;
									}
								}
	
								// Invalidate element if it's marked as bogus
								if ((attr = attrList.map['data-mce-bogus'])) {
									if (attr === 'all') {
										index = findEndTag(schema, html, tokenRegExp.lastIndex);
										tokenRegExp.lastIndex = index;
										continue;
									}
	
									isValidElement = false;
								}
							}
	
							if (isValidElement) {
								self.start(value, attrList, isShortEnded);
							}
						} else {
							isValidElement = false;
						}
	
						// Treat script, noscript and style a bit different since they may include code that looks like elements
						if ((endRegExp = specialElements[value])) {
							endRegExp.lastIndex = index = matches.index + matches[0].length;
	
							if ((matches = endRegExp.exec(html))) {
								if (isValidElement) {
									text = html.substr(index, matches.index - index);
								}
	
								index = matches.index + matches[0].length;
							} else {
								text = html.substr(index);
								index = html.length;
							}
	
							if (isValidElement) {
								if (text.length > 0) {
									self.text(text, true);
								}
	
								self.end(value);
							}
	
							tokenRegExp.lastIndex = index;
							continue;
						}
	
						// Push value on to stack
						if (!isShortEnded) {
							if (!attribsValue || attribsValue.indexOf('/') != attribsValue.length - 1) {
								stack.push({name: value, valid: isValidElement});
							} else if (isValidElement) {
								self.end(value);
							}
						}
					} else if ((value = matches[1])) { // Comment
						// Padd comment value to avoid browsers from parsing invalid comments as HTML
						if (value.charAt(0) === '>') {
							value = ' ' + value;
						}
	
						if (!settings.allow_conditional_comments && value.substr(0, 3).toLowerCase() === '[if') {
							value = ' ' + value;
						}
	
						self.comment(value);
					} else if ((value = matches[2])) { // CDATA
						self.cdata(value);
					} else if ((value = matches[3])) { // DOCTYPE
						self.doctype(value);
					} else if ((value = matches[4])) { // PI
						self.pi(value, matches[5]);
					}
	
					index = matches.index + matches[0].length;
				}
	
				// Text
				if (index < html.length) {
					self.text(decode(html.substr(index)));
				}
	
				// Close any open elements
				for (i = stack.length - 1; i >= 0; i--) {
					value = stack[i];
	
					if (value.valid) {
						self.end(value.name);
					}
				}
			};
		}
	
		SaxParser.findEndTag = findEndTag;
	
		return SaxParser;
	});
	
	// Included from: js/tinymce/classes/html/DomParser.js
	
	/**
	 * DomParser.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This class parses HTML code into a DOM like structure of nodes it will remove redundant whitespace and make
	 * sure that the node tree is valid according to the specified schema.
	 * So for example: <p>a<p>b</p>c</p> will become <p>a</p><p>b</p><p>c</p>
	 *
	 * @example
	 * var parser = new tinymce.html.DomParser({validate: true}, schema);
	 * var rootNode = parser.parse('<h1>content</h1>');
	 *
	 * @class tinymce.html.DomParser
	 * @version 3.4
	 */
	define("tinymce/html/DomParser", [
		"tinymce/html/Node",
		"tinymce/html/Schema",
		"tinymce/html/SaxParser",
		"tinymce/util/Tools"
	], function(Node, Schema, SaxParser, Tools) {
		var makeMap = Tools.makeMap, each = Tools.each, explode = Tools.explode, extend = Tools.extend;
	
		/**
		 * Constructs a new DomParser instance.
		 *
		 * @constructor
		 * @method DomParser
		 * @param {Object} settings Name/value collection of settings. comment, cdata, text, start and end are callbacks.
		 * @param {tinymce.html.Schema} schema HTML Schema class to use when parsing.
		 */
		return function(settings, schema) {
			var self = this, nodeFilters = {}, attributeFilters = [], matchedNodes = {}, matchedAttributes = {};
	
			settings = settings || {};
			settings.validate = "validate" in settings ? settings.validate : true;
			settings.root_name = settings.root_name || 'body';
			self.schema = schema = schema || new Schema();
	
			function fixInvalidChildren(nodes) {
				var ni, node, parent, parents, newParent, currentNode, tempNode, childNode, i;
				var nonEmptyElements, nonSplitableElements, textBlockElements, specialElements, sibling, nextNode;
	
				nonSplitableElements = makeMap('tr,td,th,tbody,thead,tfoot,table');
				nonEmptyElements = schema.getNonEmptyElements();
				textBlockElements = schema.getTextBlockElements();
				specialElements = schema.getSpecialElements();
	
				for (ni = 0; ni < nodes.length; ni++) {
					node = nodes[ni];
	
					// Already removed or fixed
					if (!node.parent || node.fixed) {
						continue;
					}
	
					// If the invalid element is a text block and the text block is within a parent LI element
					// Then unwrap the first text block and convert other sibling text blocks to LI elements similar to Word/Open Office
					if (textBlockElements[node.name] && node.parent.name == 'li') {
						// Move sibling text blocks after LI element
						sibling = node.next;
						while (sibling) {
							if (textBlockElements[sibling.name]) {
								sibling.name = 'li';
								sibling.fixed = true;
								node.parent.insert(sibling, node.parent);
							} else {
								break;
							}
	
							sibling = sibling.next;
						}
	
						// Unwrap current text block
						node.unwrap(node);
						continue;
					}
	
					// Get list of all parent nodes until we find a valid parent to stick the child into
					parents = [node];
					for (parent = node.parent; parent && !schema.isValidChild(parent.name, node.name) &&
						!nonSplitableElements[parent.name]; parent = parent.parent) {
						parents.push(parent);
					}
	
					// Found a suitable parent
					if (parent && parents.length > 1) {
						// Reverse the array since it makes looping easier
						parents.reverse();
	
						// Clone the related parent and insert that after the moved node
						newParent = currentNode = self.filterNode(parents[0].clone());
	
						// Start cloning and moving children on the left side of the target node
						for (i = 0; i < parents.length - 1; i++) {
							if (schema.isValidChild(currentNode.name, parents[i].name)) {
								tempNode = self.filterNode(parents[i].clone());
								currentNode.append(tempNode);
							} else {
								tempNode = currentNode;
							}
	
							for (childNode = parents[i].firstChild; childNode && childNode != parents[i + 1];) {
								nextNode = childNode.next;
								tempNode.append(childNode);
								childNode = nextNode;
							}
	
							currentNode = tempNode;
						}
	
						if (!newParent.isEmpty(nonEmptyElements)) {
							parent.insert(newParent, parents[0], true);
							parent.insert(node, newParent);
						} else {
							parent.insert(node, parents[0], true);
						}
	
						// Check if the element is empty by looking through it's contents and special treatment for <p><br /></p>
						parent = parents[0];
						if (parent.isEmpty(nonEmptyElements) || parent.firstChild === parent.lastChild && parent.firstChild.name === 'br') {
							parent.empty().remove();
						}
					} else if (node.parent) {
						// If it's an LI try to find a UL/OL for it or wrap it
						if (node.name === 'li') {
							sibling = node.prev;
							if (sibling && (sibling.name === 'ul' || sibling.name === 'ul')) {
								sibling.append(node);
								continue;
							}
	
							sibling = node.next;
							if (sibling && (sibling.name === 'ul' || sibling.name === 'ul')) {
								sibling.insert(node, sibling.firstChild, true);
								continue;
							}
	
							node.wrap(self.filterNode(new Node('ul', 1)));
							continue;
						}
	
						// Try wrapping the element in a DIV
						if (schema.isValidChild(node.parent.name, 'div') && schema.isValidChild('div', node.name)) {
							node.wrap(self.filterNode(new Node('div', 1)));
						} else {
							// We failed wrapping it, then remove or unwrap it
							if (specialElements[node.name]) {
								node.empty().remove();
							} else {
								node.unwrap();
							}
						}
					}
				}
			}
	
			/**
			 * Runs the specified node though the element and attributes filters.
			 *
			 * @method filterNode
			 * @param {tinymce.html.Node} Node the node to run filters on.
			 * @return {tinymce.html.Node} The passed in node.
			 */
			self.filterNode = function(node) {
				var i, name, list;
	
				// Run element filters
				if (name in nodeFilters) {
					list = matchedNodes[name];
	
					if (list) {
						list.push(node);
					} else {
						matchedNodes[name] = [node];
					}
				}
	
				// Run attribute filters
				i = attributeFilters.length;
				while (i--) {
					name = attributeFilters[i].name;
	
					if (name in node.attributes.map) {
						list = matchedAttributes[name];
	
						if (list) {
							list.push(node);
						} else {
							matchedAttributes[name] = [node];
						}
					}
				}
	
				return node;
			};
	
			/**
			 * Adds a node filter function to the parser, the parser will collect the specified nodes by name
			 * and then execute the callback ones it has finished parsing the document.
			 *
			 * @example
			 * parser.addNodeFilter('p,h1', function(nodes, name) {
			 *		for (var i = 0; i < nodes.length; i++) {
			 *			console.log(nodes[i].name);
			 *		}
			 * });
			 * @method addNodeFilter
			 * @method {String} name Comma separated list of nodes to collect.
			 * @param {function} callback Callback function to execute once it has collected nodes.
			 */
			self.addNodeFilter = function(name, callback) {
				each(explode(name), function(name) {
					var list = nodeFilters[name];
	
					if (!list) {
						nodeFilters[name] = list = [];
					}
	
					list.push(callback);
				});
			};
	
			/**
			 * Adds a attribute filter function to the parser, the parser will collect nodes that has the specified attributes
			 * and then execute the callback ones it has finished parsing the document.
			 *
			 * @example
			 * parser.addAttributeFilter('src,href', function(nodes, name) {
			 *		for (var i = 0; i < nodes.length; i++) {
			 *			console.log(nodes[i].name);
			 *		}
			 * });
			 * @method addAttributeFilter
			 * @method {String} name Comma separated list of nodes to collect.
			 * @param {function} callback Callback function to execute once it has collected nodes.
			 */
			self.addAttributeFilter = function(name, callback) {
				each(explode(name), function(name) {
					var i;
	
					for (i = 0; i < attributeFilters.length; i++) {
						if (attributeFilters[i].name === name) {
							attributeFilters[i].callbacks.push(callback);
							return;
						}
					}
	
					attributeFilters.push({name: name, callbacks: [callback]});
				});
			};
	
			/**
			 * Parses the specified HTML string into a DOM like node tree and returns the result.
			 *
			 * @example
			 * var rootNode = new DomParser({...}).parse('<b>text</b>');
			 * @method parse
			 * @param {String} html Html string to sax parse.
			 * @param {Object} args Optional args object that gets passed to all filter functions.
			 * @return {tinymce.html.Node} Root node containing the tree.
			 */
			self.parse = function(html, args) {
				var parser, rootNode, node, nodes, i, l, fi, fl, list, name, validate;
				var blockElements, startWhiteSpaceRegExp, invalidChildren = [], isInWhiteSpacePreservedElement;
				var endWhiteSpaceRegExp, allWhiteSpaceRegExp, isAllWhiteSpaceRegExp, whiteSpaceElements;
				var children, nonEmptyElements, rootBlockName;
	
				args = args || {};
				matchedNodes = {};
				matchedAttributes = {};
				blockElements = extend(makeMap('script,style,head,html,body,title,meta,param'), schema.getBlockElements());
				nonEmptyElements = schema.getNonEmptyElements();
				children = schema.children;
				validate = settings.validate;
				rootBlockName = "forced_root_block" in args ? args.forced_root_block : settings.forced_root_block;
	
				whiteSpaceElements = schema.getWhiteSpaceElements();
				startWhiteSpaceRegExp = /^[ \t\r\n]+/;
				endWhiteSpaceRegExp = /[ \t\r\n]+$/;
				allWhiteSpaceRegExp = /[ \t\r\n]+/g;
				isAllWhiteSpaceRegExp = /^[ \t\r\n]+$/;
	
				function addRootBlocks() {
					var node = rootNode.firstChild, next, rootBlockNode;
	
					// Removes whitespace at beginning and end of block so:
					// <p> x </p> -> <p>x</p>
					function trim(rootBlockNode) {
						if (rootBlockNode) {
							node = rootBlockNode.firstChild;
							if (node && node.type == 3) {
								node.value = node.value.replace(startWhiteSpaceRegExp, '');
							}
	
							node = rootBlockNode.lastChild;
							if (node && node.type == 3) {
								node.value = node.value.replace(endWhiteSpaceRegExp, '');
							}
						}
					}
	
					// Check if rootBlock is valid within rootNode for example if P is valid in H1 if H1 is the contentEditabe root
					if (!schema.isValidChild(rootNode.name, rootBlockName.toLowerCase())) {
						return;
					}
	
					while (node) {
						next = node.next;
	
						if (node.type == 3 || (node.type == 1 && node.name !== 'p' &&
							!blockElements[node.name] && !node.attr('data-mce-type'))) {
							if (!rootBlockNode) {
								// Create a new root block element
								rootBlockNode = createNode(rootBlockName, 1);
								rootBlockNode.attr(settings.forced_root_block_attrs);
								rootNode.insert(rootBlockNode, node);
								rootBlockNode.append(node);
							} else {
								rootBlockNode.append(node);
							}
						} else {
							trim(rootBlockNode);
							rootBlockNode = null;
						}
	
						node = next;
					}
	
					trim(rootBlockNode);
				}
	
				function createNode(name, type) {
					var node = new Node(name, type), list;
	
					if (name in nodeFilters) {
						list = matchedNodes[name];
	
						if (list) {
							list.push(node);
						} else {
							matchedNodes[name] = [node];
						}
					}
	
					return node;
				}
	
				function removeWhitespaceBefore(node) {
					var textNode, textNodeNext, textVal, sibling, blockElements = schema.getBlockElements();
	
					for (textNode = node.prev; textNode && textNode.type === 3;) {
						textVal = textNode.value.replace(endWhiteSpaceRegExp, '');
	
						// Found a text node with non whitespace then trim that and break
						if (textVal.length > 0) {
							textNode.value = textVal;
							return;
						}
	
						textNodeNext = textNode.next;
	
						// Fix for bug #7543 where bogus nodes would produce empty
						// text nodes and these would be removed if a nested list was before it
						if (textNodeNext) {
							if (textNodeNext.type == 3 && textNodeNext.value.length) {
								textNode = textNode.prev;
								continue;
							}
	
							if (!blockElements[textNodeNext.name] && textNodeNext.name != 'script' && textNodeNext.name != 'style') {
								textNode = textNode.prev;
								continue;
							}
						}
	
						sibling = textNode.prev;
						textNode.remove();
						textNode = sibling;
					}
				}
	
				function cloneAndExcludeBlocks(input) {
					var name, output = {};
	
					for (name in input) {
						if (name !== 'li' && name != 'p') {
							output[name] = input[name];
						}
					}
	
					return output;
				}
	
				parser = new SaxParser({
					validate: validate,
					allow_script_urls: settings.allow_script_urls,
					allow_conditional_comments: settings.allow_conditional_comments,
	
					// Exclude P and LI from DOM parsing since it's treated better by the DOM parser
					self_closing_elements: cloneAndExcludeBlocks(schema.getSelfClosingElements()),
	
					cdata: function(text) {
						node.append(createNode('#cdata', 4)).value = text;
					},
	
					text: function(text, raw) {
						var textNode;
	
						// Trim all redundant whitespace on non white space elements
						if (!isInWhiteSpacePreservedElement) {
							text = text.replace(allWhiteSpaceRegExp, ' ');
	
							if (node.lastChild && blockElements[node.lastChild.name]) {
								text = text.replace(startWhiteSpaceRegExp, '');
							}
						}
	
						// Do we need to create the node
						if (text.length !== 0) {
							textNode = createNode('#text', 3);
							textNode.raw = !!raw;
							node.append(textNode).value = text;
						}
					},
	
					comment: function(text) {
						node.append(createNode('#comment', 8)).value = text;
					},
	
					pi: function(name, text) {
						node.append(createNode(name, 7)).value = text;
						removeWhitespaceBefore(node);
					},
	
					doctype: function(text) {
						var newNode;
	
						newNode = node.append(createNode('#doctype', 10));
						newNode.value = text;
						removeWhitespaceBefore(node);
					},
	
					start: function(name, attrs, empty) {
						var newNode, attrFiltersLen, elementRule, attrName, parent;
	
						elementRule = validate ? schema.getElementRule(name) : {};
						if (elementRule) {
							newNode = createNode(elementRule.outputName || name, 1);
							newNode.attributes = attrs;
							newNode.shortEnded = empty;
	
							node.append(newNode);
	
							// Check if node is valid child of the parent node is the child is
							// unknown we don't collect it since it's probably a custom element
							parent = children[node.name];
							if (parent && children[newNode.name] && !parent[newNode.name]) {
								invalidChildren.push(newNode);
							}
	
							attrFiltersLen = attributeFilters.length;
							while (attrFiltersLen--) {
								attrName = attributeFilters[attrFiltersLen].name;
	
								if (attrName in attrs.map) {
									list = matchedAttributes[attrName];
	
									if (list) {
										list.push(newNode);
									} else {
										matchedAttributes[attrName] = [newNode];
									}
								}
							}
	
							// Trim whitespace before block
							if (blockElements[name]) {
								removeWhitespaceBefore(newNode);
							}
	
							// Change current node if the element wasn't empty i.e not <br /> or <img />
							if (!empty) {
								node = newNode;
							}
	
							// Check if we are inside a whitespace preserved element
							if (!isInWhiteSpacePreservedElement && whiteSpaceElements[name]) {
								isInWhiteSpacePreservedElement = true;
							}
						}
					},
	
					end: function(name) {
						var textNode, elementRule, text, sibling, tempNode;
	
						elementRule = validate ? schema.getElementRule(name) : {};
						if (elementRule) {
							if (blockElements[name]) {
								if (!isInWhiteSpacePreservedElement) {
									// Trim whitespace of the first node in a block
									textNode = node.firstChild;
									if (textNode && textNode.type === 3) {
										text = textNode.value.replace(startWhiteSpaceRegExp, '');
	
										// Any characters left after trim or should we remove it
										if (text.length > 0) {
											textNode.value = text;
											textNode = textNode.next;
										} else {
											sibling = textNode.next;
											textNode.remove();
											textNode = sibling;
	
											// Remove any pure whitespace siblings
											while (textNode && textNode.type === 3) {
												text = textNode.value;
												sibling = textNode.next;
	
												if (text.length === 0 || isAllWhiteSpaceRegExp.test(text)) {
													textNode.remove();
													textNode = sibling;
												}
	
												textNode = sibling;
											}
										}
									}
	
									// Trim whitespace of the last node in a block
									textNode = node.lastChild;
									if (textNode && textNode.type === 3) {
										text = textNode.value.replace(endWhiteSpaceRegExp, '');
	
										// Any characters left after trim or should we remove it
										if (text.length > 0) {
											textNode.value = text;
											textNode = textNode.prev;
										} else {
											sibling = textNode.prev;
											textNode.remove();
											textNode = sibling;
	
											// Remove any pure whitespace siblings
											while (textNode && textNode.type === 3) {
												text = textNode.value;
												sibling = textNode.prev;
	
												if (text.length === 0 || isAllWhiteSpaceRegExp.test(text)) {
													textNode.remove();
													textNode = sibling;
												}
	
												textNode = sibling;
											}
										}
									}
								}
	
								// Trim start white space
								// Removed due to: #5424
								/*textNode = node.prev;
								if (textNode && textNode.type === 3) {
									text = textNode.value.replace(startWhiteSpaceRegExp, '');
	
									if (text.length > 0)
										textNode.value = text;
									else
										textNode.remove();
								}*/
							}
	
							// Check if we exited a whitespace preserved element
							if (isInWhiteSpacePreservedElement && whiteSpaceElements[name]) {
								isInWhiteSpacePreservedElement = false;
							}
	
							// Handle empty nodes
							if (elementRule.removeEmpty || elementRule.paddEmpty) {
								if (node.isEmpty(nonEmptyElements)) {
									if (elementRule.paddEmpty) {
										node.empty().append(new Node('#text', '3')).value = '\u00a0';
									} else {
										// Leave nodes that have a name like <a name="name">
										if (!node.attributes.map.name && !node.attributes.map.id) {
											tempNode = node.parent;
	
											if (blockElements[node.name]) {
												node.empty().remove();
											} else {
												node.unwrap();
											}
	
											node = tempNode;
											return;
										}
									}
								}
							}
	
							node = node.parent;
						}
					}
				}, schema);
	
				rootNode = node = new Node(args.context || settings.root_name, 11);
	
				parser.parse(html);
	
				// Fix invalid children or report invalid children in a contextual parsing
				if (validate && invalidChildren.length) {
					if (!args.context) {
						fixInvalidChildren(invalidChildren);
					} else {
						args.invalid = true;
					}
				}
	
				// Wrap nodes in the root into block elements if the root is body
				if (rootBlockName && (rootNode.name == 'body' || args.isRootContent)) {
					addRootBlocks();
				}
	
				// Run filters only when the contents is valid
				if (!args.invalid) {
					// Run node filters
					for (name in matchedNodes) {
						list = nodeFilters[name];
						nodes = matchedNodes[name];
	
						// Remove already removed children
						fi = nodes.length;
						while (fi--) {
							if (!nodes[fi].parent) {
								nodes.splice(fi, 1);
							}
						}
	
						for (i = 0, l = list.length; i < l; i++) {
							list[i](nodes, name, args);
						}
					}
	
					// Run attribute filters
					for (i = 0, l = attributeFilters.length; i < l; i++) {
						list = attributeFilters[i];
	
						if (list.name in matchedAttributes) {
							nodes = matchedAttributes[list.name];
	
							// Remove already removed children
							fi = nodes.length;
							while (fi--) {
								if (!nodes[fi].parent) {
									nodes.splice(fi, 1);
								}
							}
	
							for (fi = 0, fl = list.callbacks.length; fi < fl; fi++) {
								list.callbacks[fi](nodes, list.name, args);
							}
						}
					}
				}
	
				return rootNode;
			};
	
			// Remove <br> at end of block elements Gecko and WebKit injects BR elements to
			// make it possible to place the caret inside empty blocks. This logic tries to remove
			// these elements and keep br elements that where intended to be there intact
			if (settings.remove_trailing_brs) {
				self.addNodeFilter('br', function(nodes) {
					var i, l = nodes.length, node, blockElements = extend({}, schema.getBlockElements());
					var nonEmptyElements = schema.getNonEmptyElements(), parent, lastParent, prev, prevName;
					var elementRule, textNode;
	
					// Remove brs from body element as well
					blockElements.body = 1;
	
					// Must loop forwards since it will otherwise remove all brs in <p>a<br><br><br></p>
					for (i = 0; i < l; i++) {
						node = nodes[i];
						parent = node.parent;
	
						if (blockElements[node.parent.name] && node === parent.lastChild) {
							// Loop all nodes to the left of the current node and check for other BR elements
							// excluding bookmarks since they are invisible
							prev = node.prev;
							while (prev) {
								prevName = prev.name;
	
								// Ignore bookmarks
								if (prevName !== "span" || prev.attr('data-mce-type') !== 'bookmark') {
									// Found a non BR element
									if (prevName !== "br") {
										break;
									}
	
									// Found another br it's a <br><br> structure then don't remove anything
									if (prevName === 'br') {
										node = null;
										break;
									}
								}
	
								prev = prev.prev;
							}
	
							if (node) {
								node.remove();
	
								// Is the parent to be considered empty after we removed the BR
								if (parent.isEmpty(nonEmptyElements)) {
									elementRule = schema.getElementRule(parent.name);
	
									// Remove or padd the element depending on schema rule
									if (elementRule) {
										if (elementRule.removeEmpty) {
											parent.remove();
										} else if (elementRule.paddEmpty) {
											parent.empty().append(new Node('#text', 3)).value = '\u00a0';
										}
									}
								}
							}
						} else {
							// Replaces BR elements inside inline elements like <p><b><i><br></i></b></p>
							// so they become <p><b><i>&nbsp;</i></b></p>
							lastParent = node;
							while (parent && parent.firstChild === lastParent && parent.lastChild === lastParent) {
								lastParent = parent;
	
								if (blockElements[parent.name]) {
									break;
								}
	
								parent = parent.parent;
							}
	
							if (lastParent === parent) {
								textNode = new Node('#text', 3);
								textNode.value = '\u00a0';
								node.replace(textNode);
							}
						}
					}
				});
			}
	
			if (!settings.allow_unsafe_link_target) {
				self.addAttributeFilter('href', function(nodes) {
					var i = nodes.length, node, rel;
					var rules = 'noopener noreferrer';
	
					function addTargetRules(rel) {
						rel = removeTargetRules(rel);
						return rel ? [rel, rules].join(' ') : rules;
					}
	
					function removeTargetRules(rel) {
						var regExp = new RegExp('(' + rules.replace(' ', '|') + ')', 'g');
						if (rel) {
							rel = Tools.trim(rel.replace(regExp, ''));
						}
						return rel ? rel : null;
					}
	
					function toggleTargetRules(rel, isUnsafe) {
						return isUnsafe ? addTargetRules(rel) : removeTargetRules(rel);
					}
	
					while (i--) {
						node = nodes[i];
						rel = node.attr('rel');
						if (node.name === 'a') {
							node.attr('rel', toggleTargetRules(rel, node.attr('target') == '_blank'));
						}
					}
				});
			}
	
			// Force anchor names closed, unless the setting "allow_html_in_named_anchor" is explicitly included.
			if (!settings.allow_html_in_named_anchor) {
				self.addAttributeFilter('id,name', function(nodes) {
					var i = nodes.length, sibling, prevSibling, parent, node;
	
					while (i--) {
						node = nodes[i];
						if (node.name === 'a' && node.firstChild && !node.attr('href')) {
							parent = node.parent;
	
							// Move children after current node
							sibling = node.lastChild;
							do {
								prevSibling = sibling.prev;
								parent.insert(sibling, node);
								sibling = prevSibling;
							} while (sibling);
						}
					}
				});
			}
	
			if (settings.validate && schema.getValidClasses()) {
				self.addAttributeFilter('class', function(nodes) {
					var i = nodes.length, node, classList, ci, className, classValue;
					var validClasses = schema.getValidClasses(), validClassesMap, valid;
	
					while (i--) {
						node = nodes[i];
						classList = node.attr('class').split(' ');
						classValue = '';
	
						for (ci = 0; ci < classList.length; ci++) {
							className = classList[ci];
							valid = false;
	
							validClassesMap = validClasses['*'];
							if (validClassesMap && validClassesMap[className]) {
								valid = true;
							}
	
							validClassesMap = validClasses[node.name];
							if (!valid && validClassesMap && validClassesMap[className]) {
								valid = true;
							}
	
							if (valid) {
								if (classValue) {
									classValue += ' ';
								}
	
								classValue += className;
							}
						}
	
						if (!classValue.length) {
							classValue = null;
						}
	
						node.attr('class', classValue);
					}
				});
			}
		};
	});
	
	// Included from: js/tinymce/classes/html/Writer.js
	
	/**
	 * Writer.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This class is used to write HTML tags out it can be used with the Serializer or the SaxParser.
	 *
	 * @class tinymce.html.Writer
	 * @example
	 * var writer = new tinymce.html.Writer({indent: true});
	 * var parser = new tinymce.html.SaxParser(writer).parse('<p><br></p>');
	 * console.log(writer.getContent());
	 *
	 * @class tinymce.html.Writer
	 * @version 3.4
	 */
	define("tinymce/html/Writer", [
		"tinymce/html/Entities",
		"tinymce/util/Tools"
	], function(Entities, Tools) {
		var makeMap = Tools.makeMap;
	
		/**
		 * Constructs a new Writer instance.
		 *
		 * @constructor
		 * @method Writer
		 * @param {Object} settings Name/value settings object.
		 */
		return function(settings) {
			var html = [], indent, indentBefore, indentAfter, encode, htmlOutput;
	
			settings = settings || {};
			indent = settings.indent;
			indentBefore = makeMap(settings.indent_before || '');
			indentAfter = makeMap(settings.indent_after || '');
			encode = Entities.getEncodeFunc(settings.entity_encoding || 'raw', settings.entities);
			htmlOutput = settings.element_format == "html";
	
			return {
				/**
				 * Writes the a start element such as <p id="a">.
				 *
				 * @method start
				 * @param {String} name Name of the element.
				 * @param {Array} attrs Optional attribute array or undefined if it hasn't any.
				 * @param {Boolean} empty Optional empty state if the tag should end like <br />.
				 */
				start: function(name, attrs, empty) {
					var i, l, attr, value;
	
					if (indent && indentBefore[name] && html.length > 0) {
						value = html[html.length - 1];
	
						if (value.length > 0 && value !== '\n') {
							html.push('\n');
						}
					}
	
					html.push('<', name);
	
					if (attrs) {
						for (i = 0, l = attrs.length; i < l; i++) {
							attr = attrs[i];
							html.push(' ', attr.name, '="', encode(attr.value, true), '"');
						}
					}
	
					if (!empty || htmlOutput) {
						html[html.length] = '>';
					} else {
						html[html.length] = ' />';
					}
	
					if (empty && indent && indentAfter[name] && html.length > 0) {
						value = html[html.length - 1];
	
						if (value.length > 0 && value !== '\n') {
							html.push('\n');
						}
					}
				},
	
				/**
				 * Writes the a end element such as </p>.
				 *
				 * @method end
				 * @param {String} name Name of the element.
				 */
				end: function(name) {
					var value;
	
					/*if (indent && indentBefore[name] && html.length > 0) {
						value = html[html.length - 1];
	
						if (value.length > 0 && value !== '\n')
							html.push('\n');
					}*/
	
					html.push('</', name, '>');
	
					if (indent && indentAfter[name] && html.length > 0) {
						value = html[html.length - 1];
	
						if (value.length > 0 && value !== '\n') {
							html.push('\n');
						}
					}
				},
	
				/**
				 * Writes a text node.
				 *
				 * @method text
				 * @param {String} text String to write out.
				 * @param {Boolean} raw Optional raw state if true the contents wont get encoded.
				 */
				text: function(text, raw) {
					if (text.length > 0) {
						html[html.length] = raw ? text : encode(text);
					}
				},
	
				/**
				 * Writes a cdata node such as <![CDATA[data]]>.
				 *
				 * @method cdata
				 * @param {String} text String to write out inside the cdata.
				 */
				cdata: function(text) {
					html.push('<![CDATA[', text, ']]>');
				},
	
				/**
				 * Writes a comment node such as <!-- Comment -->.
				 *
				 * @method cdata
				 * @param {String} text String to write out inside the comment.
				 */
				comment: function(text) {
					html.push('<!--', text, '-->');
				},
	
				/**
				 * Writes a PI node such as <?xml attr="value" ?>.
				 *
				 * @method pi
				 * @param {String} name Name of the pi.
				 * @param {String} text String to write out inside the pi.
				 */
				pi: function(name, text) {
					if (text) {
						html.push('<?', name, ' ', encode(text), '?>');
					} else {
						html.push('<?', name, '?>');
					}
	
					if (indent) {
						html.push('\n');
					}
				},
	
				/**
				 * Writes a doctype node such as <!DOCTYPE data>.
				 *
				 * @method doctype
				 * @param {String} text String to write out inside the doctype.
				 */
				doctype: function(text) {
					html.push('<!DOCTYPE', text, '>', indent ? '\n' : '');
				},
	
				/**
				 * Resets the internal buffer if one wants to reuse the writer.
				 *
				 * @method reset
				 */
				reset: function() {
					html.length = 0;
				},
	
				/**
				 * Returns the contents that got serialized.
				 *
				 * @method getContent
				 * @return {String} HTML contents that got written down.
				 */
				getContent: function() {
					return html.join('').replace(/\n$/, '');
				}
			};
		};
	});
	
	// Included from: js/tinymce/classes/html/Serializer.js
	
	/**
	 * Serializer.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This class is used to serialize down the DOM tree into a string using a Writer instance.
	 *
	 *
	 * @example
	 * new tinymce.html.Serializer().serialize(new tinymce.html.DomParser().parse('<p>text</p>'));
	 * @class tinymce.html.Serializer
	 * @version 3.4
	 */
	define("tinymce/html/Serializer", [
		"tinymce/html/Writer",
		"tinymce/html/Schema"
	], function(Writer, Schema) {
		/**
		 * Constructs a new Serializer instance.
		 *
		 * @constructor
		 * @method Serializer
		 * @param {Object} settings Name/value settings object.
		 * @param {tinymce.html.Schema} schema Schema instance to use.
		 */
		return function(settings, schema) {
			var self = this, writer = new Writer(settings);
	
			settings = settings || {};
			settings.validate = "validate" in settings ? settings.validate : true;
	
			self.schema = schema = schema || new Schema();
			self.writer = writer;
	
			/**
			 * Serializes the specified node into a string.
			 *
			 * @example
			 * new tinymce.html.Serializer().serialize(new tinymce.html.DomParser().parse('<p>text</p>'));
			 * @method serialize
			 * @param {tinymce.html.Node} node Node instance to serialize.
			 * @return {String} String with HTML based on DOM tree.
			 */
			self.serialize = function(node) {
				var handlers, validate;
	
				validate = settings.validate;
	
				handlers = {
					// #text
					3: function(node) {
						writer.text(node.value, node.raw);
					},
	
					// #comment
					8: function(node) {
						writer.comment(node.value);
					},
	
					// Processing instruction
					7: function(node) {
						writer.pi(node.name, node.value);
					},
	
					// Doctype
					10: function(node) {
						writer.doctype(node.value);
					},
	
					// CDATA
					4: function(node) {
						writer.cdata(node.value);
					},
	
					// Document fragment
					11: function(node) {
						if ((node = node.firstChild)) {
							do {
								walk(node);
							} while ((node = node.next));
						}
					}
				};
	
				writer.reset();
	
				function walk(node) {
					var handler = handlers[node.type], name, isEmpty, attrs, attrName, attrValue, sortedAttrs, i, l, elementRule;
	
					if (!handler) {
						name = node.name;
						isEmpty = node.shortEnded;
						attrs = node.attributes;
	
						// Sort attributes
						if (validate && attrs && attrs.length > 1) {
							sortedAttrs = [];
							sortedAttrs.map = {};
	
							elementRule = schema.getElementRule(node.name);
							if (elementRule) {
								for (i = 0, l = elementRule.attributesOrder.length; i < l; i++) {
									attrName = elementRule.attributesOrder[i];
	
									if (attrName in attrs.map) {
										attrValue = attrs.map[attrName];
										sortedAttrs.map[attrName] = attrValue;
										sortedAttrs.push({name: attrName, value: attrValue});
									}
								}
	
								for (i = 0, l = attrs.length; i < l; i++) {
									attrName = attrs[i].name;
	
									if (!(attrName in sortedAttrs.map)) {
										attrValue = attrs.map[attrName];
										sortedAttrs.map[attrName] = attrValue;
										sortedAttrs.push({name: attrName, value: attrValue});
									}
								}
	
								attrs = sortedAttrs;
							}
						}
	
						writer.start(node.name, attrs, isEmpty);
	
						if (!isEmpty) {
							if ((node = node.firstChild)) {
								do {
									walk(node);
								} while ((node = node.next));
							}
	
							writer.end(name);
						}
					} else {
						handler(node);
					}
				}
	
				// Serialize element and treat all non elements as fragments
				if (node.type == 1 && !settings.inner) {
					walk(node);
				} else {
					handlers[11](node);
				}
	
				return writer.getContent();
			};
		};
	});
	
	// Included from: js/tinymce/classes/dom/Serializer.js
	
	/**
	 * Serializer.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This class is used to serialize DOM trees into a string. Consult the TinyMCE Wiki API for
	 * more details and examples on how to use this class.
	 *
	 * @class tinymce.dom.Serializer
	 */
	define("tinymce/dom/Serializer", [
		"tinymce/dom/DOMUtils",
		"tinymce/html/DomParser",
		"tinymce/html/SaxParser",
		"tinymce/html/Entities",
		"tinymce/html/Serializer",
		"tinymce/html/Node",
		"tinymce/html/Schema",
		"tinymce/Env",
		"tinymce/util/Tools",
		"tinymce/text/Zwsp"
	], function(DOMUtils, DomParser, SaxParser, Entities, Serializer, Node, Schema, Env, Tools, Zwsp) {
		var each = Tools.each, trim = Tools.trim;
		var DOM = DOMUtils.DOM;
	
		/**
		 * IE 11 has a fantastic bug where it will produce two trailing BR elements to iframe bodies when
		 * the iframe is hidden by display: none on a parent container. The DOM is actually out of sync
		 * with innerHTML in this case. It's like IE adds shadow DOM BR elements that appears on innerHTML
		 * but not as the lastChild of the body. So this fix simply removes the last two
		 * BR elements at the end of the document.
		 *
		 * Example of what happens: <body>text</body> becomes <body>text<br><br></body>
		 */
		function trimTrailingBr(rootNode) {
			var brNode1, brNode2;
	
			function isBr(node) {
				return node && node.name === 'br';
			}
	
			brNode1 = rootNode.lastChild;
			if (isBr(brNode1)) {
				brNode2 = brNode1.prev;
	
				if (isBr(brNode2)) {
					brNode1.remove();
					brNode2.remove();
				}
			}
		}
	
		/**
		 * Constructs a new DOM serializer class.
		 *
		 * @constructor
		 * @method Serializer
		 * @param {Object} settings Serializer settings object.
		 * @param {tinymce.Editor} editor Optional editor to bind events to and get schema/dom from.
		 */
		return function(settings, editor) {
			var dom, schema, htmlParser, tempAttrs = ["data-mce-selected"];
	
			if (editor) {
				dom = editor.dom;
				schema = editor.schema;
			}
	
			function trimHtml(html) {
				var trimContentRegExp = new RegExp([
					'<span[^>]+data-mce-bogus[^>]+>[\u200B\uFEFF]+<\\/span>', // Trim bogus spans like caret containers
					'\\s?(' + tempAttrs.join('|') + ')="[^"]+"' // Trim temporaty data-mce prefixed attributes like data-mce-selected
				].join('|'), 'gi');
	
				html = Zwsp.trim(html.replace(trimContentRegExp, ''));
	
				return html;
			}
	
			function trimContent(html) {
				var content = html;
				var bogusAllRegExp = /<(\w+) [^>]*data-mce-bogus="all"[^>]*>/g;
				var endTagIndex, index, matchLength, matches, shortEndedElements, schema = editor.schema;
	
				content = trimHtml(content);
				shortEndedElements = schema.getShortEndedElements();
	
				// Remove all bogus elements marked with "all"
				while ((matches = bogusAllRegExp.exec(content))) {
					index = bogusAllRegExp.lastIndex;
					matchLength = matches[0].length;
	
					if (shortEndedElements[matches[1]]) {
						endTagIndex = index;
					} else {
						endTagIndex = SaxParser.findEndTag(schema, content, index);
					}
	
					content = content.substring(0, index - matchLength) + content.substring(endTagIndex);
					bogusAllRegExp.lastIndex = index - matchLength;
				}
	
				return trim(content);
			}
	
			/**
			 * Returns a trimmed version of the editor contents to be used for the undo level. This
			 * will remove any data-mce-bogus="all" marked elements since these are used for UI it will also
			 * remove the data-mce-selected attributes used for selection of objects and caret containers.
			 * It will keep all data-mce-bogus="1" elements since these can be used to place the caret etc and will
			 * be removed by the serialization logic when you save.
			 *
			 * @private
			 * @return {String} HTML contents of the editor excluding some internal bogus elements.
			 */
			function getTrimmedContent() {
				return trimContent(editor.getBody().innerHTML);
			}
	
			function addTempAttr(name) {
				if (Tools.inArray(tempAttrs, name) === -1) {
					htmlParser.addAttributeFilter(name, function(nodes, name) {
						var i = nodes.length;
	
						while (i--) {
							nodes[i].attr(name, null);
						}
					});
	
					tempAttrs.push(name);
				}
			}
	
			// Default DOM and Schema if they are undefined
			dom = dom || DOM;
			schema = schema || new Schema(settings);
			settings.entity_encoding = settings.entity_encoding || 'named';
			settings.remove_trailing_brs = "remove_trailing_brs" in settings ? settings.remove_trailing_brs : true;
	
			htmlParser = new DomParser(settings, schema);
	
			// Convert tabindex back to elements when serializing contents
			htmlParser.addAttributeFilter('data-mce-tabindex', function(nodes, name) {
				var i = nodes.length, node;
	
				while (i--) {
					node = nodes[i];
					node.attr('tabindex', node.attributes.map['data-mce-tabindex']);
					node.attr(name, null);
				}
			});
	
			// Convert move data-mce-src, data-mce-href and data-mce-style into nodes or process them if needed
			htmlParser.addAttributeFilter('src,href,style', function(nodes, name) {
				var i = nodes.length, node, value, internalName = 'data-mce-' + name;
				var urlConverter = settings.url_converter, urlConverterScope = settings.url_converter_scope, undef;
	
				while (i--) {
					node = nodes[i];
	
					value = node.attributes.map[internalName];
					if (value !== undef) {
						// Set external name to internal value and remove internal
						node.attr(name, value.length > 0 ? value : null);
						node.attr(internalName, null);
					} else {
						// No internal attribute found then convert the value we have in the DOM
						value = node.attributes.map[name];
	
						if (name === "style") {
							value = dom.serializeStyle(dom.parseStyle(value), node.name);
						} else if (urlConverter) {
							value = urlConverter.call(urlConverterScope, value, name, node.name);
						}
	
						node.attr(name, value.length > 0 ? value : null);
					}
				}
			});
	
			// Remove internal classes mceItem<..> or mceSelected
			htmlParser.addAttributeFilter('class', function(nodes) {
				var i = nodes.length, node, value;
	
				while (i--) {
					node = nodes[i];
					value = node.attr('class');
	
					if (value) {
						value = node.attr('class').replace(/(?:^|\s)mce-item-\w+(?!\S)/g, '');
						node.attr('class', value.length > 0 ? value : null);
					}
				}
			});
	
			// Remove bookmark elements
			htmlParser.addAttributeFilter('data-mce-type', function(nodes, name, args) {
				var i = nodes.length, node;
	
				while (i--) {
					node = nodes[i];
	
					if (node.attributes.map['data-mce-type'] === 'bookmark' && !args.cleanup) {
						node.remove();
					}
				}
			});
	
			htmlParser.addNodeFilter('noscript', function(nodes) {
				var i = nodes.length, node;
	
				while (i--) {
					node = nodes[i].firstChild;
	
					if (node) {
						node.value = Entities.decode(node.value);
					}
				}
			});
	
			// Force script into CDATA sections and remove the mce- prefix also add comments around styles
			htmlParser.addNodeFilter('script,style', function(nodes, name) {
				var i = nodes.length, node, value, type;
	
				function trim(value) {
					/*jshint maxlen:255 */
					/*eslint max-len:0 */
					return value.replace(/(<!--\[CDATA\[|\]\]-->)/g, '\n')
							.replace(/^[\r\n]*|[\r\n]*$/g, '')
							.replace(/^\s*((<!--)?(\s*\/\/)?\s*<!\[CDATA\[|(<!--\s*)?\/\*\s*<!\[CDATA\[\s*\*\/|(\/\/)?\s*<!--|\/\*\s*<!--\s*\*\/)\s*[\r\n]*/gi, '')
							.replace(/\s*(\/\*\s*\]\]>\s*\*\/(-->)?|\s*\/\/\s*\]\]>(-->)?|\/\/\s*(-->)?|\]\]>|\/\*\s*-->\s*\*\/|\s*-->\s*)\s*$/g, '');
				}
	
				while (i--) {
					node = nodes[i];
					value = node.firstChild ? node.firstChild.value : '';
	
					if (name === "script") {
						// Remove mce- prefix from script elements and remove default type since the user specified
						// a script element without type attribute
						type = node.attr('type');
						if (type) {
							node.attr('type', type == 'mce-no/type' ? null : type.replace(/^mce\-/, ''));
						}
	
						if (value.length > 0) {
							node.firstChild.value = '// <![CDATA[\n' + trim(value) + '\n// ]]>';
						}
					} else {
						if (value.length > 0) {
							node.firstChild.value = '<!--\n' + trim(value) + '\n-->';
						}
					}
				}
			});
	
			// Convert comments to cdata and handle protected comments
			htmlParser.addNodeFilter('#comment', function(nodes) {
				var i = nodes.length, node;
	
				while (i--) {
					node = nodes[i];
	
					if (node.value.indexOf('[CDATA[') === 0) {
						node.name = '#cdata';
						node.type = 4;
						node.value = node.value.replace(/^\[CDATA\[|\]\]$/g, '');
					} else if (node.value.indexOf('mce:protected ') === 0) {
						node.name = "#text";
						node.type = 3;
						node.raw = true;
						node.value = unescape(node.value).substr(14);
					}
				}
			});
	
			htmlParser.addNodeFilter('xml:namespace,input', function(nodes, name) {
				var i = nodes.length, node;
	
				while (i--) {
					node = nodes[i];
					if (node.type === 7) {
						node.remove();
					} else if (node.type === 1) {
						if (name === "input" && !("type" in node.attributes.map)) {
							node.attr('type', 'text');
						}
					}
				}
			});
	
			// Fix list elements, TODO: Replace this later
			if (settings.fix_list_elements) {
				htmlParser.addNodeFilter('ul,ol', function(nodes) {
					var i = nodes.length, node, parentNode;
	
					while (i--) {
						node = nodes[i];
						parentNode = node.parent;
	
						if (parentNode.name === 'ul' || parentNode.name === 'ol') {
							if (node.prev && node.prev.name === 'li') {
								node.prev.append(node);
							}
						}
					}
				});
			}
	
			// Remove internal data attributes
			htmlParser.addAttributeFilter(
				'data-mce-src,data-mce-href,data-mce-style,' +
				'data-mce-selected,data-mce-expando,' +
				'data-mce-type,data-mce-resize',
	
				function(nodes, name) {
					var i = nodes.length;
	
					while (i--) {
						nodes[i].attr(name, null);
					}
				}
			);
	
			// Return public methods
			return {
				/**
				 * Schema instance that was used to when the Serializer was constructed.
				 *
				 * @field {tinymce.html.Schema} schema
				 */
				schema: schema,
	
				/**
				 * Adds a node filter function to the parser used by the serializer, the parser will collect the specified nodes by name
				 * and then execute the callback ones it has finished parsing the document.
				 *
				 * @example
				 * parser.addNodeFilter('p,h1', function(nodes, name) {
				 *		for (var i = 0; i < nodes.length; i++) {
				 *			console.log(nodes[i].name);
				 *		}
				 * });
				 * @method addNodeFilter
				 * @method {String} name Comma separated list of nodes to collect.
				 * @param {function} callback Callback function to execute once it has collected nodes.
				 */
				addNodeFilter: htmlParser.addNodeFilter,
	
				/**
				 * Adds a attribute filter function to the parser used by the serializer, the parser will
				 * collect nodes that has the specified attributes
				 * and then execute the callback ones it has finished parsing the document.
				 *
				 * @example
				 * parser.addAttributeFilter('src,href', function(nodes, name) {
				 *		for (var i = 0; i < nodes.length; i++) {
				 *			console.log(nodes[i].name);
				 *		}
				 * });
				 * @method addAttributeFilter
				 * @method {String} name Comma separated list of nodes to collect.
				 * @param {function} callback Callback function to execute once it has collected nodes.
				 */
				addAttributeFilter: htmlParser.addAttributeFilter,
	
				/**
				 * Serializes the specified browser DOM node into a HTML string.
				 *
				 * @method serialize
				 * @param {DOMNode} node DOM node to serialize.
				 * @param {Object} args Arguments option that gets passed to event handlers.
				 */
				serialize: function(node, args) {
					var self = this, impl, doc, oldDoc, htmlSerializer, content, rootNode;
	
					// Explorer won't clone contents of script and style and the
					// selected index of select elements are cleared on a clone operation.
					if (Env.ie && dom.select('script,style,select,map').length > 0) {
						content = node.innerHTML;
						node = node.cloneNode(false);
						dom.setHTML(node, content);
					} else {
						node = node.cloneNode(true);
					}
	
					// Nodes needs to be attached to something in WebKit/Opera
					// This fix will make DOM ranges and make Sizzle happy!
					impl = document.implementation;
					if (impl.createHTMLDocument) {
						// Create an empty HTML document
						doc = impl.createHTMLDocument("");
	
						// Add the element or it's children if it's a body element to the new document
						each(node.nodeName == 'BODY' ? node.childNodes : [node], function(node) {
							doc.body.appendChild(doc.importNode(node, true));
						});
	
						// Grab first child or body element for serialization
						if (node.nodeName != 'BODY') {
							node = doc.body.firstChild;
						} else {
							node = doc.body;
						}
	
						// set the new document in DOMUtils so createElement etc works
						oldDoc = dom.doc;
						dom.doc = doc;
					}
	
					args = args || {};
					args.format = args.format || 'html';
	
					// Don't wrap content if we want selected html
					if (args.selection) {
						args.forced_root_block = '';
					}
	
					// Pre process
					if (!args.no_events) {
						args.node = node;
						self.onPreProcess(args);
					}
	
					// Parse HTML
					rootNode = htmlParser.parse(trim(args.getInner ? node.innerHTML : dom.getOuterHTML(node)), args);
					trimTrailingBr(rootNode);
	
					// Serialize HTML
					htmlSerializer = new Serializer(settings, schema);
					args.content = htmlSerializer.serialize(rootNode);
	
					// Replace all BOM characters for now until we can find a better solution
					if (!args.cleanup) {
						args.content = Zwsp.trim(args.content);
						args.content = args.content.replace(/\uFEFF/g, '');
					}
	
					// Post process
					if (!args.no_events) {
						self.onPostProcess(args);
					}
	
					// Restore the old document if it was changed
					if (oldDoc) {
						dom.doc = oldDoc;
					}
	
					args.node = null;
	
					return args.content;
				},
	
				/**
				 * Adds valid elements rules to the serializers schema instance this enables you to specify things
				 * like what elements should be outputted and what attributes specific elements might have.
				 * Consult the Wiki for more details on this format.
				 *
				 * @method addRules
				 * @param {String} rules Valid elements rules string to add to schema.
				 */
				addRules: function(rules) {
					schema.addValidElements(rules);
				},
	
				/**
				 * Sets the valid elements rules to the serializers schema instance this enables you to specify things
				 * like what elements should be outputted and what attributes specific elements might have.
				 * Consult the Wiki for more details on this format.
				 *
				 * @method setRules
				 * @param {String} rules Valid elements rules string.
				 */
				setRules: function(rules) {
					schema.setValidElements(rules);
				},
	
				onPreProcess: function(args) {
					if (editor) {
						editor.fire('PreProcess', args);
					}
				},
	
				onPostProcess: function(args) {
					if (editor) {
						editor.fire('PostProcess', args);
					}
				},
	
				/**
				 * Adds a temporary internal attribute these attributes will get removed on undo and
				 * when getting contents out of the editor.
				 *
				 * @method addTempAttr
				 * @param {String} name string
				 */
				addTempAttr: addTempAttr,
	
				// Internal
				trimHtml: trimHtml,
				getTrimmedContent: getTrimmedContent,
				trimContent: trimContent
			};
		};
	});
	
	// Included from: js/tinymce/classes/dom/TridentSelection.js
	
	/**
	 * TridentSelection.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Selection class for old explorer versions. This one fakes the
	 * native selection object available on modern browsers.
	 *
	 * @private
	 * @class tinymce.dom.TridentSelection
	 */
	define("tinymce/dom/TridentSelection", [], function() {
		function Selection(selection) {
			var self = this, dom = selection.dom, FALSE = false;
	
			function getPosition(rng, start) {
				var checkRng, startIndex = 0, endIndex, inside,
					children, child, offset, index, position = -1, parent;
	
				// Setup test range, collapse it and get the parent
				checkRng = rng.duplicate();
				checkRng.collapse(start);
				parent = checkRng.parentElement();
	
				// Check if the selection is within the right document
				if (parent.ownerDocument !== selection.dom.doc) {
					return;
				}
	
				// IE will report non editable elements as it's parent so look for an editable one
				while (parent.contentEditable === "false") {
					parent = parent.parentNode;
				}
	
				// If parent doesn't have any children then return that we are inside the element
				if (!parent.hasChildNodes()) {
					return {node: parent, inside: 1};
				}
	
				// Setup node list and endIndex
				children = parent.children;
				endIndex = children.length - 1;
	
				// Perform a binary search for the position
				while (startIndex <= endIndex) {
					index = Math.floor((startIndex + endIndex) / 2);
	
					// Move selection to node and compare the ranges
					child = children[index];
					checkRng.moveToElementText(child);
					position = checkRng.compareEndPoints(start ? 'StartToStart' : 'EndToEnd', rng);
	
					// Before/after or an exact match
					if (position > 0) {
						endIndex = index - 1;
					} else if (position < 0) {
						startIndex = index + 1;
					} else {
						return {node: child};
					}
				}
	
				// Check if child position is before or we didn't find a position
				if (position < 0) {
					// No element child was found use the parent element and the offset inside that
					if (!child) {
						checkRng.moveToElementText(parent);
						checkRng.collapse(true);
						child = parent;
						inside = true;
					} else {
						checkRng.collapse(false);
					}
	
					// Walk character by character in text node until we hit the selected range endpoint,
					// hit the end of document or parent isn't the right one
					// We need to walk char by char since rng.text or rng.htmlText will trim line endings
					offset = 0;
					while (checkRng.compareEndPoints(start ? 'StartToStart' : 'StartToEnd', rng) !== 0) {
						if (checkRng.move('character', 1) === 0 || parent != checkRng.parentElement()) {
							break;
						}
	
						offset++;
					}
				} else {
					// Child position is after the selection endpoint
					checkRng.collapse(true);
	
					// Walk character by character in text node until we hit the selected range endpoint, hit
					// the end of document or parent isn't the right one
					offset = 0;
					while (checkRng.compareEndPoints(start ? 'StartToStart' : 'StartToEnd', rng) !== 0) {
						if (checkRng.move('character', -1) === 0 || parent != checkRng.parentElement()) {
							break;
						}
	
						offset++;
					}
				}
	
				return {node: child, position: position, offset: offset, inside: inside};
			}
	
			// Returns a W3C DOM compatible range object by using the IE Range API
			function getRange() {
				var ieRange = selection.getRng(), domRange = dom.createRng(), element, collapsed, tmpRange, element2, bookmark;
	
				// If selection is outside the current document just return an empty range
				element = ieRange.item ? ieRange.item(0) : ieRange.parentElement();
				if (element.ownerDocument != dom.doc) {
					return domRange;
				}
	
				collapsed = selection.isCollapsed();
	
				// Handle control selection
				if (ieRange.item) {
					domRange.setStart(element.parentNode, dom.nodeIndex(element));
					domRange.setEnd(domRange.startContainer, domRange.startOffset + 1);
	
					return domRange;
				}
	
				function findEndPoint(start) {
					var endPoint = getPosition(ieRange, start), container, offset, textNodeOffset = 0, sibling, undef, nodeValue;
	
					container = endPoint.node;
					offset = endPoint.offset;
	
					if (endPoint.inside && !container.hasChildNodes()) {
						domRange[start ? 'setStart' : 'setEnd'](container, 0);
						return;
					}
	
					if (offset === undef) {
						domRange[start ? 'setStartBefore' : 'setEndAfter'](container);
						return;
					}
	
					if (endPoint.position < 0) {
						sibling = endPoint.inside ? container.firstChild : container.nextSibling;
	
						if (!sibling) {
							domRange[start ? 'setStartAfter' : 'setEndAfter'](container);
							return;
						}
	
						if (!offset) {
							if (sibling.nodeType == 3) {
								domRange[start ? 'setStart' : 'setEnd'](sibling, 0);
							} else {
								domRange[start ? 'setStartBefore' : 'setEndBefore'](sibling);
							}
	
							return;
						}
	
						// Find the text node and offset
						while (sibling) {
							if (sibling.nodeType == 3) {
								nodeValue = sibling.nodeValue;
								textNodeOffset += nodeValue.length;
	
								// We are at or passed the position we where looking for
								if (textNodeOffset >= offset) {
									container = sibling;
									textNodeOffset -= offset;
									textNodeOffset = nodeValue.length - textNodeOffset;
									break;
								}
							}
	
							sibling = sibling.nextSibling;
						}
					} else {
						// Find the text node and offset
						sibling = container.previousSibling;
	
						if (!sibling) {
							return domRange[start ? 'setStartBefore' : 'setEndBefore'](container);
						}
	
						// If there isn't any text to loop then use the first position
						if (!offset) {
							if (container.nodeType == 3) {
								domRange[start ? 'setStart' : 'setEnd'](sibling, container.nodeValue.length);
							} else {
								domRange[start ? 'setStartAfter' : 'setEndAfter'](sibling);
							}
	
							return;
						}
	
						while (sibling) {
							if (sibling.nodeType == 3) {
								textNodeOffset += sibling.nodeValue.length;
	
								// We are at or passed the position we where looking for
								if (textNodeOffset >= offset) {
									container = sibling;
									textNodeOffset -= offset;
									break;
								}
							}
	
							sibling = sibling.previousSibling;
						}
					}
	
					domRange[start ? 'setStart' : 'setEnd'](container, textNodeOffset);
				}
	
				try {
					// Find start point
					findEndPoint(true);
	
					// Find end point if needed
					if (!collapsed) {
						findEndPoint();
					}
				} catch (ex) {
					// IE has a nasty bug where text nodes might throw "invalid argument" when you
					// access the nodeValue or other properties of text nodes. This seems to happen when
					// text nodes are split into two nodes by a delete/backspace call.
					// So let us detect and try to fix it.
					if (ex.number == -2147024809) {
						// Get the current selection
						bookmark = self.getBookmark(2);
	
						// Get start element
						tmpRange = ieRange.duplicate();
						tmpRange.collapse(true);
						element = tmpRange.parentElement();
	
						// Get end element
						if (!collapsed) {
							tmpRange = ieRange.duplicate();
							tmpRange.collapse(false);
							element2 = tmpRange.parentElement();
							element2.innerHTML = element2.innerHTML;
						}
	
						// Remove the broken elements
						element.innerHTML = element.innerHTML;
	
						// Restore the selection
						self.moveToBookmark(bookmark);
	
						// Since the range has moved we need to re-get it
						ieRange = selection.getRng();
	
						// Find start point
						findEndPoint(true);
	
						// Find end point if needed
						if (!collapsed) {
							findEndPoint();
						}
					} else {
						throw ex; // Throw other errors
					}
				}
	
				return domRange;
			}
	
			this.getBookmark = function(type) {
				var rng = selection.getRng(), bookmark = {};
	
				function getIndexes(node) {
					var parent, root, children, i, indexes = [];
	
					parent = node.parentNode;
					root = dom.getRoot().parentNode;
	
					while (parent != root && parent.nodeType !== 9) {
						children = parent.children;
	
						i = children.length;
						while (i--) {
							if (node === children[i]) {
								indexes.push(i);
								break;
							}
						}
	
						node = parent;
						parent = parent.parentNode;
					}
	
					return indexes;
				}
	
				function getBookmarkEndPoint(start) {
					var position;
	
					position = getPosition(rng, start);
					if (position) {
						return {
							position: position.position,
							offset: position.offset,
							indexes: getIndexes(position.node),
							inside: position.inside
						};
					}
				}
	
				// Non ubstructive bookmark
				if (type === 2) {
					// Handle text selection
					if (!rng.item) {
						bookmark.start = getBookmarkEndPoint(true);
	
						if (!selection.isCollapsed()) {
							bookmark.end = getBookmarkEndPoint();
						}
					} else {
						bookmark.start = {ctrl: true, indexes: getIndexes(rng.item(0))};
					}
				}
	
				return bookmark;
			};
	
			this.moveToBookmark = function(bookmark) {
				var rng, body = dom.doc.body;
	
				function resolveIndexes(indexes) {
					var node, i, idx, children;
	
					node = dom.getRoot();
					for (i = indexes.length - 1; i >= 0; i--) {
						children = node.children;
						idx = indexes[i];
	
						if (idx <= children.length - 1) {
							node = children[idx];
						}
					}
	
					return node;
				}
	
				function setBookmarkEndPoint(start) {
					var endPoint = bookmark[start ? 'start' : 'end'], moveLeft, moveRng, undef, offset;
	
					if (endPoint) {
						moveLeft = endPoint.position > 0;
	
						moveRng = body.createTextRange();
						moveRng.moveToElementText(resolveIndexes(endPoint.indexes));
	
						offset = endPoint.offset;
						if (offset !== undef) {
							moveRng.collapse(endPoint.inside || moveLeft);
							moveRng.moveStart('character', moveLeft ? -offset : offset);
						} else {
							moveRng.collapse(start);
						}
	
						rng.setEndPoint(start ? 'StartToStart' : 'EndToStart', moveRng);
	
						if (start) {
							rng.collapse(true);
						}
					}
				}
	
				if (bookmark.start) {
					if (bookmark.start.ctrl) {
						rng = body.createControlRange();
						rng.addElement(resolveIndexes(bookmark.start.indexes));
						rng.select();
					} else {
						rng = body.createTextRange();
						setBookmarkEndPoint(true);
						setBookmarkEndPoint();
						rng.select();
					}
				}
			};
	
			this.addRange = function(rng) {
				var ieRng, ctrlRng, startContainer, startOffset, endContainer, endOffset, sibling,
					doc = selection.dom.doc, body = doc.body, nativeRng, ctrlElm;
	
				function setEndPoint(start) {
					var container, offset, marker, tmpRng, nodes;
	
					marker = dom.create('a');
					container = start ? startContainer : endContainer;
					offset = start ? startOffset : endOffset;
					tmpRng = ieRng.duplicate();
	
					if (container == doc || container == doc.documentElement) {
						container = body;
						offset = 0;
					}
	
					if (container.nodeType == 3) {
						container.parentNode.insertBefore(marker, container);
						tmpRng.moveToElementText(marker);
						tmpRng.moveStart('character', offset);
						dom.remove(marker);
						ieRng.setEndPoint(start ? 'StartToStart' : 'EndToEnd', tmpRng);
					} else {
						nodes = container.childNodes;
	
						if (nodes.length) {
							if (offset >= nodes.length) {
								dom.insertAfter(marker, nodes[nodes.length - 1]);
							} else {
								container.insertBefore(marker, nodes[offset]);
							}
	
							tmpRng.moveToElementText(marker);
						} else if (container.canHaveHTML) {
							// Empty node selection for example <div>|</div>
							// Setting innerHTML with a span marker then remove that marker seems to keep empty block elements open
							container.innerHTML = '<span>&#xFEFF;</span>';
							marker = container.firstChild;
							tmpRng.moveToElementText(marker);
							tmpRng.collapse(FALSE); // Collapse false works better than true for some odd reason
						}
	
						ieRng.setEndPoint(start ? 'StartToStart' : 'EndToEnd', tmpRng);
						dom.remove(marker);
					}
				}
	
				// Setup some shorter versions
				startContainer = rng.startContainer;
				startOffset = rng.startOffset;
				endContainer = rng.endContainer;
				endOffset = rng.endOffset;
				ieRng = body.createTextRange();
	
				// If single element selection then try making a control selection out of it
				if (startContainer == endContainer && startContainer.nodeType == 1) {
					// Trick to place the caret inside an empty block element like <p></p>
					if (startOffset == endOffset && !startContainer.hasChildNodes()) {
						if (startContainer.canHaveHTML) {
							// Check if previous sibling is an empty block if it is then we need to render it
							// IE would otherwise move the caret into the sibling instead of the empty startContainer see: #5236
							// Example this: <p></p><p>|</p> would become this: <p>|</p><p></p>
							sibling = startContainer.previousSibling;
							if (sibling && !sibling.hasChildNodes() && dom.isBlock(sibling)) {
								sibling.innerHTML = '&#xFEFF;';
							} else {
								sibling = null;
							}
	
							startContainer.innerHTML = '<span>&#xFEFF;</span><span>&#xFEFF;</span>';
							ieRng.moveToElementText(startContainer.lastChild);
							ieRng.select();
							dom.doc.selection.clear();
							startContainer.innerHTML = '';
	
							if (sibling) {
								sibling.innerHTML = '';
							}
							return;
						}
	
						startOffset = dom.nodeIndex(startContainer);
						startContainer = startContainer.parentNode;
					}
	
					if (startOffset == endOffset - 1) {
						try {
							ctrlElm = startContainer.childNodes[startOffset];
							ctrlRng = body.createControlRange();
							ctrlRng.addElement(ctrlElm);
							ctrlRng.select();
	
							// Check if the range produced is on the correct element and is a control range
							// On IE 8 it will select the parent contentEditable container if you select an inner element see: #5398
							nativeRng = selection.getRng();
							if (nativeRng.item && ctrlElm === nativeRng.item(0)) {
								return;
							}
						} catch (ex) {
							// Ignore
						}
					}
				}
	
				// Set start/end point of selection
				setEndPoint(true);
				setEndPoint();
	
				// Select the new range and scroll it into view
				ieRng.select();
			};
	
			// Expose range method
			this.getRangeAt = getRange;
		}
	
		return Selection;
	});
	
	// Included from: js/tinymce/classes/util/VK.js
	
	/**
	 * VK.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This file exposes a set of the common KeyCodes for use. Please grow it as needed.
	 */
	define("tinymce/util/VK", [
		"tinymce/Env"
	], function(Env) {
		return {
			BACKSPACE: 8,
			DELETE: 46,
			DOWN: 40,
			ENTER: 13,
			LEFT: 37,
			RIGHT: 39,
			SPACEBAR: 32,
			TAB: 9,
			UP: 38,
	
			modifierPressed: function(e) {
				return e.shiftKey || e.ctrlKey || e.altKey || this.metaKeyPressed(e);
			},
	
			metaKeyPressed: function(e) {
				// Check if ctrl or meta key is pressed. Edge case for AltGr on Windows where it produces ctrlKey+altKey states
				return (Env.mac ? e.metaKey : e.ctrlKey && !e.altKey);
			}
		};
	});
	
	// Included from: js/tinymce/classes/dom/ControlSelection.js
	
	/**
	 * ControlSelection.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This class handles control selection of elements. Controls are elements
	 * that can be resized and needs to be selected as a whole. It adds custom resize handles
	 * to all browser engines that support properly disabling the built in resize logic.
	 *
	 * @class tinymce.dom.ControlSelection
	 */
	define("tinymce/dom/ControlSelection", [
		"tinymce/util/VK",
		"tinymce/util/Tools",
		"tinymce/util/Delay",
		"tinymce/Env",
		"tinymce/dom/NodeType"
	], function(VK, Tools, Delay, Env, NodeType) {
		var isContentEditableFalse = NodeType.isContentEditableFalse;
		var isContentEditableTrue = NodeType.isContentEditableTrue;
	
		function getContentEditableRoot(root, node) {
			while (node && node != root) {
				if (isContentEditableTrue(node) || isContentEditableFalse(node)) {
					return node;
				}
	
				node = node.parentNode;
			}
	
			return null;
		}
	
		return function(selection, editor) {
			var dom = editor.dom, each = Tools.each;
			var selectedElm, selectedElmGhost, resizeHelper, resizeHandles, selectedHandle, lastMouseDownEvent;
			var startX, startY, selectedElmX, selectedElmY, startW, startH, ratio, resizeStarted;
			var width, height, editableDoc = editor.getDoc(), rootDocument = document, isIE = Env.ie && Env.ie < 11;
			var abs = Math.abs, round = Math.round, rootElement = editor.getBody(), startScrollWidth, startScrollHeight;
	
			// Details about each resize handle how to scale etc
			resizeHandles = {
				// Name: x multiplier, y multiplier, delta size x, delta size y
				/*n: [0.5, 0, 0, -1],
				e: [1, 0.5, 1, 0],
				s: [0.5, 1, 0, 1],
				w: [0, 0.5, -1, 0],*/
				nw: [0, 0, -1, -1],
				ne: [1, 0, 1, -1],
				se: [1, 1, 1, 1],
				sw: [0, 1, -1, 1]
			};
	
			// Add CSS for resize handles, cloned element and selected
			var rootClass = '.mce-content-body';
			editor.contentStyles.push(
				rootClass + ' div.mce-resizehandle {' +
					'position: absolute;' +
					'border: 1px solid black;' +
					'box-sizing: box-sizing;' +
					'background: #FFF;' +
					'width: 7px;' +
					'height: 7px;' +
					'z-index: 10000' +
				'}' +
				rootClass + ' .mce-resizehandle:hover {' +
					'background: #000' +
				'}' +
				rootClass + ' img[data-mce-selected],' + rootClass + ' hr[data-mce-selected] {' +
					'outline: 1px solid black;' +
					'resize: none' + // Have been talks about implementing this in browsers
				'}' +
				rootClass + ' .mce-clonedresizable {' +
					'position: absolute;' +
					(Env.gecko ? '' : 'outline: 1px dashed black;') + // Gecko produces trails while resizing
					'opacity: .5;' +
					'filter: alpha(opacity=50);' +
					'z-index: 10000' +
				'}' +
				rootClass + ' .mce-resize-helper {' +
					'background: #555;' +
					'background: rgba(0,0,0,0.75);' +
					'border-radius: 3px;' +
					'border: 1px;' +
					'color: white;' +
					'display: none;' +
					'font-family: sans-serif;' +
					'font-size: 12px;' +
					'white-space: nowrap;' +
					'line-height: 14px;' +
					'margin: 5px 10px;' +
					'padding: 5px;' +
					'position: absolute;' +
					'z-index: 10001' +
				'}'
			);
	
			function isResizable(elm) {
				var selector = editor.settings.object_resizing;
	
				if (selector === false || Env.iOS) {
					return false;
				}
	
				if (typeof selector != 'string') {
					selector = 'table,img,div';
				}
	
				if (elm.getAttribute('data-mce-resize') === 'false') {
					return false;
				}
	
				if (elm == editor.getBody()) {
					return false;
				}
	
				return editor.dom.is(elm, selector);
			}
	
			function resizeGhostElement(e) {
				var deltaX, deltaY, proportional;
				var resizeHelperX, resizeHelperY;
	
				// Calc new width/height
				deltaX = e.screenX - startX;
				deltaY = e.screenY - startY;
	
				// Calc new size
				width = deltaX * selectedHandle[2] + startW;
				height = deltaY * selectedHandle[3] + startH;
	
				// Never scale down lower than 5 pixels
				width = width < 5 ? 5 : width;
				height = height < 5 ? 5 : height;
	
				if (selectedElm.nodeName == "IMG" && editor.settings.resize_img_proportional !== false) {
					proportional = !VK.modifierPressed(e);
				} else {
					proportional = VK.modifierPressed(e) || (selectedElm.nodeName == "IMG" && selectedHandle[2] * selectedHandle[3] !== 0);
				}
	
				// Constrain proportions
				if (proportional) {
					if (abs(deltaX) > abs(deltaY)) {
						height = round(width * ratio);
						width = round(height / ratio);
					} else {
						width = round(height / ratio);
						height = round(width * ratio);
					}
				}
	
				// Update ghost size
				dom.setStyles(selectedElmGhost, {
					width: width,
					height: height
				});
	
				// Update resize helper position
				resizeHelperX = selectedHandle.startPos.x + deltaX;
				resizeHelperY = selectedHandle.startPos.y + deltaY;
				resizeHelperX = resizeHelperX > 0 ? resizeHelperX : 0;
				resizeHelperY = resizeHelperY > 0 ? resizeHelperY : 0;
	
				dom.setStyles(resizeHelper, {
					left: resizeHelperX,
					top: resizeHelperY,
					display: 'block'
				});
	
				resizeHelper.innerHTML = width + ' &times; ' + height;
	
				// Update ghost X position if needed
				if (selectedHandle[2] < 0 && selectedElmGhost.clientWidth <= width) {
					dom.setStyle(selectedElmGhost, 'left', selectedElmX + (startW - width));
				}
	
				// Update ghost Y position if needed
				if (selectedHandle[3] < 0 && selectedElmGhost.clientHeight <= height) {
					dom.setStyle(selectedElmGhost, 'top', selectedElmY + (startH - height));
				}
	
				// Calculate how must overflow we got
				deltaX = rootElement.scrollWidth - startScrollWidth;
				deltaY = rootElement.scrollHeight - startScrollHeight;
	
				// Re-position the resize helper based on the overflow
				if (deltaX + deltaY !== 0) {
					dom.setStyles(resizeHelper, {
						left: resizeHelperX - deltaX,
						top: resizeHelperY - deltaY
					});
				}
	
				if (!resizeStarted) {
					editor.fire('ObjectResizeStart', {target: selectedElm, width: startW, height: startH});
					resizeStarted = true;
				}
			}
	
			function endGhostResize() {
				resizeStarted = false;
	
				function setSizeProp(name, value) {
					if (value) {
						// Resize by using style or attribute
						if (selectedElm.style[name] || !editor.schema.isValid(selectedElm.nodeName.toLowerCase(), name)) {
							dom.setStyle(selectedElm, name, value);
						} else {
							dom.setAttrib(selectedElm, name, value);
						}
					}
				}
	
				// Set width/height properties
				setSizeProp('width', width);
				setSizeProp('height', height);
	
				dom.unbind(editableDoc, 'mousemove', resizeGhostElement);
				dom.unbind(editableDoc, 'mouseup', endGhostResize);
	
				if (rootDocument != editableDoc) {
					dom.unbind(rootDocument, 'mousemove', resizeGhostElement);
					dom.unbind(rootDocument, 'mouseup', endGhostResize);
				}
	
				// Remove ghost/helper and update resize handle positions
				dom.remove(selectedElmGhost);
				dom.remove(resizeHelper);
	
				if (!isIE || selectedElm.nodeName == "TABLE") {
					showResizeRect(selectedElm);
				}
	
				editor.fire('ObjectResized', {target: selectedElm, width: width, height: height});
				dom.setAttrib(selectedElm, 'style', dom.getAttrib(selectedElm, 'style'));
				editor.nodeChanged();
			}
	
			function showResizeRect(targetElm, mouseDownHandleName, mouseDownEvent) {
				var position, targetWidth, targetHeight, e, rect;
	
				hideResizeRect();
				unbindResizeHandleEvents();
	
				// Get position and size of target
				position = dom.getPos(targetElm, rootElement);
				selectedElmX = position.x;
				selectedElmY = position.y;
				rect = targetElm.getBoundingClientRect(); // Fix for Gecko offsetHeight for table with caption
				targetWidth = rect.width || (rect.right - rect.left);
				targetHeight = rect.height || (rect.bottom - rect.top);
	
				// Reset width/height if user selects a new image/table
				if (selectedElm != targetElm) {
					detachResizeStartListener();
					selectedElm = targetElm;
					width = height = 0;
				}
	
				// Makes it possible to disable resizing
				e = editor.fire('ObjectSelected', {target: targetElm});
	
				if (isResizable(targetElm) && !e.isDefaultPrevented()) {
					each(resizeHandles, function(handle, name) {
						var handleElm;
	
						function startDrag(e) {
							startX = e.screenX;
							startY = e.screenY;
							startW = selectedElm.clientWidth;
							startH = selectedElm.clientHeight;
							ratio = startH / startW;
							selectedHandle = handle;
	
							handle.startPos = {
								x: targetWidth * handle[0] + selectedElmX,
								y: targetHeight * handle[1] + selectedElmY
							};
	
							startScrollWidth = rootElement.scrollWidth;
							startScrollHeight = rootElement.scrollHeight;
	
							selectedElmGhost = selectedElm.cloneNode(true);
							dom.addClass(selectedElmGhost, 'mce-clonedresizable');
							dom.setAttrib(selectedElmGhost, 'data-mce-bogus', 'all');
							selectedElmGhost.contentEditable = false; // Hides IE move layer cursor
							selectedElmGhost.unSelectabe = true;
							dom.setStyles(selectedElmGhost, {
								left: selectedElmX,
								top: selectedElmY,
								margin: 0
							});
	
							selectedElmGhost.removeAttribute('data-mce-selected');
							rootElement.appendChild(selectedElmGhost);
	
							dom.bind(editableDoc, 'mousemove', resizeGhostElement);
							dom.bind(editableDoc, 'mouseup', endGhostResize);
	
							if (rootDocument != editableDoc) {
								dom.bind(rootDocument, 'mousemove', resizeGhostElement);
								dom.bind(rootDocument, 'mouseup', endGhostResize);
							}
	
							resizeHelper = dom.add(rootElement, 'div', {
								'class': 'mce-resize-helper',
								'data-mce-bogus': 'all'
							}, startW + ' &times; ' + startH);
						}
	
						if (mouseDownHandleName) {
							// Drag started by IE native resizestart
							if (name == mouseDownHandleName) {
								startDrag(mouseDownEvent);
							}
	
							return;
						}
	
						// Get existing or render resize handle
						handleElm = dom.get('mceResizeHandle' + name);
						if (handleElm) {
							dom.remove(handleElm);
						}
	
						handleElm = dom.add(rootElement, 'div', {
							id: 'mceResizeHandle' + name,
							'data-mce-bogus': 'all',
							'class': 'mce-resizehandle',
							unselectable: true,
							style: 'cursor:' + name + '-resize; margin:0; padding:0'
						});
	
						// Hides IE move layer cursor
						// If we set it on Chrome we get this wounderful bug: #6725
						if (Env.ie) {
							handleElm.contentEditable = false;
						}
	
						dom.bind(handleElm, 'mousedown', function(e) {
							e.stopImmediatePropagation();
							e.preventDefault();
							startDrag(e);
						});
	
						handle.elm = handleElm;
	
						// Position element
						dom.setStyles(handleElm, {
							left: (targetWidth * handle[0] + selectedElmX) - (handleElm.offsetWidth / 2),
							top: (targetHeight * handle[1] + selectedElmY) - (handleElm.offsetHeight / 2)
						});
					});
				} else {
					hideResizeRect();
				}
	
				selectedElm.setAttribute('data-mce-selected', '1');
			}
	
			function hideResizeRect() {
				var name, handleElm;
	
				unbindResizeHandleEvents();
	
				if (selectedElm) {
					selectedElm.removeAttribute('data-mce-selected');
				}
	
				for (name in resizeHandles) {
					handleElm = dom.get('mceResizeHandle' + name);
					if (handleElm) {
						dom.unbind(handleElm);
						dom.remove(handleElm);
					}
				}
			}
	
			function updateResizeRect(e) {
				var startElm, controlElm;
	
				function isChildOrEqual(node, parent) {
					if (node) {
						do {
							if (node === parent) {
								return true;
							}
						} while ((node = node.parentNode));
					}
				}
	
				// Ignore all events while resizing or if the editor instance was removed
				if (resizeStarted || editor.removed) {
					return;
				}
	
				// Remove data-mce-selected from all elements since they might have been copied using Ctrl+c/v
				each(dom.select('img[data-mce-selected],hr[data-mce-selected]'), function(img) {
					img.removeAttribute('data-mce-selected');
				});
	
				controlElm = e.type == 'mousedown' ? e.target : selection.getNode();
				controlElm = dom.$(controlElm).closest(isIE ? 'table' : 'table,img,hr')[0];
	
				if (isChildOrEqual(controlElm, rootElement)) {
					disableGeckoResize();
					startElm = selection.getStart(true);
	
					if (isChildOrEqual(startElm, controlElm) && isChildOrEqual(selection.getEnd(true), controlElm)) {
						if (!isIE || (controlElm != startElm && startElm.nodeName !== 'IMG')) {
							showResizeRect(controlElm);
							return;
						}
					}
				}
	
				hideResizeRect();
			}
	
			function attachEvent(elm, name, func) {
				if (elm && elm.attachEvent) {
					elm.attachEvent('on' + name, func);
				}
			}
	
			function detachEvent(elm, name, func) {
				if (elm && elm.detachEvent) {
					elm.detachEvent('on' + name, func);
				}
			}
	
			function resizeNativeStart(e) {
				var target = e.srcElement, pos, name, corner, cornerX, cornerY, relativeX, relativeY;
	
				pos = target.getBoundingClientRect();
				relativeX = lastMouseDownEvent.clientX - pos.left;
				relativeY = lastMouseDownEvent.clientY - pos.top;
	
				// Figure out what corner we are draging on
				for (name in resizeHandles) {
					corner = resizeHandles[name];
	
					cornerX = target.offsetWidth * corner[0];
					cornerY = target.offsetHeight * corner[1];
	
					if (abs(cornerX - relativeX) < 8 && abs(cornerY - relativeY) < 8) {
						selectedHandle = corner;
						break;
					}
				}
	
				// Remove native selection and let the magic begin
				resizeStarted = true;
				editor.fire('ObjectResizeStart', {
					target: selectedElm,
					width: selectedElm.clientWidth,
					height: selectedElm.clientHeight
				});
				editor.getDoc().selection.empty();
				showResizeRect(target, name, lastMouseDownEvent);
			}
	
			function preventDefault(e) {
				if (e.preventDefault) {
					e.preventDefault();
				} else {
					e.returnValue = false; // IE
				}
			}
	
			function isWithinContentEditableFalse(elm) {
				return isContentEditableFalse(getContentEditableRoot(editor.getBody(), elm));
			}
	
			function nativeControlSelect(e) {
				var target = e.srcElement;
	
				if (isWithinContentEditableFalse(target)) {
					preventDefault(e);
					return;
				}
	
				if (target != selectedElm) {
					editor.fire('ObjectSelected', {target: target});
					detachResizeStartListener();
	
					if (target.id.indexOf('mceResizeHandle') === 0) {
						e.returnValue = false;
						return;
					}
	
					if (target.nodeName == 'IMG' || target.nodeName == 'TABLE') {
						hideResizeRect();
						selectedElm = target;
						attachEvent(target, 'resizestart', resizeNativeStart);
					}
				}
			}
	
			function detachResizeStartListener() {
				detachEvent(selectedElm, 'resizestart', resizeNativeStart);
			}
	
			function unbindResizeHandleEvents() {
				for (var name in resizeHandles) {
					var handle = resizeHandles[name];
	
					if (handle.elm) {
						dom.unbind(handle.elm);
						delete handle.elm;
					}
				}
			}
	
			function disableGeckoResize() {
				try {
					// Disable object resizing on Gecko
					editor.getDoc().execCommand('enableObjectResizing', false, false);
				} catch (ex) {
					// Ignore
				}
			}
	
			function controlSelect(elm) {
				var ctrlRng;
	
				if (!isIE) {
					return;
				}
	
				ctrlRng = editableDoc.body.createControlRange();
	
				try {
					ctrlRng.addElement(elm);
					ctrlRng.select();
					return true;
				} catch (ex) {
					// Ignore since the element can't be control selected for example a P tag
				}
			}
	
			editor.on('init', function() {
				if (isIE) {
					// Hide the resize rect on resize and reselect the image
					editor.on('ObjectResized', function(e) {
						if (e.target.nodeName != 'TABLE') {
							hideResizeRect();
							controlSelect(e.target);
						}
					});
	
					attachEvent(rootElement, 'controlselect', nativeControlSelect);
	
					editor.on('mousedown', function(e) {
						lastMouseDownEvent = e;
					});
				} else {
					disableGeckoResize();
	
					// Sniff sniff, hard to feature detect this stuff
					if (Env.ie >= 11) {
						// Needs to be mousedown for drag/drop to work on IE 11
						// Needs to be click on Edge to properly select images
						editor.on('mousedown click', function(e) {
							var target = e.target, nodeName = target.nodeName;
	
							if (!resizeStarted && /^(TABLE|IMG|HR)$/.test(nodeName) && !isWithinContentEditableFalse(target)) {
								editor.selection.select(target, nodeName == 'TABLE');
	
								// Only fire once since nodeChange is expensive
								if (e.type == 'mousedown') {
									editor.nodeChanged();
								}
							}
						});
	
						editor.dom.bind(rootElement, 'mscontrolselect', function(e) {
							function delayedSelect(node) {
								Delay.setEditorTimeout(editor, function() {
									editor.selection.select(node);
								});
							}
	
							if (isWithinContentEditableFalse(e.target)) {
								e.preventDefault();
								delayedSelect(e.target);
								return;
							}
	
							if (/^(TABLE|IMG|HR)$/.test(e.target.nodeName)) {
								e.preventDefault();
	
								// This moves the selection from being a control selection to a text like selection like in WebKit #6753
								// TODO: Fix this the day IE works like other browsers without this nasty native ugly control selections.
								if (e.target.tagName == 'IMG') {
									delayedSelect(e.target);
								}
							}
						});
					}
				}
	
				var throttledUpdateResizeRect = Delay.throttle(function(e) {
					if (!editor.composing) {
						updateResizeRect(e);
					}
				});
	
				editor.on('nodechange ResizeEditor ResizeWindow drop', throttledUpdateResizeRect);
	
				// Update resize rect while typing in a table
				editor.on('keyup compositionend', function(e) {
					// Don't update the resize rect while composing since it blows away the IME see: #2710
					if (selectedElm && selectedElm.nodeName == "TABLE") {
						throttledUpdateResizeRect(e);
					}
				});
	
				editor.on('hide blur', hideResizeRect);
	
				// Hide rect on focusout since it would float on top of windows otherwise
				//editor.on('focusout', hideResizeRect);
			});
	
			editor.on('remove', unbindResizeHandleEvents);
	
			function destroy() {
				selectedElm = selectedElmGhost = null;
	
				if (isIE) {
					detachResizeStartListener();
					detachEvent(rootElement, 'controlselect', nativeControlSelect);
				}
			}
	
			return {
				isResizable: isResizable,
				showResizeRect: showResizeRect,
				hideResizeRect: hideResizeRect,
				updateResizeRect: updateResizeRect,
				controlSelect: controlSelect,
				destroy: destroy
			};
		};
	});
	
	// Included from: js/tinymce/classes/util/Fun.js
	
	/**
	 * Fun.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Functional utility class.
	 *
	 * @private
	 * @class tinymce.util.Fun
	 */
	define("tinymce/util/Fun", [], function() {
		var slice = [].slice;
	
		function constant(value) {
			return function() {
				return value;
			};
		}
	
		function negate(predicate) {
			return function(x) {
				return !predicate(x);
			};
		}
	
		function compose(f, g) {
			return function(x) {
				return f(g(x));
			};
		}
	
		function or() {
			var args = slice.call(arguments);
	
			return function(x) {
				for (var i = 0; i < args.length; i++) {
					if (args[i](x)) {
						return true;
					}
				}
	
				return false;
			};
		}
	
		function and() {
			var args = slice.call(arguments);
	
			return function(x) {
				for (var i = 0; i < args.length; i++) {
					if (!args[i](x)) {
						return false;
					}
				}
	
				return true;
			};
		}
	
		function curry(fn) {
			var args = slice.call(arguments);
	
			if (args.length - 1 >= fn.length) {
				return fn.apply(this, args.slice(1));
			}
	
			return function() {
				var tempArgs = args.concat([].slice.call(arguments));
				return curry.apply(this, tempArgs);
			};
		}
	
		function noop() {
		}
	
		return {
			constant: constant,
			negate: negate,
			and: and,
			or: or,
			curry: curry,
			compose: compose,
			noop: noop
		};
	});
	
	// Included from: js/tinymce/classes/caret/CaretCandidate.js
	
	/**
	 * CaretCandidate.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This module contains logic for handling caret candidates. A caret candidate is
	 * for example text nodes, images, input elements, cE=false elements etc.
	 *
	 * @private
	 * @class tinymce.caret.CaretCandidate
	 */
	define("tinymce/caret/CaretCandidate", [
		"tinymce/dom/NodeType",
		"tinymce/util/Arr",
		"tinymce/caret/CaretContainer"
	], function(NodeType, Arr, CaretContainer) {
		var isContentEditableTrue = NodeType.isContentEditableTrue,
			isContentEditableFalse = NodeType.isContentEditableFalse,
			isBr = NodeType.isBr,
			isText = NodeType.isText,
			isInvalidTextElement = NodeType.matchNodeNames('script style textarea'),
			isAtomicInline = NodeType.matchNodeNames('img input textarea hr iframe video audio object'),
			isTable = NodeType.matchNodeNames('table'),
			isCaretContainer = CaretContainer.isCaretContainer;
	
		function isCaretCandidate(node) {
			if (isCaretContainer(node)) {
				return false;
			}
	
			if (isText(node)) {
				if (isInvalidTextElement(node.parentNode)) {
					return false;
				}
	
				return true;
			}
	
			return isAtomicInline(node) || isBr(node) || isTable(node) || isContentEditableFalse(node);
		}
	
		function isInEditable(node, rootNode) {
			for (node = node.parentNode; node && node != rootNode; node = node.parentNode) {
				if (isContentEditableFalse(node)) {
					return false;
				}
	
				if (isContentEditableTrue(node)) {
					return true;
				}
			}
	
			return true;
		}
	
		function isAtomicContentEditableFalse(node) {
			if (!isContentEditableFalse(node)) {
				return false;
			}
	
			return Arr.reduce(node.getElementsByTagName('*'), function(result, elm) {
				return result || isContentEditableTrue(elm);
			}, false) !== true;
		}
	
		function isAtomic(node) {
			return isAtomicInline(node) || isAtomicContentEditableFalse(node);
		}
	
		function isEditableCaretCandidate(node, rootNode) {
			return isCaretCandidate(node) && isInEditable(node, rootNode);
		}
	
		return {
			isCaretCandidate: isCaretCandidate,
			isInEditable: isInEditable,
			isAtomic: isAtomic,
			isEditableCaretCandidate: isEditableCaretCandidate
		};
	});
	
	// Included from: js/tinymce/classes/geom/ClientRect.js
	
	/**
	 * ClientRect.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Utility functions for working with client rects.
	 *
	 * @private
	 * @class tinymce.geom.ClientRect
	 */
	define("tinymce/geom/ClientRect", [], function() {
		var round = Math.round;
	
		function clone(rect) {
			if (!rect) {
				return {left: 0, top: 0, bottom: 0, right: 0, width: 0, height: 0};
			}
	
			return {
				left: round(rect.left),
				top: round(rect.top),
				bottom: round(rect.bottom),
				right: round(rect.right),
				width: round(rect.width),
				height: round(rect.height)
			};
		}
	
		function collapse(clientRect, toStart) {
			clientRect = clone(clientRect);
	
			if (toStart) {
				clientRect.right = clientRect.left;
			} else {
				clientRect.left = clientRect.left + clientRect.width;
				clientRect.right = clientRect.left;
			}
	
			clientRect.width = 0;
	
			return clientRect;
		}
	
		function isEqual(rect1, rect2) {
			return (
				rect1.left === rect2.left &&
				rect1.top === rect2.top &&
				rect1.bottom === rect2.bottom &&
				rect1.right === rect2.right
			);
		}
	
		function isValidOverflow(overflowY, clientRect1, clientRect2) {
			return overflowY >= 0 && overflowY <= Math.min(clientRect1.height, clientRect2.height) / 2;
	
		}
	
		function isAbove(clientRect1, clientRect2) {
			if (clientRect1.bottom < clientRect2.top) {
				return true;
			}
	
			if (clientRect1.top > clientRect2.bottom) {
				return false;
			}
	
			return isValidOverflow(clientRect2.top - clientRect1.bottom, clientRect1, clientRect2);
		}
	
		function isBelow(clientRect1, clientRect2) {
			if (clientRect1.top > clientRect2.bottom) {
				return true;
			}
	
			if (clientRect1.bottom < clientRect2.top) {
				return false;
			}
	
			return isValidOverflow(clientRect2.bottom - clientRect1.top, clientRect1, clientRect2);
		}
	
		function isLeft(clientRect1, clientRect2) {
			return clientRect1.left < clientRect2.left;
		}
	
		function isRight(clientRect1, clientRect2) {
			return clientRect1.right > clientRect2.right;
		}
	
		function compare(clientRect1, clientRect2) {
			if (isAbove(clientRect1, clientRect2)) {
				return -1;
			}
	
			if (isBelow(clientRect1, clientRect2)) {
				return 1;
			}
	
			if (isLeft(clientRect1, clientRect2)) {
				return -1;
			}
	
			if (isRight(clientRect1, clientRect2)) {
				return 1;
			}
	
			return 0;
		}
	
		function containsXY(clientRect, clientX, clientY) {
			return (
				clientX >= clientRect.left &&
				clientX <= clientRect.right &&
				clientY >= clientRect.top &&
				clientY <= clientRect.bottom
			);
		}
	
		return {
			clone: clone,
			collapse: collapse,
			isEqual: isEqual,
			isAbove: isAbove,
			isBelow: isBelow,
			isLeft: isLeft,
			isRight: isRight,
			compare: compare,
			containsXY: containsXY
		};
	});
	
	// Included from: js/tinymce/classes/text/ExtendingChar.js
	
	/**
	 * ExtendingChar.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This class contains logic for detecting extending characters.
	 *
	 * @private
	 * @class tinymce.text.ExtendingChar
	 * @example
	 * var isExtending = ExtendingChar.isExtendingChar('a');
	 */
	define("tinymce/text/ExtendingChar", [], function() {
		// Generated from: http://www.unicode.org/Public/UNIDATA/DerivedCoreProperties.txt
		// Only includes the characters in that fit into UCS-2 16 bit
		var extendingChars = new RegExp(
			"[\u0300-\u036F\u0483-\u0487\u0488-\u0489\u0591-\u05BD\u05BF\u05C1-\u05C2\u05C4-\u05C5\u05C7\u0610-\u061A" +
			"\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7-\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0" +
			"\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08E3-\u0902\u093A\u093C" +
			"\u0941-\u0948\u094D\u0951-\u0957\u0962-\u0963\u0981\u09BC\u09BE\u09C1-\u09C4\u09CD\u09D7\u09E2-\u09E3" +
			"\u0A01-\u0A02\u0A3C\u0A41-\u0A42\u0A47-\u0A48\u0A4B-\u0A4D\u0A51\u0A70-\u0A71\u0A75\u0A81-\u0A82\u0ABC" +
			"\u0AC1-\u0AC5\u0AC7-\u0AC8\u0ACD\u0AE2-\u0AE3\u0B01\u0B3C\u0B3E\u0B3F\u0B41-\u0B44\u0B4D\u0B56\u0B57" +
			"\u0B62-\u0B63\u0B82\u0BBE\u0BC0\u0BCD\u0BD7\u0C00\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55-\u0C56" +
			"\u0C62-\u0C63\u0C81\u0CBC\u0CBF\u0CC2\u0CC6\u0CCC-\u0CCD\u0CD5-\u0CD6\u0CE2-\u0CE3\u0D01\u0D3E\u0D41-\u0D44" +
			"\u0D4D\u0D57\u0D62-\u0D63\u0DCA\u0DCF\u0DD2-\u0DD4\u0DD6\u0DDF\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9" +
			"\u0EBB-\u0EBC\u0EC8-\u0ECD\u0F18-\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86-\u0F87\u0F8D-\u0F97" +
			"\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039-\u103A\u103D-\u103E\u1058-\u1059\u105E-\u1060\u1071-\u1074" +
			"\u1082\u1085-\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752-\u1753\u1772-\u1773\u17B4-\u17B5" +
			"\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u18A9\u1920-\u1922\u1927-\u1928\u1932\u1939-\u193B\u1A17-\u1A18" +
			"\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ABD\u1ABE\u1B00-\u1B03\u1B34" +
			"\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80-\u1B81\u1BA2-\u1BA5\u1BA8-\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8-\u1BE9" +
			"\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8-\u1CF9" +
			"\u1DC0-\u1DF5\u1DFC-\u1DFF\u200C-\u200D\u20D0-\u20DC\u20DD-\u20E0\u20E1\u20E2-\u20E4\u20E5-\u20F0\u2CEF-\u2CF1" +
			"\u2D7F\u2DE0-\u2DFF\u302A-\u302D\u302E-\u302F\u3099-\u309A\uA66F\uA670-\uA672\uA674-\uA67D\uA69E-\uA69F\uA6F0-\uA6F1" +
			"\uA802\uA806\uA80B\uA825-\uA826\uA8C4\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC" +
			"\uA9E5\uAA29-\uAA2E\uAA31-\uAA32\uAA35-\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7-\uAAB8\uAABE-\uAABF\uAAC1" +
			"\uAAEC-\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFF9E-\uFF9F]"
		);
	
		function isExtendingChar(ch) {
			return typeof ch == "string" && ch.charCodeAt(0) >= 768 && extendingChars.test(ch);
		}
	
		return {
			isExtendingChar: isExtendingChar
		};
	});
	
	// Included from: js/tinymce/classes/caret/CaretPosition.js
	
	/**
	 * CaretPosition.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This module contains logic for creating caret positions within a document a caretposition
	 * is similar to a DOMRange object but it doesn't have two endpoints and is also more lightweight
	 * since it's now updated live when the DOM changes.
	 *
	 * @private
	 * @class tinymce.caret.CaretPosition
	 * @example
	 * var caretPos1 = new CaretPosition(container, offset);
	 * var caretPos2 = CaretPosition.fromRangeStart(someRange);
	 */
	define("tinymce/caret/CaretPosition", [
		"tinymce/util/Fun",
		"tinymce/dom/NodeType",
		"tinymce/dom/DOMUtils",
		"tinymce/dom/RangeUtils",
		"tinymce/caret/CaretCandidate",
		"tinymce/geom/ClientRect",
		"tinymce/text/ExtendingChar"
	], function(Fun, NodeType, DOMUtils, RangeUtils, CaretCandidate, ClientRect, ExtendingChar) {
		var isElement = NodeType.isElement,
			isCaretCandidate = CaretCandidate.isCaretCandidate,
			isBlock = NodeType.matchStyleValues('display', 'block table'),
			isFloated = NodeType.matchStyleValues('float', 'left right'),
			isValidElementCaretCandidate = Fun.and(isElement, isCaretCandidate, Fun.negate(isFloated)),
			isNotPre = Fun.negate(NodeType.matchStyleValues('white-space', 'pre pre-line pre-wrap')),
			isText = NodeType.isText,
			isBr = NodeType.isBr,
			nodeIndex = DOMUtils.nodeIndex,
			resolveIndex = RangeUtils.getNode;
	
		function createRange(doc) {
			return "createRange" in doc ? doc.createRange() : DOMUtils.DOM.createRng();
		}
	
		function isWhiteSpace(chr) {
			return chr && /[\r\n\t ]/.test(chr);
		}
	
		function isHiddenWhiteSpaceRange(range) {
			var container = range.startContainer,
				offset = range.startOffset,
				text;
	
			if (isWhiteSpace(range.toString()) && isNotPre(container.parentNode)) {
				text = container.data;
	
				if (isWhiteSpace(text[offset - 1]) || isWhiteSpace(text[offset + 1])) {
					return true;
				}
			}
	
			return false;
		}
	
		function getCaretPositionClientRects(caretPosition) {
			var clientRects = [], beforeNode, node;
	
			// Hack for older WebKit versions that doesn't
			// support getBoundingClientRect on BR elements
			function getBrClientRect(brNode) {
				var doc = brNode.ownerDocument,
					rng = createRange(doc),
					nbsp = doc.createTextNode('\u00a0'),
					parentNode = brNode.parentNode,
					clientRect;
	
				parentNode.insertBefore(nbsp, brNode);
				rng.setStart(nbsp, 0);
				rng.setEnd(nbsp, 1);
				clientRect = ClientRect.clone(rng.getBoundingClientRect());
				parentNode.removeChild(nbsp);
	
				return clientRect;
			}
	
			function getBoundingClientRect(item) {
				var clientRect, clientRects;
	
				clientRects = item.getClientRects();
				if (clientRects.length > 0) {
					clientRect = ClientRect.clone(clientRects[0]);
				} else {
					clientRect = ClientRect.clone(item.getBoundingClientRect());
				}
	
				if (isBr(item) && clientRect.left === 0) {
					return getBrClientRect(item);
				}
	
				return clientRect;
			}
	
			function collapseAndInflateWidth(clientRect, toStart) {
				clientRect = ClientRect.collapse(clientRect, toStart);
				clientRect.width = 1;
				clientRect.right = clientRect.left + 1;
	
				return clientRect;
			}
	
			function addUniqueAndValidRect(clientRect) {
				if (clientRect.height === 0) {
					return;
				}
	
				if (clientRects.length > 0) {
					if (ClientRect.isEqual(clientRect, clientRects[clientRects.length - 1])) {
						return;
					}
				}
	
				clientRects.push(clientRect);
			}
	
			function addCharacterOffset(container, offset) {
				var range = createRange(container.ownerDocument);
	
				if (offset < container.data.length) {
					if (ExtendingChar.isExtendingChar(container.data[offset])) {
						return clientRects;
					}
	
					// WebKit returns two client rects for a position after an extending
					// character a\uxxx|b so expand on "b" and collapse to start of "b" box
					if (ExtendingChar.isExtendingChar(container.data[offset - 1])) {
						range.setStart(container, offset);
						range.setEnd(container, offset + 1);
	
						if (!isHiddenWhiteSpaceRange(range)) {
							addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect(range), false));
							return clientRects;
						}
					}
				}
	
				if (offset > 0) {
					range.setStart(container, offset - 1);
					range.setEnd(container, offset);
	
					if (!isHiddenWhiteSpaceRange(range)) {
						addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect(range), false));
					}
				}
	
				if (offset < container.data.length) {
					range.setStart(container, offset);
					range.setEnd(container, offset + 1);
	
					if (!isHiddenWhiteSpaceRange(range)) {
						addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect(range), true));
					}
				}
			}
	
			if (isText(caretPosition.container())) {
				addCharacterOffset(caretPosition.container(), caretPosition.offset());
				return clientRects;
			}
	
			if (isElement(caretPosition.container())) {
				if (caretPosition.isAtEnd()) {
					node = resolveIndex(caretPosition.container(), caretPosition.offset());
					if (isText(node)) {
						addCharacterOffset(node, node.data.length);
					}
	
					if (isValidElementCaretCandidate(node) && !isBr(node)) {
						addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect(node), false));
					}
				} else {
					node = resolveIndex(caretPosition.container(), caretPosition.offset());
					if (isText(node)) {
						addCharacterOffset(node, 0);
					}
	
					if (isValidElementCaretCandidate(node) && caretPosition.isAtEnd()) {
						addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect(node), false));
						return clientRects;
					}
	
					beforeNode = resolveIndex(caretPosition.container(), caretPosition.offset() - 1);
					if (isValidElementCaretCandidate(beforeNode) && !isBr(beforeNode)) {
						if (isBlock(beforeNode) || isBlock(node) || !isValidElementCaretCandidate(node)) {
							addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect(beforeNode), false));
						}
					}
	
					if (isValidElementCaretCandidate(node)) {
						addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect(node), true));
					}
				}
			}
	
			return clientRects;
		}
	
		/**
		 * Represents a location within the document by a container and an offset.
		 *
		 * @constructor
		 * @param {Node} container Container node.
		 * @param {Number} offset Offset within that container node.
		 * @param {Array} clientRects Optional client rects array for the position.
		 */
		function CaretPosition(container, offset, clientRects) {
			function isAtStart() {
				if (isText(container)) {
					return offset === 0;
				}
	
				return offset === 0;
			}
	
			function isAtEnd() {
				if (isText(container)) {
					return offset >= container.data.length;
				}
	
				return offset >= container.childNodes.length;
			}
	
			function toRange() {
				var range;
	
				range = createRange(container.ownerDocument);
				range.setStart(container, offset);
				range.setEnd(container, offset);
	
				return range;
			}
	
			function getClientRects() {
				if (!clientRects) {
					clientRects = getCaretPositionClientRects(new CaretPosition(container, offset));
				}
	
				return clientRects;
			}
	
			function isVisible() {
				return getClientRects().length > 0;
			}
	
			function isEqual(caretPosition) {
				return caretPosition && container === caretPosition.container() && offset === caretPosition.offset();
			}
	
			function getNode(before) {
				return resolveIndex(container, before ? offset - 1 : offset);
			}
	
			return {
				/**
				 * Returns the container node.
				 *
				 * @method container
				 * @return {Node} Container node.
				 */
				container: Fun.constant(container),
	
				/**
				 * Returns the offset within the container node.
				 *
				 * @method offset
				 * @return {Number} Offset within the container node.
				 */
				offset: Fun.constant(offset),
	
				/**
				 * Returns a range out of a the caret position.
				 *
				 * @method toRange
				 * @return {DOMRange} range for the caret position.
				 */
				toRange: toRange,
	
				/**
				 * Returns the client rects for the caret position. Might be multiple rects between
				 * block elements.
				 *
				 * @method getClientRects
				 * @return {Array} Array of client rects.
				 */
				getClientRects: getClientRects,
	
				/**
				 * Returns true if the caret location is visible/displayed on screen.
				 *
				 * @method isVisible
				 * @return {Boolean} true/false if the position is visible or not.
				 */
				isVisible: isVisible,
	
				/**
				 * Returns true if the caret location is at the beginning of text node or container.
				 *
				 * @method isVisible
				 * @return {Boolean} true/false if the position is at the beginning.
				 */
				isAtStart: isAtStart,
	
				/**
				 * Returns true if the caret location is at the end of text node or container.
				 *
				 * @method isVisible
				 * @return {Boolean} true/false if the position is at the end.
				 */
				isAtEnd: isAtEnd,
	
				/**
				 * Compares the caret position to another caret position. This will only compare the
				 * container and offset not it's visual position.
				 *
				 * @method isEqual
				 * @param {tinymce.caret.CaretPosition} caretPosition Caret position to compare with.
				 * @return {Boolean} true if the caret positions are equal.
				 */
				isEqual: isEqual,
	
				/**
				 * Returns the closest resolved node from a node index. That means if you have an offset after the
				 * last node in a container it will return that last node.
				 *
				 * @method getNode
				 * @return {Node} Node that is closest to the index.
				 */
				getNode: getNode
			};
		}
	
		/**
		 * Creates a caret position from the start of a range.
		 *
		 * @method fromRangeStart
		 * @param {DOMRange} range DOM Range to create caret position from.
		 * @return {tinymce.caret.CaretPosition} Caret position from the start of DOM range.
		 */
		CaretPosition.fromRangeStart = function(range) {
			return new CaretPosition(range.startContainer, range.startOffset);
		};
	
		/**
		 * Creates a caret position from the end of a range.
		 *
		 * @method fromRangeEnd
		 * @param {DOMRange} range DOM Range to create caret position from.
		 * @return {tinymce.caret.CaretPosition} Caret position from the end of DOM range.
		 */
		CaretPosition.fromRangeEnd = function(range) {
			return new CaretPosition(range.endContainer, range.endOffset);
		};
	
		/**
		 * Creates a caret position from a node and places the offset after it.
		 *
		 * @method after
		 * @param {Node} node Node to get caret position from.
		 * @return {tinymce.caret.CaretPosition} Caret position from the node.
		 */
		CaretPosition.after = function(node) {
			return new CaretPosition(node.parentNode, nodeIndex(node) + 1);
		};
	
		/**
		 * Creates a caret position from a node and places the offset before it.
		 *
		 * @method before
		 * @param {Node} node Node to get caret position from.
		 * @return {tinymce.caret.CaretPosition} Caret position from the node.
		 */
		CaretPosition.before = function(node) {
			return new CaretPosition(node.parentNode, nodeIndex(node));
		};
	
		return CaretPosition;
	});
	
	// Included from: js/tinymce/classes/caret/CaretBookmark.js
	
	/**
	 * CaretBookmark.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This module creates or resolves xpath like string representation of a CaretPositions.
	 *
	 * The format is a / separated list of chunks with:
	 * <element|text()>[index|after|before]
	 *
	 * For example:
	 *  p[0]/b[0]/text()[0],1 = <p><b>a|c</b></p>
	 *  p[0]/img[0],before = <p>|<img></p>
	 *  p[0]/img[0],after = <p><img>|</p>
	 *
	 * @private
	 * @static
	 * @class tinymce.caret.CaretBookmark
	 * @example
	 * var bookmark = CaretBookmark.create(rootElm, CaretPosition.before(rootElm.firstChild));
	 * var caretPosition = CaretBookmark.resolve(bookmark);
	 */
	define('tinymce/caret/CaretBookmark', [
		'tinymce/dom/NodeType',
		'tinymce/dom/DOMUtils',
		'tinymce/util/Fun',
		'tinymce/util/Arr',
		'tinymce/caret/CaretPosition'
	], function(NodeType, DomUtils, Fun, Arr, CaretPosition) {
		var isText = NodeType.isText,
			isBogus = NodeType.isBogus,
			nodeIndex = DomUtils.nodeIndex;
	
		function normalizedParent(node) {
			var parentNode = node.parentNode;
	
			if (isBogus(parentNode)) {
				return normalizedParent(parentNode);
			}
	
			return parentNode;
		}
	
		function getChildNodes(node) {
			if (!node) {
				return [];
			}
	
			return Arr.reduce(node.childNodes, function(result, node) {
				if (isBogus(node) && node.nodeName != 'BR') {
					result = result.concat(getChildNodes(node));
				} else {
					result.push(node);
				}
	
				return result;
			}, []);
		}
	
		function normalizedTextOffset(textNode, offset) {
			while ((textNode = textNode.previousSibling)) {
				if (!isText(textNode)) {
					break;
				}
	
				offset += textNode.data.length;
			}
	
			return offset;
		}
	
		function equal(targetValue) {
			return function(value) {
				return targetValue === value;
			};
		}
	
		function normalizedNodeIndex(node) {
			var nodes, index, numTextFragments;
	
			nodes = getChildNodes(normalizedParent(node));
			index = Arr.findIndex(nodes, equal(node), node);
			nodes = nodes.slice(0, index + 1);
			numTextFragments = Arr.reduce(nodes, function(result, node, i) {
				if (isText(node) && isText(nodes[i - 1])) {
					result++;
				}
	
				return result;
			}, 0);
	
			nodes = Arr.filter(nodes, NodeType.matchNodeNames(node.nodeName));
			index = Arr.findIndex(nodes, equal(node), node);
	
			return index - numTextFragments;
		}
	
		function createPathItem(node) {
			var name;
	
			if (isText(node)) {
				name = 'text()';
			} else {
				name = node.nodeName.toLowerCase();
			}
	
			return name + '[' + normalizedNodeIndex(node) + ']';
		}
	
		function parentsUntil(rootNode, node, predicate) {
			var parents = [];
	
			for (node = node.parentNode; node != rootNode; node = node.parentNode) {
				if (predicate && predicate(node)) {
					break;
				}
	
				parents.push(node);
			}
	
			return parents;
		}
	
		function create(rootNode, caretPosition) {
			var container, offset, path = [],
				outputOffset, childNodes, parents;
	
			container = caretPosition.container();
			offset = caretPosition.offset();
	
			if (isText(container)) {
				outputOffset = normalizedTextOffset(container, offset);
			} else {
				childNodes = container.childNodes;
				if (offset >= childNodes.length) {
					outputOffset = 'after';
					offset = childNodes.length - 1;
				} else {
					outputOffset = 'before';
				}
	
				container = childNodes[offset];
			}
	
			path.push(createPathItem(container));
			parents = parentsUntil(rootNode, container);
			parents = Arr.filter(parents, Fun.negate(NodeType.isBogus));
			path = path.concat(Arr.map(parents, function(node) {
				return createPathItem(node);
			}));
	
			return path.reverse().join('/') + ',' + outputOffset;
		}
	
		function resolvePathItem(node, name, index) {
			var nodes = getChildNodes(node);
	
			nodes = Arr.filter(nodes, function(node, index) {
				return !isText(node) || !isText(nodes[index - 1]);
			});
	
			nodes = Arr.filter(nodes, NodeType.matchNodeNames(name));
			return nodes[index];
		}
	
		function findTextPosition(container, offset) {
			var node = container, targetOffset = 0, dataLen;
	
			while (isText(node)) {
				dataLen = node.data.length;
	
				if (offset >= targetOffset && offset <= targetOffset + dataLen) {
					container = node;
					offset = offset - targetOffset;
					break;
				}
	
				if (!isText(node.nextSibling)) {
					container = node;
					offset = dataLen;
					break;
				}
	
				targetOffset += dataLen;
				node = node.nextSibling;
			}
	
			if (offset > container.data.length) {
				offset = container.data.length;
			}
	
			return new CaretPosition(container, offset);
		}
	
		function resolve(rootNode, path) {
			var parts, container, offset;
	
			if (!path) {
				return null;
			}
	
			parts = path.split(',');
			path = parts[0].split('/');
			offset = parts.length > 1 ? parts[1] : 'before';
	
			container = Arr.reduce(path, function(result, value) {
				value = /([\w\-\(\)]+)\[([0-9]+)\]/.exec(value);
				if (!value) {
					return null;
				}
	
				if (value[1] === 'text()') {
					value[1] = '#text';
				}
	
				return resolvePathItem(result, value[1], parseInt(value[2], 10));
			}, rootNode);
	
			if (!container) {
				return null;
			}
	
			if (!isText(container)) {
				if (offset === 'after') {
					offset = nodeIndex(container) + 1;
				} else {
					offset = nodeIndex(container);
				}
	
				return new CaretPosition(container.parentNode, offset);
			}
	
			return findTextPosition(container, parseInt(offset, 10));
		}
	
		return {
			/**
			 * Create a xpath bookmark location for the specified caret position.
			 *
			 * @method create
			 * @param {Node} rootNode Root node to create bookmark within.
			 * @param {tinymce.caret.CaretPosition} caretPosition Caret position within the root node.
			 * @return {String} String xpath like location of caret position.
			 */
			create: create,
	
			/**
			 * Resolves a xpath like bookmark location to the a caret position.
			 *
			 * @method resolve
			 * @param {Node} rootNode Root node to resolve xpath bookmark within.
			 * @param {String} bookmark Bookmark string to resolve.
			 * @return {tinymce.caret.CaretPosition} Caret position resolved from xpath like bookmark.
			 */
			resolve: resolve
		};
	});
	
	// Included from: js/tinymce/classes/dom/BookmarkManager.js
	
	/**
	 * BookmarkManager.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This class handles selection bookmarks.
	 *
	 * @class tinymce.dom.BookmarkManager
	 */
	define("tinymce/dom/BookmarkManager", [
		"tinymce/Env",
		"tinymce/util/Tools",
		"tinymce/caret/CaretContainer",
		"tinymce/caret/CaretBookmark",
		"tinymce/caret/CaretPosition",
		"tinymce/dom/NodeType",
		"tinymce/dom/RangeUtils"
	], function(Env, Tools, CaretContainer, CaretBookmark, CaretPosition, NodeType, RangeUtils) {
		var isContentEditableFalse = NodeType.isContentEditableFalse;
	
		/**
		 * Constructs a new BookmarkManager instance for a specific selection instance.
		 *
		 * @constructor
		 * @method BookmarkManager
		 * @param {tinymce.dom.Selection} selection Selection instance to handle bookmarks for.
		 */
		function BookmarkManager(selection) {
			var dom = selection.dom;
	
			/**
			 * Returns a bookmark location for the current selection. This bookmark object
			 * can then be used to restore the selection after some content modification to the document.
			 *
			 * @method getBookmark
			 * @param {Number} type Optional state if the bookmark should be simple or not. Default is complex.
			 * @param {Boolean} normalized Optional state that enables you to get a position that it would be after normalization.
			 * @return {Object} Bookmark object, use moveToBookmark with this object to restore the selection.
			 * @example
			 * // Stores a bookmark of the current selection
			 * var bm = tinymce.activeEditor.selection.getBookmark();
			 *
			 * tinymce.activeEditor.setContent(tinymce.activeEditor.getContent() + 'Some new content');
			 *
			 * // Restore the selection bookmark
			 * tinymce.activeEditor.selection.moveToBookmark(bm);
			 */
			this.getBookmark = function(type, normalized) {
				var rng, rng2, id, collapsed, name, element, chr = '&#xFEFF;', styles;
	
				function findIndex(name, element) {
					var count = 0;
	
					Tools.each(dom.select(name), function(node) {
						if (node.getAttribute('data-mce-bogus') === 'all') {
							return;
						}
	
						if (node == element) {
							return false;
						}
	
						count++;
					});
	
					return count;
				}
	
				function normalizeTableCellSelection(rng) {
					function moveEndPoint(start) {
						var container, offset, childNodes, prefix = start ? 'start' : 'end';
	
						container = rng[prefix + 'Container'];
						offset = rng[prefix + 'Offset'];
	
						if (container.nodeType == 1 && container.nodeName == "TR") {
							childNodes = container.childNodes;
							container = childNodes[Math.min(start ? offset : offset - 1, childNodes.length - 1)];
							if (container) {
								offset = start ? 0 : container.childNodes.length;
								rng['set' + (start ? 'Start' : 'End')](container, offset);
							}
						}
					}
	
					moveEndPoint(true);
					moveEndPoint();
	
					return rng;
				}
	
				function getLocation(rng) {
					var root = dom.getRoot(), bookmark = {};
	
					function getPoint(rng, start) {
						var container = rng[start ? 'startContainer' : 'endContainer'],
							offset = rng[start ? 'startOffset' : 'endOffset'], point = [], node, childNodes, after = 0;
	
						if (container.nodeType == 3) {
							if (normalized) {
								for (node = container.previousSibling; node && node.nodeType == 3; node = node.previousSibling) {
									offset += node.nodeValue.length;
								}
							}
	
							point.push(offset);
						} else {
							childNodes = container.childNodes;
	
							if (offset >= childNodes.length && childNodes.length) {
								after = 1;
								offset = Math.max(0, childNodes.length - 1);
							}
	
							point.push(dom.nodeIndex(childNodes[offset], normalized) + after);
						}
	
						for (; container && container != root; container = container.parentNode) {
							point.push(dom.nodeIndex(container, normalized));
						}
	
						return point;
					}
	
					bookmark.start = getPoint(rng, true);
	
					if (!selection.isCollapsed()) {
						bookmark.end = getPoint(rng);
					}
	
					return bookmark;
				}
	
				function findAdjacentContentEditableFalseElm(rng) {
					function findSibling(node, offset) {
						var sibling;
	
						if (NodeType.isElement(node)) {
							node = RangeUtils.getNode(node, offset);
							if (isContentEditableFalse(node)) {
								return node;
							}
						}
	
						if (CaretContainer.isCaretContainer(node)) {
							if (NodeType.isText(node) && CaretContainer.isCaretContainerBlock(node)) {
								node = node.parentNode;
							}
	
							sibling = node.previousSibling;
							if (isContentEditableFalse(sibling)) {
								return sibling;
							}
	
							sibling = node.nextSibling;
							if (isContentEditableFalse(sibling)) {
								return sibling;
							}
						}
					}
	
					return findSibling(rng.startContainer, rng.startOffset) || findSibling(rng.endContainer, rng.endOffset);
				}
	
				if (type == 2) {
					element = selection.getNode();
					name = element ? element.nodeName : null;
					rng = selection.getRng();
	
					if (isContentEditableFalse(element) || name == 'IMG') {
						return {name: name, index: findIndex(name, element)};
					}
	
					if (selection.tridentSel) {
						return selection.tridentSel.getBookmark(type);
					}
	
					element = findAdjacentContentEditableFalseElm(rng);
					if (element) {
						name = element.tagName;
						return {name: name, index: findIndex(name, element)};
					}
	
					return getLocation(rng);
				}
	
				if (type == 3) {
					rng = selection.getRng();
	
					return {
						start: CaretBookmark.create(dom.getRoot(), CaretPosition.fromRangeStart(rng)),
						end: CaretBookmark.create(dom.getRoot(), CaretPosition.fromRangeEnd(rng))
					};
				}
	
				// Handle simple range
				if (type) {
					return {rng: selection.getRng()};
				}
	
				rng = selection.getRng();
				id = dom.uniqueId();
				collapsed = selection.isCollapsed();
				styles = 'overflow:hidden;line-height:0px';
	
				// Explorer method
				if (rng.duplicate || rng.item) {
					// Text selection
					if (!rng.item) {
						rng2 = rng.duplicate();
	
						try {
							// Insert start marker
							rng.collapse();
							rng.pasteHTML('<span data-mce-type="bookmark" id="' + id + '_start" style="' + styles + '">' + chr + '</span>');
	
							// Insert end marker
							if (!collapsed) {
								rng2.collapse(false);
	
								// Detect the empty space after block elements in IE and move the
								// end back one character <p></p>] becomes <p>]</p>
								rng.moveToElementText(rng2.parentElement());
								if (rng.compareEndPoints('StartToEnd', rng2) === 0) {
									rng2.move('character', -1);
								}
	
								rng2.pasteHTML('<span data-mce-type="bookmark" id="' + id + '_end" style="' + styles + '">' + chr + '</span>');
							}
						} catch (ex) {
							// IE might throw unspecified error so lets ignore it
							return null;
						}
					} else {
						// Control selection
						element = rng.item(0);
						name = element.nodeName;
	
						return {name: name, index: findIndex(name, element)};
					}
				} else {
					element = selection.getNode();
					name = element.nodeName;
					if (name == 'IMG') {
						return {name: name, index: findIndex(name, element)};
					}
	
					// W3C method
					rng2 = normalizeTableCellSelection(rng.cloneRange());
	
					// Insert end marker
					if (!collapsed) {
						rng2.collapse(false);
						rng2.insertNode(dom.create('span', {'data-mce-type': "bookmark", id: id + '_end', style: styles}, chr));
					}
	
					rng = normalizeTableCellSelection(rng);
					rng.collapse(true);
					rng.insertNode(dom.create('span', {'data-mce-type': "bookmark", id: id + '_start', style: styles}, chr));
				}
	
				selection.moveToBookmark({id: id, keep: 1});
	
				return {id: id};
			};
	
			/**
			 * Restores the selection to the specified bookmark.
			 *
			 * @method moveToBookmark
			 * @param {Object} bookmark Bookmark to restore selection from.
			 * @return {Boolean} true/false if it was successful or not.
			 * @example
			 * // Stores a bookmark of the current selection
			 * var bm = tinymce.activeEditor.selection.getBookmark();
			 *
			 * tinymce.activeEditor.setContent(tinymce.activeEditor.getContent() + 'Some new content');
			 *
			 * // Restore the selection bookmark
			 * tinymce.activeEditor.selection.moveToBookmark(bm);
			 */
			this.moveToBookmark = function(bookmark) {
				var rng, root, startContainer, endContainer, startOffset, endOffset;
	
				function setEndPoint(start) {
					var point = bookmark[start ? 'start' : 'end'], i, node, offset, children;
	
					if (point) {
						offset = point[0];
	
						// Find container node
						for (node = root, i = point.length - 1; i >= 1; i--) {
							children = node.childNodes;
	
							if (point[i] > children.length - 1) {
								return;
							}
	
							node = children[point[i]];
						}
	
						// Move text offset to best suitable location
						if (node.nodeType === 3) {
							offset = Math.min(point[0], node.nodeValue.length);
						}
	
						// Move element offset to best suitable location
						if (node.nodeType === 1) {
							offset = Math.min(point[0], node.childNodes.length);
						}
	
						// Set offset within container node
						if (start) {
							rng.setStart(node, offset);
						} else {
							rng.setEnd(node, offset);
						}
					}
	
					return true;
				}
	
				function restoreEndPoint(suffix) {
					var marker = dom.get(bookmark.id + '_' + suffix), node, idx, next, prev, keep = bookmark.keep;
	
					if (marker) {
						node = marker.parentNode;
	
						if (suffix == 'start') {
							if (!keep) {
								idx = dom.nodeIndex(marker);
							} else {
								node = marker.firstChild;
								idx = 1;
							}
	
							startContainer = endContainer = node;
							startOffset = endOffset = idx;
						} else {
							if (!keep) {
								idx = dom.nodeIndex(marker);
							} else {
								node = marker.firstChild;
								idx = 1;
							}
	
							endContainer = node;
							endOffset = idx;
						}
	
						if (!keep) {
							prev = marker.previousSibling;
							next = marker.nextSibling;
	
							// Remove all marker text nodes
							Tools.each(Tools.grep(marker.childNodes), function(node) {
								if (node.nodeType == 3) {
									node.nodeValue = node.nodeValue.replace(/\uFEFF/g, '');
								}
							});
	
							// Remove marker but keep children if for example contents where inserted into the marker
							// Also remove duplicated instances of the marker for example by a
							// split operation or by WebKit auto split on paste feature
							while ((marker = dom.get(bookmark.id + '_' + suffix))) {
								dom.remove(marker, 1);
							}
	
							// If siblings are text nodes then merge them unless it's Opera since it some how removes the node
							// and we are sniffing since adding a lot of detection code for a browser with 3% of the market
							// isn't worth the effort. Sorry, Opera but it's just a fact
							if (prev && next && prev.nodeType == next.nodeType && prev.nodeType == 3 && !Env.opera) {
								idx = prev.nodeValue.length;
								prev.appendData(next.nodeValue);
								dom.remove(next);
	
								if (suffix == 'start') {
									startContainer = endContainer = prev;
									startOffset = endOffset = idx;
								} else {
									endContainer = prev;
									endOffset = idx;
								}
							}
						}
					}
				}
	
				function addBogus(node) {
					// Adds a bogus BR element for empty block elements
					if (dom.isBlock(node) && !node.innerHTML && !Env.ie) {
						node.innerHTML = '<br data-mce-bogus="1" />';
					}
	
					return node;
				}
	
				function resolveCaretPositionBookmark() {
					var rng, pos;
	
					rng = dom.createRng();
					pos = CaretBookmark.resolve(dom.getRoot(), bookmark.start);
					rng.setStart(pos.container(), pos.offset());
	
					pos = CaretBookmark.resolve(dom.getRoot(), bookmark.end);
					rng.setEnd(pos.container(), pos.offset());
	
					return rng;
				}
	
				if (bookmark) {
					if (Tools.isArray(bookmark.start)) {
						rng = dom.createRng();
						root = dom.getRoot();
	
						if (selection.tridentSel) {
							return selection.tridentSel.moveToBookmark(bookmark);
						}
	
						if (setEndPoint(true) && setEndPoint()) {
							selection.setRng(rng);
						}
					} else if (typeof bookmark.start == 'string') {
						selection.setRng(resolveCaretPositionBookmark(bookmark));
					} else if (bookmark.id) {
						// Restore start/end points
						restoreEndPoint('start');
						restoreEndPoint('end');
	
						if (startContainer) {
							rng = dom.createRng();
							rng.setStart(addBogus(startContainer), startOffset);
							rng.setEnd(addBogus(endContainer), endOffset);
							selection.setRng(rng);
						}
					} else if (bookmark.name) {
						selection.select(dom.select(bookmark.name)[bookmark.index]);
					} else if (bookmark.rng) {
						selection.setRng(bookmark.rng);
					}
				}
			};
		}
	
		/**
		 * Returns true/false if the specified node is a bookmark node or not.
		 *
		 * @static
		 * @method isBookmarkNode
		 * @param {DOMNode} node DOM Node to check if it's a bookmark node or not.
		 * @return {Boolean} true/false if the node is a bookmark node or not.
		 */
		BookmarkManager.isBookmarkNode = function(node) {
			return node && node.tagName === 'SPAN' && node.getAttribute('data-mce-type') === 'bookmark';
		};
	
		return BookmarkManager;
	});
	
	// Included from: js/tinymce/classes/dom/Selection.js
	
	/**
	 * Selection.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This class handles text and control selection it's an crossbrowser utility class.
	 * Consult the TinyMCE Wiki API for more details and examples on how to use this class.
	 *
	 * @class tinymce.dom.Selection
	 * @example
	 * // Getting the currently selected node for the active editor
	 * alert(tinymce.activeEditor.selection.getNode().nodeName);
	 */
	define("tinymce/dom/Selection", [
		"tinymce/dom/TreeWalker",
		"tinymce/dom/TridentSelection",
		"tinymce/dom/ControlSelection",
		"tinymce/dom/RangeUtils",
		"tinymce/dom/BookmarkManager",
		"tinymce/dom/NodeType",
		"tinymce/Env",
		"tinymce/util/Tools",
		"tinymce/caret/CaretPosition"
	], function(TreeWalker, TridentSelection, ControlSelection, RangeUtils, BookmarkManager, NodeType, Env, Tools, CaretPosition) {
		var each = Tools.each, trim = Tools.trim;
		var isIE = Env.ie;
	
		/**
		 * Constructs a new selection instance.
		 *
		 * @constructor
		 * @method Selection
		 * @param {tinymce.dom.DOMUtils} dom DOMUtils object reference.
		 * @param {Window} win Window to bind the selection object to.
		 * @param {tinymce.Editor} editor Editor instance of the selection.
		 * @param {tinymce.dom.Serializer} serializer DOM serialization class to use for getContent.
		 */
		function Selection(dom, win, serializer, editor) {
			var self = this;
	
			self.dom = dom;
			self.win = win;
			self.serializer = serializer;
			self.editor = editor;
			self.bookmarkManager = new BookmarkManager(self);
			self.controlSelection = new ControlSelection(self, editor);
	
			// No W3C Range support
			if (!self.win.getSelection) {
				self.tridentSel = new TridentSelection(self);
			}
		}
	
		Selection.prototype = {
			/**
			 * Move the selection cursor range to the specified node and offset.
			 * If there is no node specified it will move it to the first suitable location within the body.
			 *
			 * @method setCursorLocation
			 * @param {Node} node Optional node to put the cursor in.
			 * @param {Number} offset Optional offset from the start of the node to put the cursor at.
			 */
			setCursorLocation: function(node, offset) {
				var self = this, rng = self.dom.createRng();
	
				if (!node) {
					self._moveEndPoint(rng, self.editor.getBody(), true);
					self.setRng(rng);
				} else {
					rng.setStart(node, offset);
					rng.setEnd(node, offset);
					self.setRng(rng);
					self.collapse(false);
				}
			},
	
			/**
			 * Returns the selected contents using the DOM serializer passed in to this class.
			 *
			 * @method getContent
			 * @param {Object} args Optional settings class with for example output format text or html.
			 * @return {String} Selected contents in for example HTML format.
			 * @example
			 * // Alerts the currently selected contents
			 * alert(tinymce.activeEditor.selection.getContent());
			 *
			 * // Alerts the currently selected contents as plain text
			 * alert(tinymce.activeEditor.selection.getContent({format: 'text'}));
			 */
			getContent: function(args) {
				var self = this, rng = self.getRng(), tmpElm = self.dom.create("body");
				var se = self.getSel(), whiteSpaceBefore, whiteSpaceAfter, fragment;
	
				args = args || {};
				whiteSpaceBefore = whiteSpaceAfter = '';
				args.get = true;
				args.format = args.format || 'html';
				args.selection = true;
				self.editor.fire('BeforeGetContent', args);
	
				if (args.format == 'text') {
					return self.isCollapsed() ? '' : (rng.text || (se.toString ? se.toString() : ''));
				}
	
				if (rng.cloneContents) {
					fragment = rng.cloneContents();
	
					if (fragment) {
						tmpElm.appendChild(fragment);
					}
				} else if (rng.item !== undefined || rng.htmlText !== undefined) {
					// IE will produce invalid markup if elements are present that
					// it doesn't understand like custom elements or HTML5 elements.
					// Adding a BR in front of the contents and then remoiving it seems to fix it though.
					tmpElm.innerHTML = '<br>' + (rng.item ? rng.item(0).outerHTML : rng.htmlText);
					tmpElm.removeChild(tmpElm.firstChild);
				} else {
					tmpElm.innerHTML = rng.toString();
				}
	
				// Keep whitespace before and after
				if (/^\s/.test(tmpElm.innerHTML)) {
					whiteSpaceBefore = ' ';
				}
	
				if (/\s+$/.test(tmpElm.innerHTML)) {
					whiteSpaceAfter = ' ';
				}
	
				args.getInner = true;
	
				args.content = self.isCollapsed() ? '' : whiteSpaceBefore + self.serializer.serialize(tmpElm, args) + whiteSpaceAfter;
				self.editor.fire('GetContent', args);
	
				return args.content;
			},
	
			/**
			 * Sets the current selection to the specified content. If any contents is selected it will be replaced
			 * with the contents passed in to this function. If there is no selection the contents will be inserted
			 * where the caret is placed in the editor/page.
			 *
			 * @method setContent
			 * @param {String} content HTML contents to set could also be other formats depending on settings.
			 * @param {Object} args Optional settings object with for example data format.
			 * @example
			 * // Inserts some HTML contents at the current selection
			 * tinymce.activeEditor.selection.setContent('<strong>Some contents</strong>');
			 */
			setContent: function(content, args) {
				var self = this, rng = self.getRng(), caretNode, doc = self.win.document, frag, temp;
	
				args = args || {format: 'html'};
				args.set = true;
				args.selection = true;
				args.content = content;
	
				// Dispatch before set content event
				if (!args.no_events) {
					self.editor.fire('BeforeSetContent', args);
				}
	
				content = args.content;
	
				if (rng.insertNode) {
					// Make caret marker since insertNode places the caret in the beginning of text after insert
					content += '<span id="__caret">_</span>';
	
					// Delete and insert new node
					if (rng.startContainer == doc && rng.endContainer == doc) {
						// WebKit will fail if the body is empty since the range is then invalid and it can't insert contents
						doc.body.innerHTML = content;
					} else {
						rng.deleteContents();
	
						if (doc.body.childNodes.length === 0) {
							doc.body.innerHTML = content;
						} else {
							// createContextualFragment doesn't exists in IE 9 DOMRanges
							if (rng.createContextualFragment) {
								rng.insertNode(rng.createContextualFragment(content));
							} else {
								// Fake createContextualFragment call in IE 9
								frag = doc.createDocumentFragment();
								temp = doc.createElement('div');
	
								frag.appendChild(temp);
								temp.outerHTML = content;
	
								rng.insertNode(frag);
							}
						}
					}
	
					// Move to caret marker
					caretNode = self.dom.get('__caret');
	
					// Make sure we wrap it compleatly, Opera fails with a simple select call
					rng = doc.createRange();
					rng.setStartBefore(caretNode);
					rng.setEndBefore(caretNode);
					self.setRng(rng);
	
					// Remove the caret position
					self.dom.remove('__caret');
	
					try {
						self.setRng(rng);
					} catch (ex) {
						// Might fail on Opera for some odd reason
					}
				} else {
					if (rng.item) {
						// Delete content and get caret text selection
						doc.execCommand('Delete', false, null);
						rng = self.getRng();
					}
	
					// Explorer removes spaces from the beginning of pasted contents
					if (/^\s+/.test(content)) {
						rng.pasteHTML('<span id="__mce_tmp">_</span>' + content);
						self.dom.remove('__mce_tmp');
					} else {
						rng.pasteHTML(content);
					}
				}
	
				// Dispatch set content event
				if (!args.no_events) {
					self.editor.fire('SetContent', args);
				}
			},
	
			/**
			 * Returns the start element of a selection range. If the start is in a text
			 * node the parent element will be returned.
			 *
			 * @method getStart
			 * @param {Boolean} real Optional state to get the real parent when the selection is collapsed not the closest element.
			 * @return {Element} Start element of selection range.
			 */
			getStart: function(real) {
				var self = this, rng = self.getRng(), startElement, parentElement, checkRng, node;
	
				if (rng.duplicate || rng.item) {
					// Control selection, return first item
					if (rng.item) {
						return rng.item(0);
					}
	
					// Get start element
					checkRng = rng.duplicate();
					checkRng.collapse(1);
					startElement = checkRng.parentElement();
					if (startElement.ownerDocument !== self.dom.doc) {
						startElement = self.dom.getRoot();
					}
	
					// Check if range parent is inside the start element, then return the inner parent element
					// This will fix issues when a single element is selected, IE would otherwise return the wrong start element
					parentElement = node = rng.parentElement();
					while ((node = node.parentNode)) {
						if (node == startElement) {
							startElement = parentElement;
							break;
						}
					}
	
					return startElement;
				}
	
				startElement = rng.startContainer;
	
				if (startElement.nodeType == 1 && startElement.hasChildNodes()) {
					if (!real || !rng.collapsed) {
						startElement = startElement.childNodes[Math.min(startElement.childNodes.length - 1, rng.startOffset)];
					}
				}
	
				if (startElement && startElement.nodeType == 3) {
					return startElement.parentNode;
				}
	
				return startElement;
			},
	
			/**
			 * Returns the end element of a selection range. If the end is in a text
			 * node the parent element will be returned.
			 *
			 * @method getEnd
			 * @param {Boolean} real Optional state to get the real parent when the selection is collapsed not the closest element.
			 * @return {Element} End element of selection range.
			 */
			getEnd: function(real) {
				var self = this, rng = self.getRng(), endElement, endOffset;
	
				if (rng.duplicate || rng.item) {
					if (rng.item) {
						return rng.item(0);
					}
	
					rng = rng.duplicate();
					rng.collapse(0);
					endElement = rng.parentElement();
					if (endElement.ownerDocument !== self.dom.doc) {
						endElement = self.dom.getRoot();
					}
	
					if (endElement && endElement.nodeName == 'BODY') {
						return endElement.lastChild || endElement;
					}
	
					return endElement;
				}
	
				endElement = rng.endContainer;
				endOffset = rng.endOffset;
	
				if (endElement.nodeType == 1 && endElement.hasChildNodes()) {
					if (!real || !rng.collapsed) {
						endElement = endElement.childNodes[endOffset > 0 ? endOffset - 1 : endOffset];
					}
				}
	
				if (endElement && endElement.nodeType == 3) {
					return endElement.parentNode;
				}
	
				return endElement;
			},
	
			/**
			 * Returns a bookmark location for the current selection. This bookmark object
			 * can then be used to restore the selection after some content modification to the document.
			 *
			 * @method getBookmark
			 * @param {Number} type Optional state if the bookmark should be simple or not. Default is complex.
			 * @param {Boolean} normalized Optional state that enables you to get a position that it would be after normalization.
			 * @return {Object} Bookmark object, use moveToBookmark with this object to restore the selection.
			 * @example
			 * // Stores a bookmark of the current selection
			 * var bm = tinymce.activeEditor.selection.getBookmark();
			 *
			 * tinymce.activeEditor.setContent(tinymce.activeEditor.getContent() + 'Some new content');
			 *
			 * // Restore the selection bookmark
			 * tinymce.activeEditor.selection.moveToBookmark(bm);
			 */
			getBookmark: function(type, normalized) {
				return this.bookmarkManager.getBookmark(type, normalized);
			},
	
			/**
			 * Restores the selection to the specified bookmark.
			 *
			 * @method moveToBookmark
			 * @param {Object} bookmark Bookmark to restore selection from.
			 * @return {Boolean} true/false if it was successful or not.
			 * @example
			 * // Stores a bookmark of the current selection
			 * var bm = tinymce.activeEditor.selection.getBookmark();
			 *
			 * tinymce.activeEditor.setContent(tinymce.activeEditor.getContent() + 'Some new content');
			 *
			 * // Restore the selection bookmark
			 * tinymce.activeEditor.selection.moveToBookmark(bm);
			 */
			moveToBookmark: function(bookmark) {
				return this.bookmarkManager.moveToBookmark(bookmark);
			},
	
			/**
			 * Selects the specified element. This will place the start and end of the selection range around the element.
			 *
			 * @method select
			 * @param {Element} node HTML DOM element to select.
			 * @param {Boolean} content Optional bool state if the contents should be selected or not on non IE browser.
			 * @return {Element} Selected element the same element as the one that got passed in.
			 * @example
			 * // Select the first paragraph in the active editor
			 * tinymce.activeEditor.selection.select(tinymce.activeEditor.dom.select('p')[0]);
			 */
			select: function(node, content) {
				var self = this, dom = self.dom, rng = dom.createRng(), idx;
	
				// Clear stored range set by FocusManager
				self.lastFocusBookmark = null;
	
				if (node) {
					if (!content && self.controlSelection.controlSelect(node)) {
						return;
					}
	
					idx = dom.nodeIndex(node);
					rng.setStart(node.parentNode, idx);
					rng.setEnd(node.parentNode, idx + 1);
	
					// Find first/last text node or BR element
					if (content) {
						self._moveEndPoint(rng, node, true);
						self._moveEndPoint(rng, node);
					}
	
					self.setRng(rng);
				}
	
				return node;
			},
	
			/**
			 * Returns true/false if the selection range is collapsed or not. Collapsed means if it's a caret or a larger selection.
			 *
			 * @method isCollapsed
			 * @return {Boolean} true/false state if the selection range is collapsed or not.
			 * Collapsed means if it's a caret or a larger selection.
			 */
			isCollapsed: function() {
				var self = this, rng = self.getRng(), sel = self.getSel();
	
				if (!rng || rng.item) {
					return false;
				}
	
				if (rng.compareEndPoints) {
					return rng.compareEndPoints('StartToEnd', rng) === 0;
				}
	
				return !sel || rng.collapsed;
			},
	
			/**
			 * Collapse the selection to start or end of range.
			 *
			 * @method collapse
			 * @param {Boolean} toStart Optional boolean state if to collapse to end or not. Defaults to false.
			 */
			collapse: function(toStart) {
				var self = this, rng = self.getRng(), node;
	
				// Control range on IE
				if (rng.item) {
					node = rng.item(0);
					rng = self.win.document.body.createTextRange();
					rng.moveToElementText(node);
				}
	
				rng.collapse(!!toStart);
				self.setRng(rng);
			},
	
			/**
			 * Returns the browsers internal selection object.
			 *
			 * @method getSel
			 * @return {Selection} Internal browser selection object.
			 */
			getSel: function() {
				var win = this.win;
	
				return win.getSelection ? win.getSelection() : win.document.selection;
			},
	
			/**
			 * Returns the browsers internal range object.
			 *
			 * @method getRng
			 * @param {Boolean} w3c Forces a compatible W3C range on IE.
			 * @return {Range} Internal browser range object.
			 * @see http://www.quirksmode.org/dom/range_intro.html
			 * @see http://www.dotvoid.com/2001/03/using-the-range-object-in-mozilla/
			 */
			getRng: function(w3c) {
				var self = this, selection, rng, elm, doc, ieRng, evt;
	
				function tryCompareBoundaryPoints(how, sourceRange, destinationRange) {
					try {
						return sourceRange.compareBoundaryPoints(how, destinationRange);
					} catch (ex) {
						// Gecko throws wrong document exception if the range points
						// to nodes that where removed from the dom #6690
						// Browsers should mutate existing DOMRange instances so that they always point
						// to something in the document this is not the case in Gecko works fine in IE/WebKit/Blink
						// For performance reasons just return -1
						return -1;
					}
				}
	
				if (!self.win) {
					return null;
				}
	
				doc = self.win.document;
	
				if (typeof doc === 'undefined' || doc === null) {
					return null;
				}
	
				// Use last rng passed from FocusManager if it's available this enables
				// calls to editor.selection.getStart() to work when caret focus is lost on IE
				if (!w3c && self.lastFocusBookmark) {
					var bookmark = self.lastFocusBookmark;
	
					// Convert bookmark to range IE 11 fix
					if (bookmark.startContainer) {
						rng = doc.createRange();
						rng.setStart(bookmark.startContainer, bookmark.startOffset);
						rng.setEnd(bookmark.endContainer, bookmark.endOffset);
					} else {
						rng = bookmark;
					}
	
					return rng;
				}
	
				// Found tridentSel object then we need to use that one
				if (w3c && self.tridentSel) {
					return self.tridentSel.getRangeAt(0);
				}
	
				try {
					if ((selection = self.getSel())) {
						if (selection.rangeCount > 0) {
							rng = selection.getRangeAt(0);
						} else {
							rng = selection.createRange ? selection.createRange() : doc.createRange();
						}
					}
				} catch (ex) {
					// IE throws unspecified error here if TinyMCE is placed in a frame/iframe
				}
	
				evt = self.editor.fire('GetSelectionRange', {range: rng});
				if (evt.range !== rng) {
					return evt.range;
				}
	
				// We have W3C ranges and it's IE then fake control selection since IE9 doesn't handle that correctly yet
				// IE 11 doesn't support the selection object so we check for that as well
				if (isIE && rng && rng.setStart && doc.selection) {
					try {
						// IE will sometimes throw an exception here
						ieRng = doc.selection.createRange();
					} catch (ex) {
						// Ignore
					}
	
					if (ieRng && ieRng.item) {
						elm = ieRng.item(0);
						rng = doc.createRange();
						rng.setStartBefore(elm);
						rng.setEndAfter(elm);
					}
				}
	
				// No range found then create an empty one
				// This can occur when the editor is placed in a hidden container element on Gecko
				// Or on IE when there was an exception
				if (!rng) {
					rng = doc.createRange ? doc.createRange() : doc.body.createTextRange();
				}
	
				// If range is at start of document then move it to start of body
				if (rng.setStart && rng.startContainer.nodeType === 9 && rng.collapsed) {
					elm = self.dom.getRoot();
					rng.setStart(elm, 0);
					rng.setEnd(elm, 0);
				}
	
				if (self.selectedRange && self.explicitRange) {
					if (tryCompareBoundaryPoints(rng.START_TO_START, rng, self.selectedRange) === 0 &&
						tryCompareBoundaryPoints(rng.END_TO_END, rng, self.selectedRange) === 0) {
						// Safari, Opera and Chrome only ever select text which causes the range to change.
						// This lets us use the originally set range if the selection hasn't been changed by the user.
						rng = self.explicitRange;
					} else {
						self.selectedRange = null;
						self.explicitRange = null;
					}
				}
	
				return rng;
			},
	
			/**
			 * Changes the selection to the specified DOM range.
			 *
			 * @method setRng
			 * @param {Range} rng Range to select.
			 * @param {Boolean} forward Optional boolean if the selection is forwards or backwards.
			 */
			setRng: function(rng, forward) {
				var self = this, sel, node, evt;
	
				if (!rng) {
					return;
				}
	
				// Is IE specific range
				if (rng.select) {
					self.explicitRange = null;
	
					try {
						rng.select();
					} catch (ex) {
						// Needed for some odd IE bug #1843306
					}
	
					return;
				}
	
				if (!self.tridentSel) {
					sel = self.getSel();
	
					evt = self.editor.fire('SetSelectionRange', {range: rng});
					rng = evt.range;
	
					if (sel) {
						self.explicitRange = rng;
	
						try {
							sel.removeAllRanges();
							sel.addRange(rng);
						} catch (ex) {
							// IE might throw errors here if the editor is within a hidden container and selection is changed
						}
	
						// Forward is set to false and we have an extend function
						if (forward === false && sel.extend) {
							sel.collapse(rng.endContainer, rng.endOffset);
							sel.extend(rng.startContainer, rng.startOffset);
						}
	
						// adding range isn't always successful so we need to check range count otherwise an exception can occur
						self.selectedRange = sel.rangeCount > 0 ? sel.getRangeAt(0) : null;
					}
	
					// WebKit egde case selecting images works better using setBaseAndExtent
					if (!rng.collapsed && rng.startContainer == rng.endContainer && sel.setBaseAndExtent && !Env.ie) {
						if (rng.endOffset - rng.startOffset < 2) {
							if (rng.startContainer.hasChildNodes()) {
								node = rng.startContainer.childNodes[rng.startOffset];
								if (node && node.tagName == 'IMG') {
									self.getSel().setBaseAndExtent(node, 0, node, 1);
								}
							}
						}
					}
	
					self.editor.fire('AfterSetSelectionRange', {range: rng});
				} else {
					// Is W3C Range fake range on IE
					if (rng.cloneRange) {
						try {
							self.tridentSel.addRange(rng);
						} catch (ex) {
							//IE9 throws an error here if called before selection is placed in the editor
						}
					}
				}
			},
	
			/**
			 * Sets the current selection to the specified DOM element.
			 *
			 * @method setNode
			 * @param {Element} elm Element to set as the contents of the selection.
			 * @return {Element} Returns the element that got passed in.
			 * @example
			 * // Inserts a DOM node at current selection/caret location
			 * tinymce.activeEditor.selection.setNode(tinymce.activeEditor.dom.create('img', {src: 'some.gif', title: 'some title'}));
			 */
			setNode: function(elm) {
				var self = this;
	
				self.setContent(self.dom.getOuterHTML(elm));
	
				return elm;
			},
	
			/**
			 * Returns the currently selected element or the common ancestor element for both start and end of the selection.
			 *
			 * @method getNode
			 * @return {Element} Currently selected element or common ancestor element.
			 * @example
			 * // Alerts the currently selected elements node name
			 * alert(tinymce.activeEditor.selection.getNode().nodeName);
			 */
			getNode: function() {
				var self = this, rng = self.getRng(), elm;
				var startContainer, endContainer, startOffset, endOffset, root = self.dom.getRoot();
	
				function skipEmptyTextNodes(node, forwards) {
					var orig = node;
	
					while (node && node.nodeType === 3 && node.length === 0) {
						node = forwards ? node.nextSibling : node.previousSibling;
					}
	
					return node || orig;
				}
	
				// Range maybe lost after the editor is made visible again
				if (!rng) {
					return root;
				}
	
				startContainer = rng.startContainer;
				endContainer = rng.endContainer;
				startOffset = rng.startOffset;
				endOffset = rng.endOffset;
	
				if (rng.setStart) {
					elm = rng.commonAncestorContainer;
	
					// Handle selection a image or other control like element such as anchors
					if (!rng.collapsed) {
						if (startContainer == endContainer) {
							if (endOffset - startOffset < 2) {
								if (startContainer.hasChildNodes()) {
									elm = startContainer.childNodes[startOffset];
								}
							}
						}
	
						// If the anchor node is a element instead of a text node then return this element
						//if (tinymce.isWebKit && sel.anchorNode && sel.anchorNode.nodeType == 1)
						//	return sel.anchorNode.childNodes[sel.anchorOffset];
	
						// Handle cases where the selection is immediately wrapped around a node and return that node instead of it's parent.
						// This happens when you double click an underlined word in FireFox.
						if (startContainer.nodeType === 3 && endContainer.nodeType === 3) {
							if (startContainer.length === startOffset) {
								startContainer = skipEmptyTextNodes(startContainer.nextSibling, true);
							} else {
								startContainer = startContainer.parentNode;
							}
	
							if (endOffset === 0) {
								endContainer = skipEmptyTextNodes(endContainer.previousSibling, false);
							} else {
								endContainer = endContainer.parentNode;
							}
	
							if (startContainer && startContainer === endContainer) {
								return startContainer;
							}
						}
					}
	
					if (elm && elm.nodeType == 3) {
						return elm.parentNode;
					}
	
					return elm;
				}
	
				elm = rng.item ? rng.item(0) : rng.parentElement();
	
				// IE 7 might return elements outside the iframe
				if (elm.ownerDocument !== self.win.document) {
					elm = root;
				}
	
				return elm;
			},
	
			getSelectedBlocks: function(startElm, endElm) {
				var self = this, dom = self.dom, node, root, selectedBlocks = [];
	
				root = dom.getRoot();
				startElm = dom.getParent(startElm || self.getStart(), dom.isBlock);
				endElm = dom.getParent(endElm || self.getEnd(), dom.isBlock);
	
				if (startElm && startElm != root) {
					selectedBlocks.push(startElm);
				}
	
				if (startElm && endElm && startElm != endElm) {
					node = startElm;
	
					var walker = new TreeWalker(startElm, root);
					while ((node = walker.next()) && node != endElm) {
						if (dom.isBlock(node)) {
							selectedBlocks.push(node);
						}
					}
				}
	
				if (endElm && startElm != endElm && endElm != root) {
					selectedBlocks.push(endElm);
				}
	
				return selectedBlocks;
			},
	
			isForward: function() {
				var dom = this.dom, sel = this.getSel(), anchorRange, focusRange;
	
				// No support for selection direction then always return true
				if (!sel || !sel.anchorNode || !sel.focusNode) {
					return true;
				}
	
				anchorRange = dom.createRng();
				anchorRange.setStart(sel.anchorNode, sel.anchorOffset);
				anchorRange.collapse(true);
	
				focusRange = dom.createRng();
				focusRange.setStart(sel.focusNode, sel.focusOffset);
				focusRange.collapse(true);
	
				return anchorRange.compareBoundaryPoints(anchorRange.START_TO_START, focusRange) <= 0;
			},
	
			normalize: function() {
				var self = this, rng = self.getRng();
	
				if (Env.range && new RangeUtils(self.dom).normalize(rng)) {
					self.setRng(rng, self.isForward());
				}
	
				return rng;
			},
	
			/**
			 * Executes callback when the current selection starts/stops matching the specified selector. The current
			 * state will be passed to the callback as it's first argument.
			 *
			 * @method selectorChanged
			 * @param {String} selector CSS selector to check for.
			 * @param {function} callback Callback with state and args when the selector is matches or not.
			 */
			selectorChanged: function(selector, callback) {
				var self = this, currentSelectors;
	
				if (!self.selectorChangedData) {
					self.selectorChangedData = {};
					currentSelectors = {};
	
					self.editor.on('NodeChange', function(e) {
						var node = e.element, dom = self.dom, parents = dom.getParents(node, null, dom.getRoot()), matchedSelectors = {};
	
						// Check for new matching selectors
						each(self.selectorChangedData, function(callbacks, selector) {
							each(parents, function(node) {
								if (dom.is(node, selector)) {
									if (!currentSelectors[selector]) {
										// Execute callbacks
										each(callbacks, function(callback) {
											callback(true, {node: node, selector: selector, parents: parents});
										});
	
										currentSelectors[selector] = callbacks;
									}
	
									matchedSelectors[selector] = callbacks;
									return false;
								}
							});
						});
	
						// Check if current selectors still match
						each(currentSelectors, function(callbacks, selector) {
							if (!matchedSelectors[selector]) {
								delete currentSelectors[selector];
	
								each(callbacks, function(callback) {
									callback(false, {node: node, selector: selector, parents: parents});
								});
							}
						});
					});
				}
	
				// Add selector listeners
				if (!self.selectorChangedData[selector]) {
					self.selectorChangedData[selector] = [];
				}
	
				self.selectorChangedData[selector].push(callback);
	
				return self;
			},
	
			getScrollContainer: function() {
				var scrollContainer, node = this.dom.getRoot();
	
				while (node && node.nodeName != 'BODY') {
					if (node.scrollHeight > node.clientHeight) {
						scrollContainer = node;
						break;
					}
	
					node = node.parentNode;
				}
	
				return scrollContainer;
			},
	
			scrollIntoView: function(elm, alignToTop) {
				var y, viewPort, self = this, dom = self.dom, root = dom.getRoot(), viewPortY, viewPortH, offsetY = 0;
	
				function getPos(elm) {
					var x = 0, y = 0;
	
					var offsetParent = elm;
					while (offsetParent && offsetParent.nodeType) {
						x += offsetParent.offsetLeft || 0;
						y += offsetParent.offsetTop || 0;
						offsetParent = offsetParent.offsetParent;
					}
	
					return {x: x, y: y};
				}
	
				if (!NodeType.isElement(elm)) {
					return;
				}
	
				if (alignToTop === false) {
					offsetY = elm.offsetHeight;
				}
	
				if (root.nodeName != 'BODY') {
					var scrollContainer = self.getScrollContainer();
					if (scrollContainer) {
						y = getPos(elm).y - getPos(scrollContainer).y + offsetY;
						viewPortH = scrollContainer.clientHeight;
						viewPortY = scrollContainer.scrollTop;
						if (y < viewPortY || y + 25 > viewPortY + viewPortH) {
							scrollContainer.scrollTop = y < viewPortY ? y : y - viewPortH + 25;
						}
	
						return;
					}
				}
	
				viewPort = dom.getViewPort(self.editor.getWin());
				y = dom.getPos(elm).y + offsetY;
				viewPortY = viewPort.y;
				viewPortH = viewPort.h;
				if (y < viewPort.y || y + 25 > viewPortY + viewPortH) {
					self.editor.getWin().scrollTo(0, y < viewPortY ? y : y - viewPortH + 25);
				}
			},
	
			placeCaretAt: function(clientX, clientY) {
				this.setRng(RangeUtils.getCaretRangeFromPoint(clientX, clientY, this.editor.getDoc()));
			},
	
			_moveEndPoint: function(rng, node, start) {
				var root = node, walker = new TreeWalker(node, root);
				var nonEmptyElementsMap = this.dom.schema.getNonEmptyElements();
	
				do {
					// Text node
					if (node.nodeType == 3 && trim(node.nodeValue).length !== 0) {
						if (start) {
							rng.setStart(node, 0);
						} else {
							rng.setEnd(node, node.nodeValue.length);
						}
	
						return;
					}
	
					// BR/IMG/INPUT elements but not table cells
					if (nonEmptyElementsMap[node.nodeName] && !/^(TD|TH)$/.test(node.nodeName)) {
						if (start) {
							rng.setStartBefore(node);
						} else {
							if (node.nodeName == 'BR') {
								rng.setEndBefore(node);
							} else {
								rng.setEndAfter(node);
							}
						}
	
						return;
					}
	
					// Found empty text block old IE can place the selection inside those
					if (Env.ie && Env.ie < 11 && this.dom.isBlock(node) && this.dom.isEmpty(node)) {
						if (start) {
							rng.setStart(node, 0);
						} else {
							rng.setEnd(node, 0);
						}
	
						return;
					}
				} while ((node = (start ? walker.next() : walker.prev())));
	
				// Failed to find any text node or other suitable location then move to the root of body
				if (root.nodeName == 'BODY') {
					if (start) {
						rng.setStart(root, 0);
					} else {
						rng.setEnd(root, root.childNodes.length);
					}
				}
			},
	
			getBoundingClientRect:  function() {
				var rng = this.getRng();
				return rng.collapsed ? CaretPosition.fromRangeStart(rng).getClientRects()[0] : rng.getBoundingClientRect();
			},
	
			destroy: function() {
				this.win = null;
				this.controlSelection.destroy();
			}
		};
	
		return Selection;
	});
	
	// Included from: js/tinymce/classes/dom/ElementUtils.js
	
	/**
	 * ElementUtils.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Utility class for various element specific functions.
	 *
	 * @private
	 * @class tinymce.dom.ElementUtils
	 */
	define("tinymce/dom/ElementUtils", [
		"tinymce/dom/BookmarkManager",
		"tinymce/util/Tools"
	], function(BookmarkManager, Tools) {
		var each = Tools.each;
	
		function ElementUtils(dom) {
			/**
			 * Compares two nodes and checks if it's attributes and styles matches.
			 * This doesn't compare classes as items since their order is significant.
			 *
			 * @method compare
			 * @param {Node} node1 First node to compare with.
			 * @param {Node} node2 Second node to compare with.
			 * @return {boolean} True/false if the nodes are the same or not.
			 */
			this.compare = function(node1, node2) {
				// Not the same name
				if (node1.nodeName != node2.nodeName) {
					return false;
				}
	
				/**
				 * Returns all the nodes attributes excluding internal ones, styles and classes.
				 *
				 * @private
				 * @param {Node} node Node to get attributes from.
				 * @return {Object} Name/value object with attributes and attribute values.
				 */
				function getAttribs(node) {
					var attribs = {};
	
					each(dom.getAttribs(node), function(attr) {
						var name = attr.nodeName.toLowerCase();
	
						// Don't compare internal attributes or style
						if (name.indexOf('_') !== 0 && name !== 'style' && name.indexOf('data-') !== 0) {
							attribs[name] = dom.getAttrib(node, name);
						}
					});
	
					return attribs;
				}
	
				/**
				 * Compares two objects checks if it's key + value exists in the other one.
				 *
				 * @private
				 * @param {Object} obj1 First object to compare.
				 * @param {Object} obj2 Second object to compare.
				 * @return {boolean} True/false if the objects matches or not.
				 */
				function compareObjects(obj1, obj2) {
					var value, name;
	
					for (name in obj1) {
						// Obj1 has item obj2 doesn't have
						if (obj1.hasOwnProperty(name)) {
							value = obj2[name];
	
							// Obj2 doesn't have obj1 item
							if (typeof value == "undefined") {
								return false;
							}
	
							// Obj2 item has a different value
							if (obj1[name] != value) {
								return false;
							}
	
							// Delete similar value
							delete obj2[name];
						}
					}
	
					// Check if obj 2 has something obj 1 doesn't have
					for (name in obj2) {
						// Obj2 has item obj1 doesn't have
						if (obj2.hasOwnProperty(name)) {
							return false;
						}
					}
	
					return true;
				}
	
				// Attribs are not the same
				if (!compareObjects(getAttribs(node1), getAttribs(node2))) {
					return false;
				}
	
				// Styles are not the same
				if (!compareObjects(dom.parseStyle(dom.getAttrib(node1, 'style')), dom.parseStyle(dom.getAttrib(node2, 'style')))) {
					return false;
				}
	
				return !BookmarkManager.isBookmarkNode(node1) && !BookmarkManager.isBookmarkNode(node2);
			};
		}
	
		return ElementUtils;
	});
	
	// Included from: js/tinymce/classes/fmt/Preview.js
	
	/**
	 * Preview.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Internal class for generating previews styles for formats.
	 *
	 * Example:
	 *  Preview.getCssText(editor, 'bold');
	 *
	 * @private
	 * @class tinymce.fmt.Preview
	 */
	define("tinymce/fmt/Preview", [
		"tinymce/dom/DOMUtils",
		"tinymce/util/Tools",
		"tinymce/html/Schema"
	], function(DOMUtils, Tools, Schema) {
		var each = Tools.each;
		var dom = DOMUtils.DOM;
	
		function parsedSelectorToHtml(ancestry, editor) {
			var elm, item, fragment;
			var schema = editor && editor.schema || new Schema({});
	
			function decorate(elm, item) {
				if (item.classes.length) {
					dom.addClass(elm, item.classes.join(' '));
				}
				dom.setAttribs(elm, item.attrs);
			}
	
			function createElement(sItem) {
				var elm;
	
				item = typeof sItem === 'string' ? {
					name: sItem,
					classes: [],
					attrs: {}
				} : sItem;
	
				elm = dom.create(item.name);
				decorate(elm, item);
				return elm;
			}
	
			function getRequiredParent(elm, candidate) {
				var name = typeof elm !== 'string' ? elm.nodeName.toLowerCase() : elm;
				var elmRule = schema.getElementRule(name);
				var parentsRequired = elmRule.parentsRequired;
	
				if (parentsRequired && parentsRequired.length) {
					return candidate && Tools.inArray(parentsRequired, candidate) !== -1 ? candidate : parentsRequired[0];
				} else {
					return false;
				}
			}
	
			function wrapInHtml(elm, ancestry, siblings) {
				var parent, parentCandidate, parentRequired;
				var ancestor = ancestry.length && ancestry[0];
				var ancestorName = ancestor && ancestor.name;
	
				parentRequired = getRequiredParent(elm, ancestorName);
	
				if (parentRequired) {
					if (ancestorName == parentRequired) {
						parentCandidate = ancestry[0];
						ancestry = ancestry.slice(1);
					} else {
						parentCandidate = parentRequired;
					}
				} else if (ancestor) {
					parentCandidate = ancestry[0];
					ancestry = ancestry.slice(1);
				} else if (!siblings) {
					return elm;
				}
	
				if (parentCandidate) {
					parent = createElement(parentCandidate);
					parent.appendChild(elm);
				}
	
				if (siblings) {
					if (!parent) {
						// if no more ancestry, wrap in generic div
						parent = dom.create('div');
						parent.appendChild(elm);
					}
	
					Tools.each(siblings, function(sibling) {
						var siblingElm = createElement(sibling);
						parent.insertBefore(siblingElm, elm);
					});
				}
	
				return wrapInHtml(parent, ancestry, parentCandidate && parentCandidate.siblings);
			}
	
			if (ancestry && ancestry.length) {
				item = ancestry[0];
				elm = createElement(item);
				fragment = dom.create('div');
				fragment.appendChild(wrapInHtml(elm, ancestry.slice(1), item.siblings));
				return fragment;
			} else {
				return '';
			}
		}
	
	
		function selectorToHtml(selector, editor) {
			return parsedSelectorToHtml(parseSelector(selector, editor));
		}
	
	
		function parseSelectorItem(item) {
			var tagName;
			var obj = {
				classes: [],
				attrs: {}
			};
	
			item = obj.selector = Tools.trim(item);
	
			// matching IDs, CLASSes, ATTRIBUTES and PSEUDOs
			tagName = item.replace(/(?:([#\.]|::?)([\w\-]+)|(\[)([^\]]+)\]?)/g, function($0, $1, $2, $3, $4) {
				switch ($1) {
					case '#':
						obj.attrs.id = $2;
						break;
	
					case '.':
						obj.classes.push($2);
						break;
	
					case ':':
						if (Tools.inArray('checked disabled enabled read-only required'.split(' '), $2) !== -1) {
							obj.attrs[$2] = $2;
						}
						break;
				}
	
				// atribute matched
				if ($3 == '[') {
					var m = $4.match(/([\w\-]+)(?:\=\"([^\"]+))?/);
					if (m) {
						obj.attrs[m[1]] = m[2];
					}
				}
	
				return '';
			});
	
			obj.name = tagName || 'div';
			return obj;
		}
	
	
		function parseSelector(selector) {
			if (!selector || typeof selector !== 'string') {
				return [];
			}
	
			// take into account only first one
			selector = selector.split(/\s*,\s*/)[0];
	
			// tighten
			selector = selector.replace(/\s*(~\+|~|\+|>)\s*/g, '$1');
	
			// split either on > or on space, but not the one inside brackets
			return Tools.map(selector.split(/(?:>|\s+(?![^\[\]]+\]))/), function(item) {
				// process each sibling selector separately
				var siblings = Tools.map(item.split(/(?:~\+|~|\+)/), parseSelectorItem);
				var obj = siblings.pop(); // the last one is our real target
	
				if (siblings.length) {
					obj.siblings = siblings;
				}
				return obj;
			}).reverse();
		}
	
	
		function getCssText(editor, format) {
			var name, previewFrag, previewElm, items;
			var previewCss = '', parentFontSize, previewStyles;
	
			previewStyles = editor.settings.preview_styles;
	
			// No preview forced
			if (previewStyles === false) {
				return '';
			}
	
			// Default preview
			if (typeof previewStyles !== 'string') {
				previewStyles = 'font-family font-size font-weight font-style text-decoration ' +
					'text-transform color background-color border border-radius outline text-shadow';
			}
	
			// Removes any variables since these can't be previewed
			function removeVars(val) {
				return val.replace(/%(\w+)/g, '');
			}
	
			// Create block/inline element to use for preview
			if (typeof format == "string") {
				format = editor.formatter.get(format);
				if (!format) {
					return;
				}
	
				format = format[0];
			}
	
			// Format specific preview override
			// TODO: This should probably be further reduced by the previewStyles option
			if ('preview' in format) {
				previewStyles = format.preview;
				if (previewStyles === false) {
					return '';
				}
			}
	
			name = format.block || format.inline || 'span';
	
			items = parseSelector(format.selector);
			if (items.length) {
				if (!items[0].name) { // e.g. something like ul > .someClass was provided
					items[0].name = name;
				}
				name = format.selector;
				previewFrag = parsedSelectorToHtml(items);
			} else {
				previewFrag = parsedSelectorToHtml([name]);
			}
	
			previewElm = dom.select(name, previewFrag)[0] || previewFrag.firstChild;
	
			// Add format styles to preview element
			each(format.styles, function(value, name) {
				value = removeVars(value);
	
				if (value) {
					dom.setStyle(previewElm, name, value);
				}
			});
	
			// Add attributes to preview element
			each(format.attributes, function(value, name) {
				value = removeVars(value);
	
				if (value) {
					dom.setAttrib(previewElm, name, value);
				}
			});
	
			// Add classes to preview element
			each(format.classes, function(value) {
				value = removeVars(value);
	
				if (!dom.hasClass(previewElm, value)) {
					dom.addClass(previewElm, value);
				}
			});
	
			editor.fire('PreviewFormats');
	
			// Add the previewElm outside the visual area
			dom.setStyles(previewFrag, {position: 'absolute', left: -0xFFFF});
			editor.getBody().appendChild(previewFrag);
	
			// Get parent container font size so we can compute px values out of em/% for older IE:s
			parentFontSize = dom.getStyle(editor.getBody(), 'fontSize', true);
			parentFontSize = /px$/.test(parentFontSize) ? parseInt(parentFontSize, 10) : 0;
	
			each(previewStyles.split(' '), function(name) {
				var value = dom.getStyle(previewElm, name, true);
	
				// If background is transparent then check if the body has a background color we can use
				if (name == 'background-color' && /transparent|rgba\s*\([^)]+,\s*0\)/.test(value)) {
					value = dom.getStyle(editor.getBody(), name, true);
	
					// Ignore white since it's the default color, not the nicest fix
					// TODO: Fix this by detecting runtime style
					if (dom.toHex(value).toLowerCase() == '#ffffff') {
						return;
					}
				}
	
				if (name == 'color') {
					// Ignore black since it's the default color, not the nicest fix
					// TODO: Fix this by detecting runtime style
					if (dom.toHex(value).toLowerCase() == '#000000') {
						return;
					}
				}
	
				// Old IE won't calculate the font size so we need to do that manually
				if (name == 'font-size') {
					if (/em|%$/.test(value)) {
						if (parentFontSize === 0) {
							return;
						}
	
						// Convert font size from em/% to px
						value = parseFloat(value, 10) / (/%$/.test(value) ? 100 : 1);
						value = (value * parentFontSize) + 'px';
					}
				}
	
				if (name == "border" && value) {
					previewCss += 'padding:0 2px;';
				}
	
				previewCss += name + ':' + value + ';';
			});
	
			editor.fire('AfterPreviewFormats');
	
			//previewCss += 'line-height:normal';
	
			dom.remove(previewFrag);
	
			return previewCss;
		}
	
		return {
			getCssText: getCssText,
			parseSelector: parseSelector,
			selectorToHtml: selectorToHtml
		};
	});
	
	// Included from: js/tinymce/classes/fmt/Hooks.js
	
	/**
	 * Hooks.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2016 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Internal class for overriding formatting.
	 *
	 * @private
	 * @class tinymce.fmt.Hooks
	 */
	define("tinymce/fmt/Hooks", [
		"tinymce/util/Arr",
		"tinymce/dom/NodeType",
		"tinymce/dom/DomQuery"
	], function(Arr, NodeType, $) {
		var postProcessHooks = {}, filter = Arr.filter, each = Arr.each;
	
		function addPostProcessHook(name, hook) {
			var hooks = postProcessHooks[name];
	
			if (!hooks) {
				postProcessHooks[name] = hooks = [];
			}
	
			postProcessHooks[name].push(hook);
		}
	
		function postProcess(name, editor) {
			each(postProcessHooks[name], function(hook) {
				hook(editor);
			});
		}
	
		addPostProcessHook("pre", function(editor) {
			var rng = editor.selection.getRng(), isPre, blocks;
	
			function hasPreSibling(pre) {
				return isPre(pre.previousSibling) && Arr.indexOf(blocks, pre.previousSibling) != -1;
			}
	
			function joinPre(pre1, pre2) {
				$(pre2).remove();
				$(pre1).append('<br><br>').append(pre2.childNodes);
			}
	
			isPre = NodeType.matchNodeNames('pre');
	
			if (!rng.collapsed) {
				blocks = editor.selection.getSelectedBlocks();
	
				each(filter(filter(blocks, isPre), hasPreSibling), function(pre) {
					joinPre(pre.previousSibling, pre);
				});
			}
		});
	
		return {
			postProcess: postProcess
		};
	});
	
	// Included from: js/tinymce/classes/Formatter.js
	
	/**
	 * Formatter.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Text formatter engine class. This class is used to apply formats like bold, italic, font size
	 * etc to the current selection or specific nodes. This engine was built to replace the browser's
	 * default formatting logic for execCommand due to its inconsistent and buggy behavior.
	 *
	 * @class tinymce.Formatter
	 * @example
	 *  tinymce.activeEditor.formatter.register('mycustomformat', {
	 *    inline: 'span',
	 *    styles: {color: '#ff0000'}
	 *  });
	 *
	 *  tinymce.activeEditor.formatter.apply('mycustomformat');
	 */
	define("tinymce/Formatter", [
		"tinymce/dom/TreeWalker",
		"tinymce/dom/RangeUtils",
		"tinymce/dom/BookmarkManager",
		"tinymce/dom/ElementUtils",
		"tinymce/util/Tools",
		"tinymce/fmt/Preview",
		"tinymce/fmt/Hooks"
	], function(TreeWalker, RangeUtils, BookmarkManager, ElementUtils, Tools, Preview, Hooks) {
		/**
		 * Constructs a new formatter instance.
		 *
		 * @constructor Formatter
		 * @param {tinymce.Editor} ed Editor instance to construct the formatter engine to.
		 */
		return function(ed) {
			var formats = {},
				dom = ed.dom,
				selection = ed.selection,
				rangeUtils = new RangeUtils(dom),
				isValid = ed.schema.isValidChild,
				isBlock = dom.isBlock,
				forcedRootBlock = ed.settings.forced_root_block,
				nodeIndex = dom.nodeIndex,
				INVISIBLE_CHAR = '\uFEFF',
				MCE_ATTR_RE = /^(src|href|style)$/,
				FALSE = false,
				TRUE = true,
				formatChangeData,
				undef,
				getContentEditable = dom.getContentEditable,
				disableCaretContainer,
				markCaretContainersBogus,
				isBookmarkNode = BookmarkManager.isBookmarkNode;
	
			var each = Tools.each,
				grep = Tools.grep,
				walk = Tools.walk,
				extend = Tools.extend;
	
			function isTextBlock(name) {
				if (name.nodeType) {
					name = name.nodeName;
				}
	
				return !!ed.schema.getTextBlockElements()[name.toLowerCase()];
			}
	
			function isTableCell(node) {
				return /^(TH|TD)$/.test(node.nodeName);
			}
	
			function isInlineBlock(node) {
				return node && /^(IMG)$/.test(node.nodeName);
			}
	
			function getParents(node, selector) {
				return dom.getParents(node, selector, dom.getRoot());
			}
	
			function isCaretNode(node) {
				return node.nodeType === 1 && node.id === '_mce_caret';
			}
	
			function defaultFormats() {
				register({
					valigntop: [
						{selector: 'td,th', styles: {'verticalAlign': 'top'}}
					],
	
					valignmiddle: [
						{selector: 'td,th', styles: {'verticalAlign': 'middle'}}
					],
	
					valignbottom: [
						{selector: 'td,th', styles: {'verticalAlign': 'bottom'}}
					],
	
					alignleft: [
						{
							selector: 'figure.image',
							collapsed: false,
							classes: 'align-left',
							ceFalseOverride: true,
							preview: 'font-family font-size'
						},
						{
							selector: 'figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li',
							styles: {
								textAlign: 'left'
							},
							inherit: false,
							preview: false,
							defaultBlock: 'div'
						},
						{selector: 'img,table', collapsed: false, styles: {'float': 'left'}, preview: 'font-family font-size'}
					],
	
					aligncenter: [
						{
							selector: 'figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li',
							styles: {
								textAlign: 'center'
							},
							inherit: false,
							preview: false,
							defaultBlock: 'div'
						},
						{
							selector: 'figure.image',
							collapsed: false,
							classes: 'align-center',
							ceFalseOverride: true,
							preview: 'font-family font-size'
						},
						{
							selector: 'img',
							collapsed: false,
							styles: {
								display: 'block',
								marginLeft: 'auto',
								marginRight: 'auto'
							},
							preview: false
						},
						{
							selector: 'table',
							collapsed: false,
							styles: {
								marginLeft: 'auto',
								marginRight: 'auto'
							},
							preview: 'font-family font-size'
						}
					],
	
					alignright: [
						{
							selector: 'figure.image',
							collapsed: false,
							classes: 'align-right',
							ceFalseOverride: true,
							preview: 'font-family font-size'
						},
						{
							selector: 'figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li',
							styles: {
								textAlign: 'right'
							},
							inherit: false,
							preview: 'font-family font-size',
							defaultBlock: 'div'
						},
						{
							selector: 'img,table',
							collapsed: false,
							styles: {
								'float': 'right'
							},
							preview: 'font-family font-size'
						}
					],
	
					alignjustify: [
						{
							selector: 'figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li',
							styles: {
								textAlign: 'justify'
							},
							inherit: false,
							defaultBlock: 'div',
							preview: 'font-family font-size'
						}
					],
	
					bold: [
						{inline: 'strong', remove: 'all'},
						{inline: 'span', styles: {fontWeight: 'bold'}},
						{inline: 'b', remove: 'all'}
					],
	
					italic: [
						{inline: 'em', remove: 'all'},
						{inline: 'span', styles: {fontStyle: 'italic'}},
						{inline: 'i', remove: 'all'}
					],
	
					underline: [
						{inline: 'span', styles: {textDecoration: 'underline'}, exact: true},
						{inline: 'u', remove: 'all'}
					],
	
					strikethrough: [
						{inline: 'span', styles: {textDecoration: 'line-through'}, exact: true},
						{inline: 'strike', remove: 'all'}
					],
	
					forecolor: {inline: 'span', styles: {color: '%value'}, links: true, remove_similar: true},
					hilitecolor: {inline: 'span', styles: {backgroundColor: '%value'}, links: true, remove_similar: true},
					fontname: {inline: 'span', styles: {fontFamily: '%value'}},
					fontsize: {inline: 'span', styles: {fontSize: '%value'}},
					fontsize_class: {inline: 'span', attributes: {'class': '%value'}},
					blockquote: {block: 'blockquote', wrapper: 1, remove: 'all'},
					subscript: {inline: 'sub'},
					superscript: {inline: 'sup'},
					code: {inline: 'code'},
	
					link: {inline: 'a', selector: 'a', remove: 'all', split: true, deep: true,
						onmatch: function() {
							return true;
						},
	
						onformat: function(elm, fmt, vars) {
							each(vars, function(value, key) {
								dom.setAttrib(elm, key, value);
							});
						}
					},
	
					removeformat: [
						{
							selector: 'b,strong,em,i,font,u,strike,sub,sup,dfn,code,samp,kbd,var,cite,mark,q,del,ins',
							remove: 'all',
							split: true,
							expand: false,
							block_expand: true,
							deep: true
						},
						{selector: 'span', attributes: ['style', 'class'], remove: 'empty', split: true, expand: false, deep: true},
						{selector: '*', attributes: ['style', 'class'], split: false, expand: false, deep: true}
					]
				});
	
				// Register default block formats
				each('p h1 h2 h3 h4 h5 h6 div address pre div dt dd samp'.split(/\s/), function(name) {
					register(name, {block: name, remove: 'all'});
				});
	
				// Register user defined formats
				register(ed.settings.formats);
			}
	
			function addKeyboardShortcuts() {
				// Add some inline shortcuts
				ed.addShortcut('meta+b', 'bold_desc', 'Bold');
				ed.addShortcut('meta+i', 'italic_desc', 'Italic');
				ed.addShortcut('meta+u', 'underline_desc', 'Underline');
	
				// BlockFormat shortcuts keys
				for (var i = 1; i <= 6; i++) {
					ed.addShortcut('access+' + i, '', ['FormatBlock', false, 'h' + i]);
				}
	
				ed.addShortcut('access+7', '', ['FormatBlock', false, 'p']);
				ed.addShortcut('access+8', '', ['FormatBlock', false, 'div']);
				ed.addShortcut('access+9', '', ['FormatBlock', false, 'address']);
			}
	
			// Public functions
	
			/**
			 * Returns the format by name or all formats if no name is specified.
			 *
			 * @method get
			 * @param {String} name Optional name to retrieve by.
			 * @return {Array/Object} Array/Object with all registered formats or a specific format.
			 */
			function get(name) {
				return name ? formats[name] : formats;
			}
	
			/**
			 * Registers a specific format by name.
			 *
			 * @method register
			 * @param {Object/String} name Name of the format for example "bold".
			 * @param {Object/Array} format Optional format object or array of format variants
			 * can only be omitted if the first arg is an object.
			 */
			function register(name, format) {
				if (name) {
					if (typeof name !== 'string') {
						each(name, function(format, name) {
							register(name, format);
						});
					} else {
						// Force format into array and add it to internal collection
						format = format.length ? format : [format];
	
						each(format, function(format) {
							// Set deep to false by default on selector formats this to avoid removing
							// alignment on images inside paragraphs when alignment is changed on paragraphs
							if (format.deep === undef) {
								format.deep = !format.selector;
							}
	
							// Default to true
							if (format.split === undef) {
								format.split = !format.selector || format.inline;
							}
	
							// Default to true
							if (format.remove === undef && format.selector && !format.inline) {
								format.remove = 'none';
							}
	
							// Mark format as a mixed format inline + block level
							if (format.selector && format.inline) {
								format.mixed = true;
								format.block_expand = true;
							}
	
							// Split classes if needed
							if (typeof format.classes === 'string') {
								format.classes = format.classes.split(/\s+/);
							}
						});
	
						formats[name] = format;
					}
				}
			}
	
			/**
			 * Unregister a specific format by name.
			 *
			 * @method unregister
			 * @param {String} name Name of the format for example "bold".
			 */
			function unregister(name) {
				if (name && formats[name]) {
					delete formats[name];
				}
	
				return formats;
			}
	
			function matchesUnInheritedFormatSelector(node, name) {
				var formatList = get(name);
	
				if (formatList) {
					for (var i = 0; i < formatList.length; i++) {
						if (formatList[i].inherit === false && dom.is(node, formatList[i].selector)) {
							return true;
						}
					}
				}
	
				return false;
			}
	
			function getTextDecoration(node) {
				var decoration;
	
				ed.dom.getParent(node, function(n) {
					decoration = ed.dom.getStyle(n, 'text-decoration');
					return decoration && decoration !== 'none';
				});
	
				return decoration;
			}
	
			function processUnderlineAndColor(node) {
				var textDecoration;
				if (node.nodeType === 1 && node.parentNode && node.parentNode.nodeType === 1) {
					textDecoration = getTextDecoration(node.parentNode);
					if (ed.dom.getStyle(node, 'color') && textDecoration) {
						ed.dom.setStyle(node, 'text-decoration', textDecoration);
					} else if (ed.dom.getStyle(node, 'text-decoration') === textDecoration) {
						ed.dom.setStyle(node, 'text-decoration', null);
					}
				}
			}
	
			/**
			 * Applies the specified format to the current selection or specified node.
			 *
			 * @method apply
			 * @param {String} name Name of format to apply.
			 * @param {Object} vars Optional list of variables to replace within format before applying it.
			 * @param {Node} node Optional node to apply the format to defaults to current selection.
			 */
			function apply(name, vars, node) {
				var formatList = get(name), format = formatList[0], bookmark, rng, isCollapsed = !node && selection.isCollapsed();
	
				function setElementFormat(elm, fmt) {
					fmt = fmt || format;
	
					if (elm) {
						if (fmt.onformat) {
							fmt.onformat(elm, fmt, vars, node);
						}
	
						each(fmt.styles, function(value, name) {
							dom.setStyle(elm, name, replaceVars(value, vars));
						});
	
						// Needed for the WebKit span spam bug
						// TODO: Remove this once WebKit/Blink fixes this
						if (fmt.styles) {
							var styleVal = dom.getAttrib(elm, 'style');
	
							if (styleVal) {
								elm.setAttribute('data-mce-style', styleVal);
							}
						}
	
						each(fmt.attributes, function(value, name) {
							dom.setAttrib(elm, name, replaceVars(value, vars));
						});
	
						each(fmt.classes, function(value) {
							value = replaceVars(value, vars);
	
							if (!dom.hasClass(elm, value)) {
								dom.addClass(elm, value);
							}
						});
					}
				}
	
				function applyNodeStyle(formatList, node) {
					var found = false;
	
					if (!format.selector) {
						return false;
					}
	
					// Look for matching formats
					each(formatList, function(format) {
						// Check collapsed state if it exists
						if ('collapsed' in format && format.collapsed !== isCollapsed) {
							return;
						}
	
						if (dom.is(node, format.selector) && !isCaretNode(node)) {
							setElementFormat(node, format);
							found = true;
							return false;
						}
					});
	
					return found;
				}
	
				// This converts: <p>[a</p><p>]b</p> -> <p>[a]</p><p>b</p>
				function adjustSelectionToVisibleSelection() {
					function findSelectionEnd(start, end) {
						var walker = new TreeWalker(end);
						for (node = walker.prev2(); node; node = walker.prev2()) {
							if (node.nodeType == 3 && node.data.length > 0) {
								return node;
							}
	
							if (node.childNodes.length > 1 || node == start || node.tagName == 'BR') {
								return node;
							}
						}
					}
	
					// Adjust selection so that a end container with a end offset of zero is not included in the selection
					// as this isn't visible to the user.
					var rng = ed.selection.getRng();
					var start = rng.startContainer;
					var end = rng.endContainer;
	
					if (start != end && rng.endOffset === 0) {
						var newEnd = findSelectionEnd(start, end);
						var endOffset = newEnd.nodeType == 3 ? newEnd.data.length : newEnd.childNodes.length;
	
						rng.setEnd(newEnd, endOffset);
					}
	
					return rng;
				}
	
				function applyRngStyle(rng, bookmark, node_specific) {
					var newWrappers = [], wrapName, wrapElm, contentEditable = true;
	
					// Setup wrapper element
					wrapName = format.inline || format.block;
					wrapElm = dom.create(wrapName);
					setElementFormat(wrapElm);
	
					rangeUtils.walk(rng, function(nodes) {
						var currentWrapElm;
	
						/**
						 * Process a list of nodes wrap them.
						 */
						function process(node) {
							var nodeName, parentName, hasContentEditableState, lastContentEditable;
	
							lastContentEditable = contentEditable;
							nodeName = node.nodeName.toLowerCase();
							parentName = node.parentNode.nodeName.toLowerCase();
	
							// Node has a contentEditable value
							if (node.nodeType === 1 && getContentEditable(node)) {
								lastContentEditable = contentEditable;
								contentEditable = getContentEditable(node) === "true";
								hasContentEditableState = true; // We don't want to wrap the container only it's children
							}
	
							// Stop wrapping on br elements
							if (isEq(nodeName, 'br')) {
								currentWrapElm = 0;
	
								// Remove any br elements when we wrap things
								if (format.block) {
									dom.remove(node);
								}
	
								return;
							}
	
							// If node is wrapper type
							if (format.wrapper && matchNode(node, name, vars)) {
								currentWrapElm = 0;
								return;
							}
	
							// Can we rename the block
							// TODO: Break this if up, too complex
							if (contentEditable && !hasContentEditableState && format.block &&
								!format.wrapper && isTextBlock(nodeName) && isValid(parentName, wrapName)) {
								node = dom.rename(node, wrapName);
								setElementFormat(node);
								newWrappers.push(node);
								currentWrapElm = 0;
								return;
							}
	
							// Handle selector patterns
							if (format.selector) {
								var found = applyNodeStyle(formatList, node);
	
								// Continue processing if a selector match wasn't found and a inline element is defined
								if (!format.inline || found) {
									currentWrapElm = 0;
									return;
								}
							}
	
							// Is it valid to wrap this item
							// TODO: Break this if up, too complex
							if (contentEditable && !hasContentEditableState && isValid(wrapName, nodeName) && isValid(parentName, wrapName) &&
									!(!node_specific && node.nodeType === 3 &&
									node.nodeValue.length === 1 &&
									node.nodeValue.charCodeAt(0) === 65279) &&
									!isCaretNode(node) &&
									(!format.inline || !isBlock(node))) {
								// Start wrapping
								if (!currentWrapElm) {
									// Wrap the node
									currentWrapElm = dom.clone(wrapElm, FALSE);
									node.parentNode.insertBefore(currentWrapElm, node);
									newWrappers.push(currentWrapElm);
								}
	
								currentWrapElm.appendChild(node);
							} else {
								// Start a new wrapper for possible children
								currentWrapElm = 0;
	
								each(grep(node.childNodes), process);
	
								if (hasContentEditableState) {
									contentEditable = lastContentEditable; // Restore last contentEditable state from stack
								}
	
								// End the last wrapper
								currentWrapElm = 0;
							}
						}
	
						// Process siblings from range
						each(nodes, process);
					});
	
					// Apply formats to links as well to get the color of the underline to change as well
					if (format.links === true) {
						each(newWrappers, function(node) {
							function process(node) {
								if (node.nodeName === 'A') {
									setElementFormat(node, format);
								}
	
								each(grep(node.childNodes), process);
							}
	
							process(node);
						});
					}
	
					// Cleanup
					each(newWrappers, function(node) {
						var childCount;
	
						function getChildCount(node) {
							var count = 0;
	
							each(node.childNodes, function(node) {
								if (!isWhiteSpaceNode(node) && !isBookmarkNode(node)) {
									count++;
								}
							});
	
							return count;
						}
	
						function mergeStyles(node) {
							var child, clone;
	
							each(node.childNodes, function(node) {
								if (node.nodeType == 1 && !isBookmarkNode(node) && !isCaretNode(node)) {
									child = node;
									return FALSE; // break loop
								}
							});
	
							// If child was found and of the same type as the current node
							if (child && !isBookmarkNode(child) && matchName(child, format)) {
								clone = dom.clone(child, FALSE);
								setElementFormat(clone);
	
								dom.replace(clone, node, TRUE);
								dom.remove(child, 1);
							}
	
							return clone || node;
						}
	
						childCount = getChildCount(node);
	
						// Remove empty nodes but only if there is multiple wrappers and they are not block
						// elements so never remove single <h1></h1> since that would remove the
						// current empty block element where the caret is at
						if ((newWrappers.length > 1 || !isBlock(node)) && childCount === 0) {
							dom.remove(node, 1);
							return;
						}
	
						if (format.inline || format.wrapper) {
							// Merges the current node with it's children of similar type to reduce the number of elements
							if (!format.exact && childCount === 1) {
								node = mergeStyles(node);
							}
	
							// Remove/merge children
							each(formatList, function(format) {
								// Merge all children of similar type will move styles from child to parent
								// this: <span style="color:red"><b><span style="color:red; font-size:10px">text</span></b></span>
								// will become: <span style="color:red"><b><span style="font-size:10px">text</span></b></span>
								each(dom.select(format.inline, node), function(child) {
									if (isBookmarkNode(child)) {
										return;
									}
	
									removeFormat(format, vars, child, format.exact ? child : null);
								});
							});
	
							// Remove child if direct parent is of same type
							if (matchNode(node.parentNode, name, vars)) {
								dom.remove(node, 1);
								node = 0;
								return TRUE;
							}
	
							// Look for parent with similar style format
							if (format.merge_with_parents) {
								dom.getParent(node.parentNode, function(parent) {
									if (matchNode(parent, name, vars)) {
										dom.remove(node, 1);
										node = 0;
										return TRUE;
									}
								});
							}
	
							// Merge next and previous siblings if they are similar <b>text</b><b>text</b> becomes <b>texttext</b>
							if (node && format.merge_siblings !== false) {
								node = mergeSiblings(getNonWhiteSpaceSibling(node), node);
								node = mergeSiblings(node, getNonWhiteSpaceSibling(node, TRUE));
							}
						}
					});
				}
	
				if (getContentEditable(selection.getNode()) === "false") {
					node = selection.getNode();
					for (var i = 0, l = formatList.length; i < l; i++) {
						if (formatList[i].ceFalseOverride && dom.is(node, formatList[i].selector)) {
							setElementFormat(node, formatList[i]);
							return;
						}
					}
	
					return;
				}
	
				if (format) {
					if (node) {
						if (node.nodeType) {
							if (!applyNodeStyle(formatList, node)) {
								rng = dom.createRng();
								rng.setStartBefore(node);
								rng.setEndAfter(node);
								applyRngStyle(expandRng(rng, formatList), null, true);
							}
						} else {
							applyRngStyle(node, null, true);
						}
					} else {
						if (!isCollapsed || !format.inline || dom.select('td[data-mce-selected],th[data-mce-selected]').length) {
							// Obtain selection node before selection is unselected by applyRngStyle()
							var curSelNode = ed.selection.getNode();
	
							// If the formats have a default block and we can't find a parent block then
							// start wrapping it with a DIV this is for forced_root_blocks: false
							// It's kind of a hack but people should be using the default block type P since all desktop editors work that way
							if (!forcedRootBlock && formatList[0].defaultBlock && !dom.getParent(curSelNode, dom.isBlock)) {
								apply(formatList[0].defaultBlock);
							}
	
							// Apply formatting to selection
							ed.selection.setRng(adjustSelectionToVisibleSelection());
							bookmark = selection.getBookmark();
							applyRngStyle(expandRng(selection.getRng(TRUE), formatList), bookmark);
	
							// Colored nodes should be underlined so that the color of the underline matches the text color.
							if (format.styles && (format.styles.color || format.styles.textDecoration)) {
								walk(curSelNode, processUnderlineAndColor, 'childNodes');
								processUnderlineAndColor(curSelNode);
							}
	
							selection.moveToBookmark(bookmark);
							moveStart(selection.getRng(TRUE));
							ed.nodeChanged();
						} else {
							performCaretAction('apply', name, vars);
						}
					}
	
					Hooks.postProcess(name, ed);
				}
			}
	
			/**
			 * Removes the specified format from the current selection or specified node.
			 *
			 * @method remove
			 * @param {String} name Name of format to remove.
			 * @param {Object} vars Optional list of variables to replace within format before removing it.
			 * @param {Node/Range} node Optional node or DOM range to remove the format from defaults to current selection.
			 */
			function remove(name, vars, node, similar) {
				var formatList = get(name), format = formatList[0], bookmark, rng, contentEditable = true;
	
				// Merges the styles for each node
				function process(node) {
					var children, i, l, lastContentEditable, hasContentEditableState;
	
					// Node has a contentEditable value
					if (node.nodeType === 1 && getContentEditable(node)) {
						lastContentEditable = contentEditable;
						contentEditable = getContentEditable(node) === "true";
						hasContentEditableState = true; // We don't want to wrap the container only it's children
					}
	
					// Grab the children first since the nodelist might be changed
					children = grep(node.childNodes);
	
					// Process current node
					if (contentEditable && !hasContentEditableState) {
						for (i = 0, l = formatList.length; i < l; i++) {
							if (removeFormat(formatList[i], vars, node, node)) {
								break;
							}
						}
					}
	
					// Process the children
					if (format.deep) {
						if (children.length) {
							for (i = 0, l = children.length; i < l; i++) {
								process(children[i]);
							}
	
							if (hasContentEditableState) {
								contentEditable = lastContentEditable; // Restore last contentEditable state from stack
							}
						}
					}
				}
	
				function findFormatRoot(container) {
					var formatRoot;
	
					// Find format root
					each(getParents(container.parentNode).reverse(), function(parent) {
						var format;
	
						// Find format root element
						if (!formatRoot && parent.id != '_start' && parent.id != '_end') {
							// Is the node matching the format we are looking for
							format = matchNode(parent, name, vars, similar);
							if (format && format.split !== false) {
								formatRoot = parent;
							}
						}
					});
	
					return formatRoot;
				}
	
				function wrapAndSplit(formatRoot, container, target, split) {
					var parent, clone, lastClone, firstClone, i, formatRootParent;
	
					// Format root found then clone formats and split it
					if (formatRoot) {
						formatRootParent = formatRoot.parentNode;
	
						for (parent = container.parentNode; parent && parent != formatRootParent; parent = parent.parentNode) {
							clone = dom.clone(parent, FALSE);
	
							for (i = 0; i < formatList.length; i++) {
								if (removeFormat(formatList[i], vars, clone, clone)) {
									clone = 0;
									break;
								}
							}
	
							// Build wrapper node
							if (clone) {
								if (lastClone) {
									clone.appendChild(lastClone);
								}
	
								if (!firstClone) {
									firstClone = clone;
								}
	
								lastClone = clone;
							}
						}
	
						// Never split block elements if the format is mixed
						if (split && (!format.mixed || !isBlock(formatRoot))) {
							container = dom.split(formatRoot, container);
						}
	
						// Wrap container in cloned formats
						if (lastClone) {
							target.parentNode.insertBefore(lastClone, target);
							firstClone.appendChild(target);
						}
					}
	
					return container;
				}
	
				function splitToFormatRoot(container) {
					return wrapAndSplit(findFormatRoot(container), container, container, true);
				}
	
				function unwrap(start) {
					var node = dom.get(start ? '_start' : '_end'),
						out = node[start ? 'firstChild' : 'lastChild'];
	
					// If the end is placed within the start the result will be removed
					// So this checks if the out node is a bookmark node if it is it
					// checks for another more suitable node
					if (isBookmarkNode(out)) {
						out = out[start ? 'firstChild' : 'lastChild'];
					}
	
					// Since dom.remove removes empty text nodes then we need to try to find a better node
					if (out.nodeType == 3 && out.data.length === 0) {
						out = start ? node.previousSibling || node.nextSibling : node.nextSibling || node.previousSibling;
					}
	
					dom.remove(node, true);
	
					return out;
				}
	
				function removeRngStyle(rng) {
					var startContainer, endContainer;
					var commonAncestorContainer = rng.commonAncestorContainer;
	
					rng = expandRng(rng, formatList, TRUE);
	
					if (format.split) {
						startContainer = getContainer(rng, TRUE);
						endContainer = getContainer(rng);
	
						if (startContainer != endContainer) {
							// WebKit will render the table incorrectly if we wrap a TH or TD in a SPAN
							// so let's see if we can use the first child instead
							// This will happen if you triple click a table cell and use remove formatting
							if (/^(TR|TH|TD)$/.test(startContainer.nodeName) && startContainer.firstChild) {
								if (startContainer.nodeName == "TR") {
									startContainer = startContainer.firstChild.firstChild || startContainer;
								} else {
									startContainer = startContainer.firstChild || startContainer;
								}
							}
	
							// Try to adjust endContainer as well if cells on the same row were selected - bug #6410
							if (commonAncestorContainer &&
								/^T(HEAD|BODY|FOOT|R)$/.test(commonAncestorContainer.nodeName) &&
								isTableCell(endContainer) && endContainer.firstChild) {
								endContainer = endContainer.firstChild || endContainer;
							}
	
							if (dom.isChildOf(startContainer, endContainer) && !isBlock(endContainer) &&
								!isTableCell(startContainer) && !isTableCell(endContainer)) {
								startContainer = wrap(startContainer, 'span', {id: '_start', 'data-mce-type': 'bookmark'});
								splitToFormatRoot(startContainer);
								startContainer = unwrap(TRUE);
								return;
							}
	
							// Wrap start/end nodes in span element since these might be cloned/moved
							startContainer = wrap(startContainer, 'span', {id: '_start', 'data-mce-type': 'bookmark'});
							endContainer = wrap(endContainer, 'span', {id: '_end', 'data-mce-type': 'bookmark'});
	
							// Split start/end
							splitToFormatRoot(startContainer);
							splitToFormatRoot(endContainer);
	
							// Unwrap start/end to get real elements again
							startContainer = unwrap(TRUE);
							endContainer = unwrap();
						} else {
							startContainer = endContainer = splitToFormatRoot(startContainer);
						}
	
						// Update range positions since they might have changed after the split operations
						rng.startContainer = startContainer.parentNode ? startContainer.parentNode : startContainer;
						rng.startOffset = nodeIndex(startContainer);
						rng.endContainer = endContainer.parentNode ? endContainer.parentNode : endContainer;
						rng.endOffset = nodeIndex(endContainer) + 1;
					}
	
					// Remove items between start/end
					rangeUtils.walk(rng, function(nodes) {
						each(nodes, function(node) {
							process(node);
	
							// Remove parent span if it only contains text-decoration: underline, yet a parent node is also underlined.
							if (node.nodeType === 1 && ed.dom.getStyle(node, 'text-decoration') === 'underline' &&
								node.parentNode && getTextDecoration(node.parentNode) === 'underline') {
								removeFormat({
									'deep': false,
									'exact': true,
									'inline': 'span',
									'styles': {
										'textDecoration': 'underline'
									}
								}, null, node);
							}
						});
					});
				}
	
				// Handle node
				if (node) {
					if (node.nodeType) {
						rng = dom.createRng();
						rng.setStartBefore(node);
						rng.setEndAfter(node);
						removeRngStyle(rng);
					} else {
						removeRngStyle(node);
					}
	
					return;
				}
	
				if (getContentEditable(selection.getNode()) === "false") {
					node = selection.getNode();
					for (var i = 0, l = formatList.length; i < l; i++) {
						if (formatList[i].ceFalseOverride) {
							if (removeFormat(formatList[i], vars, node, node)) {
								break;
							}
						}
					}
	
					return;
				}
	
				if (!selection.isCollapsed() || !format.inline || dom.select('td[data-mce-selected],th[data-mce-selected]').length) {
					bookmark = selection.getBookmark();
					removeRngStyle(selection.getRng(TRUE));
					selection.moveToBookmark(bookmark);
	
					// Check if start element still has formatting then we are at: "<b>text|</b>text"
					// and need to move the start into the next text node
					if (format.inline && match(name, vars, selection.getStart())) {
						moveStart(selection.getRng(true));
					}
	
					ed.nodeChanged();
				} else {
					performCaretAction('remove', name, vars, similar);
				}
			}
	
			/**
			 * Toggles the specified format on/off.
			 *
			 * @method toggle
			 * @param {String} name Name of format to apply/remove.
			 * @param {Object} vars Optional list of variables to replace within format before applying/removing it.
			 * @param {Node} node Optional node to apply the format to or remove from. Defaults to current selection.
			 */
			function toggle(name, vars, node) {
				var fmt = get(name);
	
				if (match(name, vars, node) && (!('toggle' in fmt[0]) || fmt[0].toggle)) {
					remove(name, vars, node);
				} else {
					apply(name, vars, node);
				}
			}
	
			/**
			 * Return true/false if the specified node has the specified format.
			 *
			 * @method matchNode
			 * @param {Node} node Node to check the format on.
			 * @param {String} name Format name to check.
			 * @param {Object} vars Optional list of variables to replace before checking it.
			 * @param {Boolean} similar Match format that has similar properties.
			 * @return {Object} Returns the format object it matches or undefined if it doesn't match.
			 */
			function matchNode(node, name, vars, similar) {
				var formatList = get(name), format, i, classes;
	
				function matchItems(node, format, item_name) {
					var key, value, items = format[item_name], i;
	
					// Custom match
					if (format.onmatch) {
						return format.onmatch(node, format, item_name);
					}
	
					// Check all items
					if (items) {
						// Non indexed object
						if (items.length === undef) {
							for (key in items) {
								if (items.hasOwnProperty(key)) {
									if (item_name === 'attributes') {
										value = dom.getAttrib(node, key);
									} else {
										value = getStyle(node, key);
									}
	
									if (similar && !value && !format.exact) {
										return;
									}
	
									if ((!similar || format.exact) && !isEq(value, normalizeStyleValue(replaceVars(items[key], vars), key))) {
										return;
									}
								}
							}
						} else {
							// Only one match needed for indexed arrays
							for (i = 0; i < items.length; i++) {
								if (item_name === 'attributes' ? dom.getAttrib(node, items[i]) : getStyle(node, items[i])) {
									return format;
								}
							}
						}
					}
	
					return format;
				}
	
				if (formatList && node) {
					// Check each format in list
					for (i = 0; i < formatList.length; i++) {
						format = formatList[i];
	
						// Name name, attributes, styles and classes
						if (matchName(node, format) && matchItems(node, format, 'attributes') && matchItems(node, format, 'styles')) {
							// Match classes
							if ((classes = format.classes)) {
								for (i = 0; i < classes.length; i++) {
									if (!dom.hasClass(node, classes[i])) {
										return;
									}
								}
							}
	
							return format;
						}
					}
				}
			}
	
			/**
			 * Matches the current selection or specified node against the specified format name.
			 *
			 * @method match
			 * @param {String} name Name of format to match.
			 * @param {Object} vars Optional list of variables to replace before checking it.
			 * @param {Node} node Optional node to check.
			 * @return {boolean} true/false if the specified selection/node matches the format.
			 */
			function match(name, vars, node) {
				var startNode;
	
				function matchParents(node) {
					var root = dom.getRoot();
	
					if (node === root) {
						return false;
					}
	
					// Find first node with similar format settings
					node = dom.getParent(node, function(node) {
						if (matchesUnInheritedFormatSelector(node, name)) {
							return true;
						}
	
						return node.parentNode === root || !!matchNode(node, name, vars, true);
					});
	
					// Do an exact check on the similar format element
					return matchNode(node, name, vars);
				}
	
				// Check specified node
				if (node) {
					return matchParents(node);
				}
	
				// Check selected node
				node = selection.getNode();
				if (matchParents(node)) {
					return TRUE;
				}
	
				// Check start node if it's different
				startNode = selection.getStart();
				if (startNode != node) {
					if (matchParents(startNode)) {
						return TRUE;
					}
				}
	
				return FALSE;
			}
	
			/**
			 * Matches the current selection against the array of formats and returns a new array with matching formats.
			 *
			 * @method matchAll
			 * @param {Array} names Name of format to match.
			 * @param {Object} vars Optional list of variables to replace before checking it.
			 * @return {Array} Array with matched formats.
			 */
			function matchAll(names, vars) {
				var startElement, matchedFormatNames = [], checkedMap = {};
	
				// Check start of selection for formats
				startElement = selection.getStart();
				dom.getParent(startElement, function(node) {
					var i, name;
	
					for (i = 0; i < names.length; i++) {
						name = names[i];
	
						if (!checkedMap[name] && matchNode(node, name, vars)) {
							checkedMap[name] = true;
							matchedFormatNames.push(name);
						}
					}
				}, dom.getRoot());
	
				return matchedFormatNames;
			}
	
			/**
			 * Returns true/false if the specified format can be applied to the current selection or not. It
			 * will currently only check the state for selector formats, it returns true on all other format types.
			 *
			 * @method canApply
			 * @param {String} name Name of format to check.
			 * @return {boolean} true/false if the specified format can be applied to the current selection/node.
			 */
			function canApply(name) {
				var formatList = get(name), startNode, parents, i, x, selector;
	
				if (formatList) {
					startNode = selection.getStart();
					parents = getParents(startNode);
	
					for (x = formatList.length - 1; x >= 0; x--) {
						selector = formatList[x].selector;
	
						// Format is not selector based then always return TRUE
						// Is it has a defaultBlock then it's likely it can be applied for example align on a non block element line
						if (!selector || formatList[x].defaultBlock) {
							return TRUE;
						}
	
						for (i = parents.length - 1; i >= 0; i--) {
							if (dom.is(parents[i], selector)) {
								return TRUE;
							}
						}
					}
				}
	
				return FALSE;
			}
	
			/**
			 * Executes the specified callback when the current selection matches the formats or not.
			 *
			 * @method formatChanged
			 * @param {String} formats Comma separated list of formats to check for.
			 * @param {function} callback Callback with state and args when the format is changed/toggled on/off.
			 * @param {Boolean} similar True/false state if the match should handle similar or exact formats.
			 */
			function formatChanged(formats, callback, similar) {
				var currentFormats;
	
				// Setup format node change logic
				if (!formatChangeData) {
					formatChangeData = {};
					currentFormats = {};
	
					ed.on('NodeChange', function(e) {
						var parents = getParents(e.element), matchedFormats = {};
	
						// Ignore bogus nodes like the <a> tag created by moveStart()
						parents = Tools.grep(parents, function(node) {
							return node.nodeType == 1 && !node.getAttribute('data-mce-bogus');
						});
	
						// Check for new formats
						each(formatChangeData, function(callbacks, format) {
							each(parents, function(node) {
								if (matchNode(node, format, {}, callbacks.similar)) {
									if (!currentFormats[format]) {
										// Execute callbacks
										each(callbacks, function(callback) {
											callback(true, {node: node, format: format, parents: parents});
										});
	
										currentFormats[format] = callbacks;
									}
	
									matchedFormats[format] = callbacks;
									return false;
								}
	
								if (matchesUnInheritedFormatSelector(node, format)) {
									return false;
								}
							});
						});
	
						// Check if current formats still match
						each(currentFormats, function(callbacks, format) {
							if (!matchedFormats[format]) {
								delete currentFormats[format];
	
								each(callbacks, function(callback) {
									callback(false, {node: e.element, format: format, parents: parents});
								});
							}
						});
					});
				}
	
				// Add format listeners
				each(formats.split(','), function(format) {
					if (!formatChangeData[format]) {
						formatChangeData[format] = [];
						formatChangeData[format].similar = similar;
					}
	
					formatChangeData[format].push(callback);
				});
	
				return this;
			}
	
			/**
			 * Returns a preview css text for the specified format.
			 *
			 * @method getCssText
			 * @param {String/Object} format Format to generate preview css text for.
			 * @return {String} Css text for the specified format.
			 * @example
			 * var cssText1 = editor.formatter.getCssText('bold');
			 * var cssText2 = editor.formatter.getCssText({inline: 'b'});
			 */
			function getCssText(format) {
				return Preview.getCssText(ed, format);
			}
	
			// Expose to public
			extend(this, {
				get: get,
				register: register,
				unregister: unregister,
				apply: apply,
				remove: remove,
				toggle: toggle,
				match: match,
				matchAll: matchAll,
				matchNode: matchNode,
				canApply: canApply,
				formatChanged: formatChanged,
				getCssText: getCssText
			});
	
			// Initialize
			defaultFormats();
			addKeyboardShortcuts();
			ed.on('BeforeGetContent', function(e) {
				if (markCaretContainersBogus && e.format != 'raw') {
					markCaretContainersBogus();
				}
			});
			ed.on('mouseup keydown', function(e) {
				if (disableCaretContainer) {
					disableCaretContainer(e);
				}
			});
	
			// Private functions
	
			/**
			 * Checks if the specified nodes name matches the format inline/block or selector.
			 *
			 * @private
			 * @param {Node} node Node to match against the specified format.
			 * @param {Object} format Format object o match with.
			 * @return {boolean} true/false if the format matches.
			 */
			function matchName(node, format) {
				// Check for inline match
				if (isEq(node, format.inline)) {
					return TRUE;
				}
	
				// Check for block match
				if (isEq(node, format.block)) {
					return TRUE;
				}
	
				// Check for selector match
				if (format.selector) {
					return node.nodeType == 1 && dom.is(node, format.selector);
				}
			}
	
			/**
			 * Compares two string/nodes regardless of their case.
			 *
			 * @private
			 * @param {String/Node} str1 Node or string to compare.
			 * @param {String/Node} str2 Node or string to compare.
			 * @return {boolean} True/false if they match.
			 */
			function isEq(str1, str2) {
				str1 = str1 || '';
				str2 = str2 || '';
	
				str1 = '' + (str1.nodeName || str1);
				str2 = '' + (str2.nodeName || str2);
	
				return str1.toLowerCase() == str2.toLowerCase();
			}
	
			/**
			 * Returns the style by name on the specified node. This method modifies the style
			 * contents to make it more easy to match. This will resolve a few browser issues.
			 *
			 * @private
			 * @param {Node} node to get style from.
			 * @param {String} name Style name to get.
			 * @return {String} Style item value.
			 */
			function getStyle(node, name) {
				return normalizeStyleValue(dom.getStyle(node, name), name);
			}
	
			/**
			 * Normalize style value by name. This method modifies the style contents
			 * to make it more easy to match. This will resolve a few browser issues.
			 *
			 * @private
			 * @param {String} value Value to get style from.
			 * @param {String} name Style name to get.
			 * @return {String} Style item value.
			 */
			function normalizeStyleValue(value, name) {
				// Force the format to hex
				if (name == 'color' || name == 'backgroundColor') {
					value = dom.toHex(value);
				}
	
				// Opera will return bold as 700
				if (name == 'fontWeight' && value == 700) {
					value = 'bold';
				}
	
				// Normalize fontFamily so "'Font name', Font" becomes: "Font name,Font"
				if (name == 'fontFamily') {
					value = value.replace(/[\'\"]/g, '').replace(/,\s+/g, ',');
				}
	
				return '' + value;
			}
	
			/**
			 * Replaces variables in the value. The variable format is %var.
			 *
			 * @private
			 * @param {String} value Value to replace variables in.
			 * @param {Object} vars Name/value array with variables to replace.
			 * @return {String} New value with replaced variables.
			 */
			function replaceVars(value, vars) {
				if (typeof value != "string") {
					value = value(vars);
				} else if (vars) {
					value = value.replace(/%(\w+)/g, function(str, name) {
						return vars[name] || str;
					});
				}
	
				return value;
			}
	
			function isWhiteSpaceNode(node) {
				return node && node.nodeType === 3 && /^([\t \r\n]+|)$/.test(node.nodeValue);
			}
	
			function wrap(node, name, attrs) {
				var wrapper = dom.create(name, attrs);
	
				node.parentNode.insertBefore(wrapper, node);
				wrapper.appendChild(node);
	
				return wrapper;
			}
	
			/**
			 * Expands the specified range like object to depending on format.
			 *
			 * For example on block formats it will move the start/end position
			 * to the beginning of the current block.
			 *
			 * @private
			 * @param {Object} rng Range like object.
			 * @param {Array} format Array with formats to expand by.
			 * @param {Boolean} remove
			 * @return {Object} Expanded range like object.
			 */
			function expandRng(rng, format, remove) {
				var lastIdx, leaf, endPoint,
					startContainer = rng.startContainer,
					startOffset = rng.startOffset,
					endContainer = rng.endContainer,
					endOffset = rng.endOffset;
	
				// This function walks up the tree if there is no siblings before/after the node
				function findParentContainer(start) {
					var container, parent, sibling, siblingName, root;
	
					container = parent = start ? startContainer : endContainer;
					siblingName = start ? 'previousSibling' : 'nextSibling';
					root = dom.getRoot();
	
					function isBogusBr(node) {
						return node.nodeName == "BR" && node.getAttribute('data-mce-bogus') && !node.nextSibling;
					}
	
					// If it's a text node and the offset is inside the text
					if (container.nodeType == 3 && !isWhiteSpaceNode(container)) {
						if (start ? startOffset > 0 : endOffset < container.nodeValue.length) {
							return container;
						}
					}
	
					/*eslint no-constant-condition:0 */
					while (true) {
						// Stop expanding on block elements
						if (!format[0].block_expand && isBlock(parent)) {
							return parent;
						}
	
						// Walk left/right
						for (sibling = parent[siblingName]; sibling; sibling = sibling[siblingName]) {
							if (!isBookmarkNode(sibling) && !isWhiteSpaceNode(sibling) && !isBogusBr(sibling)) {
								return parent;
							}
						}
	
						// Check if we can move up are we at root level or body level
						if (parent == root || parent.parentNode == root) {
							container = parent;
							break;
						}
	
						parent = parent.parentNode;
					}
	
					return container;
				}
	
				// This function walks down the tree to find the leaf at the selection.
				// The offset is also returned as if node initially a leaf, the offset may be in the middle of the text node.
				function findLeaf(node, offset) {
					if (offset === undef) {
						offset = node.nodeType === 3 ? node.length : node.childNodes.length;
					}
	
					while (node && node.hasChildNodes()) {
						node = node.childNodes[offset];
						if (node) {
							offset = node.nodeType === 3 ? node.length : node.childNodes.length;
						}
					}
					return {node: node, offset: offset};
				}
	
				// If index based start position then resolve it
				if (startContainer.nodeType == 1 && startContainer.hasChildNodes()) {
					lastIdx = startContainer.childNodes.length - 1;
					startContainer = startContainer.childNodes[startOffset > lastIdx ? lastIdx : startOffset];
	
					if (startContainer.nodeType == 3) {
						startOffset = 0;
					}
				}
	
				// If index based end position then resolve it
				if (endContainer.nodeType == 1 && endContainer.hasChildNodes()) {
					lastIdx = endContainer.childNodes.length - 1;
					endContainer = endContainer.childNodes[endOffset > lastIdx ? lastIdx : endOffset - 1];
	
					if (endContainer.nodeType == 3) {
						endOffset = endContainer.nodeValue.length;
					}
				}
	
				// Expands the node to the closes contentEditable false element if it exists
				function findParentContentEditable(node) {
					var parent = node;
	
					while (parent) {
						if (parent.nodeType === 1 && getContentEditable(parent)) {
							return getContentEditable(parent) === "false" ? parent : node;
						}
	
						parent = parent.parentNode;
					}
	
					return node;
				}
	
				function findWordEndPoint(container, offset, start) {
					var walker, node, pos, lastTextNode;
	
					function findSpace(node, offset) {
						var pos, pos2, str = node.nodeValue;
	
						if (typeof offset == "undefined") {
							offset = start ? str.length : 0;
						}
	
						if (start) {
							pos = str.lastIndexOf(' ', offset);
							pos2 = str.lastIndexOf('\u00a0', offset);
							pos = pos > pos2 ? pos : pos2;
	
							// Include the space on remove to avoid tag soup
							if (pos !== -1 && !remove) {
								pos++;
							}
						} else {
							pos = str.indexOf(' ', offset);
							pos2 = str.indexOf('\u00a0', offset);
							pos = pos !== -1 && (pos2 === -1 || pos < pos2) ? pos : pos2;
						}
	
						return pos;
					}
	
					if (container.nodeType === 3) {
						pos = findSpace(container, offset);
	
						if (pos !== -1) {
							return {container: container, offset: pos};
						}
	
						lastTextNode = container;
					}
	
					// Walk the nodes inside the block
					walker = new TreeWalker(container, dom.getParent(container, isBlock) || ed.getBody());
					while ((node = walker[start ? 'prev' : 'next']())) {
						if (node.nodeType === 3) {
							lastTextNode = node;
							pos = findSpace(node);
	
							if (pos !== -1) {
								return {container: node, offset: pos};
							}
						} else if (isBlock(node)) {
							break;
						}
					}
	
					if (lastTextNode) {
						if (start) {
							offset = 0;
						} else {
							offset = lastTextNode.length;
						}
	
						return {container: lastTextNode, offset: offset};
					}
				}
	
				function findSelectorEndPoint(container, sibling_name) {
					var parents, i, y, curFormat;
	
					if (container.nodeType == 3 && container.nodeValue.length === 0 && container[sibling_name]) {
						container = container[sibling_name];
					}
	
					parents = getParents(container);
					for (i = 0; i < parents.length; i++) {
						for (y = 0; y < format.length; y++) {
							curFormat = format[y];
	
							// If collapsed state is set then skip formats that doesn't match that
							if ("collapsed" in curFormat && curFormat.collapsed !== rng.collapsed) {
								continue;
							}
	
							if (dom.is(parents[i], curFormat.selector)) {
								return parents[i];
							}
						}
					}
	
					return container;
				}
	
				function findBlockEndPoint(container, sibling_name) {
					var node, root = dom.getRoot();
	
					// Expand to block of similar type
					if (!format[0].wrapper) {
						node = dom.getParent(container, format[0].block, root);
					}
	
					// Expand to first wrappable block element or any block element
					if (!node) {
						node = dom.getParent(container.nodeType == 3 ? container.parentNode : container, function(node) {
							// Fixes #6183 where it would expand to editable parent element in inline mode
							return node != root && isTextBlock(node);
						});
					}
	
					// Exclude inner lists from wrapping
					if (node && format[0].wrapper) {
						node = getParents(node, 'ul,ol').reverse()[0] || node;
					}
	
					// Didn't find a block element look for first/last wrappable element
					if (!node) {
						node = container;
	
						while (node[sibling_name] && !isBlock(node[sibling_name])) {
							node = node[sibling_name];
	
							// Break on BR but include it will be removed later on
							// we can't remove it now since we need to check if it can be wrapped
							if (isEq(node, 'br')) {
								break;
							}
						}
					}
	
					return node || container;
				}
	
				// Expand to closest contentEditable element
				startContainer = findParentContentEditable(startContainer);
				endContainer = findParentContentEditable(endContainer);
	
				// Exclude bookmark nodes if possible
				if (isBookmarkNode(startContainer.parentNode) || isBookmarkNode(startContainer)) {
					startContainer = isBookmarkNode(startContainer) ? startContainer : startContainer.parentNode;
					startContainer = startContainer.nextSibling || startContainer;
	
					if (startContainer.nodeType == 3) {
						startOffset = 0;
					}
				}
	
				if (isBookmarkNode(endContainer.parentNode) || isBookmarkNode(endContainer)) {
					endContainer = isBookmarkNode(endContainer) ? endContainer : endContainer.parentNode;
					endContainer = endContainer.previousSibling || endContainer;
	
					if (endContainer.nodeType == 3) {
						endOffset = endContainer.length;
					}
				}
	
				if (format[0].inline) {
					if (rng.collapsed) {
						// Expand left to closest word boundary
						endPoint = findWordEndPoint(startContainer, startOffset, true);
						if (endPoint) {
							startContainer = endPoint.container;
							startOffset = endPoint.offset;
						}
	
						// Expand right to closest word boundary
						endPoint = findWordEndPoint(endContainer, endOffset);
						if (endPoint) {
							endContainer = endPoint.container;
							endOffset = endPoint.offset;
						}
					}
	
					// Avoid applying formatting to a trailing space.
					leaf = findLeaf(endContainer, endOffset);
					if (leaf.node) {
						while (leaf.node && leaf.offset === 0 && leaf.node.previousSibling) {
							leaf = findLeaf(leaf.node.previousSibling);
						}
	
						if (leaf.node && leaf.offset > 0 && leaf.node.nodeType === 3 &&
								leaf.node.nodeValue.charAt(leaf.offset - 1) === ' ') {
	
							if (leaf.offset > 1) {
								endContainer = leaf.node;
								endContainer.splitText(leaf.offset - 1);
							}
						}
					}
				}
	
				// Move start/end point up the tree if the leaves are sharp and if we are in different containers
				// Example * becomes !: !<p><b><i>*text</i><i>text*</i></b></p>!
				// This will reduce the number of wrapper elements that needs to be created
				// Move start point up the tree
				if (format[0].inline || format[0].block_expand) {
					if (!format[0].inline || (startContainer.nodeType != 3 || startOffset === 0)) {
						startContainer = findParentContainer(true);
					}
	
					if (!format[0].inline || (endContainer.nodeType != 3 || endOffset === endContainer.nodeValue.length)) {
						endContainer = findParentContainer();
					}
				}
	
				// Expand start/end container to matching selector
				if (format[0].selector && format[0].expand !== FALSE && !format[0].inline) {
					// Find new startContainer/endContainer if there is better one
					startContainer = findSelectorEndPoint(startContainer, 'previousSibling');
					endContainer = findSelectorEndPoint(endContainer, 'nextSibling');
				}
	
				// Expand start/end container to matching block element or text node
				if (format[0].block || format[0].selector) {
					// Find new startContainer/endContainer if there is better one
					startContainer = findBlockEndPoint(startContainer, 'previousSibling');
					endContainer = findBlockEndPoint(endContainer, 'nextSibling');
	
					// Non block element then try to expand up the leaf
					if (format[0].block) {
						if (!isBlock(startContainer)) {
							startContainer = findParentContainer(true);
						}
	
						if (!isBlock(endContainer)) {
							endContainer = findParentContainer();
						}
					}
				}
	
				// Setup index for startContainer
				if (startContainer.nodeType == 1) {
					startOffset = nodeIndex(startContainer);
					startContainer = startContainer.parentNode;
				}
	
				// Setup index for endContainer
				if (endContainer.nodeType == 1) {
					endOffset = nodeIndex(endContainer) + 1;
					endContainer = endContainer.parentNode;
				}
	
				// Return new range like object
				return {
					startContainer: startContainer,
					startOffset: startOffset,
					endContainer: endContainer,
					endOffset: endOffset
				};
			}
	
			function isColorFormatAndAnchor(node, format) {
				return format.links && node.tagName == 'A';
			}
	
			/**
			 * Removes the specified format for the specified node. It will also remove the node if it doesn't have
			 * any attributes if the format specifies it to do so.
			 *
			 * @private
			 * @param {Object} format Format object with items to remove from node.
			 * @param {Object} vars Name/value object with variables to apply to format.
			 * @param {Node} node Node to remove the format styles on.
			 * @param {Node} compare_node Optional compare node, if specified the styles will be compared to that node.
			 * @return {Boolean} True/false if the node was removed or not.
			 */
			function removeFormat(format, vars, node, compare_node) {
				var i, attrs, stylesModified;
	
				// Check if node matches format
				if (!matchName(node, format) && !isColorFormatAndAnchor(node, format)) {
					return FALSE;
				}
	
				// Should we compare with format attribs and styles
				if (format.remove != 'all') {
					// Remove styles
					each(format.styles, function(value, name) {
						value = normalizeStyleValue(replaceVars(value, vars), name);
	
						// Indexed array
						if (typeof name === 'number') {
							name = value;
							compare_node = 0;
						}
	
						if (format.remove_similar || (!compare_node || isEq(getStyle(compare_node, name), value))) {
							dom.setStyle(node, name, '');
						}
	
						stylesModified = 1;
					});
	
					// Remove style attribute if it's empty
					if (stylesModified && dom.getAttrib(node, 'style') === '') {
						node.removeAttribute('style');
						node.removeAttribute('data-mce-style');
					}
	
					// Remove attributes
					each(format.attributes, function(value, name) {
						var valueOut;
	
						value = replaceVars(value, vars);
	
						// Indexed array
						if (typeof name === 'number') {
							name = value;
							compare_node = 0;
						}
	
						if (!compare_node || isEq(dom.getAttrib(compare_node, name), value)) {
							// Keep internal classes
							if (name == 'class') {
								value = dom.getAttrib(node, name);
								if (value) {
									// Build new class value where everything is removed except the internal prefixed classes
									valueOut = '';
									each(value.split(/\s+/), function(cls) {
										if (/mce\-\w+/.test(cls)) {
											valueOut += (valueOut ? ' ' : '') + cls;
										}
									});
	
									// We got some internal classes left
									if (valueOut) {
										dom.setAttrib(node, name, valueOut);
										return;
									}
								}
							}
	
							// IE6 has a bug where the attribute doesn't get removed correctly
							if (name == "class") {
								node.removeAttribute('className');
							}
	
							// Remove mce prefixed attributes
							if (MCE_ATTR_RE.test(name)) {
								node.removeAttribute('data-mce-' + name);
							}
	
							node.removeAttribute(name);
						}
					});
	
					// Remove classes
					each(format.classes, function(value) {
						value = replaceVars(value, vars);
	
						if (!compare_node || dom.hasClass(compare_node, value)) {
							dom.removeClass(node, value);
						}
					});
	
					// Check for non internal attributes
					attrs = dom.getAttribs(node);
					for (i = 0; i < attrs.length; i++) {
						var attrName = attrs[i].nodeName;
						if (attrName.indexOf('_') !== 0 && attrName.indexOf('data-') !== 0) {
							return FALSE;
						}
					}
				}
	
				// Remove the inline child if it's empty for example <b> or <span>
				if (format.remove != 'none') {
					removeNode(node, format);
					return TRUE;
				}
			}
	
			/**
			 * Removes the node and wrap it's children in paragraphs before doing so or
			 * appends BR elements to the beginning/end of the block element if forcedRootBlocks is disabled.
			 *
			 * If the div in the node below gets removed:
			 *  text<div>text</div>text
			 *
			 * Output becomes:
			 *  text<div><br />text<br /></div>text
			 *
			 * So when the div is removed the result is:
			 *  text<br />text<br />text
			 *
			 * @private
			 * @param {Node} node Node to remove + apply BR/P elements to.
			 * @param {Object} format Format rule.
			 * @return {Node} Input node.
			 */
			function removeNode(node, format) {
				var parentNode = node.parentNode, rootBlockElm;
	
				function find(node, next, inc) {
					node = getNonWhiteSpaceSibling(node, next, inc);
	
					return !node || (node.nodeName == 'BR' || isBlock(node));
				}
	
				if (format.block) {
					if (!forcedRootBlock) {
						// Append BR elements if needed before we remove the block
						if (isBlock(node) && !isBlock(parentNode)) {
							if (!find(node, FALSE) && !find(node.firstChild, TRUE, 1)) {
								node.insertBefore(dom.create('br'), node.firstChild);
							}
	
							if (!find(node, TRUE) && !find(node.lastChild, FALSE, 1)) {
								node.appendChild(dom.create('br'));
							}
						}
					} else {
						// Wrap the block in a forcedRootBlock if we are at the root of document
						if (parentNode == dom.getRoot()) {
							if (!format.list_block || !isEq(node, format.list_block)) {
								each(grep(node.childNodes), function(node) {
									if (isValid(forcedRootBlock, node.nodeName.toLowerCase())) {
										if (!rootBlockElm) {
											rootBlockElm = wrap(node, forcedRootBlock);
											dom.setAttribs(rootBlockElm, ed.settings.forced_root_block_attrs);
										} else {
											rootBlockElm.appendChild(node);
										}
									} else {
										rootBlockElm = 0;
									}
								});
							}
						}
					}
				}
	
				// Never remove nodes that isn't the specified inline element if a selector is specified too
				if (format.selector && format.inline && !isEq(format.inline, node)) {
					return;
				}
	
				dom.remove(node, 1);
			}
	
			/**
			 * Returns the next/previous non whitespace node.
			 *
			 * @private
			 * @param {Node} node Node to start at.
			 * @param {boolean} next (Optional) Include next or previous node defaults to previous.
			 * @param {boolean} inc (Optional) Include the current node in checking. Defaults to false.
			 * @return {Node} Next or previous node or undefined if it wasn't found.
			 */
			function getNonWhiteSpaceSibling(node, next, inc) {
				if (node) {
					next = next ? 'nextSibling' : 'previousSibling';
	
					for (node = inc ? node : node[next]; node; node = node[next]) {
						if (node.nodeType == 1 || !isWhiteSpaceNode(node)) {
							return node;
						}
					}
				}
			}
	
			/**
			 * Merges the next/previous sibling element if they match.
			 *
			 * @private
			 * @param {Node} prev Previous node to compare/merge.
			 * @param {Node} next Next node to compare/merge.
			 * @return {Node} Next node if we didn't merge and prev node if we did.
			 */
			function mergeSiblings(prev, next) {
				var sibling, tmpSibling, elementUtils = new ElementUtils(dom);
	
				function findElementSibling(node, sibling_name) {
					for (sibling = node; sibling; sibling = sibling[sibling_name]) {
						if (sibling.nodeType == 3 && sibling.nodeValue.length !== 0) {
							return node;
						}
	
						if (sibling.nodeType == 1 && !isBookmarkNode(sibling)) {
							return sibling;
						}
					}
	
					return node;
				}
	
				// Check if next/prev exists and that they are elements
				if (prev && next) {
					// If previous sibling is empty then jump over it
					prev = findElementSibling(prev, 'previousSibling');
					next = findElementSibling(next, 'nextSibling');
	
					// Compare next and previous nodes
					if (elementUtils.compare(prev, next)) {
						// Append nodes between
						for (sibling = prev.nextSibling; sibling && sibling != next;) {
							tmpSibling = sibling;
							sibling = sibling.nextSibling;
							prev.appendChild(tmpSibling);
						}
	
						// Remove next node
						dom.remove(next);
	
						// Move children into prev node
						each(grep(next.childNodes), function(node) {
							prev.appendChild(node);
						});
	
						return prev;
					}
				}
	
				return next;
			}
	
			function getContainer(rng, start) {
				var container, offset, lastIdx;
	
				container = rng[start ? 'startContainer' : 'endContainer'];
				offset = rng[start ? 'startOffset' : 'endOffset'];
	
				if (container.nodeType == 1) {
					lastIdx = container.childNodes.length - 1;
	
					if (!start && offset) {
						offset--;
					}
	
					container = container.childNodes[offset > lastIdx ? lastIdx : offset];
				}
	
				// If start text node is excluded then walk to the next node
				if (container.nodeType === 3 && start && offset >= container.nodeValue.length) {
					container = new TreeWalker(container, ed.getBody()).next() || container;
				}
	
				// If end text node is excluded then walk to the previous node
				if (container.nodeType === 3 && !start && offset === 0) {
					container = new TreeWalker(container, ed.getBody()).prev() || container;
				}
	
				return container;
			}
	
			function performCaretAction(type, name, vars, similar) {
				var caretContainerId = '_mce_caret', debug = ed.settings.caret_debug;
	
				// Creates a caret container bogus element
				function createCaretContainer(fill) {
					var caretContainer = dom.create('span', {id: caretContainerId, 'data-mce-bogus': true, style: debug ? 'color:red' : ''});
	
					if (fill) {
						caretContainer.appendChild(ed.getDoc().createTextNode(INVISIBLE_CHAR));
					}
	
					return caretContainer;
				}
	
				function isCaretContainerEmpty(node, nodes) {
					while (node) {
						if ((node.nodeType === 3 && node.nodeValue !== INVISIBLE_CHAR) || node.childNodes.length > 1) {
							return false;
						}
	
						// Collect nodes
						if (nodes && node.nodeType === 1) {
							nodes.push(node);
						}
	
						node = node.firstChild;
					}
	
					return true;
				}
	
				// Returns any parent caret container element
				function getParentCaretContainer(node) {
					while (node) {
						if (node.id === caretContainerId) {
							return node;
						}
	
						node = node.parentNode;
					}
				}
	
				// Finds the first text node in the specified node
				function findFirstTextNode(node) {
					var walker;
	
					if (node) {
						walker = new TreeWalker(node, node);
	
						for (node = walker.current(); node; node = walker.next()) {
							if (node.nodeType === 3) {
								return node;
							}
						}
					}
				}
	
				// Removes the caret container for the specified node or all on the current document
				function removeCaretContainer(node, move_caret) {
					var child, rng;
	
					if (!node) {
						node = getParentCaretContainer(selection.getStart());
	
						if (!node) {
							while ((node = dom.get(caretContainerId))) {
								removeCaretContainer(node, false);
							}
						}
					} else {
						rng = selection.getRng(true);
	
						if (isCaretContainerEmpty(node)) {
							if (move_caret !== false) {
								rng.setStartBefore(node);
								rng.setEndBefore(node);
							}
	
							dom.remove(node);
						} else {
							child = findFirstTextNode(node);
	
							if (child.nodeValue.charAt(0) === INVISIBLE_CHAR) {
								child.deleteData(0, 1);
	
								// Fix for bug #6976
								if (rng.startContainer == child && rng.startOffset > 0) {
									rng.setStart(child, rng.startOffset - 1);
								}
	
								if (rng.endContainer == child && rng.endOffset > 0) {
									rng.setEnd(child, rng.endOffset - 1);
								}
							}
	
							dom.remove(node, 1);
						}
	
						selection.setRng(rng);
					}
				}
	
				// Applies formatting to the caret position
				function applyCaretFormat() {
					var rng, caretContainer, textNode, offset, bookmark, container, text;
	
					rng = selection.getRng(true);
					offset = rng.startOffset;
					container = rng.startContainer;
					text = container.nodeValue;
	
					caretContainer = getParentCaretContainer(selection.getStart());
					if (caretContainer) {
						textNode = findFirstTextNode(caretContainer);
					}
	
					// Expand to word is caret is in the middle of a text node and the char before/after is a alpha numeric character
					if (text && offset > 0 && offset < text.length && /\w/.test(text.charAt(offset)) && /\w/.test(text.charAt(offset - 1))) {
						// Get bookmark of caret position
						bookmark = selection.getBookmark();
	
						// Collapse bookmark range (WebKit)
						rng.collapse(true);
	
						// Expand the range to the closest word and split it at those points
						rng = expandRng(rng, get(name));
						rng = rangeUtils.split(rng);
	
						// Apply the format to the range
						apply(name, vars, rng);
	
						// Move selection back to caret position
						selection.moveToBookmark(bookmark);
					} else {
						if (!caretContainer || textNode.nodeValue !== INVISIBLE_CHAR) {
							caretContainer = createCaretContainer(true);
							textNode = caretContainer.firstChild;
	
							rng.insertNode(caretContainer);
							offset = 1;
	
							apply(name, vars, caretContainer);
						} else {
							apply(name, vars, caretContainer);
						}
	
						// Move selection to text node
						selection.setCursorLocation(textNode, offset);
					}
				}
	
				function removeCaretFormat() {
					var rng = selection.getRng(true), container, offset, bookmark,
						hasContentAfter, node, formatNode, parents = [], i, caretContainer;
	
					container = rng.startContainer;
					offset = rng.startOffset;
					node = container;
	
					if (container.nodeType == 3) {
						if (offset != container.nodeValue.length) {
							hasContentAfter = true;
						}
	
						node = node.parentNode;
					}
	
					while (node) {
						if (matchNode(node, name, vars, similar)) {
							formatNode = node;
							break;
						}
	
						if (node.nextSibling) {
							hasContentAfter = true;
						}
	
						parents.push(node);
						node = node.parentNode;
					}
	
					// Node doesn't have the specified format
					if (!formatNode) {
						return;
					}
	
					// Is there contents after the caret then remove the format on the element
					if (hasContentAfter) {
						// Get bookmark of caret position
						bookmark = selection.getBookmark();
	
						// Collapse bookmark range (WebKit)
						rng.collapse(true);
	
						// Expand the range to the closest word and split it at those points
						rng = expandRng(rng, get(name), true);
						rng = rangeUtils.split(rng);
	
						// Remove the format from the range
						remove(name, vars, rng);
	
						// Move selection back to caret position
						selection.moveToBookmark(bookmark);
					} else {
						caretContainer = createCaretContainer();
	
						node = caretContainer;
						for (i = parents.length - 1; i >= 0; i--) {
							node.appendChild(dom.clone(parents[i], false));
							node = node.firstChild;
						}
	
						// Insert invisible character into inner most format element
						node.appendChild(dom.doc.createTextNode(INVISIBLE_CHAR));
						node = node.firstChild;
	
						var block = dom.getParent(formatNode, isTextBlock);
	
						if (block && dom.isEmpty(block)) {
							// Replace formatNode with caretContainer when removing format from empty block like <p><b>|</b></p>
							formatNode.parentNode.replaceChild(caretContainer, formatNode);
						} else {
							// Insert caret container after the formatted node
							dom.insertAfter(caretContainer, formatNode);
						}
	
						// Move selection to text node
						selection.setCursorLocation(node, 1);
	
						// If the formatNode is empty, we can remove it safely.
						if (dom.isEmpty(formatNode)) {
							dom.remove(formatNode);
						}
					}
				}
	
				// Checks if the parent caret container node isn't empty if that is the case it
				// will remove the bogus state on all children that isn't empty
				function unmarkBogusCaretParents() {
					var caretContainer;
	
					caretContainer = getParentCaretContainer(selection.getStart());
					if (caretContainer && !dom.isEmpty(caretContainer)) {
						walk(caretContainer, function(node) {
							if (node.nodeType == 1 && node.id !== caretContainerId && !dom.isEmpty(node)) {
								dom.setAttrib(node, 'data-mce-bogus', null);
							}
						}, 'childNodes');
					}
				}
	
				// Only bind the caret events once
				if (!ed._hasCaretEvents) {
					// Mark current caret container elements as bogus when getting the contents so we don't end up with empty elements
					markCaretContainersBogus = function() {
						var nodes = [], i;
	
						if (isCaretContainerEmpty(getParentCaretContainer(selection.getStart()), nodes)) {
							// Mark children
							i = nodes.length;
							while (i--) {
								dom.setAttrib(nodes[i], 'data-mce-bogus', '1');
							}
						}
					};
	
					disableCaretContainer = function(e) {
						var keyCode = e.keyCode;
	
						removeCaretContainer();
	
						// Remove caret container if it's empty
						if (keyCode == 8 && selection.isCollapsed() && selection.getStart().innerHTML == INVISIBLE_CHAR) {
							removeCaretContainer(getParentCaretContainer(selection.getStart()));
						}
	
						// Remove caret container on keydown and it's left/right arrow keys
						if (keyCode == 37 || keyCode == 39) {
							removeCaretContainer(getParentCaretContainer(selection.getStart()));
						}
	
						unmarkBogusCaretParents();
					};
	
					// Remove bogus state if they got filled by contents using editor.selection.setContent
					ed.on('SetContent', function(e) {
						if (e.selection) {
							unmarkBogusCaretParents();
						}
					});
					ed._hasCaretEvents = true;
				}
	
				// Do apply or remove caret format
				if (type == "apply") {
					applyCaretFormat();
				} else {
					removeCaretFormat();
				}
			}
	
			/**
			 * Moves the start to the first suitable text node.
			 */
			function moveStart(rng) {
				var container = rng.startContainer,
						offset = rng.startOffset, isAtEndOfText,
						walker, node, nodes, tmpNode;
	
				if (rng.startContainer == rng.endContainer) {
					if (isInlineBlock(rng.startContainer.childNodes[rng.startOffset])) {
						return;
					}
				}
	
				// Convert text node into index if possible
				if (container.nodeType == 3 && offset >= container.nodeValue.length) {
					// Get the parent container location and walk from there
					offset = nodeIndex(container);
					container = container.parentNode;
					isAtEndOfText = true;
				}
	
				// Move startContainer/startOffset in to a suitable node
				if (container.nodeType == 1) {
					nodes = container.childNodes;
					container = nodes[Math.min(offset, nodes.length - 1)];
					walker = new TreeWalker(container, dom.getParent(container, dom.isBlock));
	
					// If offset is at end of the parent node walk to the next one
					if (offset > nodes.length - 1 || isAtEndOfText) {
						walker.next();
					}
	
					for (node = walker.current(); node; node = walker.next()) {
						if (node.nodeType == 3 && !isWhiteSpaceNode(node)) {
							// IE has a "neat" feature where it moves the start node into the closest element
							// we can avoid this by inserting an element before it and then remove it after we set the selection
							tmpNode = dom.create('a', {'data-mce-bogus': 'all'}, INVISIBLE_CHAR);
							node.parentNode.insertBefore(tmpNode, node);
	
							// Set selection and remove tmpNode
							rng.setStart(node, 0);
							selection.setRng(rng);
							dom.remove(tmpNode);
	
							return;
						}
					}
				}
			}
		};
	});
	
	// Included from: js/tinymce/classes/undo/Diff.js
	
	/**
	 * Diff.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2016 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * JS Implementation of the O(ND) Difference Algorithm by Eugene W. Myers.
	 *
	 * @class tinymce.undo.Diff
	 * @private
	 */
	define("tinymce/undo/Diff", [
	], function () {
		var KEEP = 0, INSERT = 1, DELETE = 2;
	
		var diff = function (left, right) {
			var size = left.length + right.length + 2;
			var vDown = new Array(size);
			var vUp = new Array(size);
	
			var snake = function (start, end, diag) {
				return {
					start: start,
					end: end,
					diag: diag
				};
			};
	
			var buildScript = function (start1, end1, start2, end2, script) {
				var middle = getMiddleSnake(start1, end1, start2, end2);
	
				if (middle === null || middle.start === end1 && middle.diag === end1 - end2 ||
					middle.end === start1 && middle.diag === start1 - start2) {
					var i = start1;
					var j = start2;
					while (i < end1 || j < end2) {
						if (i < end1 && j < end2 && left[i] === right[j]) {
							script.push([KEEP, left[i]]);
							++i;
							++j;
						} else {
							if (end1 - start1 > end2 - start2) {
								script.push([DELETE, left[i]]);
								++i;
							} else {
								script.push([INSERT, right[j]]);
								++j;
							}
						}
					}
				} else {
					buildScript(start1, middle.start, start2, middle.start - middle.diag, script);
					for (var i2 = middle.start; i2 < middle.end; ++i2) {
						script.push([KEEP, left[i2]]);
					}
					buildScript(middle.end, end1, middle.end - middle.diag, end2, script);
				}
			};
	
			var buildSnake = function (start, diag, end1, end2) {
				var end = start;
				while (end - diag < end2 && end < end1 && left[end] === right[end - diag]) {
					++end;
				}
				return snake(start, end, diag);
			};
	
			var getMiddleSnake = function (start1, end1, start2, end2) {
				// Myers Algorithm
				// Initialisations
				var m = end1 - start1;
				var n = end2 - start2;
				if (m === 0 || n === 0) {
					return null;
				}
	
				var delta = m - n;
				var sum = n + m;
				var offset = (sum % 2 === 0 ? sum : sum + 1) / 2;
				vDown[1 + offset] = start1;
				vUp[1 + offset] = end1 + 1;
	
				for (var d = 0; d <= offset; ++d) {
					// Down
					for (var k = -d; k <= d; k += 2) {
						// First step
	
						var i = k + offset;
						if (k === -d || k != d && vDown[i - 1] < vDown[i + 1]) {
							vDown[i] = vDown[i + 1];
						} else {
							vDown[i] = vDown[i - 1] + 1;
						}
	
						var x = vDown[i];
						var y = x - start1 + start2 - k;
	
						while (x < end1 && y < end2 && left[x] === right[y]) {
							vDown[i] = ++x;
							++y;
						}
						// Second step
						if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {
							if (vUp[i - delta] <= vDown[i]) {
								return buildSnake(vUp[i - delta], k + start1 - start2, end1, end2);
							}
						}
					}
	
					// Up
					for (k = delta - d; k <= delta + d; k += 2) {
						// First step
						i = k + offset - delta;
						if (k === delta - d || k != delta + d && vUp[i + 1] <= vUp[i - 1]) {
							vUp[i] = vUp[i + 1] - 1;
						} else {
							vUp[i] = vUp[i - 1];
						}
	
						x = vUp[i] - 1;
						y = x - start1 + start2 - k;
						while (x >= start1 && y >= start2 && left[x] === right[y]) {
							vUp[i] = x--;
							y--;
						}
						// Second step
						if (delta % 2 === 0 && -d <= k && k <= d) {
							if (vUp[i] <= vDown[i + delta]) {
								return buildSnake(vUp[i], k + start1 - start2, end1, end2);
							}
						}
					}
				}
			};
	
			var script = [];
			buildScript(0, left.length, 0, right.length, script);
			return script;
		};
	
		return {
			KEEP: KEEP,
			DELETE: DELETE,
			INSERT: INSERT,
			diff: diff
		};
	});
	
	// Included from: js/tinymce/classes/undo/Fragments.js
	
	/**
	 * Fragments.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2016 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This module reads and applies html fragments from/to dom nodes.
	 *
	 * @class tinymce.undo.Fragments
	 * @private
	 */
	define("tinymce/undo/Fragments", [
		"tinymce/util/Arr",
		"tinymce/html/Entities",
		"tinymce/undo/Diff"
	], function (Arr, Entities, Diff) {
		var getOuterHtml = function (elm) {
			if (elm.nodeType === 1) {
				return elm.outerHTML;
			} else if (elm.nodeType === 3) {
				return Entities.encodeRaw(elm.data, false);
			} else if (elm.nodeType === 8) {
				return '<!--' + elm.data + '-->';
			}
	
			return '';
		};
	
		var createFragment = function(html) {
			var frag, node, container;
	
			container = document.createElement("div");
			frag = document.createDocumentFragment();
	
			if (html) {
				container.innerHTML = html;
			}
	
			while ((node = container.firstChild)) {
				frag.appendChild(node);
			}
	
			return frag;
		};
	
		var insertAt = function (elm, html, index) {
			var fragment = createFragment(html);
			if (elm.hasChildNodes() && index < elm.childNodes.length) {
				var target = elm.childNodes[index];
				target.parentNode.insertBefore(fragment, target);
			} else {
				elm.appendChild(fragment);
			}
		};
	
		var removeAt = function (elm, index) {
			if (elm.hasChildNodes() && index < elm.childNodes.length) {
				var target = elm.childNodes[index];
				target.parentNode.removeChild(target);
			}
		};
	
		var applyDiff = function (diff, elm) {
			var index = 0;
			Arr.each(diff, function (action) {
				if (action[0] === Diff.KEEP) {
					index++;
				} else if (action[0] === Diff.INSERT) {
					insertAt(elm, action[1], index);
					index++;
				} else if (action[0] === Diff.DELETE) {
					removeAt(elm, index);
				}
			});
		};
	
		var read = function (elm) {
			return Arr.map(elm.childNodes, getOuterHtml);
		};
	
		var write = function (fragments, elm) {
			var currentFragments = Arr.map(elm.childNodes, getOuterHtml);
			applyDiff(Diff.diff(currentFragments, fragments), elm);
			return elm;
		};
	
		return {
			read: read,
			write: write
		};
	});
	
	// Included from: js/tinymce/classes/undo/Levels.js
	
	/**
	 * Levels.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2016 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This module handles getting/setting undo levels to/from editor instances.
	 *
	 * @class tinymce.undo.Levels
	 * @private
	 */
	define("tinymce/undo/Levels", [
		"tinymce/util/Arr",
		"tinymce/undo/Fragments"
	], function (Arr, Fragments) {
		var hasIframes = function (html) {
			return html.indexOf('</iframe>') !== -1;
		};
	
		var createFragmentedLevel = function (fragments) {
			return {
				type: 'fragmented',
				fragments: fragments,
				content: '',
				bookmark: null,
				beforeBookmark: null
			};
		};
	
		var createCompleteLevel = function (content) {
			return {
				type: 'complete',
				fragments: null,
				content: content,
				bookmark: null,
				beforeBookmark: null
			};
		};
	
		var createFromEditor = function (editor) {
			var fragments, content;
	
			fragments = Fragments.read(editor.getBody());
			content = Arr.map(fragments, function (html) {
				return editor.serializer.trimContent(html);
			}).join('');
	
			return hasIframes(content) ? createFragmentedLevel(fragments) : createCompleteLevel(content);
		};
	
		var applyToEditor = function (editor, level, before) {
			if (level.type === 'fragmented') {
				Fragments.write(level.fragments, editor.getBody());
			} else {
				editor.setContent(level.content, {format: 'raw'});
			}
	
			editor.selection.moveToBookmark(before ? level.beforeBookmark : level.bookmark);
		};
	
		var getLevelContent = function (level) {
			return level.type === 'fragmented' ? level.fragments.join('') : level.content;
		};
	
		var isEq = function (level1, level2) {
			return getLevelContent(level1) === getLevelContent(level2);
		};
	
		return {
			createFragmentedLevel: createFragmentedLevel,
			createCompleteLevel: createCompleteLevel,
			createFromEditor: createFromEditor,
			applyToEditor: applyToEditor,
			isEq: isEq
		};
	});
	
	// Included from: js/tinymce/classes/UndoManager.js
	
	/**
	 * UndoManager.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This class handles the undo/redo history levels for the editor. Since the built-in undo/redo has major drawbacks a custom one was needed.
	 *
	 * @class tinymce.UndoManager
	 */
	define("tinymce/UndoManager", [
		"tinymce/util/VK",
		"tinymce/util/Tools",
		"tinymce/undo/Levels",
		"tinymce/Env"
	], function(VK, Tools, Levels, Env) {
		return function(editor) {
			var self = this, index = 0, data = [], beforeBookmark, isFirstTypedCharacter, locks = 0;
	
			function setDirty(state) {
				editor.setDirty(state);
			}
	
			function addNonTypingUndoLevel(e) {
				self.typing = false;
				self.add({}, e);
			}
	
			function endTyping() {
				if (self.typing) {
					self.typing = false;
					self.add();
				}
			}
	
			// Add initial undo level when the editor is initialized
			editor.on('init', function() {
				self.add();
			});
	
			// Get position before an execCommand is processed
			editor.on('BeforeExecCommand', function(e) {
				var cmd = e.command;
	
				if (cmd !== 'Undo' && cmd !== 'Redo' && cmd !== 'mceRepaint') {
					endTyping();
					self.beforeChange();
				}
			});
	
			// Add undo level after an execCommand call was made
			editor.on('ExecCommand', function(e) {
				var cmd = e.command;
	
				if (cmd !== 'Undo' && cmd !== 'Redo' && cmd !== 'mceRepaint') {
					addNonTypingUndoLevel(e);
				}
			});
	
			editor.on('ObjectResizeStart Cut', function() {
				self.beforeChange();
			});
	
			editor.on('SaveContent ObjectResized blur', addNonTypingUndoLevel);
			editor.on('DragEnd', addNonTypingUndoLevel);
	
			editor.on('KeyUp', function(e) {
				var keyCode = e.keyCode;
	
				// If key is prevented then don't add undo level
				// This would happen on keyboard shortcuts for example
				if (e.isDefaultPrevented()) {
					return;
				}
	
				if ((keyCode >= 33 && keyCode <= 36) || (keyCode >= 37 && keyCode <= 40) || keyCode === 45 || e.ctrlKey) {
					addNonTypingUndoLevel();
					editor.nodeChanged();
				}
	
				if (keyCode === 46 || keyCode === 8 || (Env.mac && (keyCode === 91 || keyCode === 93))) {
					editor.nodeChanged();
				}
	
				// Fire a TypingUndo event on the first character entered
				if (isFirstTypedCharacter && self.typing) {
					// Make it dirty if the content was changed after typing the first character
					if (!editor.isDirty()) {
						setDirty(data[0] && !Levels.isEq(Levels.createFromEditor(editor), data[0]));
	
						// Fire initial change event
						if (editor.isDirty()) {
							editor.fire('change', {level: data[0], lastLevel: null});
						}
					}
	
					editor.fire('TypingUndo');
					isFirstTypedCharacter = false;
					editor.nodeChanged();
				}
			});
	
			editor.on('KeyDown', function(e) {
				var keyCode = e.keyCode;
	
				// If key is prevented then don't add undo level
				// This would happen on keyboard shortcuts for example
				if (e.isDefaultPrevented()) {
					return;
				}
	
				// Is character position keys left,right,up,down,home,end,pgdown,pgup,enter
				if ((keyCode >= 33 && keyCode <= 36) || (keyCode >= 37 && keyCode <= 40) || keyCode === 45) {
					if (self.typing) {
						addNonTypingUndoLevel(e);
					}
	
					return;
				}
	
				// If key isn't Ctrl+Alt/AltGr
				var modKey = (e.ctrlKey && !e.altKey) || e.metaKey;
				if ((keyCode < 16 || keyCode > 20) && keyCode !== 224 && keyCode !== 91 && !self.typing && !modKey) {
					self.beforeChange();
					self.typing = true;
					self.add({}, e);
					isFirstTypedCharacter = true;
				}
			});
	
			editor.on('MouseDown', function(e) {
				if (self.typing) {
					addNonTypingUndoLevel(e);
				}
			});
	
			// Add keyboard shortcuts for undo/redo keys
			editor.addShortcut('meta+z', '', 'Undo');
			editor.addShortcut('meta+y,meta+shift+z', '', 'Redo');
	
			editor.on('AddUndo Undo Redo ClearUndos', function(e) {
				if (!e.isDefaultPrevented()) {
					editor.nodeChanged();
				}
			});
	
			/*eslint consistent-this:0 */
			self = {
				// Explode for debugging reasons
				data: data,
	
				/**
				 * State if the user is currently typing or not. This will add a typing operation into one undo
				 * level instead of one new level for each keystroke.
				 *
				 * @field {Boolean} typing
				 */
				typing: false,
	
				/**
				 * Stores away a bookmark to be used when performing an undo action so that the selection is before
				 * the change has been made.
				 *
				 * @method beforeChange
				 */
				beforeChange: function() {
					if (!locks) {
						beforeBookmark = editor.selection.getBookmark(2, true);
					}
				},
	
				/**
				 * Adds a new undo level/snapshot to the undo list.
				 *
				 * @method add
				 * @param {Object} level Optional undo level object to add.
				 * @param {DOMEvent} event Optional event responsible for the creation of the undo level.
				 * @return {Object} Undo level that got added or null it a level wasn't needed.
				 */
				add: function(level, event) {
					var i, settings = editor.settings, lastLevel, currentLevel;
	
					currentLevel = Levels.createFromEditor(editor);
					level = level || {};
					level = Tools.extend(level, currentLevel);
	
					if (locks || editor.removed) {
						return null;
					}
	
					lastLevel = data[index];
					if (editor.fire('BeforeAddUndo', {level: level, lastLevel: lastLevel, originalEvent: event}).isDefaultPrevented()) {
						return null;
					}
	
					// Add undo level if needed
					if (lastLevel && Levels.isEq(lastLevel, level)) {
						return null;
					}
	
					// Set before bookmark on previous level
					if (data[index]) {
						data[index].beforeBookmark = beforeBookmark;
					}
	
					// Time to compress
					if (settings.custom_undo_redo_levels) {
						if (data.length > settings.custom_undo_redo_levels) {
							for (i = 0; i < data.length - 1; i++) {
								data[i] = data[i + 1];
							}
	
							data.length--;
							index = data.length;
						}
					}
	
					// Get a non intrusive normalized bookmark
					level.bookmark = editor.selection.getBookmark(2, true);
	
					// Crop array if needed
					if (index < data.length - 1) {
						data.length = index + 1;
					}
	
					data.push(level);
					index = data.length - 1;
	
					var args = {level: level, lastLevel: lastLevel, originalEvent: event};
	
					editor.fire('AddUndo', args);
	
					if (index > 0) {
						setDirty(true);
						editor.fire('change', args);
					}
	
					return level;
				},
	
				/**
				 * Undoes the last action.
				 *
				 * @method undo
				 * @return {Object} Undo level or null if no undo was performed.
				 */
				undo: function() {
					var level;
	
					if (self.typing) {
						self.add();
						self.typing = false;
					}
	
					if (index > 0) {
						level = data[--index];
						Levels.applyToEditor(editor, level, true);
						setDirty(true);
						editor.fire('undo', {level: level});
					}
	
					return level;
				},
	
				/**
				 * Redoes the last action.
				 *
				 * @method redo
				 * @return {Object} Redo level or null if no redo was performed.
				 */
				redo: function() {
					var level;
	
					if (index < data.length - 1) {
						level = data[++index];
						Levels.applyToEditor(editor, level, false);
						setDirty(true);
						editor.fire('redo', {level: level});
					}
	
					return level;
				},
	
				/**
				 * Removes all undo levels.
				 *
				 * @method clear
				 */
				clear: function() {
					data = [];
					index = 0;
					self.typing = false;
					self.data = data;
					editor.fire('ClearUndos');
				},
	
				/**
				 * Returns true/false if the undo manager has any undo levels.
				 *
				 * @method hasUndo
				 * @return {Boolean} true/false if the undo manager has any undo levels.
				 */
				hasUndo: function() {
					// Has undo levels or typing and content isn't the same as the initial level
					return index > 0 || (self.typing && data[0] && !Levels.isEq(Levels.createFromEditor(editor), data[0]));
				},
	
				/**
				 * Returns true/false if the undo manager has any redo levels.
				 *
				 * @method hasRedo
				 * @return {Boolean} true/false if the undo manager has any redo levels.
				 */
				hasRedo: function() {
					return index < data.length - 1 && !self.typing;
				},
	
				/**
				 * Executes the specified mutator function as an undo transaction. The selection
				 * before the modification will be stored to the undo stack and if the DOM changes
				 * it will add a new undo level. Any methods within the translation that adds undo levels will
				 * be ignored. So a translation can include calls to execCommand or editor.insertContent.
				 *
				 * @method transact
				 * @param {function} callback Function that gets executed and has dom manipulation logic in it.
				 * @return {Object} Undo level that got added or null it a level wasn't needed.
				 */
				transact: function(callback) {
					endTyping();
					self.beforeChange();
	
					try {
						locks++;
						callback();
					} finally {
						locks--;
					}
	
					return self.add();
				},
	
				/**
				 * Adds an extra "hidden" undo level by first applying the first mutation and store that to the undo stack
				 * then roll back that change and do the second mutation on top of the stack. This will produce an extra
				 * undo level that the user doesn't see until they undo.
				 *
				 * @method extra
				 * @param {function} callback1 Function that does mutation but gets stored as a "hidden" extra undo level.
				 * @param {function} callback2 Function that does mutation but gets displayed to the user.
				 */
				extra: function (callback1, callback2) {
					var lastLevel, bookmark;
	
					if (self.transact(callback1)) {
						bookmark = data[index].bookmark;
						lastLevel = data[index - 1];
						Levels.applyToEditor(editor, lastLevel, true);
	
						if (self.transact(callback2)) {
							data[index - 1].beforeBookmark = bookmark;
						}
					}
				}
			};
	
			return self;
		};
	});
	
	// Included from: js/tinymce/classes/EnterKey.js
	
	/**
	 * EnterKey.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Contains logic for handling the enter key to split/generate block elements.
	 *
	 * @private
	 * @class tinymce.EnterKey
	 */
	define("tinymce/EnterKey", [
		"tinymce/dom/TreeWalker",
		"tinymce/dom/RangeUtils",
		"tinymce/caret/CaretContainer",
		"tinymce/Env"
	], function(TreeWalker, RangeUtils, CaretContainer, Env) {
		var isIE = Env.ie && Env.ie < 11;
	
		return function(editor) {
			var dom = editor.dom, selection = editor.selection, settings = editor.settings;
			var undoManager = editor.undoManager, schema = editor.schema, nonEmptyElementsMap = schema.getNonEmptyElements(),
				moveCaretBeforeOnEnterElementsMap = schema.getMoveCaretBeforeOnEnterElements();
	
			function handleEnterKey(evt) {
				var rng, tmpRng, editableRoot, container, offset, parentBlock, documentMode, shiftKey,
					newBlock, fragment, containerBlock, parentBlockName, containerBlockName, newBlockName, isAfterLastNodeInContainer;
	
				// Returns true if the block can be split into two blocks or not
				function canSplitBlock(node) {
					return node &&
						dom.isBlock(node) &&
						!/^(TD|TH|CAPTION|FORM)$/.test(node.nodeName) &&
						!/^(fixed|absolute)/i.test(node.style.position) &&
						dom.getContentEditable(node) !== "true";
				}
	
				function isTableCell(node) {
					return node && /^(TD|TH|CAPTION)$/.test(node.nodeName);
				}
	
				// Renders empty block on IE
				function renderBlockOnIE(block) {
					var oldRng;
	
					if (dom.isBlock(block)) {
						oldRng = selection.getRng();
						block.appendChild(dom.create('span', null, '\u00a0'));
						selection.select(block);
						block.lastChild.outerHTML = '';
						selection.setRng(oldRng);
					}
				}
	
				// Remove the first empty inline element of the block so this: <p><b><em></em></b>x</p> becomes this: <p>x</p>
				function trimInlineElementsOnLeftSideOfBlock(block) {
					var node = block, firstChilds = [], i;
	
					if (!node) {
						return;
					}
	
					// Find inner most first child ex: <p><i><b>*</b></i></p>
					while ((node = node.firstChild)) {
						if (dom.isBlock(node)) {
							return;
						}
	
						if (node.nodeType == 1 && !nonEmptyElementsMap[node.nodeName.toLowerCase()]) {
							firstChilds.push(node);
						}
					}
	
					i = firstChilds.length;
					while (i--) {
						node = firstChilds[i];
						if (!node.hasChildNodes() || (node.firstChild == node.lastChild && node.firstChild.nodeValue === '')) {
							dom.remove(node);
						} else {
							// Remove <a> </a> see #5381
							if (node.nodeName == "A" && (node.innerText || node.textContent) === ' ') {
								dom.remove(node);
							}
						}
					}
				}
	
				// Moves the caret to a suitable position within the root for example in the first non
				// pure whitespace text node or before an image
				function moveToCaretPosition(root) {
					var walker, node, rng, lastNode = root, tempElm;
					function firstNonWhiteSpaceNodeSibling(node) {
						while (node) {
							if (node.nodeType == 1 || (node.nodeType == 3 && node.data && /[\r\n\s]/.test(node.data))) {
								return node;
							}
	
							node = node.nextSibling;
						}
					}
	
					if (!root) {
						return;
					}
	
					// Old IE versions doesn't properly render blocks with br elements in them
					// For example <p><br></p> wont be rendered correctly in a contentEditable area
					// until you remove the br producing <p></p>
					if (Env.ie && Env.ie < 9 && parentBlock && parentBlock.firstChild) {
						if (parentBlock.firstChild == parentBlock.lastChild && parentBlock.firstChild.tagName == 'BR') {
							dom.remove(parentBlock.firstChild);
						}
					}
	
					if (/^(LI|DT|DD)$/.test(root.nodeName)) {
						var firstChild = firstNonWhiteSpaceNodeSibling(root.firstChild);
	
						if (firstChild && /^(UL|OL|DL)$/.test(firstChild.nodeName)) {
							root.insertBefore(dom.doc.createTextNode('\u00a0'), root.firstChild);
						}
					}
	
					rng = dom.createRng();
	
					// Normalize whitespace to remove empty text nodes. Fix for: #6904
					// Gecko will be able to place the caret in empty text nodes but it won't render propery
					// Older IE versions will sometimes crash so for now ignore all IE versions
					if (!Env.ie) {
						root.normalize();
					}
	
					if (root.hasChildNodes()) {
						walker = new TreeWalker(root, root);
	
						while ((node = walker.current())) {
							if (node.nodeType == 3) {
								rng.setStart(node, 0);
								rng.setEnd(node, 0);
								break;
							}
	
							if (moveCaretBeforeOnEnterElementsMap[node.nodeName.toLowerCase()]) {
								rng.setStartBefore(node);
								rng.setEndBefore(node);
								break;
							}
	
							lastNode = node;
							node = walker.next();
						}
	
						if (!node) {
							rng.setStart(lastNode, 0);
							rng.setEnd(lastNode, 0);
						}
					} else {
						if (root.nodeName == 'BR') {
							if (root.nextSibling && dom.isBlock(root.nextSibling)) {
								// Trick on older IE versions to render the caret before the BR between two lists
								if (!documentMode || documentMode < 9) {
									tempElm = dom.create('br');
									root.parentNode.insertBefore(tempElm, root);
								}
	
								rng.setStartBefore(root);
								rng.setEndBefore(root);
							} else {
								rng.setStartAfter(root);
								rng.setEndAfter(root);
							}
						} else {
							rng.setStart(root, 0);
							rng.setEnd(root, 0);
						}
					}
	
					selection.setRng(rng);
	
					// Remove tempElm created for old IE:s
					dom.remove(tempElm);
					selection.scrollIntoView(root);
				}
	
				function setForcedBlockAttrs(node) {
					var forcedRootBlockName = settings.forced_root_block;
	
					if (forcedRootBlockName && forcedRootBlockName.toLowerCase() === node.tagName.toLowerCase()) {
						dom.setAttribs(node, settings.forced_root_block_attrs);
					}
				}
	
				function emptyBlock(elm) {
					// BR is needed in empty blocks on non IE browsers
					elm.innerHTML = !isIE ? '<br data-mce-bogus="1">' : '';
				}
	
				// Creates a new block element by cloning the current one or creating a new one if the name is specified
				// This function will also copy any text formatting from the parent block and add it to the new one
				function createNewBlock(name) {
					var node = container, block, clonedNode, caretNode, textInlineElements = schema.getTextInlineElements();
	
					if (name || parentBlockName == "TABLE") {
						block = dom.create(name || newBlockName);
						setForcedBlockAttrs(block);
					} else {
						block = parentBlock.cloneNode(false);
					}
	
					caretNode = block;
	
					// Clone any parent styles
					if (settings.keep_styles !== false) {
						do {
							if (textInlineElements[node.nodeName]) {
								// Never clone a caret containers
								if (node.id == '_mce_caret') {
									continue;
								}
	
								clonedNode = node.cloneNode(false);
								dom.setAttrib(clonedNode, 'id', ''); // Remove ID since it needs to be document unique
	
								if (block.hasChildNodes()) {
									clonedNode.appendChild(block.firstChild);
									block.appendChild(clonedNode);
								} else {
									caretNode = clonedNode;
									block.appendChild(clonedNode);
								}
							}
						} while ((node = node.parentNode) && node != editableRoot);
					}
	
					// BR is needed in empty blocks on non IE browsers
					if (!isIE) {
						caretNode.innerHTML = '<br data-mce-bogus="1">';
					}
	
					return block;
				}
	
				// Returns true/false if the caret is at the start/end of the parent block element
				function isCaretAtStartOrEndOfBlock(start) {
					var walker, node, name;
	
					// Caret is in the middle of a text node like "a|b"
					if (container.nodeType == 3 && (start ? offset > 0 : offset < container.nodeValue.length)) {
						return false;
					}
	
					// If after the last element in block node edge case for #5091
					if (container.parentNode == parentBlock && isAfterLastNodeInContainer && !start) {
						return true;
					}
	
					// If the caret if before the first element in parentBlock
					if (start && container.nodeType == 1 && container == parentBlock.firstChild) {
						return true;
					}
	
					// Caret can be before/after a table
					if (container.nodeName === "TABLE" || (container.previousSibling && container.previousSibling.nodeName == "TABLE")) {
						return (isAfterLastNodeInContainer && !start) || (!isAfterLastNodeInContainer && start);
					}
	
					// Walk the DOM and look for text nodes or non empty elements
					walker = new TreeWalker(container, parentBlock);
	
					// If caret is in beginning or end of a text block then jump to the next/previous node
					if (container.nodeType == 3) {
						if (start && offset === 0) {
							walker.prev();
						} else if (!start && offset == container.nodeValue.length) {
							walker.next();
						}
					}
	
					while ((node = walker.current())) {
						if (node.nodeType === 1) {
							// Ignore bogus elements
							if (!node.getAttribute('data-mce-bogus')) {
								// Keep empty elements like <img /> <input /> but not trailing br:s like <p>text|<br></p>
								name = node.nodeName.toLowerCase();
								if (nonEmptyElementsMap[name] && name !== 'br') {
									return false;
								}
							}
						} else if (node.nodeType === 3 && !/^[ \t\r\n]*$/.test(node.nodeValue)) {
							return false;
						}
	
						if (start) {
							walker.prev();
						} else {
							walker.next();
						}
					}
	
					return true;
				}
	
				// Wraps any text nodes or inline elements in the specified forced root block name
				function wrapSelfAndSiblingsInDefaultBlock(container, offset) {
					var newBlock, parentBlock, startNode, node, next, rootBlockName, blockName = newBlockName || 'P';
	
					// Not in a block element or in a table cell or caption
					parentBlock = dom.getParent(container, dom.isBlock);
					if (!parentBlock || !canSplitBlock(parentBlock)) {
						parentBlock = parentBlock || editableRoot;
	
						if (parentBlock == editor.getBody() || isTableCell(parentBlock)) {
							rootBlockName = parentBlock.nodeName.toLowerCase();
						} else {
							rootBlockName = parentBlock.parentNode.nodeName.toLowerCase();
						}
	
						if (!parentBlock.hasChildNodes()) {
							newBlock = dom.create(blockName);
							setForcedBlockAttrs(newBlock);
							parentBlock.appendChild(newBlock);
							rng.setStart(newBlock, 0);
							rng.setEnd(newBlock, 0);
							return newBlock;
						}
	
						// Find parent that is the first child of parentBlock
						node = container;
						while (node.parentNode != parentBlock) {
							node = node.parentNode;
						}
	
						// Loop left to find start node start wrapping at
						while (node && !dom.isBlock(node)) {
							startNode = node;
							node = node.previousSibling;
						}
	
						if (startNode && schema.isValidChild(rootBlockName, blockName.toLowerCase())) {
							newBlock = dom.create(blockName);
							setForcedBlockAttrs(newBlock);
							startNode.parentNode.insertBefore(newBlock, startNode);
	
							// Start wrapping until we hit a block
							node = startNode;
							while (node && !dom.isBlock(node)) {
								next = node.nextSibling;
								newBlock.appendChild(node);
								node = next;
							}
	
							// Restore range to it's past location
							rng.setStart(container, offset);
							rng.setEnd(container, offset);
						}
					}
	
					return container;
				}
	
				// Inserts a block or br before/after or in the middle of a split list of the LI is empty
				function handleEmptyListItem() {
					function isFirstOrLastLi(first) {
						var node = containerBlock[first ? 'firstChild' : 'lastChild'];
	
						// Find first/last element since there might be whitespace there
						while (node) {
							if (node.nodeType == 1) {
								break;
							}
	
							node = node[first ? 'nextSibling' : 'previousSibling'];
						}
	
						return node === parentBlock;
					}
	
					function getContainerBlock() {
						var containerBlockParent = containerBlock.parentNode;
	
						if (/^(LI|DT|DD)$/.test(containerBlockParent.nodeName)) {
							return containerBlockParent;
						}
	
						return containerBlock;
					}
	
					if (containerBlock == editor.getBody()) {
						return;
					}
	
					// Check if we are in an nested list
					var containerBlockParentName = containerBlock.parentNode.nodeName;
					if (/^(OL|UL|LI)$/.test(containerBlockParentName)) {
						newBlockName = 'LI';
					}
	
					newBlock = newBlockName ? createNewBlock(newBlockName) : dom.create('BR');
	
					if (isFirstOrLastLi(true) && isFirstOrLastLi()) {
						if (containerBlockParentName == 'LI') {
							// Nested list is inside a LI
							dom.insertAfter(newBlock, getContainerBlock());
						} else {
							// Is first and last list item then replace the OL/UL with a text block
							dom.replace(newBlock, containerBlock);
						}
					} else if (isFirstOrLastLi(true)) {
						if (containerBlockParentName == 'LI') {
							// List nested in an LI then move the list to a new sibling LI
							dom.insertAfter(newBlock, getContainerBlock());
							newBlock.appendChild(dom.doc.createTextNode(' ')); // Needed for IE so the caret can be placed
							newBlock.appendChild(containerBlock);
						} else {
							// First LI in list then remove LI and add text block before list
							containerBlock.parentNode.insertBefore(newBlock, containerBlock);
						}
					} else if (isFirstOrLastLi()) {
						// Last LI in list then remove LI and add text block after list
						dom.insertAfter(newBlock, getContainerBlock());
						renderBlockOnIE(newBlock);
					} else {
						// Middle LI in list the split the list and insert a text block in the middle
						// Extract after fragment and insert it after the current block
						containerBlock = getContainerBlock();
						tmpRng = rng.cloneRange();
						tmpRng.setStartAfter(parentBlock);
						tmpRng.setEndAfter(containerBlock);
						fragment = tmpRng.extractContents();
	
						if (newBlockName == 'LI' && fragment.firstChild.nodeName == 'LI') {
							newBlock = fragment.firstChild;
							dom.insertAfter(fragment, containerBlock);
						} else {
							dom.insertAfter(fragment, containerBlock);
							dom.insertAfter(newBlock, containerBlock);
						}
					}
	
					dom.remove(parentBlock);
					moveToCaretPosition(newBlock);
					undoManager.add();
				}
	
				// Inserts a BR element if the forced_root_block option is set to false or empty string
				function insertBr() {
					editor.execCommand("InsertLineBreak", false, evt);
				}
	
				// Trims any linebreaks at the beginning of node user for example when pressing enter in a PRE element
				function trimLeadingLineBreaks(node) {
					do {
						if (node.nodeType === 3) {
							node.nodeValue = node.nodeValue.replace(/^[\r\n]+/, '');
						}
	
						node = node.firstChild;
					} while (node);
				}
	
				function getEditableRoot(node) {
					var root = dom.getRoot(), parent, editableRoot;
	
					// Get all parents until we hit a non editable parent or the root
					parent = node;
					while (parent !== root && dom.getContentEditable(parent) !== "false") {
						if (dom.getContentEditable(parent) === "true") {
							editableRoot = parent;
						}
	
						parent = parent.parentNode;
					}
	
					return parent !== root ? editableRoot : root;
				}
	
				// Adds a BR at the end of blocks that only contains an IMG or INPUT since
				// these might be floated and then they won't expand the block
				function addBrToBlockIfNeeded(block) {
					var lastChild;
	
					// IE will render the blocks correctly other browsers needs a BR
					if (!isIE) {
						block.normalize(); // Remove empty text nodes that got left behind by the extract
	
						// Check if the block is empty or contains a floated last child
						lastChild = block.lastChild;
						if (!lastChild || (/^(left|right)$/gi.test(dom.getStyle(lastChild, 'float', true)))) {
							dom.add(block, 'br');
						}
					}
				}
	
				function insertNewBlockAfter() {
					// If the caret is at the end of a header we produce a P tag after it similar to Word unless we are in a hgroup
					if (/^(H[1-6]|PRE|FIGURE)$/.test(parentBlockName) && containerBlockName != 'HGROUP') {
						newBlock = createNewBlock(newBlockName);
					} else {
						newBlock = createNewBlock();
					}
	
					// Split the current container block element if enter is pressed inside an empty inner block element
					if (settings.end_container_on_empty_block && canSplitBlock(containerBlock) && dom.isEmpty(parentBlock)) {
						// Split container block for example a BLOCKQUOTE at the current blockParent location for example a P
						newBlock = dom.split(containerBlock, parentBlock);
					} else {
						dom.insertAfter(newBlock, parentBlock);
					}
	
					moveToCaretPosition(newBlock);
				}
	
				rng = selection.getRng(true);
	
				// Event is blocked by some other handler for example the lists plugin
				if (evt.isDefaultPrevented()) {
					return;
				}
	
				// Delete any selected contents
				if (!rng.collapsed) {
					editor.execCommand('Delete');
					return;
				}
	
				// Setup range items and newBlockName
				new RangeUtils(dom).normalize(rng);
				container = rng.startContainer;
				offset = rng.startOffset;
				newBlockName = (settings.force_p_newlines ? 'p' : '') || settings.forced_root_block;
				newBlockName = newBlockName ? newBlockName.toUpperCase() : '';
				documentMode = dom.doc.documentMode;
				shiftKey = evt.shiftKey;
	
				// Resolve node index
				if (container.nodeType == 1 && container.hasChildNodes()) {
					isAfterLastNodeInContainer = offset > container.childNodes.length - 1;
	
					container = container.childNodes[Math.min(offset, container.childNodes.length - 1)] || container;
					if (isAfterLastNodeInContainer && container.nodeType == 3) {
						offset = container.nodeValue.length;
					} else {
						offset = 0;
					}
				}
	
				// Get editable root node, normally the body element but sometimes a div or span
				editableRoot = getEditableRoot(container);
	
				// If there is no editable root then enter is done inside a contentEditable false element
				if (!editableRoot) {
					return;
				}
	
				undoManager.beforeChange();
	
				// If editable root isn't block nor the root of the editor
				if (!dom.isBlock(editableRoot) && editableRoot != dom.getRoot()) {
					if (!newBlockName || shiftKey) {
						insertBr();
					}
	
					return;
				}
	
				// Wrap the current node and it's sibling in a default block if it's needed.
				// for example this <td>text|<b>text2</b></td> will become this <td><p>text|<b>text2</p></b></td>
				// This won't happen if root blocks are disabled or the shiftKey is pressed
				if ((newBlockName && !shiftKey) || (!newBlockName && shiftKey)) {
					container = wrapSelfAndSiblingsInDefaultBlock(container, offset);
				}
	
				// Find parent block and setup empty block paddings
				parentBlock = dom.getParent(container, dom.isBlock);
				containerBlock = parentBlock ? dom.getParent(parentBlock.parentNode, dom.isBlock) : null;
	
				// Setup block names
				parentBlockName = parentBlock ? parentBlock.nodeName.toUpperCase() : ''; // IE < 9 & HTML5
				containerBlockName = containerBlock ? containerBlock.nodeName.toUpperCase() : ''; // IE < 9 & HTML5
	
				// Enter inside block contained within a LI then split or insert before/after LI
				if (containerBlockName == 'LI' && !evt.ctrlKey) {
					parentBlock = containerBlock;
					parentBlockName = containerBlockName;
				}
	
				if (editor.undoManager.typing) {
					editor.undoManager.typing = false;
					editor.undoManager.add();
				}
	
				// Handle enter in list item
				if (/^(LI|DT|DD)$/.test(parentBlockName)) {
					if (!newBlockName && shiftKey) {
						insertBr();
						return;
					}
	
					// Handle enter inside an empty list item
					if (dom.isEmpty(parentBlock)) {
						handleEmptyListItem();
						return;
					}
				}
	
				// Don't split PRE tags but insert a BR instead easier when writing code samples etc
				if (parentBlockName == 'PRE' && settings.br_in_pre !== false) {
					if (!shiftKey) {
						insertBr();
						return;
					}
				} else {
					// If no root block is configured then insert a BR by default or if the shiftKey is pressed
					if ((!newBlockName && !shiftKey && parentBlockName != 'LI') || (newBlockName && shiftKey)) {
						insertBr();
						return;
					}
				}
	
				// If parent block is root then never insert new blocks
				if (newBlockName && parentBlock === editor.getBody()) {
					return;
				}
	
				// Default block name if it's not configured
				newBlockName = newBlockName || 'P';
	
				// Insert new block before/after the parent block depending on caret location
				if (CaretContainer.isCaretContainerBlock(parentBlock)) {
					newBlock = CaretContainer.showCaretContainerBlock(parentBlock);
				} else if (isCaretAtStartOrEndOfBlock()) {
					insertNewBlockAfter();
				} else if (isCaretAtStartOrEndOfBlock(true)) {
					// Insert new block before
					newBlock = parentBlock.parentNode.insertBefore(createNewBlock(), parentBlock);
					renderBlockOnIE(newBlock);
					moveToCaretPosition(parentBlock);
				} else {
					// Extract after fragment and insert it after the current block
					tmpRng = rng.cloneRange();
					tmpRng.setEndAfter(parentBlock);
					fragment = tmpRng.extractContents();
					trimLeadingLineBreaks(fragment);
					newBlock = fragment.firstChild;
					dom.insertAfter(fragment, parentBlock);
					trimInlineElementsOnLeftSideOfBlock(newBlock);
					addBrToBlockIfNeeded(parentBlock);
	
					if (dom.isEmpty(parentBlock)) {
						emptyBlock(parentBlock);
					}
	
					newBlock.normalize();
	
					// New block might become empty if it's <p><b>a |</b></p>
					if (dom.isEmpty(newBlock)) {
						dom.remove(newBlock);
						insertNewBlockAfter();
					} else {
						moveToCaretPosition(newBlock);
					}
				}
	
				dom.setAttrib(newBlock, 'id', ''); // Remove ID since it needs to be document unique
	
				// Allow custom handling of new blocks
				editor.fire('NewBlock', {newBlock: newBlock});
	
				undoManager.typing = false;
				undoManager.add();
			}
	
			editor.on('keydown', function(evt) {
				if (evt.keyCode == 13) {
					if (handleEnterKey(evt) !== false) {
						evt.preventDefault();
					}
				}
			});
		};
	});
	
	// Included from: js/tinymce/classes/ForceBlocks.js
	
	/**
	 * ForceBlocks.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Makes sure that everything gets wrapped in paragraphs.
	 *
	 * @private
	 * @class tinymce.ForceBlocks
	 */
	define("tinymce/ForceBlocks", [], function() {
		return function(editor) {
			var settings = editor.settings, dom = editor.dom, selection = editor.selection;
			var schema = editor.schema, blockElements = schema.getBlockElements();
	
			function addRootBlocks() {
				var node = selection.getStart(), rootNode = editor.getBody(), rng;
				var startContainer, startOffset, endContainer, endOffset, rootBlockNode;
				var tempNode, offset = -0xFFFFFF, wrapped, restoreSelection;
				var tmpRng, rootNodeName, forcedRootBlock;
	
				forcedRootBlock = settings.forced_root_block;
	
				if (!node || node.nodeType !== 1 || !forcedRootBlock) {
					return;
				}
	
				// Check if node is wrapped in block
				while (node && node != rootNode) {
					if (blockElements[node.nodeName]) {
						return;
					}
	
					node = node.parentNode;
				}
	
				// Get current selection
				rng = selection.getRng();
				if (rng.setStart) {
					startContainer = rng.startContainer;
					startOffset = rng.startOffset;
					endContainer = rng.endContainer;
					endOffset = rng.endOffset;
	
					try {
						restoreSelection = editor.getDoc().activeElement === rootNode;
					} catch (ex) {
						// IE throws unspecified error here sometimes
					}
				} else {
					// Force control range into text range
					if (rng.item) {
						node = rng.item(0);
						rng = editor.getDoc().body.createTextRange();
						rng.moveToElementText(node);
					}
	
					restoreSelection = rng.parentElement().ownerDocument === editor.getDoc();
					tmpRng = rng.duplicate();
					tmpRng.collapse(true);
					startOffset = tmpRng.move('character', offset) * -1;
	
					if (!tmpRng.collapsed) {
						tmpRng = rng.duplicate();
						tmpRng.collapse(false);
						endOffset = (tmpRng.move('character', offset) * -1) - startOffset;
					}
				}
	
				// Wrap non block elements and text nodes
				node = rootNode.firstChild;
				rootNodeName = rootNode.nodeName.toLowerCase();
				while (node) {
					// TODO: Break this up, too complex
					if (((node.nodeType === 3 || (node.nodeType == 1 && !blockElements[node.nodeName]))) &&
						schema.isValidChild(rootNodeName, forcedRootBlock.toLowerCase())) {
						// Remove empty text nodes
						if (node.nodeType === 3 && node.nodeValue.length === 0) {
							tempNode = node;
							node = node.nextSibling;
							dom.remove(tempNode);
							continue;
						}
	
						if (!rootBlockNode) {
							rootBlockNode = dom.create(forcedRootBlock, editor.settings.forced_root_block_attrs);
							node.parentNode.insertBefore(rootBlockNode, node);
							wrapped = true;
						}
	
						tempNode = node;
						node = node.nextSibling;
						rootBlockNode.appendChild(tempNode);
					} else {
						rootBlockNode = null;
						node = node.nextSibling;
					}
				}
	
				if (wrapped && restoreSelection) {
					if (rng.setStart) {
						rng.setStart(startContainer, startOffset);
						rng.setEnd(endContainer, endOffset);
						selection.setRng(rng);
					} else {
						// Only select if the previous selection was inside the document to prevent auto focus in quirks mode
						try {
							rng = editor.getDoc().body.createTextRange();
							rng.moveToElementText(rootNode);
							rng.collapse(true);
							rng.moveStart('character', startOffset);
	
							if (endOffset > 0) {
								rng.moveEnd('character', endOffset);
							}
	
							rng.select();
						} catch (ex) {
							// Ignore
						}
					}
	
					editor.nodeChanged();
				}
			}
	
			// Force root blocks
			if (settings.forced_root_block) {
				editor.on('NodeChange', addRootBlocks);
			}
		};
	});
	
	// Included from: js/tinymce/classes/caret/CaretUtils.js
	
	/**
	 * CaretUtils.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Utility functions shared by the caret logic.
	 *
	 * @private
	 * @class tinymce.caret.CaretUtils
	 */
	define("tinymce/caret/CaretUtils", [
		"tinymce/util/Fun",
		"tinymce/dom/TreeWalker",
		"tinymce/dom/NodeType",
		"tinymce/caret/CaretPosition",
		"tinymce/caret/CaretContainer",
		"tinymce/caret/CaretCandidate"
	], function(Fun, TreeWalker, NodeType, CaretPosition, CaretContainer, CaretCandidate) {
		var isContentEditableTrue = NodeType.isContentEditableTrue,
			isContentEditableFalse = NodeType.isContentEditableFalse,
			isBlockLike = NodeType.matchStyleValues('display', 'block table table-cell table-caption'),
			isCaretContainer = CaretContainer.isCaretContainer,
			isCaretContainerBlock = CaretContainer.isCaretContainerBlock,
			curry = Fun.curry,
			isElement = NodeType.isElement,
			isCaretCandidate = CaretCandidate.isCaretCandidate;
	
		function isForwards(direction) {
			return direction > 0;
		}
	
		function isBackwards(direction) {
			return direction < 0;
		}
	
		function skipCaretContainers(walk, shallow) {
			var node;
	
			while ((node = walk(shallow))) {
				if (!isCaretContainerBlock(node)) {
					return node;
				}
			}
	
			return null;
		}
	
		function findNode(node, direction, predicateFn, rootNode, shallow) {
			var walker = new TreeWalker(node, rootNode);
	
			if (isBackwards(direction)) {
				if (isContentEditableFalse(node) || isCaretContainerBlock(node)) {
					node = skipCaretContainers(walker.prev, true);
					if (predicateFn(node)) {
						return node;
					}
				}
	
				while ((node = skipCaretContainers(walker.prev, shallow))) {
					if (predicateFn(node)) {
						return node;
					}
				}
			}
	
			if (isForwards(direction)) {
				if (isContentEditableFalse(node) || isCaretContainerBlock(node)) {
					node = skipCaretContainers(walker.next, true);
					if (predicateFn(node)) {
						return node;
					}
				}
	
				while ((node = skipCaretContainers(walker.next, shallow))) {
					if (predicateFn(node)) {
						return node;
					}
				}
			}
	
			return null;
		}
	
		function getEditingHost(node, rootNode) {
			for (node = node.parentNode; node && node != rootNode; node = node.parentNode) {
				if (isContentEditableTrue(node)) {
					return node;
				}
			}
	
			return rootNode;
		}
	
		function getParentBlock(node, rootNode) {
			while (node && node != rootNode) {
				if (isBlockLike(node)) {
					return node;
				}
	
				node = node.parentNode;
			}
	
			return null;
		}
	
		function isInSameBlock(caretPosition1, caretPosition2, rootNode) {
			return getParentBlock(caretPosition1.container(), rootNode) == getParentBlock(caretPosition2.container(), rootNode);
		}
	
		function isInSameEditingHost(caretPosition1, caretPosition2, rootNode) {
			return getEditingHost(caretPosition1.container(), rootNode) == getEditingHost(caretPosition2.container(), rootNode);
		}
	
		function getChildNodeAtRelativeOffset(relativeOffset, caretPosition) {
			var container, offset;
	
			if (!caretPosition) {
				return null;
			}
	
			container = caretPosition.container();
			offset = caretPosition.offset();
	
			if (!isElement(container)) {
				return null;
			}
	
			return container.childNodes[offset + relativeOffset];
		}
	
		function beforeAfter(before, node) {
			var range = node.ownerDocument.createRange();
	
			if (before) {
				range.setStartBefore(node);
				range.setEndBefore(node);
			} else {
				range.setStartAfter(node);
				range.setEndAfter(node);
			}
	
			return range;
		}
	
		function isNodesInSameBlock(rootNode, node1, node2) {
			return getParentBlock(node1, rootNode) == getParentBlock(node2, rootNode);
		}
	
		function lean(left, rootNode, node) {
			var sibling, siblingName;
	
			if (left) {
				siblingName = 'previousSibling';
			} else {
				siblingName = 'nextSibling';
			}
	
			while (node && node != rootNode) {
				sibling = node[siblingName];
	
				if (isCaretContainer(sibling)) {
					sibling = sibling[siblingName];
				}
	
				if (isContentEditableFalse(sibling)) {
					if (isNodesInSameBlock(rootNode, sibling, node)) {
						return sibling;
					}
	
					break;
				}
	
				if (isCaretCandidate(sibling)) {
					break;
				}
	
				node = node.parentNode;
			}
	
			return null;
		}
	
		var before = curry(beforeAfter, true);
		var after = curry(beforeAfter, false);
	
		function normalizeRange(direction, rootNode, range) {
			var node, container, offset, location;
			var leanLeft = curry(lean, true, rootNode);
			var leanRight = curry(lean, false, rootNode);
	
			container = range.startContainer;
			offset = range.startOffset;
	
			if (CaretContainer.isCaretContainerBlock(container)) {
				if (!isElement(container)) {
					container = container.parentNode;
				}
	
				location = container.getAttribute('data-mce-caret');
	
				if (location == 'before') {
					node = container.nextSibling;
					if (isContentEditableFalse(node)) {
						return before(node);
					}
				}
	
				if (location == 'after') {
					node = container.previousSibling;
					if (isContentEditableFalse(node)) {
						return after(node);
					}
				}
			}
	
			if (!range.collapsed) {
				return range;
			}
	
			if (NodeType.isText(container)) {
				if (isCaretContainer(container)) {
					if (direction === 1) {
						node = leanRight(container);
						if (node) {
							return before(node);
						}
	
						node = leanLeft(container);
						if (node) {
							return after(node);
						}
					}
	
					if (direction === -1) {
						node = leanLeft(container);
						if (node) {
							return after(node);
						}
	
						node = leanRight(container);
						if (node) {
							return before(node);
						}
					}
	
					return range;
				}
	
				if (CaretContainer.endsWithCaretContainer(container) && offset >= container.data.length - 1) {
					if (direction === 1) {
						node = leanRight(container);
						if (node) {
							return before(node);
						}
					}
	
					return range;
				}
	
				if (CaretContainer.startsWithCaretContainer(container) && offset <= 1) {
					if (direction === -1) {
						node = leanLeft(container);
						if (node) {
							return after(node);
						}
					}
	
					return range;
				}
	
				if (offset === container.data.length) {
					node = leanRight(container);
					if (node) {
						return before(node);
					}
	
					return range;
				}
	
				if (offset === 0) {
					node = leanLeft(container);
					if (node) {
						return after(node);
					}
	
					return range;
				}
			}
	
			return range;
		}
	
		function isNextToContentEditableFalse(relativeOffset, caretPosition) {
			return isContentEditableFalse(getChildNodeAtRelativeOffset(relativeOffset, caretPosition));
		}
	
		return {
			isForwards: isForwards,
			isBackwards: isBackwards,
			findNode: findNode,
			getEditingHost: getEditingHost,
			getParentBlock: getParentBlock,
			isInSameBlock: isInSameBlock,
			isInSameEditingHost: isInSameEditingHost,
			isBeforeContentEditableFalse: curry(isNextToContentEditableFalse, 0),
			isAfterContentEditableFalse: curry(isNextToContentEditableFalse, -1),
			normalizeRange: normalizeRange
		};
	});
	
	// Included from: js/tinymce/classes/caret/CaretWalker.js
	
	/**
	 * CaretWalker.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This module contains logic for moving around a virtual caret in logical order within a DOM element.
	 *
	 * It ignores the most obvious invalid caret locations such as within a script element or within a
	 * contentEditable=false element but it will return locations that isn't possible to render visually.
	 *
	 * @private
	 * @class tinymce.caret.CaretWalker
	 * @example
	 * var caretWalker = new CaretWalker(rootElm);
	 *
	 * var prevLogicalCaretPosition = caretWalker.prev(CaretPosition.fromRangeStart(range));
	 * var nextLogicalCaretPosition = caretWalker.next(CaretPosition.fromRangeEnd(range));
	 */
	define("tinymce/caret/CaretWalker", [
		"tinymce/dom/NodeType",
		"tinymce/caret/CaretCandidate",
		"tinymce/caret/CaretPosition",
		"tinymce/caret/CaretUtils",
		"tinymce/util/Arr",
		"tinymce/util/Fun"
	], function(NodeType, CaretCandidate, CaretPosition, CaretUtils, Arr, Fun) {
		var isContentEditableFalse = NodeType.isContentEditableFalse,
			isText = NodeType.isText,
			isElement = NodeType.isElement,
			isBr = NodeType.isBr,
			isForwards = CaretUtils.isForwards,
			isBackwards = CaretUtils.isBackwards,
			isCaretCandidate = CaretCandidate.isCaretCandidate,
			isAtomic = CaretCandidate.isAtomic,
			isEditableCaretCandidate = CaretCandidate.isEditableCaretCandidate;
	
		function getParents(node, rootNode) {
			var parents = [];
	
			while (node && node != rootNode) {
				parents.push(node);
				node = node.parentNode;
			}
	
			return parents;
		}
	
		function nodeAtIndex(container, offset) {
			if (container.hasChildNodes() && offset < container.childNodes.length) {
				return container.childNodes[offset];
			}
	
			return null;
		}
	
		function getCaretCandidatePosition(direction, node) {
			if (isForwards(direction)) {
				if (isCaretCandidate(node.previousSibling) && !isText(node.previousSibling)) {
					return CaretPosition.before(node);
				}
	
				if (isText(node)) {
					return CaretPosition(node, 0);
				}
			}
	
			if (isBackwards(direction)) {
				if (isCaretCandidate(node.nextSibling) && !isText(node.nextSibling)) {
					return CaretPosition.after(node);
				}
	
				if (isText(node)) {
					return CaretPosition(node, node.data.length);
				}
			}
	
			if (isBackwards(direction)) {
				if (isBr(node)) {
					return CaretPosition.before(node);
				}
	
				return CaretPosition.after(node);
			}
	
			return CaretPosition.before(node);
		}
	
		// Jumps over BR elements <p>|<br></p><p>a</p> -> <p><br></p><p>|a</p>
		function isBrBeforeBlock(node, rootNode) {
			var next;
	
			if (!NodeType.isBr(node)) {
				return false;
			}
	
			next = findCaretPosition(1, CaretPosition.after(node), rootNode);
			if (!next) {
				return false;
			}
	
			return !CaretUtils.isInSameBlock(CaretPosition.before(node), CaretPosition.before(next), rootNode);
		}
	
		function findCaretPosition(direction, startCaretPosition, rootNode) {
			var container, offset, node, nextNode, innerNode,
				rootContentEditableFalseElm, caretPosition;
	
			if (!isElement(rootNode) || !startCaretPosition) {
				return null;
			}
	
			caretPosition = startCaretPosition;
			container = caretPosition.container();
			offset = caretPosition.offset();
	
			if (isText(container)) {
				if (isBackwards(direction) && offset > 0) {
					return CaretPosition(container, --offset);
				}
	
				if (isForwards(direction) && offset < container.length) {
					return CaretPosition(container, ++offset);
				}
	
				node = container;
			} else {
				if (isBackwards(direction) && offset > 0) {
					nextNode = nodeAtIndex(container, offset - 1);
					if (isCaretCandidate(nextNode)) {
						if (!isAtomic(nextNode)) {
							innerNode = CaretUtils.findNode(nextNode, direction, isEditableCaretCandidate, nextNode);
							if (innerNode) {
								if (isText(innerNode)) {
									return CaretPosition(innerNode, innerNode.data.length);
								}
	
								return CaretPosition.after(innerNode);
							}
						}
	
						if (isText(nextNode)) {
							return CaretPosition(nextNode, nextNode.data.length);
						}
	
						return CaretPosition.before(nextNode);
					}
				}
	
				if (isForwards(direction) && offset < container.childNodes.length) {
					nextNode = nodeAtIndex(container, offset);
					if (isCaretCandidate(nextNode)) {
						if (isBrBeforeBlock(nextNode, rootNode)) {
							return findCaretPosition(direction, CaretPosition.after(nextNode), rootNode);
						}
	
						if (!isAtomic(nextNode)) {
							innerNode = CaretUtils.findNode(nextNode, direction, isEditableCaretCandidate, nextNode);
							if (innerNode) {
								if (isText(innerNode)) {
									return CaretPosition(innerNode, 0);
								}
	
								return CaretPosition.before(innerNode);
							}
						}
	
						if (isText(nextNode)) {
							return CaretPosition(nextNode, 0);
						}
	
						return CaretPosition.after(nextNode);
					}
				}
	
				node = caretPosition.getNode();
			}
	
			if ((isForwards(direction) && caretPosition.isAtEnd()) || (isBackwards(direction) && caretPosition.isAtStart())) {
				node = CaretUtils.findNode(node, direction, Fun.constant(true), rootNode, true);
				if (isEditableCaretCandidate(node)) {
					return getCaretCandidatePosition(direction, node);
				}
			}
	
			nextNode = CaretUtils.findNode(node, direction, isEditableCaretCandidate, rootNode);
	
			rootContentEditableFalseElm = Arr.last(Arr.filter(getParents(container, rootNode), isContentEditableFalse));
			if (rootContentEditableFalseElm && (!nextNode || !rootContentEditableFalseElm.contains(nextNode))) {
				if (isForwards(direction)) {
					caretPosition = CaretPosition.after(rootContentEditableFalseElm);
				} else {
					caretPosition = CaretPosition.before(rootContentEditableFalseElm);
				}
	
				return caretPosition;
			}
	
			if (nextNode) {
				return getCaretCandidatePosition(direction, nextNode);
			}
	
			return null;
		}
	
		return function(rootNode) {
			return {
				/**
				 * Returns the next logical caret position from the specificed input
				 * caretPoisiton or null if there isn't any more positions left for example
				 * at the end specified root element.
				 *
				 * @method next
				 * @param {tinymce.caret.CaretPosition} caretPosition Caret position to start from.
				 * @return {tinymce.caret.CaretPosition} CaretPosition or null if no position was found.
				 */
				next: function(caretPosition) {
					return findCaretPosition(1, caretPosition, rootNode);
				},
	
				/**
				 * Returns the previous logical caret position from the specificed input
				 * caretPoisiton or null if there isn't any more positions left for example
				 * at the end specified root element.
				 *
				 * @method prev
				 * @param {tinymce.caret.CaretPosition} caretPosition Caret position to start from.
				 * @return {tinymce.caret.CaretPosition} CaretPosition or null if no position was found.
				 */
				prev: function(caretPosition) {
					return findCaretPosition(-1, caretPosition, rootNode);
				}
			};
		};
	});
	
	// Included from: js/tinymce/classes/InsertList.js
	
	/**
	 * InsertList.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2016 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Handles inserts of lists into the editor instance.
	 *
	 * @class tinymce.InsertList
	 * @private
	 */
	define("tinymce/InsertList", [
		"tinymce/util/Tools",
		"tinymce/caret/CaretWalker",
		"tinymce/caret/CaretPosition"
	], function(Tools, CaretWalker, CaretPosition) {
		var isListFragment = function(fragment) {
			var firstChild = fragment.firstChild;
			var lastChild = fragment.lastChild;
	
			// Skip meta since it's likely <meta><ul>..</ul>
			if (firstChild && firstChild.name === 'meta') {
				firstChild = firstChild.next;
			}
	
			// Skip mce_marker since it's likely <ul>..</ul><span id="mce_marker"></span>
			if (lastChild && lastChild.attr('id') === 'mce_marker') {
				lastChild = lastChild.prev;
			}
	
			if (!firstChild || firstChild !== lastChild) {
				return false;
			}
	
			return firstChild.name === 'ul' || firstChild.name === 'ol';
		};
	
		var cleanupDomFragment = function (domFragment) {
			var firstChild = domFragment.firstChild;
			var lastChild = domFragment.lastChild;
	
			// TODO: remove the meta tag from paste logic
			if (firstChild && firstChild.nodeName === 'META') {
				firstChild.parentNode.removeChild(firstChild);
			}
	
			if (lastChild && lastChild.id === 'mce_marker') {
				lastChild.parentNode.removeChild(lastChild);
			}
	
			return domFragment;
		};
	
		var toDomFragment = function(dom, serializer, fragment) {
			var html = serializer.serialize(fragment);
			var domFragment = dom.createFragment(html);
	
			return cleanupDomFragment(domFragment);
		};
	
		var listItems = function(elm) {
			return Tools.grep(elm.childNodes, function(child) {
				return child.nodeName === 'LI';
			});
		};
	
		var isEmpty = function (elm) {
			return !elm.firstChild;
		};
	
		var trimListItems = function(elms) {
			return elms.length > 0 && isEmpty(elms[elms.length - 1]) ? elms.slice(0, -1) : elms;
		};
	
		var getParentLi = function(dom, node) {
			var parentBlock = dom.getParent(node, dom.isBlock);
			return parentBlock && parentBlock.nodeName === 'LI' ? parentBlock : null;
		};
	
		var isParentBlockLi = function(dom, node) {
			return !!getParentLi(dom, node);
		};
	
		var getSplit = function(parentNode, rng) {
			var beforeRng = rng.cloneRange();
			var afterRng = rng.cloneRange();
	
			beforeRng.setStartBefore(parentNode);
			afterRng.setEndAfter(parentNode);
	
			return [
				beforeRng.cloneContents(),
				afterRng.cloneContents()
			];
		};
	
		var findFirstIn = function(node, rootNode) {
			var caretPos = CaretPosition.before(node);
			var caretWalker = new CaretWalker(rootNode);
			var newCaretPos = caretWalker.next(caretPos);
	
			return newCaretPos ? newCaretPos.toRange() : null;
		};
	
		var findLastOf = function(node, rootNode) {
			var caretPos = CaretPosition.after(node);
			var caretWalker = new CaretWalker(rootNode);
			var newCaretPos = caretWalker.prev(caretPos);
	
			return newCaretPos ? newCaretPos.toRange() : null;
		};
	
		var insertMiddle = function(target, elms, rootNode, rng) {
			var parts = getSplit(target, rng);
			var parentElm = target.parentNode;
	
			parentElm.insertBefore(parts[0], target);
			Tools.each(elms, function(li) {
				parentElm.insertBefore(li, target);
			});
			parentElm.insertBefore(parts[1], target);
			parentElm.removeChild(target);
	
			return findLastOf(elms[elms.length - 1], rootNode);
		};
	
		var insertBefore = function(target, elms, rootNode) {
			var parentElm = target.parentNode;
	
			Tools.each(elms, function(elm) {
				parentElm.insertBefore(elm, target);
			});
	
			return findFirstIn(target, rootNode);
		};
	
		var insertAfter = function(target, elms, rootNode, dom) {
			dom.insertAfter(elms.reverse(), target);
			return findLastOf(elms[0], rootNode);
		};
	
		var insertAtCaret = function(serializer, dom, rng, fragment) {
			var domFragment = toDomFragment(dom, serializer, fragment);
			var liTarget = getParentLi(dom, rng.startContainer);
			var liElms = trimListItems(listItems(domFragment.firstChild));
			var BEGINNING = 1, END = 2;
			var rootNode = dom.getRoot();
	
			var isAt = function(location) {
				var caretPos = CaretPosition.fromRangeStart(rng);
				var caretWalker = new CaretWalker(dom.getRoot());
				var newPos = location === BEGINNING ? caretWalker.prev(caretPos) : caretWalker.next(caretPos);
	
				return newPos ? getParentLi(dom, newPos.getNode()) !== liTarget : true;
			};
	
			if (isAt(BEGINNING)) {
				return insertBefore(liTarget, liElms, rootNode);
			} else if (isAt(END)) {
				return insertAfter(liTarget, liElms, rootNode, dom);
			}
	
			return insertMiddle(liTarget, liElms, rootNode, rng);
		};
	
		return {
			isListFragment: isListFragment,
			insertAtCaret: insertAtCaret,
			isParentBlockLi: isParentBlockLi,
			trimListItems: trimListItems,
			listItems: listItems
		};
	});
	
	// Included from: js/tinymce/classes/InsertContent.js
	
	/**
	 * InsertContent.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2016 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Handles inserts of contents into the editor instance.
	 *
	 * @class tinymce.InsertContent
	 * @private
	 */
	define("tinymce/InsertContent", [
		"tinymce/Env",
		"tinymce/util/Tools",
		"tinymce/html/Serializer",
		"tinymce/caret/CaretWalker",
		"tinymce/caret/CaretPosition",
		"tinymce/dom/ElementUtils",
		"tinymce/dom/NodeType",
		"tinymce/InsertList"
	], function(Env, Tools, Serializer, CaretWalker, CaretPosition, ElementUtils, NodeType, InsertList) {
		var isTableCell = NodeType.matchNodeNames('td th');
	
		var insertHtmlAtCaret = function(editor, value, details) {
			var parser, serializer, parentNode, rootNode, fragment, args;
			var marker, rng, node, node2, bookmarkHtml, merge;
			var textInlineElements = editor.schema.getTextInlineElements();
			var selection = editor.selection, dom = editor.dom;
	
			function trimOrPaddLeftRight(html) {
				var rng, container, offset;
	
				rng = selection.getRng(true);
				container = rng.startContainer;
				offset = rng.startOffset;
	
				function hasSiblingText(siblingName) {
					return container[siblingName] && container[siblingName].nodeType == 3;
				}
	
				if (container.nodeType == 3) {
					if (offset > 0) {
						html = html.replace(/^&nbsp;/, ' ');
					} else if (!hasSiblingText('previousSibling')) {
						html = html.replace(/^ /, '&nbsp;');
					}
	
					if (offset < container.length) {
						html = html.replace(/&nbsp;(<br>|)$/, ' ');
					} else if (!hasSiblingText('nextSibling')) {
						html = html.replace(/(&nbsp;| )(<br>|)$/, '&nbsp;');
					}
				}
	
				return html;
			}
	
			// Removes &nbsp; from a [b] c -> a &nbsp;c -> a c
			function trimNbspAfterDeleteAndPaddValue() {
				var rng, container, offset;
	
				rng = selection.getRng(true);
				container = rng.startContainer;
				offset = rng.startOffset;
	
				if (container.nodeType == 3 && rng.collapsed) {
					if (container.data[offset] === '\u00a0') {
						container.deleteData(offset, 1);
	
						if (!/[\u00a0| ]$/.test(value)) {
							value += ' ';
						}
					} else if (container.data[offset - 1] === '\u00a0') {
						container.deleteData(offset - 1, 1);
	
						if (!/[\u00a0| ]$/.test(value)) {
							value = ' ' + value;
						}
					}
				}
			}
	
			function reduceInlineTextElements() {
				if (merge) {
					var root = editor.getBody(), elementUtils = new ElementUtils(dom);
	
					Tools.each(dom.select('*[data-mce-fragment]'), function(node) {
						for (var testNode = node.parentNode; testNode && testNode != root; testNode = testNode.parentNode) {
							if (textInlineElements[node.nodeName.toLowerCase()] && elementUtils.compare(testNode, node)) {
								dom.remove(node, true);
							}
						}
					});
				}
			}
	
			function markFragmentElements(fragment) {
				var node = fragment;
	
				while ((node = node.walk())) {
					if (node.type === 1) {
						node.attr('data-mce-fragment', '1');
					}
				}
			}
	
			function umarkFragmentElements(elm) {
				Tools.each(elm.getElementsByTagName('*'), function(elm) {
					elm.removeAttribute('data-mce-fragment');
				});
			}
	
			function isPartOfFragment(node) {
				return !!node.getAttribute('data-mce-fragment');
			}
	
			function canHaveChildren(node) {
				return node && !editor.schema.getShortEndedElements()[node.nodeName];
			}
	
			function moveSelectionToMarker(marker) {
				var parentEditableFalseElm, parentBlock, nextRng;
	
				function getContentEditableFalseParent(node) {
					var root = editor.getBody();
	
					for (; node && node !== root; node = node.parentNode) {
						if (editor.dom.getContentEditable(node) === 'false') {
							return node;
						}
					}
	
					return null;
				}
	
				if (!marker) {
					return;
				}
	
				selection.scrollIntoView(marker);
	
				// If marker is in cE=false then move selection to that element instead
				parentEditableFalseElm = getContentEditableFalseParent(marker);
				if (parentEditableFalseElm) {
					dom.remove(marker);
					selection.select(parentEditableFalseElm);
					return;
				}
	
				// Move selection before marker and remove it
				rng = dom.createRng();
	
				// If previous sibling is a text node set the selection to the end of that node
				node = marker.previousSibling;
				if (node && node.nodeType == 3) {
					rng.setStart(node, node.nodeValue.length);
	
					// TODO: Why can't we normalize on IE
					if (!Env.ie) {
						node2 = marker.nextSibling;
						if (node2 && node2.nodeType == 3) {
							node.appendData(node2.data);
							node2.parentNode.removeChild(node2);
						}
					}
				} else {
					// If the previous sibling isn't a text node or doesn't exist set the selection before the marker node
					rng.setStartBefore(marker);
					rng.setEndBefore(marker);
				}
	
				function findNextCaretRng(rng) {
					var caretPos = CaretPosition.fromRangeStart(rng);
					var caretWalker = new CaretWalker(editor.getBody());
	
					caretPos = caretWalker.next(caretPos);
					if (caretPos) {
						return caretPos.toRange();
					}
				}
	
				// Remove the marker node and set the new range
				parentBlock = dom.getParent(marker, dom.isBlock);
				dom.remove(marker);
	
				if (parentBlock && dom.isEmpty(parentBlock)) {
					editor.$(parentBlock).empty();
	
					rng.setStart(parentBlock, 0);
					rng.setEnd(parentBlock, 0);
	
					if (!isTableCell(parentBlock) && !isPartOfFragment(parentBlock) && (nextRng = findNextCaretRng(rng))) {
						rng = nextRng;
						dom.remove(parentBlock);
					} else {
						dom.add(parentBlock, dom.create('br', {'data-mce-bogus': '1'}));
					}
				}
	
				selection.setRng(rng);
			}
	
			// Check for whitespace before/after value
			if (/^ | $/.test(value)) {
				value = trimOrPaddLeftRight(value);
			}
	
			// Setup parser and serializer
			parser = editor.parser;
			merge = details.merge;
	
			serializer = new Serializer({
				validate: editor.settings.validate
			}, editor.schema);
			bookmarkHtml = '<span id="mce_marker" data-mce-type="bookmark">&#xFEFF;&#x200B;</span>';
	
			// Run beforeSetContent handlers on the HTML to be inserted
			args = {content: value, format: 'html', selection: true};
			editor.fire('BeforeSetContent', args);
			value = args.content;
	
			// Add caret at end of contents if it's missing
			if (value.indexOf('{$caret}') == -1) {
				value += '{$caret}';
			}
	
			// Replace the caret marker with a span bookmark element
			value = value.replace(/\{\$caret\}/, bookmarkHtml);
	
			// If selection is at <body>|<p></p> then move it into <body><p>|</p>
			rng = selection.getRng();
			var caretElement = rng.startContainer || (rng.parentElement ? rng.parentElement() : null);
			var body = editor.getBody();
			if (caretElement === body && selection.isCollapsed()) {
				if (dom.isBlock(body.firstChild) && canHaveChildren(body.firstChild) && dom.isEmpty(body.firstChild)) {
					rng = dom.createRng();
					rng.setStart(body.firstChild, 0);
					rng.setEnd(body.firstChild, 0);
					selection.setRng(rng);
				}
			}
	
			// Insert node maker where we will insert the new HTML and get it's parent
			if (!selection.isCollapsed()) {
				// Fix for #2595 seems that delete removes one extra character on
				// WebKit for some odd reason if you double click select a word
				editor.selection.setRng(editor.selection.getRng());
				editor.getDoc().execCommand('Delete', false, null);
				trimNbspAfterDeleteAndPaddValue();
			}
	
			parentNode = selection.getNode();
	
			// Parse the fragment within the context of the parent node
			var parserArgs = {context: parentNode.nodeName.toLowerCase(), data: details.data};
			fragment = parser.parse(value, parserArgs);
	
			// Custom handling of lists
			if (details.paste === true && InsertList.isListFragment(fragment) && InsertList.isParentBlockLi(dom, parentNode)) {
				rng = InsertList.insertAtCaret(serializer, dom, editor.selection.getRng(true), fragment);
				editor.selection.setRng(rng);
				editor.fire('SetContent', args);
				return;
			}
	
			markFragmentElements(fragment);
	
			// Move the caret to a more suitable location
			node = fragment.lastChild;
			if (node.attr('id') == 'mce_marker') {
				marker = node;
	
				for (node = node.prev; node; node = node.walk(true)) {
					if (node.type == 3 || !dom.isBlock(node.name)) {
						if (editor.schema.isValidChild(node.parent.name, 'span')) {
							node.parent.insert(marker, node, node.name === 'br');
						}
						break;
					}
				}
			}
	
			editor._selectionOverrides.showBlockCaretContainer(parentNode);
	
			// If parser says valid we can insert the contents into that parent
			if (!parserArgs.invalid) {
				value = serializer.serialize(fragment);
	
				// Check if parent is empty or only has one BR element then set the innerHTML of that parent
				node = parentNode.firstChild;
				node2 = parentNode.lastChild;
				if (!node || (node === node2 && node.nodeName === 'BR')) {
					dom.setHTML(parentNode, value);
				} else {
					selection.setContent(value);
				}
			} else {
				// If the fragment was invalid within that context then we need
				// to parse and process the parent it's inserted into
	
				// Insert bookmark node and get the parent
				selection.setContent(bookmarkHtml);
				parentNode = selection.getNode();
				rootNode = editor.getBody();
	
				// Opera will return the document node when selection is in root
				if (parentNode.nodeType == 9) {
					parentNode = node = rootNode;
				} else {
					node = parentNode;
				}
	
				// Find the ancestor just before the root element
				while (node !== rootNode) {
					parentNode = node;
					node = node.parentNode;
				}
	
				// Get the outer/inner HTML depending on if we are in the root and parser and serialize that
				value = parentNode == rootNode ? rootNode.innerHTML : dom.getOuterHTML(parentNode);
				value = serializer.serialize(
					parser.parse(
						// Need to replace by using a function since $ in the contents would otherwise be a problem
						value.replace(/<span (id="mce_marker"|id=mce_marker).+?<\/span>/i, function() {
							return serializer.serialize(fragment);
						})
					)
				);
	
				// Set the inner/outer HTML depending on if we are in the root or not
				if (parentNode == rootNode) {
					dom.setHTML(rootNode, value);
				} else {
					dom.setOuterHTML(parentNode, value);
				}
			}
	
			reduceInlineTextElements();
			moveSelectionToMarker(dom.get('mce_marker'));
			umarkFragmentElements(editor.getBody());
			editor.fire('SetContent', args);
			editor.addVisual();
		};
	
		var processValue = function (value) {
			var details;
	
			if (typeof value !== 'string') {
				details = Tools.extend({
					paste: value.paste,
					data: {
						paste: value.paste
					}
				}, value);
	
				return {
					content: value.content,
					details: details
				};
			}
	
			return {
				content: value,
				details: {}
			};
		};
	
		var insertAtCaret = function (editor, value) {
			var result = processValue(value);
			insertHtmlAtCaret(editor, result.content, result.details);
		};
	
		return {
			insertAtCaret: insertAtCaret
		};
	});
	
	// Included from: js/tinymce/classes/EditorCommands.js
	
	/**
	 * EditorCommands.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This class enables you to add custom editor commands and it contains
	 * overrides for native browser commands to address various bugs and issues.
	 *
	 * @class tinymce.EditorCommands
	 */
	define("tinymce/EditorCommands", [
		"tinymce/Env",
		"tinymce/util/Tools",
		"tinymce/dom/RangeUtils",
		"tinymce/dom/TreeWalker",
		"tinymce/InsertContent"
	], function(Env, Tools, RangeUtils, TreeWalker, InsertContent) {
		// Added for compression purposes
		var each = Tools.each, extend = Tools.extend;
		var map = Tools.map, inArray = Tools.inArray, explode = Tools.explode;
		var isOldIE = Env.ie && Env.ie < 11;
		var TRUE = true, FALSE = false;
	
		return function(editor) {
			var dom, selection, formatter,
				commands = {state: {}, exec: {}, value: {}},
				settings = editor.settings,
				bookmark;
	
			editor.on('PreInit', function() {
				dom = editor.dom;
				selection = editor.selection;
				settings = editor.settings;
				formatter = editor.formatter;
			});
	
			/**
			 * Executes the specified command.
			 *
			 * @method execCommand
			 * @param {String} command Command to execute.
			 * @param {Boolean} ui Optional user interface state.
			 * @param {Object} value Optional value for command.
			 * @param {Object} args Optional extra arguments to the execCommand.
			 * @return {Boolean} true/false if the command was found or not.
			 */
			function execCommand(command, ui, value, args) {
				var func, customCommand, state = 0;
	
				if (!/^(mceAddUndoLevel|mceEndUndoLevel|mceBeginUndoLevel|mceRepaint)$/.test(command) && (!args || !args.skip_focus)) {
					editor.focus();
				}
	
				args = editor.fire('BeforeExecCommand', {command: command, ui: ui, value: value});
				if (args.isDefaultPrevented()) {
					return false;
				}
	
				customCommand = command.toLowerCase();
				if ((func = commands.exec[customCommand])) {
					func(customCommand, ui, value);
					editor.fire('ExecCommand', {command: command, ui: ui, value: value});
					return true;
				}
	
				// Plugin commands
				each(editor.plugins, function(p) {
					if (p.execCommand && p.execCommand(command, ui, value)) {
						editor.fire('ExecCommand', {command: command, ui: ui, value: value});
						state = true;
						return false;
					}
				});
	
				if (state) {
					return state;
				}
	
				// Theme commands
				if (editor.theme && editor.theme.execCommand && editor.theme.execCommand(command, ui, value)) {
					editor.fire('ExecCommand', {command: command, ui: ui, value: value});
					return true;
				}
	
				// Browser commands
				try {
					state = editor.getDoc().execCommand(command, ui, value);
				} catch (ex) {
					// Ignore old IE errors
				}
	
				if (state) {
					editor.fire('ExecCommand', {command: command, ui: ui, value: value});
					return true;
				}
	
				return false;
			}
	
			/**
			 * Queries the current state for a command for example if the current selection is "bold".
			 *
			 * @method queryCommandState
			 * @param {String} command Command to check the state of.
			 * @return {Boolean/Number} true/false if the selected contents is bold or not, -1 if it's not found.
			 */
			function queryCommandState(command) {
				var func;
	
				// Is hidden then return undefined
				if (editor.quirks.isHidden()) {
					return;
				}
	
				command = command.toLowerCase();
				if ((func = commands.state[command])) {
					return func(command);
				}
	
				// Browser commands
				try {
					return editor.getDoc().queryCommandState(command);
				} catch (ex) {
					// Fails sometimes see bug: 1896577
				}
	
				return false;
			}
	
			/**
			 * Queries the command value for example the current fontsize.
			 *
			 * @method queryCommandValue
			 * @param {String} command Command to check the value of.
			 * @return {Object} Command value of false if it's not found.
			 */
			function queryCommandValue(command) {
				var func;
	
				// Is hidden then return undefined
				if (editor.quirks.isHidden()) {
					return;
				}
	
				command = command.toLowerCase();
				if ((func = commands.value[command])) {
					return func(command);
				}
	
				// Browser commands
				try {
					return editor.getDoc().queryCommandValue(command);
				} catch (ex) {
					// Fails sometimes see bug: 1896577
				}
			}
	
			/**
			 * Adds commands to the command collection.
			 *
			 * @method addCommands
			 * @param {Object} command_list Name/value collection with commands to add, the names can also be comma separated.
			 * @param {String} type Optional type to add, defaults to exec. Can be value or state as well.
			 */
			function addCommands(command_list, type) {
				type = type || 'exec';
	
				each(command_list, function(callback, command) {
					each(command.toLowerCase().split(','), function(command) {
						commands[type][command] = callback;
					});
				});
			}
	
			function addCommand(command, callback, scope) {
				command = command.toLowerCase();
				commands.exec[command] = function(command, ui, value, args) {
					return callback.call(scope || editor, ui, value, args);
				};
			}
	
			/**
			 * Returns true/false if the command is supported or not.
			 *
			 * @method queryCommandSupported
			 * @param {String} command Command that we check support for.
			 * @return {Boolean} true/false if the command is supported or not.
			 */
			function queryCommandSupported(command) {
				command = command.toLowerCase();
	
				if (commands.exec[command]) {
					return true;
				}
	
				// Browser commands
				try {
					return editor.getDoc().queryCommandSupported(command);
				} catch (ex) {
					// Fails sometimes see bug: 1896577
				}
	
				return false;
			}
	
			function addQueryStateHandler(command, callback, scope) {
				command = command.toLowerCase();
				commands.state[command] = function() {
					return callback.call(scope || editor);
				};
			}
	
			function addQueryValueHandler(command, callback, scope) {
				command = command.toLowerCase();
				commands.value[command] = function() {
					return callback.call(scope || editor);
				};
			}
	
			function hasCustomCommand(command) {
				command = command.toLowerCase();
				return !!commands.exec[command];
			}
	
			// Expose public methods
			extend(this, {
				execCommand: execCommand,
				queryCommandState: queryCommandState,
				queryCommandValue: queryCommandValue,
				queryCommandSupported: queryCommandSupported,
				addCommands: addCommands,
				addCommand: addCommand,
				addQueryStateHandler: addQueryStateHandler,
				addQueryValueHandler: addQueryValueHandler,
				hasCustomCommand: hasCustomCommand
			});
	
			// Private methods
	
			function execNativeCommand(command, ui, value) {
				if (ui === undefined) {
					ui = FALSE;
				}
	
				if (value === undefined) {
					value = null;
				}
	
				return editor.getDoc().execCommand(command, ui, value);
			}
	
			function isFormatMatch(name) {
				return formatter.match(name);
			}
	
			function toggleFormat(name, value) {
				formatter.toggle(name, value ? {value: value} : undefined);
				editor.nodeChanged();
			}
	
			function storeSelection(type) {
				bookmark = selection.getBookmark(type);
			}
	
			function restoreSelection() {
				selection.moveToBookmark(bookmark);
			}
	
			// Add execCommand overrides
			addCommands({
				// Ignore these, added for compatibility
				'mceResetDesignMode,mceBeginUndoLevel': function() {},
	
				// Add undo manager logic
				'mceEndUndoLevel,mceAddUndoLevel': function() {
					editor.undoManager.add();
				},
	
				'Cut,Copy,Paste': function(command) {
					var doc = editor.getDoc(), failed;
	
					// Try executing the native command
					try {
						execNativeCommand(command);
					} catch (ex) {
						// Command failed
						failed = TRUE;
					}
	
					// Chrome reports the paste command as supported however older IE:s will return false for cut/paste
					if (command === 'paste' && !doc.queryCommandEnabled(command)) {
						failed = true;
					}
	
					// Present alert message about clipboard access not being available
					if (failed || !doc.queryCommandSupported(command)) {
						var msg = editor.translate(
							"Your browser doesn't support direct access to the clipboard. " +
							"Please use the Ctrl+X/C/V keyboard shortcuts instead."
						);
	
						if (Env.mac) {
							msg = msg.replace(/Ctrl\+/g, '\u2318+');
						}
	
						editor.notificationManager.open({text: msg, type: 'error'});
					}
				},
	
				// Override unlink command
				unlink: function() {
					if (selection.isCollapsed()) {
						var elm = editor.dom.getParent(editor.selection.getStart(), 'a');
						if (elm) {
							editor.dom.remove(elm, true);
						}
	
						return;
					}
	
					formatter.remove("link");
				},
	
				// Override justify commands to use the text formatter engine
				'JustifyLeft,JustifyCenter,JustifyRight,JustifyFull,JustifyNone': function(command) {
					var align = command.substring(7);
	
					if (align == 'full') {
						align = 'justify';
					}
	
					// Remove all other alignments first
					each('left,center,right,justify'.split(','), function(name) {
						if (align != name) {
							formatter.remove('align' + name);
						}
					});
	
					if (align != 'none') {
						toggleFormat('align' + align);
					}
				},
	
				// Override list commands to fix WebKit bug
				'InsertUnorderedList,InsertOrderedList': function(command) {
					var listElm, listParent;
	
					execNativeCommand(command);
	
					// WebKit produces lists within block elements so we need to split them
					// we will replace the native list creation logic to custom logic later on
					// TODO: Remove this when the list creation logic is removed
					listElm = dom.getParent(selection.getNode(), 'ol,ul');
					if (listElm) {
						listParent = listElm.parentNode;
	
						// If list is within a text block then split that block
						if (/^(H[1-6]|P|ADDRESS|PRE)$/.test(listParent.nodeName)) {
							storeSelection();
							dom.split(listParent, listElm);
							restoreSelection();
						}
					}
				},
	
				// Override commands to use the text formatter engine
				'Bold,Italic,Underline,Strikethrough,Superscript,Subscript': function(command) {
					toggleFormat(command);
				},
	
				// Override commands to use the text formatter engine
				'ForeColor,HiliteColor,FontName': function(command, ui, value) {
					toggleFormat(command, value);
				},
	
				FontSize: function(command, ui, value) {
					var fontClasses, fontSizes;
	
					// Convert font size 1-7 to styles
					if (value >= 1 && value <= 7) {
						fontSizes = explode(settings.font_size_style_values);
						fontClasses = explode(settings.font_size_classes);
	
						if (fontClasses) {
							value = fontClasses[value - 1] || value;
						} else {
							value = fontSizes[value - 1] || value;
						}
					}
	
					toggleFormat(command, value);
				},
	
				RemoveFormat: function(command) {
					formatter.remove(command);
				},
	
				mceBlockQuote: function() {
					toggleFormat('blockquote');
				},
	
				FormatBlock: function(command, ui, value) {
					return toggleFormat(value || 'p');
				},
	
				mceCleanup: function() {
					var bookmark = selection.getBookmark();
	
					editor.setContent(editor.getContent({cleanup: TRUE}), {cleanup: TRUE});
	
					selection.moveToBookmark(bookmark);
				},
	
				mceRemoveNode: function(command, ui, value) {
					var node = value || selection.getNode();
	
					// Make sure that the body node isn't removed
					if (node != editor.getBody()) {
						storeSelection();
						editor.dom.remove(node, TRUE);
						restoreSelection();
					}
				},
	
				mceSelectNodeDepth: function(command, ui, value) {
					var counter = 0;
	
					dom.getParent(selection.getNode(), function(node) {
						if (node.nodeType == 1 && counter++ == value) {
							selection.select(node);
							return FALSE;
						}
					}, editor.getBody());
				},
	
				mceSelectNode: function(command, ui, value) {
					selection.select(value);
				},
	
				mceInsertContent: function(command, ui, value) {
					InsertContent.insertAtCaret(editor, value);
				},
	
				mceInsertRawHTML: function(command, ui, value) {
					selection.setContent('tiny_mce_marker');
					editor.setContent(
						editor.getContent().replace(/tiny_mce_marker/g, function() {
							return value;
						})
					);
				},
	
				mceToggleFormat: function(command, ui, value) {
					toggleFormat(value);
				},
	
				mceSetContent: function(command, ui, value) {
					editor.setContent(value);
				},
	
				'Indent,Outdent': function(command) {
					var intentValue, indentUnit, value;
	
					// Setup indent level
					intentValue = settings.indentation;
					indentUnit = /[a-z%]+$/i.exec(intentValue);
					intentValue = parseInt(intentValue, 10);
	
					if (!queryCommandState('InsertUnorderedList') && !queryCommandState('InsertOrderedList')) {
						// If forced_root_blocks is set to false we don't have a block to indent so lets create a div
						if (!settings.forced_root_block && !dom.getParent(selection.getNode(), dom.isBlock)) {
							formatter.apply('div');
						}
	
						each(selection.getSelectedBlocks(), function(element) {
							if (dom.getContentEditable(element) === "false") {
								return;
							}
	
							if (element.nodeName !== "LI") {
								var indentStyleName = editor.getParam('indent_use_margin', false) ? 'margin' : 'padding';
								indentStyleName = element.nodeName === 'TABLE' ? 'margin' : indentStyleName;
								indentStyleName += dom.getStyle(element, 'direction', true) == 'rtl' ? 'Right' : 'Left';
	
								if (command == 'outdent') {
									value = Math.max(0, parseInt(element.style[indentStyleName] || 0, 10) - intentValue);
									dom.setStyle(element, indentStyleName, value ? value + indentUnit : '');
								} else {
									value = (parseInt(element.style[indentStyleName] || 0, 10) + intentValue) + indentUnit;
									dom.setStyle(element, indentStyleName, value);
								}
							}
						});
					} else {
						execNativeCommand(command);
					}
				},
	
				mceRepaint: function() {
				},
	
				InsertHorizontalRule: function() {
					editor.execCommand('mceInsertContent', false, '<hr />');
				},
	
				mceToggleVisualAid: function() {
					editor.hasVisual = !editor.hasVisual;
					editor.addVisual();
				},
	
				mceReplaceContent: function(command, ui, value) {
					editor.execCommand('mceInsertContent', false, value.replace(/\{\$selection\}/g, selection.getContent({format: 'text'})));
				},
	
				mceInsertLink: function(command, ui, value) {
					var anchor;
	
					if (typeof value == 'string') {
						value = {href: value};
					}
	
					anchor = dom.getParent(selection.getNode(), 'a');
	
					// Spaces are never valid in URLs and it's a very common mistake for people to make so we fix it here.
					value.href = value.href.replace(' ', '%20');
	
					// Remove existing links if there could be child links or that the href isn't specified
					if (!anchor || !value.href) {
						formatter.remove('link');
					}
	
					// Apply new link to selection
					if (value.href) {
						formatter.apply('link', value, anchor);
					}
				},
	
				selectAll: function() {
					var root = dom.getRoot(), rng;
	
					if (selection.getRng().setStart) {
						rng = dom.createRng();
						rng.setStart(root, 0);
						rng.setEnd(root, root.childNodes.length);
						selection.setRng(rng);
					} else {
						// IE will render it's own root level block elements and sometimes
						// even put font elements in them when the user starts typing. So we need to
						// move the selection to a more suitable element from this:
						// <body>|<p></p></body> to this: <body><p>|</p></body>
						rng = selection.getRng();
						if (!rng.item) {
							rng.moveToElementText(root);
							rng.select();
						}
					}
				},
	
				"delete": function() {
					execNativeCommand("Delete");
	
					// Check if body is empty after the delete call if so then set the contents
					// to an empty string and move the caret to any block produced by that operation
					// this fixes the issue with root blocks not being properly produced after a delete call on IE
					var body = editor.getBody();
	
					if (dom.isEmpty(body)) {
						editor.setContent('');
	
						if (body.firstChild && dom.isBlock(body.firstChild)) {
							editor.selection.setCursorLocation(body.firstChild, 0);
						} else {
							editor.selection.setCursorLocation(body, 0);
						}
					}
				},
	
				mceNewDocument: function() {
					editor.setContent('');
				},
	
				InsertLineBreak: function(command, ui, value) {
					// We load the current event in from EnterKey.js when appropriate to heed
					// certain event-specific variations such as ctrl-enter in a list
					var evt = value;
					var brElm, extraBr, marker;
					var rng = selection.getRng(true);
					new RangeUtils(dom).normalize(rng);
	
					var offset = rng.startOffset;
					var container = rng.startContainer;
	
					// Resolve node index
					if (container.nodeType == 1 && container.hasChildNodes()) {
						var isAfterLastNodeInContainer = offset > container.childNodes.length - 1;
	
						container = container.childNodes[Math.min(offset, container.childNodes.length - 1)] || container;
						if (isAfterLastNodeInContainer && container.nodeType == 3) {
							offset = container.nodeValue.length;
						} else {
							offset = 0;
						}
					}
	
					var parentBlock = dom.getParent(container, dom.isBlock);
					var parentBlockName = parentBlock ? parentBlock.nodeName.toUpperCase() : ''; // IE < 9 & HTML5
					var containerBlock = parentBlock ? dom.getParent(parentBlock.parentNode, dom.isBlock) : null;
					var containerBlockName = containerBlock ? containerBlock.nodeName.toUpperCase() : ''; // IE < 9 & HTML5
	
					// Enter inside block contained within a LI then split or insert before/after LI
					var isControlKey = evt && evt.ctrlKey;
					if (containerBlockName == 'LI' && !isControlKey) {
						parentBlock = containerBlock;
						parentBlockName = containerBlockName;
					}
	
					// Walks the parent block to the right and look for BR elements
					function hasRightSideContent() {
						var walker = new TreeWalker(container, parentBlock), node;
						var nonEmptyElementsMap = editor.schema.getNonEmptyElements();
	
						while ((node = walker.next())) {
							if (nonEmptyElementsMap[node.nodeName.toLowerCase()] || node.length > 0) {
								return true;
							}
						}
					}
	
					if (container && container.nodeType == 3 && offset >= container.nodeValue.length) {
						// Insert extra BR element at the end block elements
						if (!isOldIE && !hasRightSideContent()) {
							brElm = dom.create('br');
							rng.insertNode(brElm);
							rng.setStartAfter(brElm);
							rng.setEndAfter(brElm);
							extraBr = true;
						}
					}
	
					brElm = dom.create('br');
					rng.insertNode(brElm);
	
					// Rendering modes below IE8 doesn't display BR elements in PRE unless we have a \n before it
					var documentMode = dom.doc.documentMode;
					if (isOldIE && parentBlockName == 'PRE' && (!documentMode || documentMode < 8)) {
						brElm.parentNode.insertBefore(dom.doc.createTextNode('\r'), brElm);
					}
	
					// Insert temp marker and scroll to that
					marker = dom.create('span', {}, '&nbsp;');
					brElm.parentNode.insertBefore(marker, brElm);
					selection.scrollIntoView(marker);
					dom.remove(marker);
	
					if (!extraBr) {
						rng.setStartAfter(brElm);
						rng.setEndAfter(brElm);
					} else {
						rng.setStartBefore(brElm);
						rng.setEndBefore(brElm);
					}
	
					selection.setRng(rng);
					editor.undoManager.add();
	
					return TRUE;
				}
			});
	
			// Add queryCommandState overrides
			addCommands({
				// Override justify commands
				'JustifyLeft,JustifyCenter,JustifyRight,JustifyFull': function(command) {
					var name = 'align' + command.substring(7);
					var nodes = selection.isCollapsed() ? [dom.getParent(selection.getNode(), dom.isBlock)] : selection.getSelectedBlocks();
					var matches = map(nodes, function(node) {
						return !!formatter.matchNode(node, name);
					});
					return inArray(matches, TRUE) !== -1;
				},
	
				'Bold,Italic,Underline,Strikethrough,Superscript,Subscript': function(command) {
					return isFormatMatch(command);
				},
	
				mceBlockQuote: function() {
					return isFormatMatch('blockquote');
				},
	
				Outdent: function() {
					var node;
	
					if (settings.inline_styles) {
						if ((node = dom.getParent(selection.getStart(), dom.isBlock)) && parseInt(node.style.paddingLeft, 10) > 0) {
							return TRUE;
						}
	
						if ((node = dom.getParent(selection.getEnd(), dom.isBlock)) && parseInt(node.style.paddingLeft, 10) > 0) {
							return TRUE;
						}
					}
	
					return (
						queryCommandState('InsertUnorderedList') ||
						queryCommandState('InsertOrderedList') ||
						(!settings.inline_styles && !!dom.getParent(selection.getNode(), 'BLOCKQUOTE'))
					);
				},
	
				'InsertUnorderedList,InsertOrderedList': function(command) {
					var list = dom.getParent(selection.getNode(), 'ul,ol');
	
					return list &&
						(
							command === 'insertunorderedlist' && list.tagName === 'UL' ||
							command === 'insertorderedlist' && list.tagName === 'OL'
						);
				}
			}, 'state');
	
			// Add queryCommandValue overrides
			addCommands({
				'FontSize,FontName': function(command) {
					var value = 0, parent;
	
					if ((parent = dom.getParent(selection.getNode(), 'span'))) {
						if (command == 'fontsize') {
							value = parent.style.fontSize;
						} else {
							value = parent.style.fontFamily.replace(/, /g, ',').replace(/[\'\"]/g, '').toLowerCase();
						}
					}
	
					return value;
				}
			}, 'value');
	
			// Add undo manager logic
			addCommands({
				Undo: function() {
					editor.undoManager.undo();
				},
	
				Redo: function() {
					editor.undoManager.redo();
				}
			});
		};
	});
	
	// Included from: js/tinymce/classes/util/URI.js
	
	/**
	 * URI.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This class handles parsing, modification and serialization of URI/URL strings.
	 * @class tinymce.util.URI
	 */
	define("tinymce/util/URI", [
		"tinymce/util/Tools"
	], function(Tools) {
		var each = Tools.each, trim = Tools.trim;
		var queryParts = "source protocol authority userInfo user password host port relative path directory file query anchor".split(' ');
		var DEFAULT_PORTS = {
			'ftp': 21,
			'http': 80,
			'https': 443,
			'mailto': 25
		};
	
		/**
		 * Constructs a new URI instance.
		 *
		 * @constructor
		 * @method URI
		 * @param {String} url URI string to parse.
		 * @param {Object} settings Optional settings object.
		 */
		function URI(url, settings) {
			var self = this, baseUri, base_url;
	
			url = trim(url);
			settings = self.settings = settings || {};
			baseUri = settings.base_uri;
	
			// Strange app protocol that isn't http/https or local anchor
			// For example: mailto,skype,tel etc.
			if (/^([\w\-]+):([^\/]{2})/i.test(url) || /^\s*#/.test(url)) {
				self.source = url;
				return;
			}
	
			var isProtocolRelative = url.indexOf('//') === 0;
	
			// Absolute path with no host, fake host and protocol
			if (url.indexOf('/') === 0 && !isProtocolRelative) {
				url = (baseUri ? baseUri.protocol || 'http' : 'http') + '://mce_host' + url;
			}
	
			// Relative path http:// or protocol relative //path
			if (!/^[\w\-]*:?\/\//.test(url)) {
				base_url = settings.base_uri ? settings.base_uri.path : new URI(location.href).directory;
				if (settings.base_uri.protocol === "") {
					url = '//mce_host' + self.toAbsPath(base_url, url);
				} else {
					url = /([^#?]*)([#?]?.*)/.exec(url);
					url = ((baseUri && baseUri.protocol) || 'http') + '://mce_host' + self.toAbsPath(base_url, url[1]) + url[2];
				}
			}
	
			// Parse URL (Credits goes to Steave, http://blog.stevenlevithan.com/archives/parseuri)
			url = url.replace(/@@/g, '(mce_at)'); // Zope 3 workaround, they use @@something
	
			/*jshint maxlen: 255 */
			/*eslint max-len: 0 */
			url = /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@\/]*):?([^:@\/]*))?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/.exec(url);
	
			each(queryParts, function(v, i) {
				var part = url[i];
	
				// Zope 3 workaround, they use @@something
				if (part) {
					part = part.replace(/\(mce_at\)/g, '@@');
				}
	
				self[v] = part;
			});
	
			if (baseUri) {
				if (!self.protocol) {
					self.protocol = baseUri.protocol;
				}
	
				if (!self.userInfo) {
					self.userInfo = baseUri.userInfo;
				}
	
				if (!self.port && self.host === 'mce_host') {
					self.port = baseUri.port;
				}
	
				if (!self.host || self.host === 'mce_host') {
					self.host = baseUri.host;
				}
	
				self.source = '';
			}
	
			if (isProtocolRelative) {
				self.protocol = '';
			}
	
			//t.path = t.path || '/';
		}
	
		URI.prototype = {
			/**
			 * Sets the internal path part of the URI.
			 *
			 * @method setPath
			 * @param {string} path Path string to set.
			 */
			setPath: function(path) {
				var self = this;
	
				path = /^(.*?)\/?(\w+)?$/.exec(path);
	
				// Update path parts
				self.path = path[0];
				self.directory = path[1];
				self.file = path[2];
	
				// Rebuild source
				self.source = '';
				self.getURI();
			},
	
			/**
			 * Converts the specified URI into a relative URI based on the current URI instance location.
			 *
			 * @method toRelative
			 * @param {String} uri URI to convert into a relative path/URI.
			 * @return {String} Relative URI from the point specified in the current URI instance.
			 * @example
			 * // Converts an absolute URL to an relative URL url will be somedir/somefile.htm
			 * var url = new tinymce.util.URI('http://www.site.com/dir/').toRelative('http://www.site.com/dir/somedir/somefile.htm');
			 */
			toRelative: function(uri) {
				var self = this, output;
	
				if (uri === "./") {
					return uri;
				}
	
				uri = new URI(uri, {base_uri: self});
	
				// Not on same domain/port or protocol
				if ((uri.host != 'mce_host' && self.host != uri.host && uri.host) || self.port != uri.port ||
					(self.protocol != uri.protocol && uri.protocol !== "")) {
					return uri.getURI();
				}
	
				var tu = self.getURI(), uu = uri.getURI();
	
				// Allow usage of the base_uri when relative_urls = true
				if (tu == uu || (tu.charAt(tu.length - 1) == "/" && tu.substr(0, tu.length - 1) == uu)) {
					return tu;
				}
	
				output = self.toRelPath(self.path, uri.path);
	
				// Add query
				if (uri.query) {
					output += '?' + uri.query;
				}
	
				// Add anchor
				if (uri.anchor) {
					output += '#' + uri.anchor;
				}
	
				return output;
			},
	
			/**
			 * Converts the specified URI into a absolute URI based on the current URI instance location.
			 *
			 * @method toAbsolute
			 * @param {String} uri URI to convert into a relative path/URI.
			 * @param {Boolean} noHost No host and protocol prefix.
			 * @return {String} Absolute URI from the point specified in the current URI instance.
			 * @example
			 * // Converts an relative URL to an absolute URL url will be http://www.site.com/dir/somedir/somefile.htm
			 * var url = new tinymce.util.URI('http://www.site.com/dir/').toAbsolute('somedir/somefile.htm');
			 */
			toAbsolute: function(uri, noHost) {
				uri = new URI(uri, {base_uri: this});
	
				return uri.getURI(noHost && this.isSameOrigin(uri));
			},
	
			/**
			 * Determine whether the given URI has the same origin as this URI.  Based on RFC-6454.
			 * Supports default ports for protocols listed in DEFAULT_PORTS.  Unsupported protocols will fail safe: they
			 * won't match, if the port specifications differ.
			 *
			 * @method isSameOrigin
			 * @param {tinymce.util.URI} uri Uri instance to compare.
			 * @returns {Boolean} True if the origins are the same.
			 */
			isSameOrigin: function(uri) {
				if (this.host == uri.host && this.protocol == uri.protocol) {
					if (this.port == uri.port) {
						return true;
					}
	
					var defaultPort = DEFAULT_PORTS[this.protocol];
					if (defaultPort && ((this.port || defaultPort) == (uri.port || defaultPort))) {
						return true;
					}
				}
	
				return false;
			},
	
			/**
			 * Converts a absolute path into a relative path.
			 *
			 * @method toRelPath
			 * @param {String} base Base point to convert the path from.
			 * @param {String} path Absolute path to convert into a relative path.
			 */
			toRelPath: function(base, path) {
				var items, breakPoint = 0, out = '', i, l;
	
				// Split the paths
				base = base.substring(0, base.lastIndexOf('/'));
				base = base.split('/');
				items = path.split('/');
	
				if (base.length >= items.length) {
					for (i = 0, l = base.length; i < l; i++) {
						if (i >= items.length || base[i] != items[i]) {
							breakPoint = i + 1;
							break;
						}
					}
				}
	
				if (base.length < items.length) {
					for (i = 0, l = items.length; i < l; i++) {
						if (i >= base.length || base[i] != items[i]) {
							breakPoint = i + 1;
							break;
						}
					}
				}
	
				if (breakPoint === 1) {
					return path;
				}
	
				for (i = 0, l = base.length - (breakPoint - 1); i < l; i++) {
					out += "../";
				}
	
				for (i = breakPoint - 1, l = items.length; i < l; i++) {
					if (i != breakPoint - 1) {
						out += "/" + items[i];
					} else {
						out += items[i];
					}
				}
	
				return out;
			},
	
			/**
			 * Converts a relative path into a absolute path.
			 *
			 * @method toAbsPath
			 * @param {String} base Base point to convert the path from.
			 * @param {String} path Relative path to convert into an absolute path.
			 */
			toAbsPath: function(base, path) {
				var i, nb = 0, o = [], tr, outPath;
	
				// Split paths
				tr = /\/$/.test(path) ? '/' : '';
				base = base.split('/');
				path = path.split('/');
	
				// Remove empty chunks
				each(base, function(k) {
					if (k) {
						o.push(k);
					}
				});
	
				base = o;
	
				// Merge relURLParts chunks
				for (i = path.length - 1, o = []; i >= 0; i--) {
					// Ignore empty or .
					if (path[i].length === 0 || path[i] === ".") {
						continue;
					}
	
					// Is parent
					if (path[i] === '..') {
						nb++;
						continue;
					}
	
					// Move up
					if (nb > 0) {
						nb--;
						continue;
					}
	
					o.push(path[i]);
				}
	
				i = base.length - nb;
	
				// If /a/b/c or /
				if (i <= 0) {
					outPath = o.reverse().join('/');
				} else {
					outPath = base.slice(0, i).join('/') + '/' + o.reverse().join('/');
				}
	
				// Add front / if it's needed
				if (outPath.indexOf('/') !== 0) {
					outPath = '/' + outPath;
				}
	
				// Add traling / if it's needed
				if (tr && outPath.lastIndexOf('/') !== outPath.length - 1) {
					outPath += tr;
				}
	
				return outPath;
			},
	
			/**
			 * Returns the full URI of the internal structure.
			 *
			 * @method getURI
			 * @param {Boolean} noProtoHost Optional no host and protocol part. Defaults to false.
			 */
			getURI: function(noProtoHost) {
				var s, self = this;
	
				// Rebuild source
				if (!self.source || noProtoHost) {
					s = '';
	
					if (!noProtoHost) {
						if (self.protocol) {
							s += self.protocol + '://';
						} else {
							s += '//';
						}
	
						if (self.userInfo) {
							s += self.userInfo + '@';
						}
	
						if (self.host) {
							s += self.host;
						}
	
						if (self.port) {
							s += ':' + self.port;
						}
					}
	
					if (self.path) {
						s += self.path;
					}
	
					if (self.query) {
						s += '?' + self.query;
					}
	
					if (self.anchor) {
						s += '#' + self.anchor;
					}
	
					self.source = s;
				}
	
				return self.source;
			}
		};
	
		URI.parseDataUri = function(uri) {
			var type, matches;
	
			uri = decodeURIComponent(uri).split(',');
	
			matches = /data:([^;]+)/.exec(uri[0]);
			if (matches) {
				type = matches[1];
			}
	
			return {
				type: type,
				data: uri[1]
			};
		};
	
		URI.getDocumentBaseUrl = function(loc) {
			var baseUrl;
	
			// Pass applewebdata:// and other non web protocols though
			if (loc.protocol.indexOf('http') !== 0 && loc.protocol !== 'file:') {
				baseUrl = loc.href;
			} else {
				baseUrl = loc.protocol + '//' + loc.host + loc.pathname;
			}
	
			if (/^[^:]+:\/\/\/?[^\/]+\//.test(baseUrl)) {
				baseUrl = baseUrl.replace(/[\?#].*$/, '').replace(/[\/\\][^\/]+$/, '');
	
				if (!/[\/\\]$/.test(baseUrl)) {
					baseUrl += '/';
				}
			}
	
			return baseUrl;
		};
	
		return URI;
	});
	
	// Included from: js/tinymce/classes/util/Class.js
	
	/**
	 * Class.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This utilitiy class is used for easier inheritance.
	 *
	 * Features:
	 * * Exposed super functions: this._super();
	 * * Mixins
	 * * Dummy functions
	 * * Property functions: var value = object.value(); and object.value(newValue);
	 * * Static functions
	 * * Defaults settings
	 */
	define("tinymce/util/Class", [
		"tinymce/util/Tools"
	], function(Tools) {
		var each = Tools.each, extend = Tools.extend;
	
		var extendClass, initializing;
	
		function Class() {
		}
	
		// Provides classical inheritance, based on code made by John Resig
		Class.extend = extendClass = function(prop) {
			var self = this, _super = self.prototype, prototype, name, member;
	
			// The dummy class constructor
			function Class() {
				var i, mixins, mixin, self = this;
	
				// All construction is actually done in the init method
				if (!initializing) {
					// Run class constuctor
					if (self.init) {
						self.init.apply(self, arguments);
					}
	
					// Run mixin constructors
					mixins = self.Mixins;
					if (mixins) {
						i = mixins.length;
						while (i--) {
							mixin = mixins[i];
							if (mixin.init) {
								mixin.init.apply(self, arguments);
							}
						}
					}
				}
			}
	
			// Dummy function, needs to be extended in order to provide functionality
			function dummy() {
				return this;
			}
	
			// Creates a overloaded method for the class
			// this enables you to use this._super(); to call the super function
			function createMethod(name, fn) {
				return function() {
					var self = this, tmp = self._super, ret;
	
					self._super = _super[name];
					ret = fn.apply(self, arguments);
					self._super = tmp;
	
					return ret;
				};
			}
	
			// Instantiate a base class (but only create the instance,
			// don't run the init constructor)
			initializing = true;
	
			/*eslint new-cap:0 */
			prototype = new self();
			initializing = false;
	
			// Add mixins
			if (prop.Mixins) {
				each(prop.Mixins, function(mixin) {
					for (var name in mixin) {
						if (name !== "init") {
							prop[name] = mixin[name];
						}
					}
				});
	
				if (_super.Mixins) {
					prop.Mixins = _super.Mixins.concat(prop.Mixins);
				}
			}
	
			// Generate dummy methods
			if (prop.Methods) {
				each(prop.Methods.split(','), function(name) {
					prop[name] = dummy;
				});
			}
	
			// Generate property methods
			if (prop.Properties) {
				each(prop.Properties.split(','), function(name) {
					var fieldName = '_' + name;
	
					prop[name] = function(value) {
						var self = this, undef;
	
						// Set value
						if (value !== undef) {
							self[fieldName] = value;
	
							return self;
						}
	
						// Get value
						return self[fieldName];
					};
				});
			}
	
			// Static functions
			if (prop.Statics) {
				each(prop.Statics, function(func, name) {
					Class[name] = func;
				});
			}
	
			// Default settings
			if (prop.Defaults && _super.Defaults) {
				prop.Defaults = extend({}, _super.Defaults, prop.Defaults);
			}
	
			// Copy the properties over onto the new prototype
			for (name in prop) {
				member = prop[name];
	
				if (typeof member == "function" && _super[name]) {
					prototype[name] = createMethod(name, member);
				} else {
					prototype[name] = member;
				}
			}
	
			// Populate our constructed prototype object
			Class.prototype = prototype;
	
			// Enforce the constructor to be what we expect
			Class.constructor = Class;
	
			// And make this class extendible
			Class.extend = extendClass;
	
			return Class;
		};
	
		return Class;
	});
	
	// Included from: js/tinymce/classes/util/EventDispatcher.js
	
	/**
	 * EventDispatcher.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This class lets you add/remove and fire events by name on the specified scope. This makes
	 * it easy to add event listener logic to any class.
	 *
	 * @class tinymce.util.EventDispatcher
	 * @example
	 *  var eventDispatcher = new EventDispatcher();
	 *
	 *  eventDispatcher.on('click', function() {console.log('data');});
	 *  eventDispatcher.fire('click', {data: 123});
	 */
	define("tinymce/util/EventDispatcher", [
		"tinymce/util/Tools"
	], function(Tools) {
		var nativeEvents = Tools.makeMap(
			"focus blur focusin focusout click dblclick mousedown mouseup mousemove mouseover beforepaste paste cut copy selectionchange " +
			"mouseout mouseenter mouseleave wheel keydown keypress keyup input contextmenu dragstart dragend dragover " +
			"draggesture dragdrop drop drag submit " +
			"compositionstart compositionend compositionupdate touchstart touchmove touchend",
			' '
		);
	
		function Dispatcher(settings) {
			var self = this, scope, bindings = {}, toggleEvent;
	
			function returnFalse() {
				return false;
			}
	
			function returnTrue() {
				return true;
			}
	
			settings = settings || {};
			scope = settings.scope || self;
			toggleEvent = settings.toggleEvent || returnFalse;
	
			/**
			 * Fires the specified event by name.
			 *
			 * @method fire
			 * @param {String} name Name of the event to fire.
			 * @param {Object?} args Event arguments.
			 * @return {Object} Event args instance passed in.
			 * @example
			 * instance.fire('event', {...});
			 */
			function fire(name, args) {
				var handlers, i, l, callback;
	
				name = name.toLowerCase();
				args = args || {};
				args.type = name;
	
				// Setup target is there isn't one
				if (!args.target) {
					args.target = scope;
				}
	
				// Add event delegation methods if they are missing
				if (!args.preventDefault) {
					// Add preventDefault method
					args.preventDefault = function() {
						args.isDefaultPrevented = returnTrue;
					};
	
					// Add stopPropagation
					args.stopPropagation = function() {
						args.isPropagationStopped = returnTrue;
					};
	
					// Add stopImmediatePropagation
					args.stopImmediatePropagation = function() {
						args.isImmediatePropagationStopped = returnTrue;
					};
	
					// Add event delegation states
					args.isDefaultPrevented = returnFalse;
					args.isPropagationStopped = returnFalse;
					args.isImmediatePropagationStopped = returnFalse;
				}
	
				if (settings.beforeFire) {
					settings.beforeFire(args);
				}
	
				handlers = bindings[name];
				if (handlers) {
					for (i = 0, l = handlers.length; i < l; i++) {
						callback = handlers[i];
	
						// Unbind handlers marked with "once"
						if (callback.once) {
							off(name, callback.func);
						}
	
						// Stop immediate propagation if needed
						if (args.isImmediatePropagationStopped()) {
							args.stopPropagation();
							return args;
						}
	
						// If callback returns false then prevent default and stop all propagation
						if (callback.func.call(scope, args) === false) {
							args.preventDefault();
							return args;
						}
					}
				}
	
				return args;
			}
	
			/**
			 * Binds an event listener to a specific event by name.
			 *
			 * @method on
			 * @param {String} name Event name or space separated list of events to bind.
			 * @param {callback} callback Callback to be executed when the event occurs.
			 * @param {Boolean} first Optional flag if the event should be prepended. Use this with care.
			 * @return {Object} Current class instance.
			 * @example
			 * instance.on('event', function(e) {
			 *     // Callback logic
			 * });
			 */
			function on(name, callback, prepend, extra) {
				var handlers, names, i;
	
				if (callback === false) {
					callback = returnFalse;
				}
	
				if (callback) {
					callback = {
						func: callback
					};
	
					if (extra) {
						Tools.extend(callback, extra);
					}
	
					names = name.toLowerCase().split(' ');
					i = names.length;
					while (i--) {
						name = names[i];
						handlers = bindings[name];
						if (!handlers) {
							handlers = bindings[name] = [];
							toggleEvent(name, true);
						}
	
						if (prepend) {
							handlers.unshift(callback);
						} else {
							handlers.push(callback);
						}
					}
				}
	
				return self;
			}
	
			/**
			 * Unbinds an event listener to a specific event by name.
			 *
			 * @method off
			 * @param {String?} name Name of the event to unbind.
			 * @param {callback?} callback Callback to unbind.
			 * @return {Object} Current class instance.
			 * @example
			 * // Unbind specific callback
			 * instance.off('event', handler);
			 *
			 * // Unbind all listeners by name
			 * instance.off('event');
			 *
			 * // Unbind all events
			 * instance.off();
			 */
			function off(name, callback) {
				var i, handlers, bindingName, names, hi;
	
				if (name) {
					names = name.toLowerCase().split(' ');
					i = names.length;
					while (i--) {
						name = names[i];
						handlers = bindings[name];
	
						// Unbind all handlers
						if (!name) {
							for (bindingName in bindings) {
								toggleEvent(bindingName, false);
								delete bindings[bindingName];
							}
	
							return self;
						}
	
						if (handlers) {
							// Unbind all by name
							if (!callback) {
								handlers.length = 0;
							} else {
								// Unbind specific ones
								hi = handlers.length;
								while (hi--) {
									if (handlers[hi].func === callback) {
										handlers = handlers.slice(0, hi).concat(handlers.slice(hi + 1));
										bindings[name] = handlers;
									}
								}
							}
	
							if (!handlers.length) {
								toggleEvent(name, false);
								delete bindings[name];
							}
						}
					}
				} else {
					for (name in bindings) {
						toggleEvent(name, false);
					}
	
					bindings = {};
				}
	
				return self;
			}
	
			/**
			 * Binds an event listener to a specific event by name
			 * and automatically unbind the event once the callback fires.
			 *
			 * @method once
			 * @param {String} name Event name or space separated list of events to bind.
			 * @param {callback} callback Callback to be executed when the event occurs.
			 * @param {Boolean} first Optional flag if the event should be prepended. Use this with care.
			 * @return {Object} Current class instance.
			 * @example
			 * instance.once('event', function(e) {
			 *     // Callback logic
			 * });
			 */
			function once(name, callback, prepend) {
				return on(name, callback, prepend, {once: true});
			}
	
			/**
			 * Returns true/false if the dispatcher has a event of the specified name.
			 *
			 * @method has
			 * @param {String} name Name of the event to check for.
			 * @return {Boolean} true/false if the event exists or not.
			 */
			function has(name) {
				name = name.toLowerCase();
				return !(!bindings[name] || bindings[name].length === 0);
			}
	
			// Expose
			self.fire = fire;
			self.on = on;
			self.off = off;
			self.once = once;
			self.has = has;
		}
	
		/**
		 * Returns true/false if the specified event name is a native browser event or not.
		 *
		 * @method isNative
		 * @param {String} name Name to check if it's native.
		 * @return {Boolean} true/false if the event is native or not.
		 * @static
		 */
		Dispatcher.isNative = function(name) {
			return !!nativeEvents[name.toLowerCase()];
		};
	
		return Dispatcher;
	});
	
	// Included from: js/tinymce/classes/data/Binding.js
	
	/**
	 * Binding.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This class gets dynamically extended to provide a binding between two models. This makes it possible to
	 * sync the state of two properties in two models by a layer of abstraction.
	 *
	 * @private
	 * @class tinymce.data.Binding
	 */
	define("tinymce/data/Binding", [], function() {
		/**
		 * Constructs a new bidning.
		 *
		 * @constructor
		 * @method Binding
		 * @param {Object} settings Settings to the binding.
		 */
		function Binding(settings) {
			this.create = settings.create;
		}
	
		/**
		 * Creates a binding for a property on a model.
		 *
		 * @method create
		 * @param {tinymce.data.ObservableObject} model Model to create binding to.
		 * @param {String} name Name of property to bind.
		 * @return {tinymce.data.Binding} Binding instance.
		 */
		Binding.create = function(model, name) {
			return new Binding({
				create: function(otherModel, otherName) {
					var bindings;
	
					function fromSelfToOther(e) {
						otherModel.set(otherName, e.value);
					}
	
					function fromOtherToSelf(e) {
						model.set(name, e.value);
					}
	
					otherModel.on('change:' + otherName, fromOtherToSelf);
					model.on('change:' + name, fromSelfToOther);
	
					// Keep track of the bindings
					bindings = otherModel._bindings;
	
					if (!bindings) {
						bindings = otherModel._bindings = [];
	
						otherModel.on('destroy', function() {
							var i = bindings.length;
	
							while (i--) {
								bindings[i]();
							}
						});
					}
	
					bindings.push(function() {
						model.off('change:' + name, fromSelfToOther);
					});
	
					return model.get(name);
				}
			});
		};
	
		return Binding;
	});
	
	// Included from: js/tinymce/classes/util/Observable.js
	
	/**
	 * Observable.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This mixin will add event binding logic to classes.
	 *
	 * @mixin tinymce.util.Observable
	 */
	define("tinymce/util/Observable", [
		"tinymce/util/EventDispatcher"
	], function(EventDispatcher) {
		function getEventDispatcher(obj) {
			if (!obj._eventDispatcher) {
				obj._eventDispatcher = new EventDispatcher({
					scope: obj,
					toggleEvent: function(name, state) {
						if (EventDispatcher.isNative(name) && obj.toggleNativeEvent) {
							obj.toggleNativeEvent(name, state);
						}
					}
				});
			}
	
			return obj._eventDispatcher;
		}
	
		return {
			/**
			 * Fires the specified event by name. Consult the
			 * <a href="/advanced/events">event reference</a> for more details on each event.
			 *
			 * @method fire
			 * @param {String} name Name of the event to fire.
			 * @param {Object?} args Event arguments.
			 * @param {Boolean?} bubble True/false if the event is to be bubbled.
			 * @return {Object} Event args instance passed in.
			 * @example
			 * instance.fire('event', {...});
			 */
			fire: function(name, args, bubble) {
				var self = this;
	
				// Prevent all events except the remove event after the instance has been removed
				if (self.removed && name !== "remove") {
					return args;
				}
	
				args = getEventDispatcher(self).fire(name, args, bubble);
	
				// Bubble event up to parents
				if (bubble !== false && self.parent) {
					var parent = self.parent();
					while (parent && !args.isPropagationStopped()) {
						parent.fire(name, args, false);
						parent = parent.parent();
					}
				}
	
				return args;
			},
	
			/**
			 * Binds an event listener to a specific event by name. Consult the
			 * <a href="/advanced/events">event reference</a> for more details on each event.
			 *
			 * @method on
			 * @param {String} name Event name or space separated list of events to bind.
			 * @param {callback} callback Callback to be executed when the event occurs.
			 * @param {Boolean} first Optional flag if the event should be prepended. Use this with care.
			 * @return {Object} Current class instance.
			 * @example
			 * instance.on('event', function(e) {
			 *     // Callback logic
			 * });
			 */
			on: function(name, callback, prepend) {
				return getEventDispatcher(this).on(name, callback, prepend);
			},
	
			/**
			 * Unbinds an event listener to a specific event by name. Consult the
			 * <a href="/advanced/events">event reference</a> for more details on each event.
			 *
			 * @method off
			 * @param {String?} name Name of the event to unbind.
			 * @param {callback?} callback Callback to unbind.
			 * @return {Object} Current class instance.
			 * @example
			 * // Unbind specific callback
			 * instance.off('event', handler);
			 *
			 * // Unbind all listeners by name
			 * instance.off('event');
			 *
			 * // Unbind all events
			 * instance.off();
			 */
			off: function(name, callback) {
				return getEventDispatcher(this).off(name, callback);
			},
	
			/**
			 * Bind the event callback and once it fires the callback is removed. Consult the
			 * <a href="/advanced/events">event reference</a> for more details on each event.
			 *
			 * @method once
			 * @param {String} name Name of the event to bind.
			 * @param {callback} callback Callback to bind only once.
			 * @return {Object} Current class instance.
			 */
			once: function(name, callback) {
				return getEventDispatcher(this).once(name, callback);
			},
	
			/**
			 * Returns true/false if the object has a event of the specified name.
			 *
			 * @method hasEventListeners
			 * @param {String} name Name of the event to check for.
			 * @return {Boolean} true/false if the event exists or not.
			 */
			hasEventListeners: function(name) {
				return getEventDispatcher(this).has(name);
			}
		};
	});
	
	// Included from: js/tinymce/classes/data/ObservableObject.js
	
	/**
	 * ObservableObject.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This class is a object that is observable when properties changes a change event gets emitted.
	 *
	 * @private
	 * @class tinymce.data.ObservableObject
	 */
	define("tinymce/data/ObservableObject", [
		"tinymce/data/Binding",
		"tinymce/util/Observable",
		"tinymce/util/Class",
		"tinymce/util/Tools"
	], function(Binding, Observable, Class, Tools) {
		function isNode(node) {
			return node.nodeType > 0;
		}
	
		// Todo: Maybe this should be shallow compare since it might be huge object references
		function isEqual(a, b) {
			var k, checked;
	
			// Strict equals
			if (a === b) {
				return true;
			}
	
			// Compare null
			if (a === null || b === null) {
				return a === b;
			}
	
			// Compare number, boolean, string, undefined
			if (typeof a !== "object" || typeof b !== "object") {
				return a === b;
			}
	
			// Compare arrays
			if (Tools.isArray(b)) {
				if (a.length !== b.length) {
					return false;
				}
	
				k = a.length;
				while (k--) {
					if (!isEqual(a[k], b[k])) {
						return false;
					}
				}
			}
	
			// Shallow compare nodes
			if (isNode(a) || isNode(b)) {
				return a === b;
			}
	
			// Compare objects
			checked = {};
			for (k in b) {
				if (!isEqual(a[k], b[k])) {
					return false;
				}
	
				checked[k] = true;
			}
	
			for (k in a) {
				if (!checked[k] && !isEqual(a[k], b[k])) {
					return false;
				}
			}
	
			return true;
		}
	
		return Class.extend({
			Mixins: [Observable],
	
			/**
			 * Constructs a new observable object instance.
			 *
			 * @constructor
			 * @param {Object} data Initial data for the object.
			 */
			init: function(data) {
				var name, value;
	
				data = data || {};
	
				for (name in data) {
					value = data[name];
	
					if (value instanceof Binding) {
						data[name] = value.create(this, name);
					}
				}
	
				this.data = data;
			},
	
			/**
			 * Sets a property on the value this will call
			 * observers if the value is a change from the current value.
			 *
			 * @method set
			 * @param {String/object} name Name of the property to set or a object of items to set.
			 * @param {Object} value Value to set for the property.
			 * @return {tinymce.data.ObservableObject} Observable object instance.
			 */
			set: function(name, value) {
				var key, args, oldValue = this.data[name];
	
				if (value instanceof Binding) {
					value = value.create(this, name);
				}
	
				if (typeof name === "object") {
					for (key in name) {
						this.set(key, name[key]);
					}
	
					return this;
				}
	
				if (!isEqual(oldValue, value)) {
					this.data[name] = value;
	
					args = {
						target: this,
						name: name,
						value: value,
						oldValue: oldValue
					};
	
					this.fire('change:' + name, args);
					this.fire('change', args);
				}
	
				return this;
			},
	
			/**
			 * Gets a property by name.
			 *
			 * @method get
			 * @param {String} name Name of the property to get.
			 * @return {Object} Object value of propery.
			 */
			get: function(name) {
				return this.data[name];
			},
	
			/**
			 * Returns true/false if the specified property exists.
			 *
			 * @method has
			 * @param {String} name Name of the property to check for.
			 * @return {Boolean} true/false if the item exists.
			 */
			has: function(name) {
				return name in this.data;
			},
	
			/**
			 * Returns a dynamic property binding for the specified property name. This makes
			 * it possible to sync the state of two properties in two ObservableObject instances.
			 *
			 * @method bind
			 * @param {String} name Name of the property to sync with the property it's inserted to.
			 * @return {tinymce.data.Binding} Data binding instance.
			 */
			bind: function(name) {
				return Binding.create(this, name);
			},
	
			/**
			 * Destroys the observable object and fires the "destroy"
			 * event and clean up any internal resources.
			 *
			 * @method destroy
			 */
			destroy: function() {
				this.fire('destroy');
			}
		});
	});
	
	// Included from: js/tinymce/classes/ui/Selector.js
	
	/**
	 * Selector.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/*eslint no-nested-ternary:0 */
	
	/**
	 * Selector engine, enables you to select controls by using CSS like expressions.
	 * We currently only support basic CSS expressions to reduce the size of the core
	 * and the ones we support should be enough for most cases.
	 *
	 * @example
	 * Supported expressions:
	 *  element
	 *  element#name
	 *  element.class
	 *  element[attr]
	 *  element[attr*=value]
	 *  element[attr~=value]
	 *  element[attr!=value]
	 *  element[attr^=value]
	 *  element[attr$=value]
	 *  element:<state>
	 *  element:not(<expression>)
	 *  element:first
	 *  element:last
	 *  element:odd
	 *  element:even
	 *  element element
	 *  element > element
	 *
	 * @class tinymce.ui.Selector
	 */
	define("tinymce/ui/Selector", [
		"tinymce/util/Class"
	], function(Class) {
		"use strict";
	
		/**
		 * Produces an array with a unique set of objects. It will not compare the values
		 * but the references of the objects.
		 *
		 * @private
		 * @method unqiue
		 * @param {Array} array Array to make into an array with unique items.
		 * @return {Array} Array with unique items.
		 */
		function unique(array) {
			var uniqueItems = [], i = array.length, item;
	
			while (i--) {
				item = array[i];
	
				if (!item.__checked) {
					uniqueItems.push(item);
					item.__checked = 1;
				}
			}
	
			i = uniqueItems.length;
			while (i--) {
				delete uniqueItems[i].__checked;
			}
	
			return uniqueItems;
		}
	
		var expression = /^([\w\\*]+)?(?:#([\w\-\\]+))?(?:\.([\w\\\.]+))?(?:\[\@?([\w\\]+)([\^\$\*!~]?=)([\w\\]+)\])?(?:\:(.+))?/i;
	
		/*jshint maxlen:255 */
		/*eslint max-len:0 */
		var chunker = /((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^\[\]]*\]|['"][^'"]*['"]|[^\[\]'"]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?((?:.|\r|\n)*)/g,
			whiteSpace = /^\s*|\s*$/g,
			Collection;
	
		var Selector = Class.extend({
			/**
			 * Constructs a new Selector instance.
			 *
			 * @constructor
			 * @method init
			 * @param {String} selector CSS like selector expression.
			 */
			init: function(selector) {
				var match = this.match;
	
				function compileNameFilter(name) {
					if (name) {
						name = name.toLowerCase();
	
						return function(item) {
							return name === '*' || item.type === name;
						};
					}
				}
	
				function compileIdFilter(id) {
					if (id) {
						return function(item) {
							return item._name === id;
						};
					}
				}
	
				function compileClassesFilter(classes) {
					if (classes) {
						classes = classes.split('.');
	
						return function(item) {
							var i = classes.length;
	
							while (i--) {
								if (!item.classes.contains(classes[i])) {
									return false;
								}
							}
	
							return true;
						};
					}
				}
	
				function compileAttrFilter(name, cmp, check) {
					if (name) {
						return function(item) {
							var value = item[name] ? item[name]() : '';
	
							return !cmp ? !!check :
								cmp === "=" ? value === check :
								cmp === "*=" ? value.indexOf(check) >= 0 :
								cmp === "~=" ? (" " + value + " ").indexOf(" " + check + " ") >= 0 :
								cmp === "!=" ? value != check :
								cmp === "^=" ? value.indexOf(check) === 0 :
								cmp === "$=" ? value.substr(value.length - check.length) === check :
								false;
						};
					}
				}
	
				function compilePsuedoFilter(name) {
					var notSelectors;
	
					if (name) {
						name = /(?:not\((.+)\))|(.+)/i.exec(name);
	
						if (!name[1]) {
							name = name[2];
	
							return function(item, index, length) {
								return name === 'first' ? index === 0 :
									name === 'last' ? index === length - 1 :
									name === 'even' ? index % 2 === 0 :
									name === 'odd' ? index % 2 === 1 :
									item[name] ? item[name]() :
									false;
							};
						}
	
						// Compile not expression
						notSelectors = parseChunks(name[1], []);
	
						return function(item) {
							return !match(item, notSelectors);
						};
					}
				}
	
				function compile(selector, filters, direct) {
					var parts;
	
					function add(filter) {
						if (filter) {
							filters.push(filter);
						}
					}
	
					// Parse expression into parts
					parts = expression.exec(selector.replace(whiteSpace, ''));
	
					add(compileNameFilter(parts[1]));
					add(compileIdFilter(parts[2]));
					add(compileClassesFilter(parts[3]));
					add(compileAttrFilter(parts[4], parts[5], parts[6]));
					add(compilePsuedoFilter(parts[7]));
	
					// Mark the filter with pseudo for performance
					filters.pseudo = !!parts[7];
					filters.direct = direct;
	
					return filters;
				}
	
				// Parser logic based on Sizzle by John Resig
				function parseChunks(selector, selectors) {
					var parts = [], extra, matches, i;
	
					do {
						chunker.exec("");
						matches = chunker.exec(selector);
	
						if (matches) {
							selector = matches[3];
							parts.push(matches[1]);
	
							if (matches[2]) {
								extra = matches[3];
								break;
							}
						}
					} while (matches);
	
					if (extra) {
						parseChunks(extra, selectors);
					}
	
					selector = [];
					for (i = 0; i < parts.length; i++) {
						if (parts[i] != '>') {
							selector.push(compile(parts[i], [], parts[i - 1] === '>'));
						}
					}
	
					selectors.push(selector);
	
					return selectors;
				}
	
				this._selectors = parseChunks(selector, []);
			},
	
			/**
			 * Returns true/false if the selector matches the specified control.
			 *
			 * @method match
			 * @param {tinymce.ui.Control} control Control to match against the selector.
			 * @param {Array} selectors Optional array of selectors, mostly used internally.
			 * @return {Boolean} true/false state if the control matches or not.
			 */
			match: function(control, selectors) {
				var i, l, si, sl, selector, fi, fl, filters, index, length, siblings, count, item;
	
				selectors = selectors || this._selectors;
				for (i = 0, l = selectors.length; i < l; i++) {
					selector = selectors[i];
					sl = selector.length;
					item = control;
					count = 0;
	
					for (si = sl - 1; si >= 0; si--) {
						filters = selector[si];
	
						while (item) {
							// Find the index and length since a pseudo filter like :first needs it
							if (filters.pseudo) {
								siblings = item.parent().items();
								index = length = siblings.length;
								while (index--) {
									if (siblings[index] === item) {
										break;
									}
								}
							}
	
							for (fi = 0, fl = filters.length; fi < fl; fi++) {
								if (!filters[fi](item, index, length)) {
									fi = fl + 1;
									break;
								}
							}
	
							if (fi === fl) {
								count++;
								break;
							} else {
								// If it didn't match the right most expression then
								// break since it's no point looking at the parents
								if (si === sl - 1) {
									break;
								}
							}
	
							item = item.parent();
						}
					}
	
					// If we found all selectors then return true otherwise continue looking
					if (count === sl) {
						return true;
					}
				}
	
				return false;
			},
	
			/**
			 * Returns a tinymce.ui.Collection with matches of the specified selector inside the specified container.
			 *
			 * @method find
			 * @param {tinymce.ui.Control} container Container to look for items in.
			 * @return {tinymce.ui.Collection} Collection with matched elements.
			 */
			find: function(container) {
				var matches = [], i, l, selectors = this._selectors;
	
				function collect(items, selector, index) {
					var i, l, fi, fl, item, filters = selector[index];
	
					for (i = 0, l = items.length; i < l; i++) {
						item = items[i];
	
						// Run each filter against the item
						for (fi = 0, fl = filters.length; fi < fl; fi++) {
							if (!filters[fi](item, i, l)) {
								fi = fl + 1;
								break;
							}
						}
	
						// All filters matched the item
						if (fi === fl) {
							// Matched item is on the last expression like: panel toolbar [button]
							if (index == selector.length - 1) {
								matches.push(item);
							} else {
								// Collect next expression type
								if (item.items) {
									collect(item.items(), selector, index + 1);
								}
							}
						} else if (filters.direct) {
							return;
						}
	
						// Collect child items
						if (item.items) {
							collect(item.items(), selector, index);
						}
					}
				}
	
				if (container.items) {
					for (i = 0, l = selectors.length; i < l; i++) {
						collect(container.items(), selectors[i], 0);
					}
	
					// Unique the matches if needed
					if (l > 1) {
						matches = unique(matches);
					}
				}
	
				// Fix for circular reference
				if (!Collection) {
					// TODO: Fix me!
					Collection = Selector.Collection;
				}
	
				return new Collection(matches);
			}
		});
	
		return Selector;
	});
	
	// Included from: js/tinymce/classes/ui/Collection.js
	
	/**
	 * Collection.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Control collection, this class contains control instances and it enables you to
	 * perform actions on all the contained items. This is very similar to how jQuery works.
	 *
	 * @example
	 * someCollection.show().disabled(true);
	 *
	 * @class tinymce.ui.Collection
	 */
	define("tinymce/ui/Collection", [
		"tinymce/util/Tools",
		"tinymce/ui/Selector",
		"tinymce/util/Class"
	], function(Tools, Selector, Class) {
		"use strict";
	
		var Collection, proto, push = Array.prototype.push, slice = Array.prototype.slice;
	
		proto = {
			/**
			 * Current number of contained control instances.
			 *
			 * @field length
			 * @type Number
			 */
			length: 0,
	
			/**
			 * Constructor for the collection.
			 *
			 * @constructor
			 * @method init
			 * @param {Array} items Optional array with items to add.
			 */
			init: function(items) {
				if (items) {
					this.add(items);
				}
			},
	
			/**
			 * Adds new items to the control collection.
			 *
			 * @method add
			 * @param {Array} items Array if items to add to collection.
			 * @return {tinymce.ui.Collection} Current collection instance.
			 */
			add: function(items) {
				var self = this;
	
				// Force single item into array
				if (!Tools.isArray(items)) {
					if (items instanceof Collection) {
						self.add(items.toArray());
					} else {
						push.call(self, items);
					}
				} else {
					push.apply(self, items);
				}
	
				return self;
			},
	
			/**
			 * Sets the contents of the collection. This will remove any existing items
			 * and replace them with the ones specified in the input array.
			 *
			 * @method set
			 * @param {Array} items Array with items to set into the Collection.
			 * @return {tinymce.ui.Collection} Collection instance.
			 */
			set: function(items) {
				var self = this, len = self.length, i;
	
				self.length = 0;
				self.add(items);
	
				// Remove old entries
				for (i = self.length; i < len; i++) {
					delete self[i];
				}
	
				return self;
			},
	
			/**
			 * Filters the collection item based on the specified selector expression or selector function.
			 *
			 * @method filter
			 * @param {String} selector Selector expression to filter items by.
			 * @return {tinymce.ui.Collection} Collection containing the filtered items.
			 */
			filter: function(selector) {
				var self = this, i, l, matches = [], item, match;
	
				// Compile string into selector expression
				if (typeof selector === "string") {
					selector = new Selector(selector);
	
					match = function(item) {
						return selector.match(item);
					};
				} else {
					// Use selector as matching function
					match = selector;
				}
	
				for (i = 0, l = self.length; i < l; i++) {
					item = self[i];
	
					if (match(item)) {
						matches.push(item);
					}
				}
	
				return new Collection(matches);
			},
	
			/**
			 * Slices the items within the collection.
			 *
			 * @method slice
			 * @param {Number} index Index to slice at.
			 * @param {Number} len Optional length to slice.
			 * @return {tinymce.ui.Collection} Current collection.
			 */
			slice: function() {
				return new Collection(slice.apply(this, arguments));
			},
	
			/**
			 * Makes the current collection equal to the specified index.
			 *
			 * @method eq
			 * @param {Number} index Index of the item to set the collection to.
			 * @return {tinymce.ui.Collection} Current collection.
			 */
			eq: function(index) {
				return index === -1 ? this.slice(index) : this.slice(index, +index + 1);
			},
	
			/**
			 * Executes the specified callback on each item in collection.
			 *
			 * @method each
			 * @param {function} callback Callback to execute for each item in collection.
			 * @return {tinymce.ui.Collection} Current collection instance.
			 */
			each: function(callback) {
				Tools.each(this, callback);
	
				return this;
			},
	
			/**
			 * Returns an JavaScript array object of the contents inside the collection.
			 *
			 * @method toArray
			 * @return {Array} Array with all items from collection.
			 */
			toArray: function() {
				return Tools.toArray(this);
			},
	
			/**
			 * Finds the index of the specified control or return -1 if it isn't in the collection.
			 *
			 * @method indexOf
			 * @param {Control} ctrl Control instance to look for.
			 * @return {Number} Index of the specified control or -1.
			 */
			indexOf: function(ctrl) {
				var self = this, i = self.length;
	
				while (i--) {
					if (self[i] === ctrl) {
						break;
					}
				}
	
				return i;
			},
	
			/**
			 * Returns a new collection of the contents in reverse order.
			 *
			 * @method reverse
			 * @return {tinymce.ui.Collection} Collection instance with reversed items.
			 */
			reverse: function() {
				return new Collection(Tools.toArray(this).reverse());
			},
	
			/**
			 * Returns true/false if the class exists or not.
			 *
			 * @method hasClass
			 * @param {String} cls Class to check for.
			 * @return {Boolean} true/false state if the class exists or not.
			 */
			hasClass: function(cls) {
				return this[0] ? this[0].classes.contains(cls) : false;
			},
	
			/**
			 * Sets/gets the specific property on the items in the collection. The same as executing control.<property>(<value>);
			 *
			 * @method prop
			 * @param {String} name Property name to get/set.
			 * @param {Object} value Optional object value to set.
			 * @return {tinymce.ui.Collection} Current collection instance or value of the first item on a get operation.
			 */
			prop: function(name, value) {
				var self = this, undef, item;
	
				if (value !== undef) {
					self.each(function(item) {
						if (item[name]) {
							item[name](value);
						}
					});
	
					return self;
				}
	
				item = self[0];
	
				if (item && item[name]) {
					return item[name]();
				}
			},
	
			/**
			 * Executes the specific function name with optional arguments an all items in collection if it exists.
			 *
			 * @example collection.exec("myMethod", arg1, arg2, arg3);
			 * @method exec
			 * @param {String} name Name of the function to execute.
			 * @param {Object} ... Multiple arguments to pass to each function.
			 * @return {tinymce.ui.Collection} Current collection.
			 */
			exec: function(name) {
				var self = this, args = Tools.toArray(arguments).slice(1);
	
				self.each(function(item) {
					if (item[name]) {
						item[name].apply(item, args);
					}
				});
	
				return self;
			},
	
			/**
			 * Remove all items from collection and DOM.
			 *
			 * @method remove
			 * @return {tinymce.ui.Collection} Current collection.
			 */
			remove: function() {
				var i = this.length;
	
				while (i--) {
					this[i].remove();
				}
	
				return this;
			},
	
			/**
			 * Adds a class to all items in the collection.
			 *
			 * @method addClass
			 * @param {String} cls Class to add to each item.
			 * @return {tinymce.ui.Collection} Current collection instance.
			 */
			addClass: function(cls) {
				return this.each(function(item) {
					item.classes.add(cls);
				});
			},
	
			/**
			 * Removes the specified class from all items in collection.
			 *
			 * @method removeClass
			 * @param {String} cls Class to remove from each item.
			 * @return {tinymce.ui.Collection} Current collection instance.
			 */
			removeClass: function(cls) {
				return this.each(function(item) {
					item.classes.remove(cls);
				});
			}
	
			/**
			 * Fires the specified event by name and arguments on the control. This will execute all
			 * bound event handlers.
			 *
			 * @method fire
			 * @param {String} name Name of the event to fire.
			 * @param {Object} args Optional arguments to pass to the event.
			 * @return {tinymce.ui.Collection} Current collection instance.
			 */
			// fire: function(event, args) {}, -- Generated by code below
	
			/**
			 * Binds a callback to the specified event. This event can both be
			 * native browser events like "click" or custom ones like PostRender.
			 *
			 * The callback function will have two parameters the first one being the control that received the event
			 * the second one will be the event object either the browsers native event object or a custom JS object.
			 *
			 * @method on
			 * @param {String} name Name of the event to bind. For example "click".
			 * @param {String/function} callback Callback function to execute ones the event occurs.
			 * @return {tinymce.ui.Collection} Current collection instance.
			 */
			// on: function(name, callback) {}, -- Generated by code below
	
			/**
			 * Unbinds the specified event and optionally a specific callback. If you omit the name
			 * parameter all event handlers will be removed. If you omit the callback all event handles
			 * by the specified name will be removed.
			 *
			 * @method off
			 * @param {String} name Optional name for the event to unbind.
			 * @param {function} callback Optional callback function to unbind.
			 * @return {tinymce.ui.Collection} Current collection instance.
			 */
			// off: function(name, callback) {}, -- Generated by code below
	
			/**
			 * Shows the items in the current collection.
			 *
			 * @method show
			 * @return {tinymce.ui.Collection} Current collection instance.
			 */
			// show: function() {}, -- Generated by code below
	
			/**
			 * Hides the items in the current collection.
			 *
			 * @method hide
			 * @return {tinymce.ui.Collection} Current collection instance.
			 */
			// hide: function() {}, -- Generated by code below
	
			/**
			 * Sets/gets the text contents of the items in the current collection.
			 *
			 * @method text
			 * @return {tinymce.ui.Collection} Current collection instance or text value of the first item on a get operation.
			 */
			// text: function(value) {}, -- Generated by code below
	
			/**
			 * Sets/gets the name contents of the items in the current collection.
			 *
			 * @method name
			 * @return {tinymce.ui.Collection} Current collection instance or name value of the first item on a get operation.
			 */
			// name: function(value) {}, -- Generated by code below
	
			/**
			 * Sets/gets the disabled state on the items in the current collection.
			 *
			 * @method disabled
			 * @return {tinymce.ui.Collection} Current collection instance or disabled state of the first item on a get operation.
			 */
			// disabled: function(state) {}, -- Generated by code below
	
			/**
			 * Sets/gets the active state on the items in the current collection.
			 *
			 * @method active
			 * @return {tinymce.ui.Collection} Current collection instance or active state of the first item on a get operation.
			 */
			// active: function(state) {}, -- Generated by code below
	
			/**
			 * Sets/gets the selected state on the items in the current collection.
			 *
			 * @method selected
			 * @return {tinymce.ui.Collection} Current collection instance or selected state of the first item on a get operation.
			 */
			// selected: function(state) {}, -- Generated by code below
	
			/**
			 * Sets/gets the selected state on the items in the current collection.
			 *
			 * @method visible
			 * @return {tinymce.ui.Collection} Current collection instance or visible state of the first item on a get operation.
			 */
			// visible: function(state) {}, -- Generated by code below
		};
	
		// Extend tinymce.ui.Collection prototype with some generated control specific methods
		Tools.each('fire on off show hide append prepend before after reflow'.split(' '), function(name) {
			proto[name] = function() {
				var args = Tools.toArray(arguments);
	
				this.each(function(ctrl) {
					if (name in ctrl) {
						ctrl[name].apply(ctrl, args);
					}
				});
	
				return this;
			};
		});
	
		// Extend tinymce.ui.Collection prototype with some property methods
		Tools.each('text name disabled active selected checked visible parent value data'.split(' '), function(name) {
			proto[name] = function(value) {
				return this.prop(name, value);
			};
		});
	
		// Create class based on the new prototype
		Collection = Class.extend(proto);
	
		// Stick Collection into Selector to prevent circual references
		Selector.Collection = Collection;
	
		return Collection;
	});
	
	// Included from: js/tinymce/classes/ui/DomUtils.js
	
	/**
	 * DomUtils.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Private UI DomUtils proxy.
	 *
	 * @private
	 * @class tinymce.ui.DomUtils
	 */
	define("tinymce/ui/DomUtils", [
		"tinymce/Env",
		"tinymce/util/Tools",
		"tinymce/dom/DOMUtils"
	], function(Env, Tools, DOMUtils) {
		"use strict";
	
		var count = 0;
	
		var funcs = {
			id: function() {
				return 'mceu_' + (count++);
			},
	
			create: function(name, attrs, children) {
				var elm = document.createElement(name);
	
				DOMUtils.DOM.setAttribs(elm, attrs);
	
				if (typeof children === 'string') {
					elm.innerHTML = children;
				} else {
					Tools.each(children, function(child) {
						if (child.nodeType) {
							elm.appendChild(child);
						}
					});
				}
	
				return elm;
			},
	
			createFragment: function(html) {
				return DOMUtils.DOM.createFragment(html);
			},
	
			getWindowSize: function() {
				return DOMUtils.DOM.getViewPort();
			},
	
			getSize: function(elm) {
				var width, height;
	
				if (elm.getBoundingClientRect) {
					var rect = elm.getBoundingClientRect();
	
					width = Math.max(rect.width || (rect.right - rect.left), elm.offsetWidth);
					height = Math.max(rect.height || (rect.bottom - rect.bottom), elm.offsetHeight);
				} else {
					width = elm.offsetWidth;
					height = elm.offsetHeight;
				}
	
				return {width: width, height: height};
			},
	
			getPos: function(elm, root) {
				return DOMUtils.DOM.getPos(elm, root || funcs.getContainer());
			},
	
			getContainer: function () {
				return Env.container ? Env.container : document.body;
			},
	
			getViewPort: function(win) {
				return DOMUtils.DOM.getViewPort(win);
			},
	
			get: function(id) {
				return document.getElementById(id);
			},
	
			addClass: function(elm, cls) {
				return DOMUtils.DOM.addClass(elm, cls);
			},
	
			removeClass: function(elm, cls) {
				return DOMUtils.DOM.removeClass(elm, cls);
			},
	
			hasClass: function(elm, cls) {
				return DOMUtils.DOM.hasClass(elm, cls);
			},
	
			toggleClass: function(elm, cls, state) {
				return DOMUtils.DOM.toggleClass(elm, cls, state);
			},
	
			css: function(elm, name, value) {
				return DOMUtils.DOM.setStyle(elm, name, value);
			},
	
			getRuntimeStyle: function(elm, name) {
				return DOMUtils.DOM.getStyle(elm, name, true);
			},
	
			on: function(target, name, callback, scope) {
				return DOMUtils.DOM.bind(target, name, callback, scope);
			},
	
			off: function(target, name, callback) {
				return DOMUtils.DOM.unbind(target, name, callback);
			},
	
			fire: function(target, name, args) {
				return DOMUtils.DOM.fire(target, name, args);
			},
	
			innerHtml: function(elm, html) {
				// Workaround for <div> in <p> bug on IE 8 #6178
				DOMUtils.DOM.setHTML(elm, html);
			}
		};
	
		return funcs;
	});
	
	// Included from: js/tinymce/classes/ui/BoxUtils.js
	
	/**
	 * BoxUtils.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Utility class for box parsing and measuring.
	 *
	 * @private
	 * @class tinymce.ui.BoxUtils
	 */
	define("tinymce/ui/BoxUtils", [
	], function() {
		"use strict";
	
		return {
			/**
			 * Parses the specified box value. A box value contains 1-4 properties in clockwise order.
			 *
			 * @method parseBox
			 * @param {String/Number} value Box value "0 1 2 3" or "0" etc.
			 * @return {Object} Object with top/right/bottom/left properties.
			 * @private
			 */
			parseBox: function(value) {
				var len, radix = 10;
	
				if (!value) {
					return;
				}
	
				if (typeof value === "number") {
					value = value || 0;
	
					return {
						top: value,
						left: value,
						bottom: value,
						right: value
					};
				}
	
				value = value.split(' ');
				len = value.length;
	
				if (len === 1) {
					value[1] = value[2] = value[3] = value[0];
				} else if (len === 2) {
					value[2] = value[0];
					value[3] = value[1];
				} else if (len === 3) {
					value[3] = value[1];
				}
	
				return {
					top: parseInt(value[0], radix) || 0,
					right: parseInt(value[1], radix) || 0,
					bottom: parseInt(value[2], radix) || 0,
					left: parseInt(value[3], radix) || 0
				};
			},
	
			measureBox: function(elm, prefix) {
				function getStyle(name) {
					var defaultView = document.defaultView;
	
					if (defaultView) {
						// Remove camelcase
						name = name.replace(/[A-Z]/g, function(a) {
							return '-' + a;
						});
	
						return defaultView.getComputedStyle(elm, null).getPropertyValue(name);
					}
	
					return elm.currentStyle[name];
				}
	
				function getSide(name) {
					var val = parseFloat(getStyle(name), 10);
	
					return isNaN(val) ? 0 : val;
				}
	
				return {
					top: getSide(prefix + "TopWidth"),
					right: getSide(prefix + "RightWidth"),
					bottom: getSide(prefix + "BottomWidth"),
					left: getSide(prefix + "LeftWidth")
				};
			}
		};
	});
	
	// Included from: js/tinymce/classes/ui/ClassList.js
	
	/**
	 * ClassList.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Handles adding and removal of classes.
	 *
	 * @private
	 * @class tinymce.ui.ClassList
	 */
	define("tinymce/ui/ClassList", [
		"tinymce/util/Tools"
	], function(Tools) {
		"use strict";
	
		function noop() {
		}
	
		/**
		 * Constructs a new class list the specified onchange
		 * callback will be executed when the class list gets modifed.
		 *
		 * @constructor ClassList
		 * @param {function} onchange Onchange callback to be executed.
		 */
		function ClassList(onchange) {
			this.cls = [];
			this.cls._map = {};
			this.onchange = onchange || noop;
			this.prefix = '';
		}
	
		Tools.extend(ClassList.prototype, {
			/**
			 * Adds a new class to the class list.
			 *
			 * @method add
			 * @param {String} cls Class to be added.
			 * @return {tinymce.ui.ClassList} Current class list instance.
			 */
			add: function(cls) {
				if (cls && !this.contains(cls)) {
					this.cls._map[cls] = true;
					this.cls.push(cls);
					this._change();
				}
	
				return this;
			},
	
			/**
			 * Removes the specified class from the class list.
			 *
			 * @method remove
			 * @param {String} cls Class to be removed.
			 * @return {tinymce.ui.ClassList} Current class list instance.
			 */
			remove: function(cls) {
				if (this.contains(cls)) {
					for (var i = 0; i < this.cls.length; i++) {
						if (this.cls[i] === cls) {
							break;
						}
					}
	
					this.cls.splice(i, 1);
					delete this.cls._map[cls];
					this._change();
				}
	
				return this;
			},
	
			/**
			 * Toggles a class in the class list.
			 *
			 * @method toggle
			 * @param {String} cls Class to be added/removed.
			 * @param {Boolean} state Optional state if it should be added/removed.
			 * @return {tinymce.ui.ClassList} Current class list instance.
			 */
			toggle: function(cls, state) {
				var curState = this.contains(cls);
	
				if (curState !== state) {
					if (curState) {
						this.remove(cls);
					} else {
						this.add(cls);
					}
	
					this._change();
				}
	
				return this;
			},
	
			/**
			 * Returns true if the class list has the specified class.
			 *
			 * @method contains
			 * @param {String} cls Class to look for.
			 * @return {Boolean} true/false if the class exists or not.
			 */
			contains: function(cls) {
				return !!this.cls._map[cls];
			},
	
			/**
			 * Returns a space separated list of classes.
			 *
			 * @method toString
			 * @return {String} Space separated list of classes.
			 */
	
			_change: function() {
				delete this.clsValue;
				this.onchange.call(this);
			}
		});
	
		// IE 8 compatibility
		ClassList.prototype.toString = function() {
			var value;
	
			if (this.clsValue) {
				return this.clsValue;
			}
	
			value = '';
			for (var i = 0; i < this.cls.length; i++) {
				if (i > 0) {
					value += ' ';
				}
	
				value += this.prefix + this.cls[i];
			}
	
			return value;
		};
	
		return ClassList;
	});
	
	// Included from: js/tinymce/classes/ui/ReflowQueue.js
	
	/**
	 * ReflowQueue.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This class will automatically reflow controls on the next animation frame within a few milliseconds on older browsers.
	 * If the user manually reflows then the automatic reflow will be cancelled. This class is used internally when various control states
	 * changes that triggers a reflow.
	 *
	 * @class tinymce.ui.ReflowQueue
	 * @static
	 */
	define("tinymce/ui/ReflowQueue", [
		"tinymce/util/Delay"
	], function(Delay) {
		var dirtyCtrls = {}, animationFrameRequested;
	
		return {
			/**
			 * Adds a control to the next automatic reflow call. This is the control that had a state
			 * change for example if the control was hidden/shown.
			 *
			 * @method add
			 * @param {tinymce.ui.Control} ctrl Control to add to queue.
			 */
			add: function(ctrl) {
				var parent = ctrl.parent();
	
				if (parent) {
					if (!parent._layout || parent._layout.isNative()) {
						return;
					}
	
					if (!dirtyCtrls[parent._id]) {
						dirtyCtrls[parent._id] = parent;
					}
	
					if (!animationFrameRequested) {
						animationFrameRequested = true;
	
						Delay.requestAnimationFrame(function() {
							var id, ctrl;
	
							animationFrameRequested = false;
	
							for (id in dirtyCtrls) {
								ctrl = dirtyCtrls[id];
	
								if (ctrl.state.get('rendered')) {
									ctrl.reflow();
								}
							}
	
							dirtyCtrls = {};
						}, document.body);
					}
				}
			},
	
			/**
			 * Removes the specified control from the automatic reflow. This will happen when for example the user
			 * manually triggers a reflow.
			 *
			 * @method remove
			 * @param {tinymce.ui.Control} ctrl Control to remove from queue.
			 */
			remove: function(ctrl) {
				if (dirtyCtrls[ctrl._id]) {
					delete dirtyCtrls[ctrl._id];
				}
			}
		};
	});
	
	// Included from: js/tinymce/classes/ui/Control.js
	
	/**
	 * Control.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/*eslint consistent-this:0 */
	
	/**
	 * This is the base class for all controls and containers. All UI control instances inherit
	 * from this one as it has the base logic needed by all of them.
	 *
	 * @class tinymce.ui.Control
	 */
	define("tinymce/ui/Control", [
		"tinymce/util/Class",
		"tinymce/util/Tools",
		"tinymce/util/EventDispatcher",
		"tinymce/data/ObservableObject",
		"tinymce/ui/Collection",
		"tinymce/ui/DomUtils",
		"tinymce/dom/DomQuery",
		"tinymce/ui/BoxUtils",
		"tinymce/ui/ClassList",
		"tinymce/ui/ReflowQueue"
	], function(Class, Tools, EventDispatcher, ObservableObject, Collection, DomUtils, $, BoxUtils, ClassList, ReflowQueue) {
		"use strict";
	
		var hasMouseWheelEventSupport = "onmousewheel" in document;
		var hasWheelEventSupport = false;
		var classPrefix = "mce-";
		var Control, idCounter = 0;
	
		var proto = {
			Statics: {
				classPrefix: classPrefix
			},
	
			isRtl: function() {
				return Control.rtl;
			},
	
			/**
			 * Class/id prefix to use for all controls.
			 *
			 * @final
			 * @field {String} classPrefix
			 */
			classPrefix: classPrefix,
	
			/**
			 * Constructs a new control instance with the specified settings.
			 *
			 * @constructor
			 * @param {Object} settings Name/value object with settings.
			 * @setting {String} style Style CSS properties to add.
			 * @setting {String} border Border box values example: 1 1 1 1
			 * @setting {String} padding Padding box values example: 1 1 1 1
			 * @setting {String} margin Margin box values example: 1 1 1 1
			 * @setting {Number} minWidth Minimal width for the control.
			 * @setting {Number} minHeight Minimal height for the control.
			 * @setting {String} classes Space separated list of classes to add.
			 * @setting {String} role WAI-ARIA role to use for control.
			 * @setting {Boolean} hidden Is the control hidden by default.
			 * @setting {Boolean} disabled Is the control disabled by default.
			 * @setting {String} name Name of the control instance.
			 */
			init: function(settings) {
				var self = this, classes, defaultClasses;
	
				function applyClasses(classes) {
					var i;
	
					classes = classes.split(' ');
					for (i = 0; i < classes.length; i++) {
						self.classes.add(classes[i]);
					}
				}
	
				self.settings = settings = Tools.extend({}, self.Defaults, settings);
	
				// Initial states
				self._id = settings.id || ('mceu_' + (idCounter++));
				self._aria = {role: settings.role};
				self._elmCache = {};
				self.$ = $;
	
				self.state = new ObservableObject({
					visible: true,
					active: false,
					disabled: false,
					value: ''
				});
	
				self.data = new ObservableObject(settings.data);
	
				self.classes = new ClassList(function() {
					if (self.state.get('rendered')) {
						self.getEl().className = this.toString();
					}
				});
				self.classes.prefix = self.classPrefix;
	
				// Setup classes
				classes = settings.classes;
				if (classes) {
					if (self.Defaults) {
						defaultClasses = self.Defaults.classes;
	
						if (defaultClasses && classes != defaultClasses) {
							applyClasses(defaultClasses);
						}
					}
	
					applyClasses(classes);
				}
	
				Tools.each('title text name visible disabled active value'.split(' '), function(name) {
					if (name in settings) {
						self[name](settings[name]);
					}
				});
	
				self.on('click', function() {
					if (self.disabled()) {
						return false;
					}
				});
	
				/**
				 * Name/value object with settings for the current control.
				 *
				 * @field {Object} settings
				 */
				self.settings = settings;
	
				self.borderBox = BoxUtils.parseBox(settings.border);
				self.paddingBox = BoxUtils.parseBox(settings.padding);
				self.marginBox = BoxUtils.parseBox(settings.margin);
	
				if (settings.hidden) {
					self.hide();
				}
			},
	
			// Will generate getter/setter methods for these properties
			Properties: 'parent,name',
	
			/**
			 * Returns the root element to render controls into.
			 *
			 * @method getContainerElm
			 * @return {Element} HTML DOM element to render into.
			 */
			getContainerElm: function() {
				return DomUtils.getContainer();
			},
	
			/**
			 * Returns a control instance for the current DOM element.
			 *
			 * @method getParentCtrl
			 * @param {Element} elm HTML dom element to get parent control from.
			 * @return {tinymce.ui.Control} Control instance or undefined.
			 */
			getParentCtrl: function(elm) {
				var ctrl, lookup = this.getRoot().controlIdLookup;
	
				while (elm && lookup) {
					ctrl = lookup[elm.id];
					if (ctrl) {
						break;
					}
	
					elm = elm.parentNode;
				}
	
				return ctrl;
			},
	
			/**
			 * Initializes the current controls layout rect.
			 * This will be executed by the layout managers to determine the
			 * default minWidth/minHeight etc.
			 *
			 * @method initLayoutRect
			 * @return {Object} Layout rect instance.
			 */
			initLayoutRect: function() {
				var self = this, settings = self.settings, borderBox, layoutRect;
				var elm = self.getEl(), width, height, minWidth, minHeight, autoResize;
				var startMinWidth, startMinHeight, initialSize;
	
				// Measure the current element
				borderBox = self.borderBox = self.borderBox || BoxUtils.measureBox(elm, 'border');
				self.paddingBox = self.paddingBox || BoxUtils.measureBox(elm, 'padding');
				self.marginBox = self.marginBox || BoxUtils.measureBox(elm, 'margin');
				initialSize = DomUtils.getSize(elm);
	
				// Setup minWidth/minHeight and width/height
				startMinWidth = settings.minWidth;
				startMinHeight = settings.minHeight;
				minWidth = startMinWidth || initialSize.width;
				minHeight = startMinHeight || initialSize.height;
				width = settings.width;
				height = settings.height;
				autoResize = settings.autoResize;
				autoResize = typeof autoResize != "undefined" ? autoResize : !width && !height;
	
				width = width || minWidth;
				height = height || minHeight;
	
				var deltaW = borderBox.left + borderBox.right;
				var deltaH = borderBox.top + borderBox.bottom;
	
				var maxW = settings.maxWidth || 0xFFFF;
				var maxH = settings.maxHeight || 0xFFFF;
	
				// Setup initial layout rect
				self._layoutRect = layoutRect = {
					x: settings.x || 0,
					y: settings.y || 0,
					w: width,
					h: height,
					deltaW: deltaW,
					deltaH: deltaH,
					contentW: width - deltaW,
					contentH: height - deltaH,
					innerW: width - deltaW,
					innerH: height - deltaH,
					startMinWidth: startMinWidth || 0,
					startMinHeight: startMinHeight || 0,
					minW: Math.min(minWidth, maxW),
					minH: Math.min(minHeight, maxH),
					maxW: maxW,
					maxH: maxH,
					autoResize: autoResize,
					scrollW: 0
				};
	
				self._lastLayoutRect = {};
	
				return layoutRect;
			},
	
			/**
			 * Getter/setter for the current layout rect.
			 *
			 * @method layoutRect
			 * @param {Object} [newRect] Optional new layout rect.
			 * @return {tinymce.ui.Control/Object} Current control or rect object.
			 */
			layoutRect: function(newRect) {
				var self = this, curRect = self._layoutRect, lastLayoutRect, size, deltaWidth, deltaHeight, undef, repaintControls;
	
				// Initialize default layout rect
				if (!curRect) {
					curRect = self.initLayoutRect();
				}
	
				// Set new rect values
				if (newRect) {
					// Calc deltas between inner and outer sizes
					deltaWidth = curRect.deltaW;
					deltaHeight = curRect.deltaH;
	
					// Set x position
					if (newRect.x !== undef) {
						curRect.x = newRect.x;
					}
	
					// Set y position
					if (newRect.y !== undef) {
						curRect.y = newRect.y;
					}
	
					// Set minW
					if (newRect.minW !== undef) {
						curRect.minW = newRect.minW;
					}
	
					// Set minH
					if (newRect.minH !== undef) {
						curRect.minH = newRect.minH;
					}
	
					// Set new width and calculate inner width
					size = newRect.w;
					if (size !== undef) {
						size = size < curRect.minW ? curRect.minW : size;
						size = size > curRect.maxW ? curRect.maxW : size;
						curRect.w = size;
						curRect.innerW = size - deltaWidth;
					}
	
					// Set new height and calculate inner height
					size = newRect.h;
					if (size !== undef) {
						size = size < curRect.minH ? curRect.minH : size;
						size = size > curRect.maxH ? curRect.maxH : size;
						curRect.h = size;
						curRect.innerH = size - deltaHeight;
					}
	
					// Set new inner width and calculate width
					size = newRect.innerW;
					if (size !== undef) {
						size = size < curRect.minW - deltaWidth ? curRect.minW - deltaWidth : size;
						size = size > curRect.maxW - deltaWidth ? curRect.maxW - deltaWidth : size;
						curRect.innerW = size;
						curRect.w = size + deltaWidth;
					}
	
					// Set new height and calculate inner height
					size = newRect.innerH;
					if (size !== undef) {
						size = size < curRect.minH - deltaHeight ? curRect.minH - deltaHeight : size;
						size = size > curRect.maxH - deltaHeight ? curRect.maxH - deltaHeight : size;
						curRect.innerH = size;
						curRect.h = size + deltaHeight;
					}
	
					// Set new contentW
					if (newRect.contentW !== undef) {
						curRect.contentW = newRect.contentW;
					}
	
					// Set new contentH
					if (newRect.contentH !== undef) {
						curRect.contentH = newRect.contentH;
					}
	
					// Compare last layout rect with the current one to see if we need to repaint or not
					lastLayoutRect = self._lastLayoutRect;
					if (lastLayoutRect.x !== curRect.x || lastLayoutRect.y !== curRect.y ||
						lastLayoutRect.w !== curRect.w || lastLayoutRect.h !== curRect.h) {
						repaintControls = Control.repaintControls;
	
						if (repaintControls) {
							if (repaintControls.map && !repaintControls.map[self._id]) {
								repaintControls.push(self);
								repaintControls.map[self._id] = true;
							}
						}
	
						lastLayoutRect.x = curRect.x;
						lastLayoutRect.y = curRect.y;
						lastLayoutRect.w = curRect.w;
						lastLayoutRect.h = curRect.h;
					}
	
					return self;
				}
	
				return curRect;
			},
	
			/**
			 * Repaints the control after a layout operation.
			 *
			 * @method repaint
			 */
			repaint: function() {
				var self = this, style, bodyStyle, bodyElm, rect, borderBox;
				var borderW, borderH, lastRepaintRect, round, value;
	
				// Use Math.round on all values on IE < 9
				round = !document.createRange ? Math.round : function(value) {
					return value;
				};
	
				style = self.getEl().style;
				rect = self._layoutRect;
				lastRepaintRect = self._lastRepaintRect || {};
	
				borderBox = self.borderBox;
				borderW = borderBox.left + borderBox.right;
				borderH = borderBox.top + borderBox.bottom;
	
				if (rect.x !== lastRepaintRect.x) {
					style.left = round(rect.x) + 'px';
					lastRepaintRect.x = rect.x;
				}
	
				if (rect.y !== lastRepaintRect.y) {
					style.top = round(rect.y) + 'px';
					lastRepaintRect.y = rect.y;
				}
	
				if (rect.w !== lastRepaintRect.w) {
					value = round(rect.w - borderW);
					style.width = (value >= 0 ? value : 0) + 'px';
					lastRepaintRect.w = rect.w;
				}
	
				if (rect.h !== lastRepaintRect.h) {
					value = round(rect.h - borderH);
					style.height = (value >= 0 ? value : 0) + 'px';
					lastRepaintRect.h = rect.h;
				}
	
				// Update body if needed
				if (self._hasBody && rect.innerW !== lastRepaintRect.innerW) {
					value = round(rect.innerW);
	
					bodyElm = self.getEl('body');
					if (bodyElm) {
						bodyStyle = bodyElm.style;
						bodyStyle.width = (value >= 0 ? value : 0) + 'px';
					}
	
					lastRepaintRect.innerW = rect.innerW;
				}
	
				if (self._hasBody && rect.innerH !== lastRepaintRect.innerH) {
					value = round(rect.innerH);
	
					bodyElm = bodyElm || self.getEl('body');
					if (bodyElm) {
						bodyStyle = bodyStyle || bodyElm.style;
						bodyStyle.height = (value >= 0 ? value : 0) + 'px';
					}
	
					lastRepaintRect.innerH = rect.innerH;
				}
	
				self._lastRepaintRect = lastRepaintRect;
				self.fire('repaint', {}, false);
			},
	
			/**
			 * Updates the controls layout rect by re-measuing it.
			 */
			updateLayoutRect: function() {
				var self = this;
	
				self.parent()._lastRect = null;
	
				DomUtils.css(self.getEl(), {width: '', height: ''});
	
				self._layoutRect = self._lastRepaintRect = self._lastLayoutRect = null;
				self.initLayoutRect();
			},
	
			/**
			 * Binds a callback to the specified event. This event can both be
			 * native browser events like "click" or custom ones like PostRender.
			 *
			 * The callback function will be passed a DOM event like object that enables yout do stop propagation.
			 *
			 * @method on
			 * @param {String} name Name of the event to bind. For example "click".
			 * @param {String/function} callback Callback function to execute ones the event occurs.
			 * @return {tinymce.ui.Control} Current control object.
			 */
			on: function(name, callback) {
				var self = this;
	
				function resolveCallbackName(name) {
					var callback, scope;
	
					if (typeof name != 'string') {
						return name;
					}
	
					return function(e) {
						if (!callback) {
							self.parentsAndSelf().each(function(ctrl) {
								var callbacks = ctrl.settings.callbacks;
	
								if (callbacks && (callback = callbacks[name])) {
									scope = ctrl;
									return false;
								}
							});
						}
	
						if (!callback) {
							e.action = name;
							this.fire('execute', e);
							return;
						}
	
						return callback.call(scope, e);
					};
				}
	
				getEventDispatcher(self).on(name, resolveCallbackName(callback));
	
				return self;
			},
	
			/**
			 * Unbinds the specified event and optionally a specific callback. If you omit the name
			 * parameter all event handlers will be removed. If you omit the callback all event handles
			 * by the specified name will be removed.
			 *
			 * @method off
			 * @param {String} [name] Name for the event to unbind.
			 * @param {function} [callback] Callback function to unbind.
			 * @return {tinymce.ui.Control} Current control object.
			 */
			off: function(name, callback) {
				getEventDispatcher(this).off(name, callback);
				return this;
			},
	
			/**
			 * Fires the specified event by name and arguments on the control. This will execute all
			 * bound event handlers.
			 *
			 * @method fire
			 * @param {String} name Name of the event to fire.
			 * @param {Object} [args] Arguments to pass to the event.
			 * @param {Boolean} [bubble] Value to control bubbling. Defaults to true.
			 * @return {Object} Current arguments object.
			 */
			fire: function(name, args, bubble) {
				var self = this;
	
				args = args || {};
	
				if (!args.control) {
					args.control = self;
				}
	
				args = getEventDispatcher(self).fire(name, args);
	
				// Bubble event up to parents
				if (bubble !== false && self.parent) {
					var parent = self.parent();
					while (parent && !args.isPropagationStopped()) {
						parent.fire(name, args, false);
						parent = parent.parent();
					}
				}
	
				return args;
			},
	
			/**
			 * Returns true/false if the specified event has any listeners.
			 *
			 * @method hasEventListeners
			 * @param {String} name Name of the event to check for.
			 * @return {Boolean} True/false state if the event has listeners.
			 */
			hasEventListeners: function(name) {
				return getEventDispatcher(this).has(name);
			},
	
			/**
			 * Returns a control collection with all parent controls.
			 *
			 * @method parents
			 * @param {String} selector Optional selector expression to find parents.
			 * @return {tinymce.ui.Collection} Collection with all parent controls.
			 */
			parents: function(selector) {
				var self = this, ctrl, parents = new Collection();
	
				// Add each parent to collection
				for (ctrl = self.parent(); ctrl; ctrl = ctrl.parent()) {
					parents.add(ctrl);
				}
	
				// Filter away everything that doesn't match the selector
				if (selector) {
					parents = parents.filter(selector);
				}
	
				return parents;
			},
	
			/**
			 * Returns the current control and it's parents.
			 *
			 * @method parentsAndSelf
			 * @param {String} selector Optional selector expression to find parents.
			 * @return {tinymce.ui.Collection} Collection with all parent controls.
			 */
			parentsAndSelf: function(selector) {
				return new Collection(this).add(this.parents(selector));
			},
	
			/**
			 * Returns the control next to the current control.
			 *
			 * @method next
			 * @return {tinymce.ui.Control} Next control instance.
			 */
			next: function() {
				var parentControls = this.parent().items();
	
				return parentControls[parentControls.indexOf(this) + 1];
			},
	
			/**
			 * Returns the control previous to the current control.
			 *
			 * @method prev
			 * @return {tinymce.ui.Control} Previous control instance.
			 */
			prev: function() {
				var parentControls = this.parent().items();
	
				return parentControls[parentControls.indexOf(this) - 1];
			},
	
			/**
			 * Sets the inner HTML of the control element.
			 *
			 * @method innerHtml
			 * @param {String} html Html string to set as inner html.
			 * @return {tinymce.ui.Control} Current control object.
			 */
			innerHtml: function(html) {
				this.$el.html(html);
				return this;
			},
	
			/**
			 * Returns the control DOM element or sub element.
			 *
			 * @method getEl
			 * @param {String} [suffix] Suffix to get element by.
			 * @return {Element} HTML DOM element for the current control or it's children.
			 */
			getEl: function(suffix) {
				var id = suffix ? this._id + '-' + suffix : this._id;
	
				if (!this._elmCache[id]) {
					this._elmCache[id] = $('#' + id)[0];
				}
	
				return this._elmCache[id];
			},
	
			/**
			 * Sets the visible state to true.
			 *
			 * @method show
			 * @return {tinymce.ui.Control} Current control instance.
			 */
			show: function() {
				return this.visible(true);
			},
	
			/**
			 * Sets the visible state to false.
			 *
			 * @method hide
			 * @return {tinymce.ui.Control} Current control instance.
			 */
			hide: function() {
				return this.visible(false);
			},
	
			/**
			 * Focuses the current control.
			 *
			 * @method focus
			 * @return {tinymce.ui.Control} Current control instance.
			 */
			focus: function() {
				try {
					this.getEl().focus();
				} catch (ex) {
					// Ignore IE error
				}
	
				return this;
			},
	
			/**
			 * Blurs the current control.
			 *
			 * @method blur
			 * @return {tinymce.ui.Control} Current control instance.
			 */
			blur: function() {
				this.getEl().blur();
	
				return this;
			},
	
			/**
			 * Sets the specified aria property.
			 *
			 * @method aria
			 * @param {String} name Name of the aria property to set.
			 * @param {String} value Value of the aria property.
			 * @return {tinymce.ui.Control} Current control instance.
			 */
			aria: function(name, value) {
				var self = this, elm = self.getEl(self.ariaTarget);
	
				if (typeof value === "undefined") {
					return self._aria[name];
				}
	
				self._aria[name] = value;
	
				if (self.state.get('rendered')) {
					elm.setAttribute(name == 'role' ? name : 'aria-' + name, value);
				}
	
				return self;
			},
	
			/**
			 * Encodes the specified string with HTML entities. It will also
			 * translate the string to different languages.
			 *
			 * @method encode
			 * @param {String/Object/Array} text Text to entity encode.
			 * @param {Boolean} [translate=true] False if the contents shouldn't be translated.
			 * @return {String} Encoded and possible traslated string.
			 */
			encode: function(text, translate) {
				if (translate !== false) {
					text = this.translate(text);
				}
	
				return (text || '').replace(/[&<>"]/g, function(match) {
					return '&#' + match.charCodeAt(0) + ';';
				});
			},
	
			/**
			 * Returns the translated string.
			 *
			 * @method translate
			 * @param {String} text Text to translate.
			 * @return {String} Translated string or the same as the input.
			 */
			translate: function(text) {
				return Control.translate ? Control.translate(text) : text;
			},
	
			/**
			 * Adds items before the current control.
			 *
			 * @method before
			 * @param {Array/tinymce.ui.Collection} items Array of items to prepend before this control.
			 * @return {tinymce.ui.Control} Current control instance.
			 */
			before: function(items) {
				var self = this, parent = self.parent();
	
				if (parent) {
					parent.insert(items, parent.items().indexOf(self), true);
				}
	
				return self;
			},
	
			/**
			 * Adds items after the current control.
			 *
			 * @method after
			 * @param {Array/tinymce.ui.Collection} items Array of items to append after this control.
			 * @return {tinymce.ui.Control} Current control instance.
			 */
			after: function(items) {
				var self = this, parent = self.parent();
	
				if (parent) {
					parent.insert(items, parent.items().indexOf(self));
				}
	
				return self;
			},
	
			/**
			 * Removes the current control from DOM and from UI collections.
			 *
			 * @method remove
			 * @return {tinymce.ui.Control} Current control instance.
			 */
			remove: function() {
				var self = this, elm = self.getEl(), parent = self.parent(), newItems, i;
	
				if (self.items) {
					var controls = self.items().toArray();
					i = controls.length;
					while (i--) {
						controls[i].remove();
					}
				}
	
				if (parent && parent.items) {
					newItems = [];
	
					parent.items().each(function(item) {
						if (item !== self) {
							newItems.push(item);
						}
					});
	
					parent.items().set(newItems);
					parent._lastRect = null;
				}
	
				if (self._eventsRoot && self._eventsRoot == self) {
					$(elm).off();
				}
	
				var lookup = self.getRoot().controlIdLookup;
				if (lookup) {
					delete lookup[self._id];
				}
	
				if (elm && elm.parentNode) {
					elm.parentNode.removeChild(elm);
				}
	
				self.state.set('rendered', false);
				self.state.destroy();
	
				self.fire('remove');
	
				return self;
			},
	
			/**
			 * Renders the control before the specified element.
			 *
			 * @method renderBefore
			 * @param {Element} elm Element to render before.
			 * @return {tinymce.ui.Control} Current control instance.
			 */
			renderBefore: function(elm) {
				$(elm).before(this.renderHtml());
				this.postRender();
				return this;
			},
	
			/**
			 * Renders the control to the specified element.
			 *
			 * @method renderBefore
			 * @param {Element} elm Element to render to.
			 * @return {tinymce.ui.Control} Current control instance.
			 */
			renderTo: function(elm) {
				$(elm || this.getContainerElm()).append(this.renderHtml());
				this.postRender();
				return this;
			},
	
			preRender: function() {
			},
	
			render: function() {
			},
	
			renderHtml: function() {
				return '<div id="' + this._id + '" class="' + this.classes + '"></div>';
			},
	
			/**
			 * Post render method. Called after the control has been rendered to the target.
			 *
			 * @method postRender
			 * @return {tinymce.ui.Control} Current control instance.
			 */
			postRender: function() {
				var self = this, settings = self.settings, elm, box, parent, name, parentEventsRoot;
	
				self.$el = $(self.getEl());
				self.state.set('rendered', true);
	
				// Bind on<event> settings
				for (name in settings) {
					if (name.indexOf("on") === 0) {
						self.on(name.substr(2), settings[name]);
					}
				}
	
				if (self._eventsRoot) {
					for (parent = self.parent(); !parentEventsRoot && parent; parent = parent.parent()) {
						parentEventsRoot = parent._eventsRoot;
					}
	
					if (parentEventsRoot) {
						for (name in parentEventsRoot._nativeEvents) {
							self._nativeEvents[name] = true;
						}
					}
				}
	
				bindPendingEvents(self);
	
				if (settings.style) {
					elm = self.getEl();
					if (elm) {
						elm.setAttribute('style', settings.style);
						elm.style.cssText = settings.style;
					}
				}
	
				if (self.settings.border) {
					box = self.borderBox;
					self.$el.css({
						'border-top-width': box.top,
						'border-right-width': box.right,
						'border-bottom-width': box.bottom,
						'border-left-width': box.left
					});
				}
	
				// Add instance to lookup
				var root = self.getRoot();
				if (!root.controlIdLookup) {
					root.controlIdLookup = {};
				}
	
				root.controlIdLookup[self._id] = self;
	
				for (var key in self._aria) {
					self.aria(key, self._aria[key]);
				}
	
				if (self.state.get('visible') === false) {
					self.getEl().style.display = 'none';
				}
	
				self.bindStates();
	
				self.state.on('change:visible', function(e) {
					var state = e.value, parentCtrl;
	
					if (self.state.get('rendered')) {
						self.getEl().style.display = state === false ? 'none' : '';
	
						// Need to force a reflow here on IE 8
						self.getEl().getBoundingClientRect();
					}
	
					// Parent container needs to reflow
					parentCtrl = self.parent();
					if (parentCtrl) {
						parentCtrl._lastRect = null;
					}
	
					self.fire(state ? 'show' : 'hide');
	
					ReflowQueue.add(self);
				});
	
				self.fire('postrender', {}, false);
			},
	
			bindStates: function() {
			},
	
			/**
			 * Scrolls the current control into view.
			 *
			 * @method scrollIntoView
			 * @param {String} align Alignment in view top|center|bottom.
			 * @return {tinymce.ui.Control} Current control instance.
			 */
			scrollIntoView: function(align) {
				function getOffset(elm, rootElm) {
					var x, y, parent = elm;
	
					x = y = 0;
					while (parent && parent != rootElm && parent.nodeType) {
						x += parent.offsetLeft || 0;
						y += parent.offsetTop || 0;
						parent = parent.offsetParent;
					}
	
					return {x: x, y: y};
				}
	
				var elm = this.getEl(), parentElm = elm.parentNode;
				var x, y, width, height, parentWidth, parentHeight;
				var pos = getOffset(elm, parentElm);
	
				x = pos.x;
				y = pos.y;
				width = elm.offsetWidth;
				height = elm.offsetHeight;
				parentWidth = parentElm.clientWidth;
				parentHeight = parentElm.clientHeight;
	
				if (align == "end") {
					x -= parentWidth - width;
					y -= parentHeight - height;
				} else if (align == "center") {
					x -= (parentWidth / 2) - (width / 2);
					y -= (parentHeight / 2) - (height / 2);
				}
	
				parentElm.scrollLeft = x;
				parentElm.scrollTop = y;
	
				return this;
			},
	
			getRoot: function() {
				var ctrl = this, rootControl, parents = [];
	
				while (ctrl) {
					if (ctrl.rootControl) {
						rootControl = ctrl.rootControl;
						break;
					}
	
					parents.push(ctrl);
					rootControl = ctrl;
					ctrl = ctrl.parent();
				}
	
				if (!rootControl) {
					rootControl = this;
				}
	
				var i = parents.length;
				while (i--) {
					parents[i].rootControl = rootControl;
				}
	
				return rootControl;
			},
	
			/**
			 * Reflows the current control and it's parents.
			 * This should be used after you for example append children to the current control so
			 * that the layout managers know that they need to reposition everything.
			 *
			 * @example
			 * container.append({type: 'button', text: 'My button'}).reflow();
			 *
			 * @method reflow
			 * @return {tinymce.ui.Control} Current control instance.
			 */
			reflow: function() {
				ReflowQueue.remove(this);
	
				var parent = this.parent();
				if (parent._layout && !parent._layout.isNative()) {
					parent.reflow();
				}
	
				return this;
			}
	
			/**
			 * Sets/gets the parent container for the control.
			 *
			 * @method parent
			 * @param {tinymce.ui.Container} parent Optional parent to set.
			 * @return {tinymce.ui.Control} Parent control or the current control on a set action.
			 */
			// parent: function(parent) {} -- Generated
	
			/**
			 * Sets/gets the text for the control.
			 *
			 * @method text
			 * @param {String} value Value to set to control.
			 * @return {String/tinymce.ui.Control} Current control on a set operation or current value on a get.
			 */
			// text: function(value) {} -- Generated
	
			/**
			 * Sets/gets the disabled state on the control.
			 *
			 * @method disabled
			 * @param {Boolean} state Value to set to control.
			 * @return {Boolean/tinymce.ui.Control} Current control on a set operation or current state on a get.
			 */
			// disabled: function(state) {} -- Generated
	
			/**
			 * Sets/gets the active for the control.
			 *
			 * @method active
			 * @param {Boolean} state Value to set to control.
			 * @return {Boolean/tinymce.ui.Control} Current control on a set operation or current state on a get.
			 */
			// active: function(state) {} -- Generated
	
			/**
			 * Sets/gets the name for the control.
			 *
			 * @method name
			 * @param {String} value Value to set to control.
			 * @return {String/tinymce.ui.Control} Current control on a set operation or current value on a get.
			 */
			// name: function(value) {} -- Generated
	
			/**
			 * Sets/gets the title for the control.
			 *
			 * @method title
			 * @param {String} value Value to set to control.
			 * @return {String/tinymce.ui.Control} Current control on a set operation or current value on a get.
			 */
			// title: function(value) {} -- Generated
	
			/**
			 * Sets/gets the visible for the control.
			 *
			 * @method visible
			 * @param {Boolean} state Value to set to control.
			 * @return {Boolean/tinymce.ui.Control} Current control on a set operation or current state on a get.
			 */
			// visible: function(value) {} -- Generated
		};
	
		/**
		 * Setup state properties.
		 */
		Tools.each('text title visible disabled active value'.split(' '), function(name) {
			proto[name] = function(value) {
				if (arguments.length === 0) {
					return this.state.get(name);
				}
	
				if (typeof value != "undefined") {
					this.state.set(name, value);
				}
	
				return this;
			};
		});
	
		Control = Class.extend(proto);
	
		function getEventDispatcher(obj) {
			if (!obj._eventDispatcher) {
				obj._eventDispatcher = new EventDispatcher({
					scope: obj,
					toggleEvent: function(name, state) {
						if (state && EventDispatcher.isNative(name)) {
							if (!obj._nativeEvents) {
								obj._nativeEvents = {};
							}
	
							obj._nativeEvents[name] = true;
	
							if (obj.state.get('rendered')) {
								bindPendingEvents(obj);
							}
						}
					}
				});
			}
	
			return obj._eventDispatcher;
		}
	
		function bindPendingEvents(eventCtrl) {
			var i, l, parents, eventRootCtrl, nativeEvents, name;
	
			function delegate(e) {
				var control = eventCtrl.getParentCtrl(e.target);
	
				if (control) {
					control.fire(e.type, e);
				}
			}
	
			function mouseLeaveHandler() {
				var ctrl = eventRootCtrl._lastHoverCtrl;
	
				if (ctrl) {
					ctrl.fire("mouseleave", {target: ctrl.getEl()});
	
					ctrl.parents().each(function(ctrl) {
						ctrl.fire("mouseleave", {target: ctrl.getEl()});
					});
	
					eventRootCtrl._lastHoverCtrl = null;
				}
			}
	
			function mouseEnterHandler(e) {
				var ctrl = eventCtrl.getParentCtrl(e.target), lastCtrl = eventRootCtrl._lastHoverCtrl, idx = 0, i, parents, lastParents;
	
				// Over on a new control
				if (ctrl !== lastCtrl) {
					eventRootCtrl._lastHoverCtrl = ctrl;
	
					parents = ctrl.parents().toArray().reverse();
					parents.push(ctrl);
	
					if (lastCtrl) {
						lastParents = lastCtrl.parents().toArray().reverse();
						lastParents.push(lastCtrl);
	
						for (idx = 0; idx < lastParents.length; idx++) {
							if (parents[idx] !== lastParents[idx]) {
								break;
							}
						}
	
						for (i = lastParents.length - 1; i >= idx; i--) {
							lastCtrl = lastParents[i];
							lastCtrl.fire("mouseleave", {
								target: lastCtrl.getEl()
							});
						}
					}
	
					for (i = idx; i < parents.length; i++) {
						ctrl = parents[i];
						ctrl.fire("mouseenter", {
							target: ctrl.getEl()
						});
					}
				}
			}
	
			function fixWheelEvent(e) {
				e.preventDefault();
	
				if (e.type == "mousewheel") {
					e.deltaY = -1 / 40 * e.wheelDelta;
	
					if (e.wheelDeltaX) {
						e.deltaX = -1 / 40 * e.wheelDeltaX;
					}
				} else {
					e.deltaX = 0;
					e.deltaY = e.detail;
				}
	
				e = eventCtrl.fire("wheel", e);
			}
	
			nativeEvents = eventCtrl._nativeEvents;
			if (nativeEvents) {
				// Find event root element if it exists
				parents = eventCtrl.parents().toArray();
				parents.unshift(eventCtrl);
				for (i = 0, l = parents.length; !eventRootCtrl && i < l; i++) {
					eventRootCtrl = parents[i]._eventsRoot;
				}
	
				// Event root wasn't found the use the root control
				if (!eventRootCtrl) {
					eventRootCtrl = parents[parents.length - 1] || eventCtrl;
				}
	
				// Set the eventsRoot property on children that didn't have it
				eventCtrl._eventsRoot = eventRootCtrl;
				for (l = i, i = 0; i < l; i++) {
					parents[i]._eventsRoot = eventRootCtrl;
				}
	
				var eventRootDelegates = eventRootCtrl._delegates;
				if (!eventRootDelegates) {
					eventRootDelegates = eventRootCtrl._delegates = {};
				}
	
				// Bind native event delegates
				for (name in nativeEvents) {
					if (!nativeEvents) {
						return false;
					}
	
					if (name === "wheel" && !hasWheelEventSupport) {
						if (hasMouseWheelEventSupport) {
							$(eventCtrl.getEl()).on("mousewheel", fixWheelEvent);
						} else {
							$(eventCtrl.getEl()).on("DOMMouseScroll", fixWheelEvent);
						}
	
						continue;
					}
	
					// Special treatment for mousenter/mouseleave since these doesn't bubble
					if (name === "mouseenter" || name === "mouseleave") {
						// Fake mousenter/mouseleave
						if (!eventRootCtrl._hasMouseEnter) {
							$(eventRootCtrl.getEl()).on("mouseleave", mouseLeaveHandler).on("mouseover", mouseEnterHandler);
							eventRootCtrl._hasMouseEnter = 1;
						}
					} else if (!eventRootDelegates[name]) {
						$(eventRootCtrl.getEl()).on(name, delegate);
						eventRootDelegates[name] = true;
					}
	
					// Remove the event once it's bound
					nativeEvents[name] = false;
				}
			}
		}
	
		return Control;
	});
	
	// Included from: js/tinymce/classes/ui/Factory.js
	
	/**
	 * Factory.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/*global tinymce:true */
	
	/**
	 * This class is a factory for control instances. This enables you
	 * to create instances of controls without having to require the UI controls directly.
	 *
	 * It also allow you to override or add new control types.
	 *
	 * @class tinymce.ui.Factory
	 */
	define("tinymce/ui/Factory", [], function() {
		"use strict";
	
		var types = {}, namespaceInit;
	
		return {
			/**
			 * Adds a new control instance type to the factory.
			 *
			 * @method add
			 * @param {String} type Type name for example "button".
			 * @param {function} typeClass Class type function.
			 */
			add: function(type, typeClass) {
				types[type.toLowerCase()] = typeClass;
			},
	
			/**
			 * Returns true/false if the specified type exists or not.
			 *
			 * @method has
			 * @param {String} type Type to look for.
			 * @return {Boolean} true/false if the control by name exists.
			 */
			has: function(type) {
				return !!types[type.toLowerCase()];
			},
	
			/**
			 * Creates a new control instance based on the settings provided. The instance created will be
			 * based on the specified type property it can also create whole structures of components out of
			 * the specified JSON object.
			 *
			 * @example
			 * tinymce.ui.Factory.create({
			 *     type: 'button',
			 *     text: 'Hello world!'
			 * });
			 *
			 * @method create
			 * @param {Object/String} settings Name/Value object with items used to create the type.
			 * @return {tinymce.ui.Control} Control instance based on the specified type.
			 */
			create: function(type, settings) {
				var ControlType, name, namespace;
	
				// Build type lookup
				if (!namespaceInit) {
					namespace = tinymce.ui;
	
					for (name in namespace) {
						types[name.toLowerCase()] = namespace[name];
					}
	
					namespaceInit = true;
				}
	
				// If string is specified then use it as the type
				if (typeof type == 'string') {
					settings = settings || {};
					settings.type = type;
				} else {
					settings = type;
					type = settings.type;
				}
	
				// Find control type
				type = type.toLowerCase();
				ControlType = types[type];
	
				// #if debug
	
				if (!ControlType) {
					throw new Error("Could not find control by type: " + type);
				}
	
				// #endif
	
				ControlType = new ControlType(settings);
				ControlType.type = type; // Set the type on the instance, this will be used by the Selector engine
	
				return ControlType;
			}
		};
	});
	
	// Included from: js/tinymce/classes/ui/KeyboardNavigation.js
	
	/**
	 * KeyboardNavigation.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This class handles keyboard navigation of controls and elements.
	 *
	 * @class tinymce.ui.KeyboardNavigation
	 */
	define("tinymce/ui/KeyboardNavigation", [
	], function() {
		"use strict";
	
		/**
		 * This class handles all keyboard navigation for WAI-ARIA support. Each root container
		 * gets an instance of this class.
		 *
		 * @constructor
		 */
		return function(settings) {
			var root = settings.root, focusedElement, focusedControl;
	
			function isElement(node) {
				return node && node.nodeType === 1;
			}
	
			try {
				focusedElement = document.activeElement;
			} catch (ex) {
				// IE sometimes fails to return a proper element
				focusedElement = document.body;
			}
	
			focusedControl = root.getParentCtrl(focusedElement);
	
			/**
			 * Returns the currently focused elements wai aria role of the currently
			 * focused element or specified element.
			 *
			 * @private
			 * @param {Element} elm Optional element to get role from.
			 * @return {String} Role of specified element.
			 */
			function getRole(elm) {
				elm = elm || focusedElement;
	
				if (isElement(elm)) {
					return elm.getAttribute('role');
				}
	
				return null;
			}
	
			/**
			 * Returns the wai role of the parent element of the currently
			 * focused element or specified element.
			 *
			 * @private
			 * @param {Element} elm Optional element to get parent role from.
			 * @return {String} Role of the first parent that has a role.
			 */
			function getParentRole(elm) {
				var role, parent = elm || focusedElement;
	
				while ((parent = parent.parentNode)) {
					if ((role = getRole(parent))) {
						return role;
					}
				}
			}
	
			/**
			 * Returns a wai aria property by name for example aria-selected.
			 *
			 * @private
			 * @param {String} name Name of the aria property to get for example "disabled".
			 * @return {String} Aria property value.
			 */
			function getAriaProp(name) {
				var elm = focusedElement;
	
				if (isElement(elm)) {
					return elm.getAttribute('aria-' + name);
				}
			}
	
			/**
			 * Is the element a text input element or not.
			 *
			 * @private
			 * @param {Element} elm Element to check if it's an text input element or not.
			 * @return {Boolean} True/false if the element is a text element or not.
			 */
			function isTextInputElement(elm) {
				var tagName = elm.tagName.toUpperCase();
	
				// Notice: since type can be "email" etc we don't check the type
				// So all input elements gets treated as text input elements
				return tagName == "INPUT" || tagName == "TEXTAREA" || tagName == "SELECT";
			}
	
			/**
			 * Returns true/false if the specified element can be focused or not.
			 *
			 * @private
			 * @param {Element} elm DOM element to check if it can be focused or not.
			 * @return {Boolean} True/false if the element can have focus.
			 */
			function canFocus(elm) {
				if (isTextInputElement(elm) && !elm.hidden) {
					return true;
				}
	
				if (/^(button|menuitem|checkbox|tab|menuitemcheckbox|option|gridcell|slider)$/.test(getRole(elm))) {
					return true;
				}
	
				return false;
			}
	
			/**
			 * Returns an array of focusable visible elements within the specified container element.
			 *
			 * @private
			 * @param {Element} elm DOM element to find focusable elements within.
			 * @return {Array} Array of focusable elements.
			 */
			function getFocusElements(elm) {
				var elements = [];
	
				function collect(elm) {
					if (elm.nodeType != 1 || elm.style.display == 'none' || elm.disabled) {
						return;
					}
	
					if (canFocus(elm)) {
						elements.push(elm);
					}
	
					for (var i = 0; i < elm.childNodes.length; i++) {
						collect(elm.childNodes[i]);
					}
				}
	
				collect(elm || root.getEl());
	
				return elements;
			}
	
			/**
			 * Returns the navigation root control for the specified control. The navigation root
			 * is the control that the keyboard navigation gets scoped to for example a menubar or toolbar group.
			 * It will look for parents of the specified target control or the currently focused control if this option is omitted.
			 *
			 * @private
			 * @param {tinymce.ui.Control} targetControl Optional target control to find root of.
			 * @return {tinymce.ui.Control} Navigation root control.
			 */
			function getNavigationRoot(targetControl) {
				var navigationRoot, controls;
	
				targetControl = targetControl || focusedControl;
				controls = targetControl.parents().toArray();
				controls.unshift(targetControl);
	
				for (var i = 0; i < controls.length; i++) {
					navigationRoot = controls[i];
	
					if (navigationRoot.settings.ariaRoot) {
						break;
					}
				}
	
				return navigationRoot;
			}
	
			/**
			 * Focuses the first item in the specified targetControl element or the last aria index if the
			 * navigation root has the ariaRemember option enabled.
			 *
			 * @private
			 * @param {tinymce.ui.Control} targetControl Target control to focus the first item in.
			 */
			function focusFirst(targetControl) {
				var navigationRoot = getNavigationRoot(targetControl);
				var focusElements = getFocusElements(navigationRoot.getEl());
	
				if (navigationRoot.settings.ariaRemember && "lastAriaIndex" in navigationRoot) {
					moveFocusToIndex(navigationRoot.lastAriaIndex, focusElements);
				} else {
					moveFocusToIndex(0, focusElements);
				}
			}
	
			/**
			 * Moves the focus to the specified index within the elements list.
			 * This will scope the index to the size of the element list if it changed.
			 *
			 * @private
			 * @param {Number} idx Specified index to move to.
			 * @param {Array} elements Array with dom elements to move focus within.
			 * @return {Number} Input index or a changed index if it was out of range.
			 */
			function moveFocusToIndex(idx, elements) {
				if (idx < 0) {
					idx = elements.length - 1;
				} else if (idx >= elements.length) {
					idx = 0;
				}
	
				if (elements[idx]) {
					elements[idx].focus();
				}
	
				return idx;
			}
	
			/**
			 * Moves the focus forwards or backwards.
			 *
			 * @private
			 * @param {Number} dir Direction to move in positive means forward, negative means backwards.
			 * @param {Array} elements Optional array of elements to move within defaults to the current navigation roots elements.
			 */
			function moveFocus(dir, elements) {
				var idx = -1, navigationRoot = getNavigationRoot();
	
				elements = elements || getFocusElements(navigationRoot.getEl());
	
				for (var i = 0; i < elements.length; i++) {
					if (elements[i] === focusedElement) {
						idx = i;
					}
				}
	
				idx += dir;
				navigationRoot.lastAriaIndex = moveFocusToIndex(idx, elements);
			}
	
			/**
			 * Moves the focus to the left this is called by the left key.
			 *
			 * @private
			 */
			function left() {
				var parentRole = getParentRole();
	
				if (parentRole == "tablist") {
					moveFocus(-1, getFocusElements(focusedElement.parentNode));
				} else if (focusedControl.parent().submenu) {
					cancel();
				} else {
					moveFocus(-1);
				}
			}
	
			/**
			 * Moves the focus to the right this is called by the right key.
			 *
			 * @private
			 */
			function right() {
				var role = getRole(), parentRole = getParentRole();
	
				if (parentRole == "tablist") {
					moveFocus(1, getFocusElements(focusedElement.parentNode));
				} else if (role == "menuitem" && parentRole == "menu" && getAriaProp('haspopup')) {
					enter();
				} else {
					moveFocus(1);
				}
			}
	
			/**
			 * Moves the focus to the up this is called by the up key.
			 *
			 * @private
			 */
			function up() {
				moveFocus(-1);
			}
	
			/**
			 * Moves the focus to the up this is called by the down key.
			 *
			 * @private
			 */
			function down() {
				var role = getRole(), parentRole = getParentRole();
	
				if (role == "menuitem" && parentRole == "menubar") {
					enter();
				} else if (role == "button" && getAriaProp('haspopup')) {
					enter({key: 'down'});
				} else {
					moveFocus(1);
				}
			}
	
			/**
			 * Moves the focus to the next item or previous item depending on shift key.
			 *
			 * @private
			 * @param {DOMEvent} e DOM event object.
			 */
			function tab(e) {
				var parentRole = getParentRole();
	
				if (parentRole == "tablist") {
					var elm = getFocusElements(focusedControl.getEl('body'))[0];
	
					if (elm) {
						elm.focus();
					}
				} else {
					moveFocus(e.shiftKey ? -1 : 1);
				}
			}
	
			/**
			 * Calls the cancel event on the currently focused control. This is normally done using the Esc key.
			 *
			 * @private
			 */
			function cancel() {
				focusedControl.fire('cancel');
			}
	
			/**
			 * Calls the click event on the currently focused control. This is normally done using the Enter/Space keys.
			 *
			 * @private
			 * @param {Object} aria Optional aria data to pass along with the enter event.
			 */
			function enter(aria) {
				aria = aria || {};
				focusedControl.fire('click', {target: focusedElement, aria: aria});
			}
	
			root.on('keydown', function(e) {
				function handleNonTabOrEscEvent(e, handler) {
					// Ignore non tab keys for text elements
					if (isTextInputElement(focusedElement)) {
						return;
					}
	
					if (getRole(focusedElement) === 'slider') {
						return;
					}
	
					if (handler(e) !== false) {
						e.preventDefault();
					}
				}
	
				if (e.isDefaultPrevented()) {
					return;
				}
	
				switch (e.keyCode) {
					case 37: // DOM_VK_LEFT
						handleNonTabOrEscEvent(e, left);
						break;
	
					case 39: // DOM_VK_RIGHT
						handleNonTabOrEscEvent(e, right);
						break;
	
					case 38: // DOM_VK_UP
						handleNonTabOrEscEvent(e, up);
						break;
	
					case 40: // DOM_VK_DOWN
						handleNonTabOrEscEvent(e, down);
						break;
	
					case 27: // DOM_VK_ESCAPE
						cancel();
						break;
	
					case 14: // DOM_VK_ENTER
					case 13: // DOM_VK_RETURN
					case 32: // DOM_VK_SPACE
						handleNonTabOrEscEvent(e, enter);
						break;
	
					case 9: // DOM_VK_TAB
						if (tab(e) !== false) {
							e.preventDefault();
						}
						break;
				}
			});
	
			root.on('focusin', function(e) {
				focusedElement = e.target;
				focusedControl = e.control;
			});
	
			return {
				focusFirst: focusFirst
			};
		};
	});
	
	// Included from: js/tinymce/classes/ui/Container.js
	
	/**
	 * Container.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Container control. This is extended by all controls that can have
	 * children such as panels etc. You can also use this class directly as an
	 * generic container instance. The container doesn't have any specific role or style.
	 *
	 * @-x-less Container.less
	 * @class tinymce.ui.Container
	 * @extends tinymce.ui.Control
	 */
	define("tinymce/ui/Container", [
		"tinymce/ui/Control",
		"tinymce/ui/Collection",
		"tinymce/ui/Selector",
		"tinymce/ui/Factory",
		"tinymce/ui/KeyboardNavigation",
		"tinymce/util/Tools",
		"tinymce/dom/DomQuery",
		"tinymce/ui/ClassList",
		"tinymce/ui/ReflowQueue"
	], function(Control, Collection, Selector, Factory, KeyboardNavigation, Tools, $, ClassList, ReflowQueue) {
		"use strict";
	
		var selectorCache = {};
	
		return Control.extend({
			/**
			 * Constructs a new control instance with the specified settings.
			 *
			 * @constructor
			 * @param {Object} settings Name/value object with settings.
			 * @setting {Array} items Items to add to container in JSON format or control instances.
			 * @setting {String} layout Layout manager by name to use.
			 * @setting {Object} defaults Default settings to apply to all items.
			 */
			init: function(settings) {
				var self = this;
	
				self._super(settings);
				settings = self.settings;
	
				if (settings.fixed) {
					self.state.set('fixed', true);
				}
	
				self._items = new Collection();
	
				if (self.isRtl()) {
					self.classes.add('rtl');
				}
	
				self.bodyClasses = new ClassList(function() {
					if (self.state.get('rendered')) {
						self.getEl('body').className = this.toString();
					}
				});
				self.bodyClasses.prefix = self.classPrefix;
	
				self.classes.add('container');
				self.bodyClasses.add('container-body');
	
				if (settings.containerCls) {
					self.classes.add(settings.containerCls);
				}
	
				self._layout = Factory.create((settings.layout || '') + 'layout');
	
				if (self.settings.items) {
					self.add(self.settings.items);
				} else {
					self.add(self.render());
				}
	
				// TODO: Fix this!
				self._hasBody = true;
			},
	
			/**
			 * Returns a collection of child items that the container currently have.
			 *
			 * @method items
			 * @return {tinymce.ui.Collection} Control collection direct child controls.
			 */
			items: function() {
				return this._items;
			},
	
			/**
			 * Find child controls by selector.
			 *
			 * @method find
			 * @param {String} selector Selector CSS pattern to find children by.
			 * @return {tinymce.ui.Collection} Control collection with child controls.
			 */
			find: function(selector) {
				selector = selectorCache[selector] = selectorCache[selector] || new Selector(selector);
	
				return selector.find(this);
			},
	
			/**
			 * Adds one or many items to the current container. This will create instances of
			 * the object representations if needed.
			 *
			 * @method add
			 * @param {Array/Object/tinymce.ui.Control} items Array or item that will be added to the container.
			 * @return {tinymce.ui.Collection} Current collection control.
			 */
			add: function(items) {
				var self = this;
	
				self.items().add(self.create(items)).parent(self);
	
				return self;
			},
	
			/**
			 * Focuses the current container instance. This will look
			 * for the first control in the container and focus that.
			 *
			 * @method focus
			 * @param {Boolean} keyboard Optional true/false if the focus was a keyboard focus or not.
			 * @return {tinymce.ui.Collection} Current instance.
			 */
			focus: function(keyboard) {
				var self = this, focusCtrl, keyboardNav, items;
	
				if (keyboard) {
					keyboardNav = self.keyboardNav || self.parents().eq(-1)[0].keyboardNav;
	
					if (keyboardNav) {
						keyboardNav.focusFirst(self);
						return;
					}
				}
	
				items = self.find('*');
	
				// TODO: Figure out a better way to auto focus alert dialog buttons
				if (self.statusbar) {
					items.add(self.statusbar.items());
				}
	
				items.each(function(ctrl) {
					if (ctrl.settings.autofocus) {
						focusCtrl = null;
						return false;
					}
	
					if (ctrl.canFocus) {
						focusCtrl = focusCtrl || ctrl;
					}
				});
	
				if (focusCtrl) {
					focusCtrl.focus();
				}
	
				return self;
			},
	
			/**
			 * Replaces the specified child control with a new control.
			 *
			 * @method replace
			 * @param {tinymce.ui.Control} oldItem Old item to be replaced.
			 * @param {tinymce.ui.Control} newItem New item to be inserted.
			 */
			replace: function(oldItem, newItem) {
				var ctrlElm, items = this.items(), i = items.length;
	
				// Replace the item in collection
				while (i--) {
					if (items[i] === oldItem) {
						items[i] = newItem;
						break;
					}
				}
	
				if (i >= 0) {
					// Remove new item from DOM
					ctrlElm = newItem.getEl();
					if (ctrlElm) {
						ctrlElm.parentNode.removeChild(ctrlElm);
					}
	
					// Remove old item from DOM
					ctrlElm = oldItem.getEl();
					if (ctrlElm) {
						ctrlElm.parentNode.removeChild(ctrlElm);
					}
				}
	
				// Adopt the item
				newItem.parent(this);
			},
	
			/**
			 * Creates the specified items. If any of the items is plain JSON style objects
			 * it will convert these into real tinymce.ui.Control instances.
			 *
			 * @method create
			 * @param {Array} items Array of items to convert into control instances.
			 * @return {Array} Array with control instances.
			 */
			create: function(items) {
				var self = this, settings, ctrlItems = [];
	
				// Non array structure, then force it into an array
				if (!Tools.isArray(items)) {
					items = [items];
				}
	
				// Add default type to each child control
				Tools.each(items, function(item) {
					if (item) {
						// Construct item if needed
						if (!(item instanceof Control)) {
							// Name only then convert it to an object
							if (typeof item == "string") {
								item = {type: item};
							}
	
							// Create control instance based on input settings and default settings
							settings = Tools.extend({}, self.settings.defaults, item);
							item.type = settings.type = settings.type || item.type || self.settings.defaultType ||
								(settings.defaults ? settings.defaults.type : null);
							item = Factory.create(settings);
						}
	
						ctrlItems.push(item);
					}
				});
	
				return ctrlItems;
			},
	
			/**
			 * Renders new control instances.
			 *
			 * @private
			 */
			renderNew: function() {
				var self = this;
	
				// Render any new items
				self.items().each(function(ctrl, index) {
					var containerElm;
	
					ctrl.parent(self);
	
					if (!ctrl.state.get('rendered')) {
						containerElm = self.getEl('body');
	
						// Insert or append the item
						if (containerElm.hasChildNodes() && index <= containerElm.childNodes.length - 1) {
							$(containerElm.childNodes[index]).before(ctrl.renderHtml());
						} else {
							$(containerElm).append(ctrl.renderHtml());
						}
	
						ctrl.postRender();
						ReflowQueue.add(ctrl);
					}
				});
	
				self._layout.applyClasses(self.items().filter(':visible'));
				self._lastRect = null;
	
				return self;
			},
	
			/**
			 * Appends new instances to the current container.
			 *
			 * @method append
			 * @param {Array/tinymce.ui.Collection} items Array if controls to append.
			 * @return {tinymce.ui.Container} Current container instance.
			 */
			append: function(items) {
				return this.add(items).renderNew();
			},
	
			/**
			 * Prepends new instances to the current container.
			 *
			 * @method prepend
			 * @param {Array/tinymce.ui.Collection} items Array if controls to prepend.
			 * @return {tinymce.ui.Container} Current container instance.
			 */
			prepend: function(items) {
				var self = this;
	
				self.items().set(self.create(items).concat(self.items().toArray()));
	
				return self.renderNew();
			},
	
			/**
			 * Inserts an control at a specific index.
			 *
			 * @method insert
			 * @param {Array/tinymce.ui.Collection} items Array if controls to insert.
			 * @param {Number} index Index to insert controls at.
			 * @param {Boolean} [before=false] Inserts controls before the index.
			 */
			insert: function(items, index, before) {
				var self = this, curItems, beforeItems, afterItems;
	
				items = self.create(items);
				curItems = self.items();
	
				if (!before && index < curItems.length - 1) {
					index += 1;
				}
	
				if (index >= 0 && index < curItems.length) {
					beforeItems = curItems.slice(0, index).toArray();
					afterItems = curItems.slice(index).toArray();
					curItems.set(beforeItems.concat(items, afterItems));
				}
	
				return self.renderNew();
			},
	
			/**
			 * Populates the form fields from the specified JSON data object.
			 *
			 * Control items in the form that matches the data will have it's value set.
			 *
			 * @method fromJSON
			 * @param {Object} data JSON data object to set control values by.
			 * @return {tinymce.ui.Container} Current form instance.
			 */
			fromJSON: function(data) {
				var self = this;
	
				for (var name in data) {
					self.find('#' + name).value(data[name]);
				}
	
				return self;
			},
	
			/**
			 * Serializes the form into a JSON object by getting all items
			 * that has a name and a value.
			 *
			 * @method toJSON
			 * @return {Object} JSON object with form data.
			 */
			toJSON: function() {
				var self = this, data = {};
	
				self.find('*').each(function(ctrl) {
					var name = ctrl.name(), value = ctrl.value();
	
					if (name && typeof value != "undefined") {
						data[name] = value;
					}
				});
	
				return data;
			},
	
			/**
			 * Renders the control as a HTML string.
			 *
			 * @method renderHtml
			 * @return {String} HTML representing the control.
			 */
			renderHtml: function() {
				var self = this, layout = self._layout, role = this.settings.role;
	
				self.preRender();
				layout.preRender(self);
	
				return (
					'<div id="' + self._id + '" class="' + self.classes + '"' + (role ? ' role="' + this.settings.role + '"' : '') + '>' +
						'<div id="' + self._id + '-body" class="' + self.bodyClasses + '">' +
							(self.settings.html || '') + layout.renderHtml(self) +
						'</div>' +
					'</div>'
				);
			},
	
			/**
			 * Post render method. Called after the control has been rendered to the target.
			 *
			 * @method postRender
			 * @return {tinymce.ui.Container} Current combobox instance.
			 */
			postRender: function() {
				var self = this, box;
	
				self.items().exec('postRender');
				self._super();
	
				self._layout.postRender(self);
				self.state.set('rendered', true);
	
				if (self.settings.style) {
					self.$el.css(self.settings.style);
				}
	
				if (self.settings.border) {
					box = self.borderBox;
					self.$el.css({
						'border-top-width': box.top,
						'border-right-width': box.right,
						'border-bottom-width': box.bottom,
						'border-left-width': box.left
					});
				}
	
				if (!self.parent()) {
					self.keyboardNav = new KeyboardNavigation({
						root: self
					});
				}
	
				return self;
			},
	
			/**
			 * Initializes the current controls layout rect.
			 * This will be executed by the layout managers to determine the
			 * default minWidth/minHeight etc.
			 *
			 * @method initLayoutRect
			 * @return {Object} Layout rect instance.
			 */
			initLayoutRect: function() {
				var self = this, layoutRect = self._super();
	
				// Recalc container size by asking layout manager
				self._layout.recalc(self);
	
				return layoutRect;
			},
	
			/**
			 * Recalculates the positions of the controls in the current container.
			 * This is invoked by the reflow method and shouldn't be called directly.
			 *
			 * @method recalc
			 */
			recalc: function() {
				var self = this, rect = self._layoutRect, lastRect = self._lastRect;
	
				if (!lastRect || lastRect.w != rect.w || lastRect.h != rect.h) {
					self._layout.recalc(self);
					rect = self.layoutRect();
					self._lastRect = {x: rect.x, y: rect.y, w: rect.w, h: rect.h};
					return true;
				}
			},
	
			/**
			 * Reflows the current container and it's children and possible parents.
			 * This should be used after you for example append children to the current control so
			 * that the layout managers know that they need to reposition everything.
			 *
			 * @example
			 * container.append({type: 'button', text: 'My button'}).reflow();
			 *
			 * @method reflow
			 * @return {tinymce.ui.Container} Current container instance.
			 */
			reflow: function() {
				var i;
	
				ReflowQueue.remove(this);
	
				if (this.visible()) {
					Control.repaintControls = [];
					Control.repaintControls.map = {};
	
					this.recalc();
					i = Control.repaintControls.length;
	
					while (i--) {
						Control.repaintControls[i].repaint();
					}
	
					// TODO: Fix me!
					if (this.settings.layout !== "flow" && this.settings.layout !== "stack") {
						this.repaint();
					}
	
					Control.repaintControls = [];
				}
	
				return this;
			}
		});
	});
	
	// Included from: js/tinymce/classes/ui/DragHelper.js
	
	/**
	 * DragHelper.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Drag/drop helper class.
	 *
	 * @example
	 * var dragHelper = new tinymce.ui.DragHelper('mydiv', {
	 *     start: function(evt) {
	 *     },
	 *
	 *     drag: function(evt) {
	 *     },
	 *
	 *     end: function(evt) {
	 *     }
	 * });
	 *
	 * @class tinymce.ui.DragHelper
	 */
	define("tinymce/ui/DragHelper", [
		"tinymce/dom/DomQuery"
	], function($) {
		"use strict";
	
		function getDocumentSize(doc) {
			var documentElement, body, scrollWidth, clientWidth;
			var offsetWidth, scrollHeight, clientHeight, offsetHeight, max = Math.max;
	
			documentElement = doc.documentElement;
			body = doc.body;
	
			scrollWidth = max(documentElement.scrollWidth, body.scrollWidth);
			clientWidth = max(documentElement.clientWidth, body.clientWidth);
			offsetWidth = max(documentElement.offsetWidth, body.offsetWidth);
	
			scrollHeight = max(documentElement.scrollHeight, body.scrollHeight);
			clientHeight = max(documentElement.clientHeight, body.clientHeight);
			offsetHeight = max(documentElement.offsetHeight, body.offsetHeight);
	
			return {
				width: scrollWidth < offsetWidth ? clientWidth : scrollWidth,
				height: scrollHeight < offsetHeight ? clientHeight : scrollHeight
			};
		}
	
		function updateWithTouchData(e) {
			var keys, i;
	
			if (e.changedTouches) {
				keys = "screenX screenY pageX pageY clientX clientY".split(' ');
				for (i = 0; i < keys.length; i++) {
					e[keys[i]] = e.changedTouches[0][keys[i]];
				}
			}
		}
	
		return function(id, settings) {
			var $eventOverlay, doc = settings.document || document, downButton, start, stop, drag, startX, startY;
	
			settings = settings || {};
	
			function getHandleElm() {
				return doc.getElementById(settings.handle || id);
			}
	
			start = function(e) {
				var docSize = getDocumentSize(doc), handleElm, cursor;
	
				updateWithTouchData(e);
	
				e.preventDefault();
				downButton = e.button;
				handleElm = getHandleElm();
				startX = e.screenX;
				startY = e.screenY;
	
				// Grab cursor from handle so we can place it on overlay
				if (window.getComputedStyle) {
					cursor = window.getComputedStyle(handleElm, null).getPropertyValue("cursor");
				} else {
					cursor = handleElm.runtimeStyle.cursor;
				}
	
				$eventOverlay = $('<div></div>').css({
					position: "absolute",
					top: 0, left: 0,
					width: docSize.width,
					height: docSize.height,
					zIndex: 0x7FFFFFFF,
					opacity: 0.0001,
					cursor: cursor
				}).appendTo(doc.body);
	
				$(doc).on('mousemove touchmove', drag).on('mouseup touchend', stop);
	
				settings.start(e);
			};
	
			drag = function(e) {
				updateWithTouchData(e);
	
				if (e.button !== downButton) {
					return stop(e);
				}
	
				e.deltaX = e.screenX - startX;
				e.deltaY = e.screenY - startY;
	
				e.preventDefault();
				settings.drag(e);
			};
	
			stop = function(e) {
				updateWithTouchData(e);
	
				$(doc).off('mousemove touchmove', drag).off('mouseup touchend', stop);
	
				$eventOverlay.remove();
	
				if (settings.stop) {
					settings.stop(e);
				}
			};
	
			/**
			 * Destroys the drag/drop helper instance.
			 *
			 * @method destroy
			 */
			this.destroy = function() {
				$(getHandleElm()).off();
			};
	
			$(getHandleElm()).on('mousedown touchstart', start);
		};
	});
	
	// Included from: js/tinymce/classes/ui/Scrollable.js
	
	/**
	 * Scrollable.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This mixin makes controls scrollable using custom scrollbars.
	 *
	 * @-x-less Scrollable.less
	 * @mixin tinymce.ui.Scrollable
	 */
	define("tinymce/ui/Scrollable", [
		"tinymce/dom/DomQuery",
		"tinymce/ui/DragHelper"
	], function($, DragHelper) {
		"use strict";
	
		return {
			init: function() {
				var self = this;
				self.on('repaint', self.renderScroll);
			},
	
			renderScroll: function() {
				var self = this, margin = 2;
	
				function repaintScroll() {
					var hasScrollH, hasScrollV, bodyElm;
	
					function repaintAxis(axisName, posName, sizeName, contentSizeName, hasScroll, ax) {
						var containerElm, scrollBarElm, scrollThumbElm;
						var containerSize, scrollSize, ratio, rect;
						var posNameLower, sizeNameLower;
	
						scrollBarElm = self.getEl('scroll' + axisName);
						if (scrollBarElm) {
							posNameLower = posName.toLowerCase();
							sizeNameLower = sizeName.toLowerCase();
	
							$(self.getEl('absend')).css(posNameLower, self.layoutRect()[contentSizeName] - 1);
	
							if (!hasScroll) {
								$(scrollBarElm).css('display', 'none');
								return;
							}
	
							$(scrollBarElm).css('display', 'block');
							containerElm = self.getEl('body');
							scrollThumbElm = self.getEl('scroll' + axisName + "t");
							containerSize = containerElm["client" + sizeName] - (margin * 2);
							containerSize -= hasScrollH && hasScrollV ? scrollBarElm["client" + ax] : 0;
							scrollSize = containerElm["scroll" + sizeName];
							ratio = containerSize / scrollSize;
	
							rect = {};
							rect[posNameLower] = containerElm["offset" + posName] + margin;
							rect[sizeNameLower] = containerSize;
							$(scrollBarElm).css(rect);
	
							rect = {};
							rect[posNameLower] = containerElm["scroll" + posName] * ratio;
							rect[sizeNameLower] = containerSize * ratio;
							$(scrollThumbElm).css(rect);
						}
					}
	
					bodyElm = self.getEl('body');
					hasScrollH = bodyElm.scrollWidth > bodyElm.clientWidth;
					hasScrollV = bodyElm.scrollHeight > bodyElm.clientHeight;
	
					repaintAxis("h", "Left", "Width", "contentW", hasScrollH, "Height");
					repaintAxis("v", "Top", "Height", "contentH", hasScrollV, "Width");
				}
	
				function addScroll() {
					function addScrollAxis(axisName, posName, sizeName, deltaPosName, ax) {
						var scrollStart, axisId = self._id + '-scroll' + axisName, prefix = self.classPrefix;
	
						$(self.getEl()).append(
							'<div id="' + axisId + '" class="' + prefix + 'scrollbar ' + prefix + 'scrollbar-' + axisName + '">' +
								'<div id="' + axisId + 't" class="' + prefix + 'scrollbar-thumb"></div>' +
							'</div>'
						);
	
						self.draghelper = new DragHelper(axisId + 't', {
							start: function() {
								scrollStart = self.getEl('body')["scroll" + posName];
								$('#' + axisId).addClass(prefix + 'active');
							},
	
							drag: function(e) {
								var ratio, hasScrollH, hasScrollV, containerSize, layoutRect = self.layoutRect();
	
								hasScrollH = layoutRect.contentW > layoutRect.innerW;
								hasScrollV = layoutRect.contentH > layoutRect.innerH;
								containerSize = self.getEl('body')["client" + sizeName] - (margin * 2);
								containerSize -= hasScrollH && hasScrollV ? self.getEl('scroll' + axisName)["client" + ax] : 0;
	
								ratio = containerSize / self.getEl('body')["scroll" + sizeName];
								self.getEl('body')["scroll" + posName] = scrollStart + (e["delta" + deltaPosName] / ratio);
							},
	
							stop: function() {
								$('#' + axisId).removeClass(prefix + 'active');
							}
						});
					}
	
					self.classes.add('scroll');
	
					addScrollAxis("v", "Top", "Height", "Y", "Width");
					addScrollAxis("h", "Left", "Width", "X", "Height");
				}
	
				if (self.settings.autoScroll) {
					if (!self._hasScroll) {
						self._hasScroll = true;
						addScroll();
	
						self.on('wheel', function(e) {
							var bodyEl = self.getEl('body');
	
							bodyEl.scrollLeft += (e.deltaX || 0) * 10;
							bodyEl.scrollTop += e.deltaY * 10;
	
							repaintScroll();
						});
	
						$(self.getEl('body')).on("scroll", repaintScroll);
					}
	
					repaintScroll();
				}
			}
		};
	});
	
	// Included from: js/tinymce/classes/ui/Panel.js
	
	/**
	 * Panel.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Creates a new panel.
	 *
	 * @-x-less Panel.less
	 * @class tinymce.ui.Panel
	 * @extends tinymce.ui.Container
	 * @mixes tinymce.ui.Scrollable
	 */
	define("tinymce/ui/Panel", [
		"tinymce/ui/Container",
		"tinymce/ui/Scrollable"
	], function(Container, Scrollable) {
		"use strict";
	
		return Container.extend({
			Defaults: {
				layout: 'fit',
				containerCls: 'panel'
			},
	
			Mixins: [Scrollable],
	
			/**
			 * Renders the control as a HTML string.
			 *
			 * @method renderHtml
			 * @return {String} HTML representing the control.
			 */
			renderHtml: function() {
				var self = this, layout = self._layout, innerHtml = self.settings.html;
	
				self.preRender();
				layout.preRender(self);
	
				if (typeof innerHtml == "undefined") {
					innerHtml = (
						'<div id="' + self._id + '-body" class="' + self.bodyClasses + '">' +
							layout.renderHtml(self) +
						'</div>'
					);
				} else {
					if (typeof innerHtml == 'function') {
						innerHtml = innerHtml.call(self);
					}
	
					self._hasBody = false;
				}
	
				return (
					'<div id="' + self._id + '" class="' + self.classes + '" hidefocus="1" tabindex="-1" role="group">' +
						(self._preBodyHtml || '') +
						innerHtml +
					'</div>'
				);
			}
		});
	});
	
	// Included from: js/tinymce/classes/ui/Movable.js
	
	/**
	 * Movable.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Movable mixin. Makes controls movable absolute and relative to other elements.
	 *
	 * @mixin tinymce.ui.Movable
	 */
	define("tinymce/ui/Movable", [
		"tinymce/ui/DomUtils"
	], function(DomUtils) {
		"use strict";
	
		function calculateRelativePosition(ctrl, targetElm, rel) {
			var ctrlElm, pos, x, y, selfW, selfH, targetW, targetH, viewport, size;
	
			viewport = DomUtils.getViewPort();
	
			// Get pos of target
			pos = DomUtils.getPos(targetElm);
			x = pos.x;
			y = pos.y;
	
			if (ctrl.state.get('fixed') && DomUtils.getRuntimeStyle(document.body, 'position') == 'static') {
				x -= viewport.x;
				y -= viewport.y;
			}
	
			// Get size of self
			ctrlElm = ctrl.getEl();
			size = DomUtils.getSize(ctrlElm);
			selfW = size.width;
			selfH = size.height;
	
			// Get size of target
			size = DomUtils.getSize(targetElm);
			targetW = size.width;
			targetH = size.height;
	
			// Parse align string
			rel = (rel || '').split('');
	
			// Target corners
			if (rel[0] === 'b') {
				y += targetH;
			}
	
			if (rel[1] === 'r') {
				x += targetW;
			}
	
			if (rel[0] === 'c') {
				y += Math.round(targetH / 2);
			}
	
			if (rel[1] === 'c') {
				x += Math.round(targetW / 2);
			}
	
			// Self corners
			if (rel[3] === 'b') {
				y -= selfH;
			}
	
			if (rel[4] === 'r') {
				x -= selfW;
			}
	
			if (rel[3] === 'c') {
				y -= Math.round(selfH / 2);
			}
	
			if (rel[4] === 'c') {
				x -= Math.round(selfW / 2);
			}
	
			return {
				x: x,
				y: y,
				w: selfW,
				h: selfH
			};
		}
	
		return {
			/**
			 * Tests various positions to get the most suitable one.
			 *
			 * @method testMoveRel
			 * @param {DOMElement} elm Element to position against.
			 * @param {Array} rels Array with relative positions.
			 * @return {String} Best suitable relative position.
			 */
			testMoveRel: function(elm, rels) {
				var viewPortRect = DomUtils.getViewPort();
	
				for (var i = 0; i < rels.length; i++) {
					var pos = calculateRelativePosition(this, elm, rels[i]);
	
					if (this.state.get('fixed')) {
						if (pos.x > 0 && pos.x + pos.w < viewPortRect.w && pos.y > 0 && pos.y + pos.h < viewPortRect.h) {
							return rels[i];
						}
					} else {
						if (pos.x > viewPortRect.x && pos.x + pos.w < viewPortRect.w + viewPortRect.x &&
							pos.y > viewPortRect.y && pos.y + pos.h < viewPortRect.h + viewPortRect.y) {
							return rels[i];
						}
					}
				}
	
				return rels[0];
			},
	
			/**
			 * Move relative to the specified element.
			 *
			 * @method moveRel
			 * @param {Element} elm Element to move relative to.
			 * @param {String} rel Relative mode. For example: br-tl.
			 * @return {tinymce.ui.Control} Current control instance.
			 */
			moveRel: function(elm, rel) {
				if (typeof rel != 'string') {
					rel = this.testMoveRel(elm, rel);
				}
	
				var pos = calculateRelativePosition(this, elm, rel);
				return this.moveTo(pos.x, pos.y);
			},
	
			/**
			 * Move by a relative x, y values.
			 *
			 * @method moveBy
			 * @param {Number} dx Relative x position.
			 * @param {Number} dy Relative y position.
			 * @return {tinymce.ui.Control} Current control instance.
			 */
			moveBy: function(dx, dy) {
				var self = this, rect = self.layoutRect();
	
				self.moveTo(rect.x + dx, rect.y + dy);
	
				return self;
			},
	
			/**
			 * Move to absolute position.
			 *
			 * @method moveTo
			 * @param {Number} x Absolute x position.
			 * @param {Number} y Absolute y position.
			 * @return {tinymce.ui.Control} Current control instance.
			 */
			moveTo: function(x, y) {
				var self = this;
	
				// TODO: Move this to some global class
				function constrain(value, max, size) {
					if (value < 0) {
						return 0;
					}
	
					if (value + size > max) {
						value = max - size;
						return value < 0 ? 0 : value;
					}
	
					return value;
				}
	
				if (self.settings.constrainToViewport) {
					var viewPortRect = DomUtils.getViewPort(window);
					var layoutRect = self.layoutRect();
	
					x = constrain(x, viewPortRect.w + viewPortRect.x, layoutRect.w);
					y = constrain(y, viewPortRect.h + viewPortRect.y, layoutRect.h);
				}
	
				if (self.state.get('rendered')) {
					self.layoutRect({x: x, y: y}).repaint();
				} else {
					self.settings.x = x;
					self.settings.y = y;
				}
	
				self.fire('move', {x: x, y: y});
	
				return self;
			}
		};
	});
	
	// Included from: js/tinymce/classes/ui/Resizable.js
	
	/**
	 * Resizable.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Resizable mixin. Enables controls to be resized.
	 *
	 * @mixin tinymce.ui.Resizable
	 */
	define("tinymce/ui/Resizable", [
		"tinymce/ui/DomUtils"
	], function(DomUtils) {
		"use strict";
	
		return {
			/**
			 * Resizes the control to contents.
			 *
			 * @method resizeToContent
			 */
			resizeToContent: function() {
				this._layoutRect.autoResize = true;
				this._lastRect = null;
				this.reflow();
			},
	
			/**
			 * Resizes the control to a specific width/height.
			 *
			 * @method resizeTo
			 * @param {Number} w Control width.
			 * @param {Number} h Control height.
			 * @return {tinymce.ui.Control} Current control instance.
			 */
			resizeTo: function(w, h) {
				// TODO: Fix hack
				if (w <= 1 || h <= 1) {
					var rect = DomUtils.getWindowSize();
	
					w = w <= 1 ? w * rect.w : w;
					h = h <= 1 ? h * rect.h : h;
				}
	
				this._layoutRect.autoResize = false;
				return this.layoutRect({minW: w, minH: h, w: w, h: h}).reflow();
			},
	
			/**
			 * Resizes the control to a specific relative width/height.
			 *
			 * @method resizeBy
			 * @param {Number} dw Relative control width.
			 * @param {Number} dh Relative control height.
			 * @return {tinymce.ui.Control} Current control instance.
			 */
			resizeBy: function(dw, dh) {
				var self = this, rect = self.layoutRect();
	
				return self.resizeTo(rect.w + dw, rect.h + dh);
			}
		};
	});
	
	// Included from: js/tinymce/classes/ui/FloatPanel.js
	
	/**
	 * FloatPanel.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This class creates a floating panel.
	 *
	 * @-x-less FloatPanel.less
	 * @class tinymce.ui.FloatPanel
	 * @extends tinymce.ui.Panel
	 * @mixes tinymce.ui.Movable
	 * @mixes tinymce.ui.Resizable
	 */
	define("tinymce/ui/FloatPanel", [
		"tinymce/ui/Panel",
		"tinymce/ui/Movable",
		"tinymce/ui/Resizable",
		"tinymce/ui/DomUtils",
		"tinymce/dom/DomQuery",
		"tinymce/util/Delay"
	], function(Panel, Movable, Resizable, DomUtils, $, Delay) {
		"use strict";
	
		var documentClickHandler, documentScrollHandler, windowResizeHandler, visiblePanels = [];
		var zOrder = [], hasModal;
	
		function isChildOf(ctrl, parent) {
			while (ctrl) {
				if (ctrl == parent) {
					return true;
				}
	
				ctrl = ctrl.parent();
			}
		}
	
		function skipOrHidePanels(e) {
			// Hide any float panel when a click/focus out is out side that float panel and the
			// float panels direct parent for example a click on a menu button
			var i = visiblePanels.length;
	
			while (i--) {
				var panel = visiblePanels[i], clickCtrl = panel.getParentCtrl(e.target);
	
				if (panel.settings.autohide) {
					if (clickCtrl) {
						if (isChildOf(clickCtrl, panel) || panel.parent() === clickCtrl) {
							continue;
						}
					}
	
					e = panel.fire('autohide', {target: e.target});
					if (!e.isDefaultPrevented()) {
						panel.hide();
					}
				}
			}
		}
	
		function bindDocumentClickHandler() {
	
			if (!documentClickHandler) {
				documentClickHandler = function(e) {
					// Gecko fires click event and in the wrong order on Mac so lets normalize
					if (e.button == 2) {
						return;
					}
	
					skipOrHidePanels(e);
				};
	
				$(document).on('click touchstart', documentClickHandler);
			}
		}
	
		function bindDocumentScrollHandler() {
			if (!documentScrollHandler) {
				documentScrollHandler = function() {
					var i;
	
					i = visiblePanels.length;
					while (i--) {
						repositionPanel(visiblePanels[i]);
					}
				};
	
				$(window).on('scroll', documentScrollHandler);
			}
		}
	
		function bindWindowResizeHandler() {
			if (!windowResizeHandler) {
				var docElm = document.documentElement, clientWidth = docElm.clientWidth, clientHeight = docElm.clientHeight;
	
				windowResizeHandler = function() {
					// Workaround for #7065 IE 7 fires resize events event though the window wasn't resized
					if (!document.all || clientWidth != docElm.clientWidth || clientHeight != docElm.clientHeight) {
						clientWidth = docElm.clientWidth;
						clientHeight = docElm.clientHeight;
						FloatPanel.hideAll();
					}
				};
	
				$(window).on('resize', windowResizeHandler);
			}
		}
	
		/**
		 * Repositions the panel to the top of page if the panel is outside of the visual viewport. It will
		 * also reposition all child panels of the current panel.
		 */
		function repositionPanel(panel) {
			var scrollY = DomUtils.getViewPort().y;
	
			function toggleFixedChildPanels(fixed, deltaY) {
				var parent;
	
				for (var i = 0; i < visiblePanels.length; i++) {
					if (visiblePanels[i] != panel) {
						parent = visiblePanels[i].parent();
	
						while (parent && (parent = parent.parent())) {
							if (parent == panel) {
								visiblePanels[i].fixed(fixed).moveBy(0, deltaY).repaint();
							}
						}
					}
				}
			}
	
			if (panel.settings.autofix) {
				if (!panel.state.get('fixed')) {
					panel._autoFixY = panel.layoutRect().y;
	
					if (panel._autoFixY < scrollY) {
						panel.fixed(true).layoutRect({y: 0}).repaint();
						toggleFixedChildPanels(true, scrollY - panel._autoFixY);
					}
				} else {
					if (panel._autoFixY > scrollY) {
						panel.fixed(false).layoutRect({y: panel._autoFixY}).repaint();
						toggleFixedChildPanels(false, panel._autoFixY - scrollY);
					}
				}
			}
		}
	
		function addRemove(add, ctrl) {
			var i, zIndex = FloatPanel.zIndex || 0xFFFF, topModal;
	
			if (add) {
				zOrder.push(ctrl);
			} else {
				i = zOrder.length;
	
				while (i--) {
					if (zOrder[i] === ctrl) {
						zOrder.splice(i, 1);
					}
				}
			}
	
			if (zOrder.length) {
				for (i = 0; i < zOrder.length; i++) {
					if (zOrder[i].modal) {
						zIndex++;
						topModal = zOrder[i];
					}
	
					zOrder[i].getEl().style.zIndex = zIndex;
					zOrder[i].zIndex = zIndex;
					zIndex++;
				}
			}
	
			var modalBlockEl = $('#' + ctrl.classPrefix + 'modal-block', ctrl.getContainerElm())[0];
	
			if (topModal) {
				$(modalBlockEl).css('z-index', topModal.zIndex - 1);
			} else if (modalBlockEl) {
				modalBlockEl.parentNode.removeChild(modalBlockEl);
				hasModal = false;
			}
	
			FloatPanel.currentZIndex = zIndex;
		}
	
		var FloatPanel = Panel.extend({
			Mixins: [Movable, Resizable],
	
			/**
			 * Constructs a new control instance with the specified settings.
			 *
			 * @constructor
			 * @param {Object} settings Name/value object with settings.
			 * @setting {Boolean} autohide Automatically hide the panel.
			 */
			init: function(settings) {
				var self = this;
	
				self._super(settings);
				self._eventsRoot = self;
	
				self.classes.add('floatpanel');
	
				// Hide floatpanes on click out side the root button
				if (settings.autohide) {
					bindDocumentClickHandler();
					bindWindowResizeHandler();
					visiblePanels.push(self);
				}
	
				if (settings.autofix) {
					bindDocumentScrollHandler();
	
					self.on('move', function() {
						repositionPanel(this);
					});
				}
	
				self.on('postrender show', function(e) {
					if (e.control == self) {
						var $modalBlockEl, prefix = self.classPrefix;
	
						if (self.modal && !hasModal) {
							$modalBlockEl = $('#' + prefix + 'modal-block', self.getContainerElm());
							if (!$modalBlockEl[0]) {
								$modalBlockEl = $(
									'<div id="' + prefix + 'modal-block" class="' + prefix + 'reset ' + prefix + 'fade"></div>'
								).appendTo(self.getContainerElm());
							}
	
							Delay.setTimeout(function() {
								$modalBlockEl.addClass(prefix + 'in');
								$(self.getEl()).addClass(prefix + 'in');
							});
	
							hasModal = true;
						}
	
						addRemove(true, self);
					}
				});
	
				self.on('show', function() {
					self.parents().each(function(ctrl) {
						if (ctrl.state.get('fixed')) {
							self.fixed(true);
							return false;
						}
					});
				});
	
				if (settings.popover) {
					self._preBodyHtml = '<div class="' + self.classPrefix + 'arrow"></div>';
					self.classes.add('popover').add('bottom').add(self.isRtl() ? 'end' : 'start');
				}
	
				self.aria('label', settings.ariaLabel);
				self.aria('labelledby', self._id);
				self.aria('describedby', self.describedBy || self._id + '-none');
			},
	
			fixed: function(state) {
				var self = this;
	
				if (self.state.get('fixed') != state) {
					if (self.state.get('rendered')) {
						var viewport = DomUtils.getViewPort();
	
						if (state) {
							self.layoutRect().y -= viewport.y;
						} else {
							self.layoutRect().y += viewport.y;
						}
					}
	
					self.classes.toggle('fixed', state);
					self.state.set('fixed', state);
				}
	
				return self;
			},
	
			/**
			 * Shows the current float panel.
			 *
			 * @method show
			 * @return {tinymce.ui.FloatPanel} Current floatpanel instance.
			 */
			show: function() {
				var self = this, i, state = self._super();
	
				i = visiblePanels.length;
				while (i--) {
					if (visiblePanels[i] === self) {
						break;
					}
				}
	
				if (i === -1) {
					visiblePanels.push(self);
				}
	
				return state;
			},
	
			/**
			 * Hides the current float panel.
			 *
			 * @method hide
			 * @return {tinymce.ui.FloatPanel} Current floatpanel instance.
			 */
			hide: function() {
				removeVisiblePanel(this);
				addRemove(false, this);
	
				return this._super();
			},
	
			/**
			 * Hide all visible float panels with he autohide setting enabled. This is for
			 * manually hiding floating menus or panels.
			 *
			 * @method hideAll
			 */
			hideAll: function() {
				FloatPanel.hideAll();
			},
	
			/**
			 * Closes the float panel. This will remove the float panel from page and fire the close event.
			 *
			 * @method close
			 */
			close: function() {
				var self = this;
	
				if (!self.fire('close').isDefaultPrevented()) {
					self.remove();
					addRemove(false, self);
				}
	
				return self;
			},
	
			/**
			 * Removes the float panel from page.
			 *
			 * @method remove
			 */
			remove: function() {
				removeVisiblePanel(this);
				this._super();
			},
	
			postRender: function() {
				var self = this;
	
				if (self.settings.bodyRole) {
					this.getEl('body').setAttribute('role', self.settings.bodyRole);
				}
	
				return self._super();
			}
		});
	
		/**
		 * Hide all visible float panels with he autohide setting enabled. This is for
		 * manually hiding floating menus or panels.
		 *
		 * @static
		 * @method hideAll
		 */
		FloatPanel.hideAll = function() {
			var i = visiblePanels.length;
	
			while (i--) {
				var panel = visiblePanels[i];
	
				if (panel && panel.settings.autohide) {
					panel.hide();
					visiblePanels.splice(i, 1);
				}
			}
		};
	
		function removeVisiblePanel(panel) {
			var i;
	
			i = visiblePanels.length;
			while (i--) {
				if (visiblePanels[i] === panel) {
					visiblePanels.splice(i, 1);
				}
			}
	
			i = zOrder.length;
			while (i--) {
				if (zOrder[i] === panel) {
					zOrder.splice(i, 1);
				}
			}
		}
	
		return FloatPanel;
	});
	
	// Included from: js/tinymce/classes/ui/Window.js
	
	/**
	 * Window.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Creates a new window.
	 *
	 * @-x-less Window.less
	 * @class tinymce.ui.Window
	 * @extends tinymce.ui.FloatPanel
	 */
	define("tinymce/ui/Window", [
		"tinymce/ui/FloatPanel",
		"tinymce/ui/Panel",
		"tinymce/ui/DomUtils",
		"tinymce/dom/DomQuery",
		"tinymce/ui/DragHelper",
		"tinymce/ui/BoxUtils",
		"tinymce/Env",
		"tinymce/util/Delay"
	], function(FloatPanel, Panel, DomUtils, $, DragHelper, BoxUtils, Env, Delay) {
		"use strict";
	
		var windows = [], oldMetaValue = '';
	
		function toggleFullScreenState(state) {
			var noScaleMetaValue = 'width=device-width,initial-scale=1.0,user-scalable=0,minimum-scale=1.0,maximum-scale=1.0',
				viewport = $("meta[name=viewport]")[0],
				contentValue;
	
			if (Env.overrideViewPort === false) {
				return;
			}
	
			if (!viewport) {
				viewport = document.createElement('meta');
				viewport.setAttribute('name', 'viewport');
				document.getElementsByTagName('head')[0].appendChild(viewport);
			}
	
			contentValue = viewport.getAttribute('content');
			if (contentValue && typeof oldMetaValue != 'undefined') {
				oldMetaValue = contentValue;
			}
	
			viewport.setAttribute('content', state ? noScaleMetaValue : oldMetaValue);
		}
	
		function toggleBodyFullScreenClasses(classPrefix, state) {
			if (checkFullscreenWindows() && state === false) {
				$([document.documentElement, document.body]).removeClass(classPrefix + 'fullscreen');
			}
		}
	
		function checkFullscreenWindows() {
			for (var i = 0; i < windows.length; i++) {
				if (windows[i]._fullscreen) {
					return true;
				}
			}
			return false;
		}
	
		function handleWindowResize() {
			if (!Env.desktop) {
				var lastSize = {
					w: window.innerWidth,
					h: window.innerHeight
				};
	
				Delay.setInterval(function() {
					var w = window.innerWidth,
						h = window.innerHeight;
	
					if (lastSize.w != w || lastSize.h != h) {
						lastSize = {
							w: w,
							h: h
						};
	
						$(window).trigger('resize');
					}
				}, 100);
			}
	
			function reposition() {
				var i, rect = DomUtils.getWindowSize(), layoutRect;
	
				for (i = 0; i < windows.length; i++) {
					layoutRect = windows[i].layoutRect();
	
					windows[i].moveTo(
						windows[i].settings.x || Math.max(0, rect.w / 2 - layoutRect.w / 2),
						windows[i].settings.y || Math.max(0, rect.h / 2 - layoutRect.h / 2)
					);
				}
			}
	
			$(window).on('resize', reposition);
		}
	
		var Window = FloatPanel.extend({
			modal: true,
	
			Defaults: {
				border: 1,
				layout: 'flex',
				containerCls: 'panel',
				role: 'dialog',
				callbacks: {
					submit: function() {
						this.fire('submit', {data: this.toJSON()});
					},
	
					close: function() {
						this.close();
					}
				}
			},
	
			/**
			 * Constructs a instance with the specified settings.
			 *
			 * @constructor
			 * @param {Object} settings Name/value object with settings.
			 */
			init: function(settings) {
				var self = this;
	
				self._super(settings);
	
				if (self.isRtl()) {
					self.classes.add('rtl');
				}
	
				self.classes.add('window');
				self.bodyClasses.add('window-body');
				self.state.set('fixed', true);
	
				// Create statusbar
				if (settings.buttons) {
					self.statusbar = new Panel({
						layout: 'flex',
						border: '1 0 0 0',
						spacing: 3,
						padding: 10,
						align: 'center',
						pack: self.isRtl() ? 'start' : 'end',
						defaults: {
							type: 'button'
						},
						items: settings.buttons
					});
	
					self.statusbar.classes.add('foot');
					self.statusbar.parent(self);
				}
	
				self.on('click', function(e) {
					var closeClass = self.classPrefix + 'close';
	
					if (DomUtils.hasClass(e.target, closeClass) || DomUtils.hasClass(e.target.parentNode, closeClass)) {
						self.close();
					}
				});
	
				self.on('cancel', function() {
					self.close();
				});
	
				self.aria('describedby', self.describedBy || self._id + '-none');
				self.aria('label', settings.title);
				self._fullscreen = false;
			},
	
			/**
			 * Recalculates the positions of the controls in the current container.
			 * This is invoked by the reflow method and shouldn't be called directly.
			 *
			 * @method recalc
			 */
			recalc: function() {
				var self = this, statusbar = self.statusbar, layoutRect, width, x, needsRecalc;
	
				if (self._fullscreen) {
					self.layoutRect(DomUtils.getWindowSize());
					self.layoutRect().contentH = self.layoutRect().innerH;
				}
	
				self._super();
	
				layoutRect = self.layoutRect();
	
				// Resize window based on title width
				if (self.settings.title && !self._fullscreen) {
					width = layoutRect.headerW;
					if (width > layoutRect.w) {
						x = layoutRect.x - Math.max(0, width / 2);
						self.layoutRect({w: width, x: x});
						needsRecalc = true;
					}
				}
	
				// Resize window based on statusbar width
				if (statusbar) {
					statusbar.layoutRect({w: self.layoutRect().innerW}).recalc();
	
					width = statusbar.layoutRect().minW + layoutRect.deltaW;
					if (width > layoutRect.w) {
						x = layoutRect.x - Math.max(0, width - layoutRect.w);
						self.layoutRect({w: width, x: x});
						needsRecalc = true;
					}
				}
	
				// Recalc body and disable auto resize
				if (needsRecalc) {
					self.recalc();
				}
			},
	
			/**
			 * Initializes the current controls layout rect.
			 * This will be executed by the layout managers to determine the
			 * default minWidth/minHeight etc.
			 *
			 * @method initLayoutRect
			 * @return {Object} Layout rect instance.
			 */
			initLayoutRect: function() {
				var self = this, layoutRect = self._super(), deltaH = 0, headEl;
	
				// Reserve vertical space for title
				if (self.settings.title && !self._fullscreen) {
					headEl = self.getEl('head');
	
					var size = DomUtils.getSize(headEl);
	
					layoutRect.headerW = size.width;
					layoutRect.headerH = size.height;
	
					deltaH += layoutRect.headerH;
				}
	
				// Reserve vertical space for statusbar
				if (self.statusbar) {
					deltaH += self.statusbar.layoutRect().h;
				}
	
				layoutRect.deltaH += deltaH;
				layoutRect.minH += deltaH;
				//layoutRect.innerH -= deltaH;
				layoutRect.h += deltaH;
	
				var rect = DomUtils.getWindowSize();
	
				layoutRect.x = self.settings.x || Math.max(0, rect.w / 2 - layoutRect.w / 2);
				layoutRect.y = self.settings.y || Math.max(0, rect.h / 2 - layoutRect.h / 2);
	
				return layoutRect;
			},
	
			/**
			 * Renders the control as a HTML string.
			 *
			 * @method renderHtml
			 * @return {String} HTML representing the control.
			 */
			renderHtml: function() {
				var self = this, layout = self._layout, id = self._id, prefix = self.classPrefix;
				var settings = self.settings, headerHtml = '', footerHtml = '', html = settings.html;
	
				self.preRender();
				layout.preRender(self);
	
				if (settings.title) {
					headerHtml = (
						'<div id="' + id + '-head" class="' + prefix + 'window-head">' +
							'<div id="' + id + '-title" class="' + prefix + 'title">' + self.encode(settings.title) + '</div>' +
							'<div id="' + id + '-dragh" class="' + prefix + 'dragh"></div>' +
							'<button type="button" class="' + prefix + 'close" aria-hidden="true">' +
								'<i class="mce-ico mce-i-remove"></i>' +
							'</button>' +
						'</div>'
					);
				}
	
				if (settings.url) {
					html = '<iframe src="' + settings.url + '" tabindex="-1"></iframe>';
				}
	
				if (typeof html == "undefined") {
					html = layout.renderHtml(self);
				}
	
				if (self.statusbar) {
					footerHtml = self.statusbar.renderHtml();
				}
	
				return (
					'<div id="' + id + '" class="' + self.classes + '" hidefocus="1">' +
						'<div class="' + self.classPrefix + 'reset" role="application">' +
							headerHtml +
							'<div id="' + id + '-body" class="' + self.bodyClasses + '">' +
								html +
							'</div>' +
							footerHtml +
						'</div>' +
					'</div>'
				);
			},
	
			/**
			 * Switches the window fullscreen mode.
			 *
			 * @method fullscreen
			 * @param {Boolean} state True/false state.
			 * @return {tinymce.ui.Window} Current window instance.
			 */
			fullscreen: function(state) {
				var self = this, documentElement = document.documentElement, slowRendering, prefix = self.classPrefix, layoutRect;
	
				if (state != self._fullscreen) {
					$(window).on('resize', function() {
						var time;
	
						if (self._fullscreen) {
							// Time the layout time if it's to slow use a timeout to not hog the CPU
							if (!slowRendering) {
								time = new Date().getTime();
	
								var rect = DomUtils.getWindowSize();
								self.moveTo(0, 0).resizeTo(rect.w, rect.h);
	
								if ((new Date().getTime()) - time > 50) {
									slowRendering = true;
								}
							} else {
								if (!self._timer) {
									self._timer = Delay.setTimeout(function() {
										var rect = DomUtils.getWindowSize();
										self.moveTo(0, 0).resizeTo(rect.w, rect.h);
	
										self._timer = 0;
									}, 50);
								}
							}
						}
					});
	
					layoutRect = self.layoutRect();
					self._fullscreen = state;
	
					if (!state) {
						self.borderBox = BoxUtils.parseBox(self.settings.border);
						self.getEl('head').style.display = '';
						layoutRect.deltaH += layoutRect.headerH;
						$([documentElement, document.body]).removeClass(prefix + 'fullscreen');
						self.classes.remove('fullscreen');
						self.moveTo(self._initial.x, self._initial.y).resizeTo(self._initial.w, self._initial.h);
					} else {
						self._initial = {x: layoutRect.x, y: layoutRect.y, w: layoutRect.w, h: layoutRect.h};
	
						self.borderBox = BoxUtils.parseBox('0');
						self.getEl('head').style.display = 'none';
						layoutRect.deltaH -= layoutRect.headerH + 2;
						$([documentElement, document.body]).addClass(prefix + 'fullscreen');
						self.classes.add('fullscreen');
	
						var rect = DomUtils.getWindowSize();
						self.moveTo(0, 0).resizeTo(rect.w, rect.h);
					}
				}
	
				return self.reflow();
			},
	
			/**
			 * Called after the control has been rendered.
			 *
			 * @method postRender
			 */
			postRender: function() {
				var self = this, startPos;
	
				setTimeout(function() {
					self.classes.add('in');
					self.fire('open');
				}, 0);
	
				self._super();
	
				if (self.statusbar) {
					self.statusbar.postRender();
				}
	
				self.focus();
	
				this.dragHelper = new DragHelper(self._id + '-dragh', {
					start: function() {
						startPos = {
							x: self.layoutRect().x,
							y: self.layoutRect().y
						};
					},
	
					drag: function(e) {
						self.moveTo(startPos.x + e.deltaX, startPos.y + e.deltaY);
					}
				});
	
				self.on('submit', function(e) {
					if (!e.isDefaultPrevented()) {
						self.close();
					}
				});
	
				windows.push(self);
				toggleFullScreenState(true);
			},
	
			/**
			 * Fires a submit event with the serialized form.
			 *
			 * @method submit
			 * @return {Object} Event arguments object.
			 */
			submit: function() {
				return this.fire('submit', {data: this.toJSON()});
			},
	
			/**
			 * Removes the current control from DOM and from UI collections.
			 *
			 * @method remove
			 * @return {tinymce.ui.Control} Current control instance.
			 */
			remove: function() {
				var self = this, i;
	
				self.dragHelper.destroy();
				self._super();
	
				if (self.statusbar) {
					this.statusbar.remove();
				}
	
				toggleBodyFullScreenClasses(self.classPrefix, false);
	
				i = windows.length;
				while (i--) {
					if (windows[i] === self) {
						windows.splice(i, 1);
					}
				}
	
				toggleFullScreenState(windows.length > 0);
			},
	
			/**
			 * Returns the contentWindow object of the iframe if it exists.
			 *
			 * @method getContentWindow
			 * @return {Window} window object or null.
			 */
			getContentWindow: function() {
				var ifr = this.getEl().getElementsByTagName('iframe')[0];
				return ifr ? ifr.contentWindow : null;
			}
		});
	
		handleWindowResize();
	
		return Window;
	});
	
	// Included from: js/tinymce/classes/ui/MessageBox.js
	
	/**
	 * MessageBox.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This class is used to create MessageBoxes like alerts/confirms etc.
	 *
	 * @class tinymce.ui.MessageBox
	 * @extends tinymce.ui.FloatPanel
	 */
	define("tinymce/ui/MessageBox", [
		"tinymce/ui/Window"
	], function(Window) {
		"use strict";
	
		var MessageBox = Window.extend({
			/**
			 * Constructs a instance with the specified settings.
			 *
			 * @constructor
			 * @param {Object} settings Name/value object with settings.
			 */
			init: function(settings) {
				settings = {
					border: 1,
					padding: 20,
					layout: 'flex',
					pack: "center",
					align: "center",
					containerCls: 'panel',
					autoScroll: true,
					buttons: {type: "button", text: "Ok", action: "ok"},
					items: {
						type: "label",
						multiline: true,
						maxWidth: 500,
						maxHeight: 200
					}
				};
	
				this._super(settings);
			},
	
			Statics: {
				/**
				 * Ok buttons constant.
				 *
				 * @static
				 * @final
				 * @field {Number} OK
				 */
				OK: 1,
	
				/**
				 * Ok/cancel buttons constant.
				 *
				 * @static
				 * @final
				 * @field {Number} OK_CANCEL
				 */
				OK_CANCEL: 2,
	
				/**
				 * yes/no buttons constant.
				 *
				 * @static
				 * @final
				 * @field {Number} YES_NO
				 */
				YES_NO: 3,
	
				/**
				 * yes/no/cancel buttons constant.
				 *
				 * @static
				 * @final
				 * @field {Number} YES_NO_CANCEL
				 */
				YES_NO_CANCEL: 4,
	
				/**
				 * Constructs a new message box and renders it to the body element.
				 *
				 * @static
				 * @method msgBox
				 * @param {Object} settings Name/value object with settings.
				 */
				msgBox: function(settings) {
					var buttons, callback = settings.callback || function() {};
	
					function createButton(text, status, primary) {
						return {
							type: "button",
							text: text,
							subtype: primary ? 'primary' : '',
							onClick: function(e) {
								e.control.parents()[1].close();
								callback(status);
							}
						};
					}
	
					switch (settings.buttons) {
						case MessageBox.OK_CANCEL:
							buttons = [
								createButton('Ok', true, true),
								createButton('Cancel', false)
							];
							break;
	
						case MessageBox.YES_NO:
						case MessageBox.YES_NO_CANCEL:
							buttons = [
								createButton('Yes', 1, true),
								createButton('No', 0)
							];
	
							if (settings.buttons == MessageBox.YES_NO_CANCEL) {
								buttons.push(createButton('Cancel', -1));
							}
							break;
	
						default:
							buttons = [
								createButton('Ok', true, true)
							];
							break;
					}
	
					return new Window({
						padding: 20,
						x: settings.x,
						y: settings.y,
						minWidth: 300,
						minHeight: 100,
						layout: "flex",
						pack: "center",
						align: "center",
						buttons: buttons,
						title: settings.title,
						role: 'alertdialog',
						items: {
							type: "label",
							multiline: true,
							maxWidth: 500,
							maxHeight: 200,
							text: settings.text
						},
						onPostRender: function() {
							this.aria('describedby', this.items()[0]._id);
						},
						onClose: settings.onClose,
						onCancel: function() {
							callback(false);
						}
					}).renderTo(document.body).reflow();
				},
	
				/**
				 * Creates a new alert dialog.
				 *
				 * @method alert
				 * @param {Object} settings Settings for the alert dialog.
				 * @param {function} [callback] Callback to execute when the user makes a choice.
				 */
				alert: function(settings, callback) {
					if (typeof settings == "string") {
						settings = {text: settings};
					}
	
					settings.callback = callback;
					return MessageBox.msgBox(settings);
				},
	
				/**
				 * Creates a new confirm dialog.
				 *
				 * @method confirm
				 * @param {Object} settings Settings for the confirm dialog.
				 * @param {function} [callback] Callback to execute when the user makes a choice.
				 */
				confirm: function(settings, callback) {
					if (typeof settings == "string") {
						settings = {text: settings};
					}
	
					settings.callback = callback;
					settings.buttons = MessageBox.OK_CANCEL;
	
					return MessageBox.msgBox(settings);
				}
			}
		});
	
		return MessageBox;
	});
	
	// Included from: js/tinymce/classes/WindowManager.js
	
	/**
	 * WindowManager.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This class handles the creation of native windows and dialogs. This class can be extended to provide for example inline dialogs.
	 *
	 * @class tinymce.WindowManager
	 * @example
	 * // Opens a new dialog with the file.htm file and the size 320x240
	 * // It also adds a custom parameter this can be retrieved by using tinyMCEPopup.getWindowArg inside the dialog.
	 * tinymce.activeEditor.windowManager.open({
	 *    url: 'file.htm',
	 *    width: 320,
	 *    height: 240
	 * }, {
	 *    custom_param: 1
	 * });
	 *
	 * // Displays an alert box using the active editors window manager instance
	 * tinymce.activeEditor.windowManager.alert('Hello world!');
	 *
	 * // Displays an confirm box and an alert message will be displayed depending on what you choose in the confirm
	 * tinymce.activeEditor.windowManager.confirm("Do you want to do something", function(s) {
	 *    if (s)
	 *       tinymce.activeEditor.windowManager.alert("Ok");
	 *    else
	 *       tinymce.activeEditor.windowManager.alert("Cancel");
	 * });
	 */
	define("tinymce/WindowManager", [
		"tinymce/ui/Window",
		"tinymce/ui/MessageBox"
	], function(Window, MessageBox) {
		return function(editor) {
			var self = this, windows = [];
	
			function getTopMostWindow() {
				if (windows.length) {
					return windows[windows.length - 1];
				}
			}
	
			function fireOpenEvent(win) {
				editor.fire('OpenWindow', {
					win: win
				});
			}
	
			function fireCloseEvent(win) {
				editor.fire('CloseWindow', {
					win: win
				});
			}
	
			self.windows = windows;
	
			editor.on('remove', function() {
				var i = windows.length;
	
				while (i--) {
					windows[i].close();
				}
			});
	
			/**
			 * Opens a new window.
			 *
			 * @method open
			 * @param {Object} args Optional name/value settings collection contains things like width/height/url etc.
			 * @param {Object} params Options like title, file, width, height etc.
			 * @option {String} title Window title.
			 * @option {String} file URL of the file to open in the window.
			 * @option {Number} width Width in pixels.
			 * @option {Number} height Height in pixels.
			 * @option {Boolean} autoScroll Specifies whether the popup window can have scrollbars if required (i.e. content
			 * larger than the popup size specified).
			 */
			self.open = function(args, params) {
				var win;
	
				editor.editorManager.setActive(editor);
	
				args.title = args.title || ' ';
	
				// Handle URL
				args.url = args.url || args.file; // Legacy
				if (args.url) {
					args.width = parseInt(args.width || 320, 10);
					args.height = parseInt(args.height || 240, 10);
				}
	
				// Handle body
				if (args.body) {
					args.items = {
						defaults: args.defaults,
						type: args.bodyType || 'form',
						items: args.body,
						data: args.data,
						callbacks: args.commands
					};
				}
	
				if (!args.url && !args.buttons) {
					args.buttons = [
						{text: 'Ok', subtype: 'primary', onclick: function() {
							win.find('form')[0].submit();
						}},
	
						{text: 'Cancel', onclick: function() {
							win.close();
						}}
					];
				}
	
				win = new Window(args);
				windows.push(win);
	
				win.on('close', function() {
					var i = windows.length;
	
					while (i--) {
						if (windows[i] === win) {
							windows.splice(i, 1);
						}
					}
	
					if (!windows.length) {
						editor.focus();
					}
	
					fireCloseEvent(win);
				});
	
				// Handle data
				if (args.data) {
					win.on('postRender', function() {
						this.find('*').each(function(ctrl) {
							var name = ctrl.name();
	
							if (name in args.data) {
								ctrl.value(args.data[name]);
							}
						});
					});
				}
	
				// store args and parameters
				win.features = args || {};
				win.params = params || {};
	
				// Takes a snapshot in the FocusManager of the selection before focus is lost to dialog
				if (windows.length === 1) {
					editor.nodeChanged();
				}
	
				win = win.renderTo().reflow();
	
				fireOpenEvent(win);
	
				return win;
			};
	
			/**
			 * Creates a alert dialog. Please don't use the blocking behavior of this
			 * native version use the callback method instead then it can be extended.
			 *
			 * @method alert
			 * @param {String} message Text to display in the new alert dialog.
			 * @param {function} callback Callback function to be executed after the user has selected ok.
			 * @param {Object} scope Optional scope to execute the callback in.
			 * @example
			 * // Displays an alert box using the active editors window manager instance
			 * tinymce.activeEditor.windowManager.alert('Hello world!');
			 */
			self.alert = function(message, callback, scope) {
				var win;
	
				win = MessageBox.alert(message, function() {
					if (callback) {
						callback.call(scope || this);
					} else {
						editor.focus();
					}
				});
	
				win.on('close', function() {
					fireCloseEvent(win);
				});
	
				fireOpenEvent(win);
			};
	
			/**
			 * Creates a confirm dialog. Please don't use the blocking behavior of this
			 * native version use the callback method instead then it can be extended.
			 *
			 * @method confirm
			 * @param {String} message Text to display in the new confirm dialog.
			 * @param {function} callback Callback function to be executed after the user has selected ok or cancel.
			 * @param {Object} scope Optional scope to execute the callback in.
			 * @example
			 * // Displays an confirm box and an alert message will be displayed depending on what you choose in the confirm
			 * tinymce.activeEditor.windowManager.confirm("Do you want to do something", function(s) {
			 *    if (s)
			 *       tinymce.activeEditor.windowManager.alert("Ok");
			 *    else
			 *       tinymce.activeEditor.windowManager.alert("Cancel");
			 * });
			 */
			self.confirm = function(message, callback, scope) {
				var win;
	
				win = MessageBox.confirm(message, function(state) {
					callback.call(scope || this, state);
				});
	
				win.on('close', function() {
					fireCloseEvent(win);
				});
	
				fireOpenEvent(win);
			};
	
			/**
			 * Closes the top most window.
			 *
			 * @method close
			 */
			self.close = function() {
				if (getTopMostWindow()) {
					getTopMostWindow().close();
				}
			};
	
			/**
			 * Returns the params of the last window open call. This can be used in iframe based
			 * dialog to get params passed from the tinymce plugin.
			 *
			 * @example
			 * var dialogArguments = top.tinymce.activeEditor.windowManager.getParams();
			 *
			 * @method getParams
			 * @return {Object} Name/value object with parameters passed from windowManager.open call.
			 */
			self.getParams = function() {
				return getTopMostWindow() ? getTopMostWindow().params : null;
			};
	
			/**
			 * Sets the params of the last opened window.
			 *
			 * @method setParams
			 * @param {Object} params Params object to set for the last opened window.
			 */
			self.setParams = function(params) {
				if (getTopMostWindow()) {
					getTopMostWindow().params = params;
				}
			};
	
			/**
			 * Returns the currently opened window objects.
			 *
			 * @method getWindows
			 * @return {Array} Array of the currently opened windows.
			 */
			self.getWindows = function() {
				return windows;
			};
		};
	});
	
	// Included from: js/tinymce/classes/ui/Tooltip.js
	
	/**
	 * Tooltip.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Creates a tooltip instance.
	 *
	 * @-x-less ToolTip.less
	 * @class tinymce.ui.ToolTip
	 * @extends tinymce.ui.Control
	 * @mixes tinymce.ui.Movable
	 */
	define("tinymce/ui/Tooltip", [
		"tinymce/ui/Control",
		"tinymce/ui/Movable"
	], function(Control, Movable) {
		return Control.extend({
			Mixins: [Movable],
	
			Defaults: {
				classes: 'widget tooltip tooltip-n'
			},
	
			/**
			 * Renders the control as a HTML string.
			 *
			 * @method renderHtml
			 * @return {String} HTML representing the control.
			 */
			renderHtml: function() {
				var self = this, prefix = self.classPrefix;
	
				return (
					'<div id="' + self._id + '" class="' + self.classes + '" role="presentation">' +
						'<div class="' + prefix + 'tooltip-arrow"></div>' +
						'<div class="' + prefix + 'tooltip-inner">' + self.encode(self.state.get('text')) + '</div>' +
					'</div>'
				);
			},
	
			bindStates: function() {
				var self = this;
	
				self.state.on('change:text', function(e) {
					self.getEl().lastChild.innerHTML = self.encode(e.value);
				});
	
				return self._super();
			},
	
			/**
			 * Repaints the control after a layout operation.
			 *
			 * @method repaint
			 */
			repaint: function() {
				var self = this, style, rect;
	
				style = self.getEl().style;
				rect = self._layoutRect;
	
				style.left = rect.x + 'px';
				style.top = rect.y + 'px';
				style.zIndex = 0xFFFF + 0xFFFF;
			}
		});
	});
	
	// Included from: js/tinymce/classes/ui/Widget.js
	
	/**
	 * Widget.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Widget base class a widget is a control that has a tooltip and some basic states.
	 *
	 * @class tinymce.ui.Widget
	 * @extends tinymce.ui.Control
	 */
	define("tinymce/ui/Widget", [
		"tinymce/ui/Control",
		"tinymce/ui/Tooltip"
	], function(Control, Tooltip) {
		"use strict";
	
		var tooltip;
	
		var Widget = Control.extend({
			/**
			 * Constructs a instance with the specified settings.
			 *
			 * @constructor
			 * @param {Object} settings Name/value object with settings.
			 * @setting {String} tooltip Tooltip text to display when hovering.
			 * @setting {Boolean} autofocus True if the control should be focused when rendered.
			 * @setting {String} text Text to display inside widget.
			 */
			init: function(settings) {
				var self = this;
	
				self._super(settings);
				settings = self.settings;
				self.canFocus = true;
	
				if (settings.tooltip && Widget.tooltips !== false) {
					self.on('mouseenter', function(e) {
						var tooltip = self.tooltip().moveTo(-0xFFFF);
	
						if (e.control == self) {
							var rel = tooltip.text(settings.tooltip).show().testMoveRel(self.getEl(), ['bc-tc', 'bc-tl', 'bc-tr']);
	
							tooltip.classes.toggle('tooltip-n', rel == 'bc-tc');
							tooltip.classes.toggle('tooltip-nw', rel == 'bc-tl');
							tooltip.classes.toggle('tooltip-ne', rel == 'bc-tr');
	
							tooltip.moveRel(self.getEl(), rel);
						} else {
							tooltip.hide();
						}
					});
	
					self.on('mouseleave mousedown click', function() {
						self.tooltip().hide();
					});
				}
	
				self.aria('label', settings.ariaLabel || settings.tooltip);
			},
	
			/**
			 * Returns the current tooltip instance.
			 *
			 * @method tooltip
			 * @return {tinymce.ui.Tooltip} Tooltip instance.
			 */
			tooltip: function() {
				if (!tooltip) {
					tooltip = new Tooltip({type: 'tooltip'});
					tooltip.renderTo();
				}
	
				return tooltip;
			},
	
			/**
			 * Called after the control has been rendered.
			 *
			 * @method postRender
			 */
			postRender: function() {
				var self = this, settings = self.settings;
	
				self._super();
	
				if (!self.parent() && (settings.width || settings.height)) {
					self.initLayoutRect();
					self.repaint();
				}
	
				if (settings.autofocus) {
					self.focus();
				}
			},
	
			bindStates: function() {
				var self = this;
	
				function disable(state) {
					self.aria('disabled', state);
					self.classes.toggle('disabled', state);
				}
	
				function active(state) {
					self.aria('pressed', state);
					self.classes.toggle('active', state);
				}
	
				self.state.on('change:disabled', function(e) {
					disable(e.value);
				});
	
				self.state.on('change:active', function(e) {
					active(e.value);
				});
	
				if (self.state.get('disabled')) {
					disable(true);
				}
	
				if (self.state.get('active')) {
					active(true);
				}
	
				return self._super();
			},
	
			/**
			 * Removes the current control from DOM and from UI collections.
			 *
			 * @method remove
			 * @return {tinymce.ui.Control} Current control instance.
			 */
			remove: function() {
				this._super();
	
				if (tooltip) {
					tooltip.remove();
					tooltip = null;
				}
			}
		});
	
		return Widget;
	});
	
	// Included from: js/tinymce/classes/ui/Progress.js
	
	/**
	 * Progress.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Progress control.
	 *
	 * @-x-less Progress.less
	 * @class tinymce.ui.Progress
	 * @extends tinymce.ui.Control
	 */
	define("tinymce/ui/Progress", [
		"tinymce/ui/Widget"
	], function(Widget) {
		"use strict";
	
		return Widget.extend({
			Defaults: {
				value: 0
			},
	
			init: function(settings) {
				var self = this;
	
				self._super(settings);
				self.classes.add('progress');
	
				if (!self.settings.filter) {
					self.settings.filter = function(value) {
						return Math.round(value);
					};
				}
			},
	
			renderHtml: function() {
				var self = this, id = self._id, prefix = this.classPrefix;
	
				return (
					'<div id="' + id + '" class="' + self.classes + '">' +
						'<div class="' + prefix + 'bar-container">' +
							'<div class="' + prefix + 'bar"></div>' +
						'</div>' +
						'<div class="' + prefix + 'text">0%</div>' +
					'</div>'
				);
			},
	
			postRender: function() {
				var self = this;
	
				self._super();
				self.value(self.settings.value);
	
				return self;
			},
	
			bindStates: function() {
				var self = this;
	
				function setValue(value) {
					value = self.settings.filter(value);
					self.getEl().lastChild.innerHTML = value + '%';
					self.getEl().firstChild.firstChild.style.width = value + '%';
				}
	
				self.state.on('change:value', function(e) {
					setValue(e.value);
				});
	
				setValue(self.state.get('value'));
	
				return self._super();
			}
		});
	});
	
	// Included from: js/tinymce/classes/ui/Notification.js
	
	/**
	 * Notification.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Creates a notification instance.
	 *
	 * @-x-less Notification.less
	 * @class tinymce.ui.Notification
	 * @extends tinymce.ui.Container
	 * @mixes tinymce.ui.Movable
	 */
	define("tinymce/ui/Notification", [
		"tinymce/ui/Control",
		"tinymce/ui/Movable",
		"tinymce/ui/Progress",
		"tinymce/util/Delay"
	], function(Control, Movable, Progress, Delay) {
		return Control.extend({
			Mixins: [Movable],
	
			Defaults: {
				classes: 'widget notification'
			},
	
			init: function(settings) {
				var self = this;
	
				self._super(settings);
	
				if (settings.text) {
					self.text(settings.text);
				}
	
				if (settings.icon) {
					self.icon = settings.icon;
				}
	
				if (settings.color) {
					self.color = settings.color;
				}
	
				if (settings.type) {
					self.classes.add('notification-' + settings.type);
				}
	
				if (settings.timeout && (settings.timeout < 0 || settings.timeout > 0) && !settings.closeButton) {
					self.closeButton = false;
				} else {
					self.classes.add('has-close');
					self.closeButton = true;
				}
	
				if (settings.progressBar) {
					self.progressBar = new Progress();
				}
	
				self.on('click', function(e) {
					if (e.target.className.indexOf(self.classPrefix + 'close') != -1) {
						self.close();
					}
				});
			},
	
			/**
			 * Renders the control as a HTML string.
			 *
			 * @method renderHtml
			 * @return {String} HTML representing the control.
			 */
			renderHtml: function() {
				var self = this, prefix = self.classPrefix, icon = '', closeButton = '', progressBar = '', notificationStyle = '';
	
				if (self.icon) {
					icon = '<i class="' + prefix + 'ico' + ' ' + prefix + 'i-' + self.icon + '"></i>';
				}
	
				if (self.color) {
					notificationStyle = ' style="background-color: ' + self.color + '"';
				}
	
				if (self.closeButton) {
					closeButton = '<button type="button" class="' + prefix + 'close" aria-hidden="true">\u00d7</button>';
				}
	
				if (self.progressBar) {
					progressBar = self.progressBar.renderHtml();
				}
	
				return (
					'<div id="' + self._id + '" class="' + self.classes + '"' + notificationStyle + ' role="presentation">' +
						icon +
						'<div class="' + prefix + 'notification-inner">' + self.state.get('text') + '</div>' +
						progressBar +
						closeButton +
					'</div>'
				);
			},
	
			postRender: function() {
				var self = this;
	
				Delay.setTimeout(function() {
					self.$el.addClass(self.classPrefix + 'in');
				});
	
				return self._super();
			},
	
			bindStates: function() {
				var self = this;
	
				self.state.on('change:text', function(e) {
					self.getEl().childNodes[1].innerHTML = e.value;
				});
				if (self.progressBar) {
					self.progressBar.bindStates();
				}
				return self._super();
			},
	
			close: function() {
				var self = this;
	
				if (!self.fire('close').isDefaultPrevented()) {
					self.remove();
				}
	
				return self;
			},
	
			/**
			 * Repaints the control after a layout operation.
			 *
			 * @method repaint
			 */
			repaint: function() {
				var self = this, style, rect;
	
				style = self.getEl().style;
				rect = self._layoutRect;
	
				style.left = rect.x + 'px';
				style.top = rect.y + 'px';
	
				// Hardcoded arbitrary z-value because we want the
				// notifications under the other windows
				style.zIndex = 0xFFFF - 1;
			}
		});
	});
	
	// Included from: js/tinymce/classes/NotificationManager.js
	
	/**
	 * NotificationManager.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This class handles the creation of TinyMCE's notifications.
	 *
	 * @class tinymce.notificationManager
	 * @example
	 * // Opens a new notification of type "error" with text "An error occurred."
	 * tinymce.activeEditor.notificationManager.open({
	 *    text: 'An error occurred.',
	 *    type: 'error'
	 * });
	 */
	define("tinymce/NotificationManager", [
		"tinymce/ui/Notification",
		"tinymce/util/Delay",
		"tinymce/util/Tools"
	], function(Notification, Delay, Tools) {
		return function(editor) {
			var self = this, notifications = [];
	
			function getLastNotification() {
				if (notifications.length) {
					return notifications[notifications.length - 1];
				}
			}
	
			self.notifications = notifications;
	
			function resizeWindowEvent() {
				Delay.requestAnimationFrame(function() {
					prePositionNotifications();
					positionNotifications();
				});
			}
	
			// Since the viewport will change based on the present notifications, we need to move them all to the
			// top left of the viewport to give an accurate size measurement so we can position them later.
			function prePositionNotifications() {
				for (var i = 0; i < notifications.length; i++) {
					notifications[i].moveTo(0, 0);
				}
			}
	
			function positionNotifications() {
				if (notifications.length > 0) {
					var firstItem = notifications.slice(0, 1)[0];
					var container = editor.inline ? editor.getElement() : editor.getContentAreaContainer();
					firstItem.moveRel(container, 'tc-tc');
					if (notifications.length > 1) {
						for (var i = 1; i < notifications.length; i++) {
							notifications[i].moveRel(notifications[i - 1].getEl(), 'bc-tc');
						}
					}
				}
			}
	
			editor.on('remove', function() {
				var i = notifications.length;
	
				while (i--) {
					notifications[i].close();
				}
			});
	
			editor.on('ResizeEditor', positionNotifications);
			editor.on('ResizeWindow', resizeWindowEvent);
	
			/**
			 * Opens a new notification.
			 *
			 * @method open
			 * @param {Object} args Optional name/value settings collection contains things like timeout/color/message etc.
			 */
			self.open = function(args) {
				// Never open notification if editor has been removed.
				if (editor.removed) {
					return;
				}
	
				var notif;
	
				editor.editorManager.setActive(editor);
	
				var duplicate = findDuplicateMessage(notifications, args);
	
				if (duplicate === null) {
					notif = new Notification(args);
					notifications.push(notif);
	
					//If we have a timeout value
					if (args.timeout > 0) {
							notif.timer = setTimeout(function() {
								notif.close();
							}, args.timeout);
					}
	
					notif.on('close', function() {
						var i = notifications.length;
	
						if (notif.timer) {
							editor.getWin().clearTimeout(notif.timer);
						}
	
						while (i--) {
							if (notifications[i] === notif) {
								notifications.splice(i, 1);
							}
						}
	
						positionNotifications();
					});
	
					notif.renderTo();
	
					positionNotifications();
				} else {
					notif = duplicate;
				}
	
				return notif;
			};
	
			/**
			 * Closes the top most notification.
			 *
			 * @method close
			 */
			self.close = function() {
				if (getLastNotification()) {
					getLastNotification().close();
				}
			};
	
			/**
			 * Returns the currently opened notification objects.
			 *
			 * @method getNotifications
			 * @return {Array} Array of the currently opened notifications.
			 */
			self.getNotifications = function() {
				return notifications;
			};
	
			editor.on('SkinLoaded', function() {
				var serviceMessage = editor.settings.service_message;
	
				if (serviceMessage) {
					editor.notificationManager.open({
						text: serviceMessage,
						type: 'warning',
						timeout: 0,
						icon: ''
					});
				}
			});
	
			/**
			 * Finds any existing notification with the same properties as the new one.
			 * Returns either the found notification or null.
			 *
			 * @param {Notification[]} notificationArray - Array of current notifications
			 * @param {type: string, } newNotification - New notification object
			 * @returns {?Notification}
			 */
			function findDuplicateMessage(notificationArray, newNotification) {
				if (!isPlainTextNotification(newNotification)) {
					return null;
				}
	
				var filteredNotifications = Tools.grep(notificationArray, function (notification) {
					return isSameNotification(newNotification, notification);
				});
	
				return filteredNotifications.length === 0 ? null : filteredNotifications[0];
			}
	
			/**
			 * Checks if the passed in args object has the same
			 * type and text properties as the sent in notification.
			 *
			 * @param {type: string, text: string} a - New notification args object
			 * @param {Notification} b - Old notification
			 * @returns {boolean}
			 */
			function isSameNotification(a, b) {
				return a.type === b.settings.type && a.text === b.settings.text;
			}
	
			/**
			 * Checks that the notification does not have a progressBar
			 * or timeour property.
			 *
			 * @param {Notification} notification - Notification to check
			 * @returns {boolean}
			 */
			function isPlainTextNotification(notification) {
				return !notification.progressBar && !notification.timeout;
			}
	
			//self.positionNotifications = positionNotifications;
		};
	});
	
	// Included from: js/tinymce/classes/dom/NodePath.js
	
	/**
	 * NodePath.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Handles paths of nodes within an element.
	 *
	 * @private
	 * @class tinymce.dom.NodePath
	 */
	define("tinymce/dom/NodePath", [
		"tinymce/dom/DOMUtils"
	], function(DOMUtils) {
		function create(rootNode, targetNode, normalized) {
			var path = [];
	
			for (; targetNode && targetNode != rootNode; targetNode = targetNode.parentNode) {
				path.push(DOMUtils.nodeIndex(targetNode, normalized));
			}
	
			return path;
		}
	
		function resolve(rootNode, path) {
			var i, node, children;
	
			for (node = rootNode, i = path.length - 1; i >= 0; i--) {
				children = node.childNodes;
	
				if (path[i] > children.length - 1) {
					return null;
				}
	
				node = children[path[i]];
			}
	
			return node;
		}
	
		return {
			create: create,
			resolve: resolve
		};
	});
	
	// Included from: js/tinymce/classes/util/Quirks.js
	
	/**
	 * Quirks.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 *
	 * @ignore-file
	 */
	
	/**
	 * This file includes fixes for various browser quirks it's made to make it easy to add/remove browser specific fixes.
	 *
	 * @private
	 * @class tinymce.util.Quirks
	 */
	define("tinymce/util/Quirks", [
		"tinymce/util/VK",
		"tinymce/dom/RangeUtils",
		"tinymce/dom/TreeWalker",
		"tinymce/dom/NodePath",
		"tinymce/html/Node",
		"tinymce/html/Entities",
		"tinymce/Env",
		"tinymce/util/Tools",
		"tinymce/util/Delay",
		"tinymce/caret/CaretContainer",
		"tinymce/caret/CaretPosition",
		"tinymce/caret/CaretWalker"
	], function(VK, RangeUtils, TreeWalker, NodePath, Node, Entities, Env, Tools, Delay, CaretContainer, CaretPosition, CaretWalker) {
		return function(editor) {
			var each = Tools.each, $ = editor.$;
			var BACKSPACE = VK.BACKSPACE, DELETE = VK.DELETE, dom = editor.dom, selection = editor.selection,
				settings = editor.settings, parser = editor.parser, serializer = editor.serializer;
			var isGecko = Env.gecko, isIE = Env.ie, isWebKit = Env.webkit;
			var mceInternalUrlPrefix = 'data:text/mce-internal,';
			var mceInternalDataType = isIE ? 'Text' : 'URL';
	
			/**
			 * Executes a command with a specific state this can be to enable/disable browser editing features.
			 */
			function setEditorCommandState(cmd, state) {
				try {
					editor.getDoc().execCommand(cmd, false, state);
				} catch (ex) {
					// Ignore
				}
			}
	
			/**
			 * Returns current IE document mode.
			 */
			function getDocumentMode() {
				var documentMode = editor.getDoc().documentMode;
	
				return documentMode ? documentMode : 6;
			}
	
			/**
			 * Returns true/false if the event is prevented or not.
			 *
			 * @private
			 * @param {Event} e Event object.
			 * @return {Boolean} true/false if the event is prevented or not.
			 */
			function isDefaultPrevented(e) {
				return e.isDefaultPrevented();
			}
	
			/**
			 * Sets Text/URL data on the event's dataTransfer object to a special data:text/mce-internal url.
			 * This is to workaround the inability to set custom contentType on IE and Safari.
			 * The editor's selected content is encoded into this url so drag and drop between editors will work.
			 *
			 * @private
			 * @param {DragEvent} e Event object
			 */
			function setMceInternalContent(e) {
				var selectionHtml, internalContent;
	
				if (e.dataTransfer) {
					if (editor.selection.isCollapsed() && e.target.tagName == 'IMG') {
						selection.select(e.target);
					}
	
					selectionHtml = editor.selection.getContent();
	
					// Safari/IE doesn't support custom dataTransfer items so we can only use URL and Text
					if (selectionHtml.length > 0) {
						internalContent = mceInternalUrlPrefix + escape(editor.id) + ',' + escape(selectionHtml);
						e.dataTransfer.setData(mceInternalDataType, internalContent);
					}
				}
			}
	
			/**
			 * Gets content of special data:text/mce-internal url on the event's dataTransfer object.
			 * This is to workaround the inability to set custom contentType on IE and Safari.
			 * The editor's selected content is encoded into this url so drag and drop between editors will work.
			 *
			 * @private
			 * @param {DragEvent} e Event object
			 * @returns {String} mce-internal content
			 */
			function getMceInternalContent(e) {
				var internalContent;
	
				if (e.dataTransfer) {
					internalContent = e.dataTransfer.getData(mceInternalDataType);
	
					if (internalContent && internalContent.indexOf(mceInternalUrlPrefix) >= 0) {
						internalContent = internalContent.substr(mceInternalUrlPrefix.length).split(',');
	
						return {
							id: unescape(internalContent[0]),
							html: unescape(internalContent[1])
						};
					}
				}
	
				return null;
			}
	
			/**
			 * Inserts contents using the paste clipboard command if it's available if it isn't it will fallback
			 * to the core command.
			 *
			 * @private
			 * @param {String} content Content to insert at selection.
			 */
			function insertClipboardContents(content) {
				if (editor.queryCommandSupported('mceInsertClipboardContent')) {
					editor.execCommand('mceInsertClipboardContent', false, {content: content});
				} else {
					editor.execCommand('mceInsertContent', false, content);
				}
			}
	
			/**
			 * Fixes a WebKit bug when deleting contents using backspace or delete key.
			 * WebKit will produce a span element if you delete across two block elements.
			 *
			 * Example:
			 * <h1>a</h1><p>|b</p>
			 *
			 * Will produce this on backspace:
			 * <h1>a<span style="<all runtime styles>">b</span></p>
			 *
			 * This fixes the backspace to produce:
			 * <h1>a|b</p>
			 *
			 * See bug: https://bugs.webkit.org/show_bug.cgi?id=45784
			 *
			 * This fixes the following delete scenarios:
			 *  1. Delete by pressing backspace key.
			 *  2. Delete by pressing delete key.
			 *  3. Delete by pressing backspace key with ctrl/cmd (Word delete).
			 *  4. Delete by pressing delete key with ctrl/cmd (Word delete).
			 *  5. Delete by drag/dropping contents inside the editor.
			 *  6. Delete by using Cut Ctrl+X/Cmd+X.
			 *  7. Delete by selecting contents and writing a character.
			 *
			 * This code is a ugly hack since writing full custom delete logic for just this bug
			 * fix seemed like a huge task. I hope we can remove this before the year 2030.
			 */
			function cleanupStylesWhenDeleting() {
				var doc = editor.getDoc(), dom = editor.dom, selection = editor.selection;
				var MutationObserver = window.MutationObserver, olderWebKit, dragStartRng;
	
				// Add mini polyfill for older WebKits
				// TODO: Remove this when old Safari versions gets updated
				if (!MutationObserver) {
					olderWebKit = true;
	
					MutationObserver = function() {
						var records = [], target;
	
						function nodeInsert(e) {
							var target = e.relatedNode || e.target;
							records.push({target: target, addedNodes: [target]});
						}
	
						function attrModified(e) {
							var target = e.relatedNode || e.target;
							records.push({target: target, attributeName: e.attrName});
						}
	
						this.observe = function(node) {
							target = node;
							target.addEventListener('DOMSubtreeModified', nodeInsert, false);
							target.addEventListener('DOMNodeInsertedIntoDocument', nodeInsert, false);
							target.addEventListener('DOMNodeInserted', nodeInsert, false);
							target.addEventListener('DOMAttrModified', attrModified, false);
						};
	
						this.disconnect = function() {
							target.removeEventListener('DOMSubtreeModified', nodeInsert, false);
							target.removeEventListener('DOMNodeInsertedIntoDocument', nodeInsert, false);
							target.removeEventListener('DOMNodeInserted', nodeInsert, false);
							target.removeEventListener('DOMAttrModified', attrModified, false);
						};
	
						this.takeRecords = function() {
							return records;
						};
					};
				}
	
				function isTrailingBr(node) {
					var blockElements = dom.schema.getBlockElements(), rootNode = editor.getBody();
	
					if (node.nodeName != 'BR') {
						return false;
					}
	
					for (; node != rootNode && !blockElements[node.nodeName]; node = node.parentNode) {
						if (node.nextSibling) {
							return false;
						}
					}
	
					return true;
				}
	
				function isSiblingsIgnoreWhiteSpace(node1, node2) {
					var node;
	
					for (node = node1.nextSibling; node && node != node2; node = node.nextSibling) {
						if (node.nodeType == 3 && $.trim(node.data).length === 0) {
							continue;
						}
	
						if (node !== node2) {
							return false;
						}
					}
	
					return node === node2;
				}
	
				function findCaretNode(node, forward, startNode) {
					var walker, current, nonEmptyElements;
	
					// Protect against the possibility we are asked to find a caret node relative
					// to a node that is no longer in the DOM tree. In this case attempting to
					// select on any match leads to a scenario where selection is completely removed
					// from the editor. This scenario is met in real world at a minimum on
					// WebKit browsers when selecting all and Cmd-X cutting to delete content.
					if (!dom.isChildOf(node, editor.getBody())) {
						return;
					}
	
					nonEmptyElements = dom.schema.getNonEmptyElements();
	
					walker = new TreeWalker(startNode || node, node);
	
					while ((current = walker[forward ? 'next' : 'prev']())) {
						if (nonEmptyElements[current.nodeName] && !isTrailingBr(current)) {
							return current;
						}
	
						if (current.nodeType == 3 && current.data.length > 0) {
							return current;
						}
					}
				}
	
				function deleteRangeBetweenTextBlocks(rng) {
					var startBlock, endBlock, caretNodeBefore, caretNodeAfter, textBlockElements;
	
					if (rng.collapsed) {
						return;
					}
	
					startBlock = dom.getParent(RangeUtils.getNode(rng.startContainer, rng.startOffset), dom.isBlock);
					endBlock = dom.getParent(RangeUtils.getNode(rng.endContainer, rng.endOffset), dom.isBlock);
					textBlockElements = editor.schema.getTextBlockElements();
	
					if (startBlock == endBlock) {
						return;
					}
	
					if (!textBlockElements[startBlock.nodeName] || !textBlockElements[endBlock.nodeName]) {
						return;
					}
	
					if (dom.getContentEditable(startBlock) === "false" || dom.getContentEditable(endBlock) === "false") {
						return;
					}
	
					rng.deleteContents();
	
					caretNodeBefore = findCaretNode(startBlock, false);
					caretNodeAfter = findCaretNode(endBlock, true);
	
					if (!dom.isEmpty(endBlock)) {
						$(startBlock).append(endBlock.childNodes);
					}
	
					$(endBlock).remove();
	
					if (caretNodeBefore) {
						if (caretNodeBefore.nodeType == 1) {
							if (caretNodeBefore.nodeName == "BR") {
								rng.setStartBefore(caretNodeBefore);
								rng.setEndBefore(caretNodeBefore);
							} else {
								rng.setStartAfter(caretNodeBefore);
								rng.setEndAfter(caretNodeBefore);
							}
						} else {
							rng.setStart(caretNodeBefore, caretNodeBefore.data.length);
							rng.setEnd(caretNodeBefore, caretNodeBefore.data.length);
						}
					} else if (caretNodeAfter) {
						if (caretNodeAfter.nodeType == 1) {
							rng.setStartBefore(caretNodeAfter);
							rng.setEndBefore(caretNodeAfter);
						} else {
							rng.setStart(caretNodeAfter, 0);
							rng.setEnd(caretNodeAfter, 0);
						}
					}
	
					selection.setRng(rng);
	
					return true;
				}
	
				function expandBetweenBlocks(rng, isForward) {
					var caretNode, targetCaretNode, textBlock, targetTextBlock, container, offset;
	
					if (!rng.collapsed) {
						return rng;
					}
	
					container = rng.startContainer;
					offset = rng.startOffset;
	
					if (container.nodeType == 3) {
						if (isForward) {
							if (offset < container.data.length) {
								return rng;
							}
						} else {
							if (offset > 0) {
								return rng;
							}
						}
					}
	
					caretNode = RangeUtils.getNode(container, offset);
					textBlock = dom.getParent(caretNode, dom.isBlock);
					targetCaretNode = findCaretNode(editor.getBody(), isForward, caretNode);
					targetTextBlock = dom.getParent(targetCaretNode, dom.isBlock);
					var isAfter = container.nodeType === 1 && offset > container.childNodes.length - 1;
	
					if (!caretNode || !targetCaretNode) {
						return rng;
					}
	
					if (targetTextBlock && textBlock != targetTextBlock) {
						if (!isForward) {
							if (!isSiblingsIgnoreWhiteSpace(targetTextBlock, textBlock)) {
								return rng;
							}
	
							if (targetCaretNode.nodeType == 1) {
								if (targetCaretNode.nodeName == "BR") {
									rng.setStartBefore(targetCaretNode);
								} else {
									rng.setStartAfter(targetCaretNode);
								}
							} else {
								rng.setStart(targetCaretNode, targetCaretNode.data.length);
							}
	
							if (caretNode.nodeType == 1) {
								if (isAfter) {
									rng.setEndAfter(caretNode);
								} else {
									rng.setEndBefore(caretNode);
								}
							} else {
								rng.setEndBefore(caretNode);
							}
						} else {
							if (!isSiblingsIgnoreWhiteSpace(textBlock, targetTextBlock)) {
								return rng;
							}
	
							if (caretNode.nodeType == 1) {
								if (caretNode.nodeName == "BR") {
									rng.setStartBefore(caretNode);
								} else {
									rng.setStartAfter(caretNode);
								}
							} else {
								rng.setStart(caretNode, caretNode.data.length);
							}
	
							if (targetCaretNode.nodeType == 1) {
								rng.setEnd(targetCaretNode, 0);
							} else {
								rng.setEndBefore(targetCaretNode);
							}
						}
					}
	
					return rng;
				}
	
				function handleTextBlockMergeDelete(isForward) {
					var rng = selection.getRng();
	
					rng = expandBetweenBlocks(rng, isForward);
	
					if (deleteRangeBetweenTextBlocks(rng)) {
						return true;
					}
				}
	
				/**
				 * This retains the formatting if the last character is to be deleted.
				 *
				 * Backspace on this: <p><b><i>a|</i></b></p> would become <p>|</p> in WebKit.
				 * With this patch: <p><b><i>|<br></i></b></p>
				 */
				function handleLastBlockCharacterDelete(isForward, rng) {
					var path, blockElm, newBlockElm, clonedBlockElm, sibling,
						container, offset, br, currentFormatNodes;
	
					function cloneTextBlockWithFormats(blockElm, node) {
						currentFormatNodes = $(node).parents().filter(function(idx, node) {
							return !!editor.schema.getTextInlineElements()[node.nodeName];
						});
	
						newBlockElm = blockElm.cloneNode(false);
	
						currentFormatNodes = Tools.map(currentFormatNodes, function(formatNode) {
							formatNode = formatNode.cloneNode(false);
	
							if (newBlockElm.hasChildNodes()) {
								formatNode.appendChild(newBlockElm.firstChild);
								newBlockElm.appendChild(formatNode);
							} else {
								newBlockElm.appendChild(formatNode);
							}
	
							newBlockElm.appendChild(formatNode);
	
							return formatNode;
						});
	
						if (currentFormatNodes.length) {
							br = dom.create('br');
							currentFormatNodes[0].appendChild(br);
							dom.replace(newBlockElm, blockElm);
	
							rng.setStartBefore(br);
							rng.setEndBefore(br);
							editor.selection.setRng(rng);
	
							return br;
						}
	
						return null;
					}
	
					function isTextBlock(node) {
						return node && editor.schema.getTextBlockElements()[node.tagName];
					}
	
					if (!rng.collapsed) {
						return;
					}
	
					container = rng.startContainer;
					offset = rng.startOffset;
					blockElm = dom.getParent(container, dom.isBlock);
					if (!isTextBlock(blockElm)) {
						return;
					}
	
					if (container.nodeType == 1) {
						container = container.childNodes[offset];
						if (container && container.tagName != 'BR') {
							return;
						}
	
						if (isForward) {
							sibling = blockElm.nextSibling;
						} else {
							sibling = blockElm.previousSibling;
						}
	
						if (dom.isEmpty(blockElm) && isTextBlock(sibling) && dom.isEmpty(sibling)) {
							if (cloneTextBlockWithFormats(blockElm, container)) {
								dom.remove(sibling);
								return true;
							}
						}
					} else if (container.nodeType == 3) {
						path = NodePath.create(blockElm, container);
						clonedBlockElm = blockElm.cloneNode(true);
						container = NodePath.resolve(clonedBlockElm, path);
	
						if (isForward) {
							if (offset >= container.data.length) {
								return;
							}
	
							container.deleteData(offset, 1);
						} else {
							if (offset <= 0) {
								return;
							}
	
							container.deleteData(offset - 1, 1);
						}
	
						if (dom.isEmpty(clonedBlockElm)) {
							return cloneTextBlockWithFormats(blockElm, container);
						}
					}
				}
	
				function customDelete(isForward) {
					var mutationObserver, rng, caretElement;
	
					if (handleTextBlockMergeDelete(isForward)) {
						return;
					}
	
					Tools.each(editor.getBody().getElementsByTagName('*'), function(elm) {
						// Mark existing spans
						if (elm.tagName == 'SPAN') {
							elm.setAttribute('mce-data-marked', 1);
						}
	
						// Make sure all elements has a data-mce-style attribute
						if (!elm.hasAttribute('data-mce-style') && elm.hasAttribute('style')) {
							editor.dom.setAttrib(elm, 'style', editor.dom.getAttrib(elm, 'style'));
						}
					});
	
					// Observe added nodes and style attribute changes
					mutationObserver = new MutationObserver(function() {});
					mutationObserver.observe(editor.getDoc(), {
						childList: true,
						attributes: true,
						subtree: true,
						attributeFilter: ['style']
					});
	
					editor.getDoc().execCommand(isForward ? 'ForwardDelete' : 'Delete', false, null);
	
					rng = editor.selection.getRng();
					caretElement = rng.startContainer.parentNode;
	
					Tools.each(mutationObserver.takeRecords(), function(record) {
						if (!dom.isChildOf(record.target, editor.getBody())) {
							return;
						}
	
						// Restore style attribute to previous value
						if (record.attributeName == "style") {
							var oldValue = record.target.getAttribute('data-mce-style');
	
							if (oldValue) {
								record.target.setAttribute("style", oldValue);
							} else {
								record.target.removeAttribute("style");
							}
						}
	
						// Remove all spans that aren't marked and retain selection
						Tools.each(record.addedNodes, function(node) {
							if (node.nodeName == "SPAN" && !node.getAttribute('mce-data-marked')) {
								var offset, container;
	
								if (node == caretElement) {
									offset = rng.startOffset;
									container = node.firstChild;
								}
	
								dom.remove(node, true);
	
								if (container) {
									rng.setStart(container, offset);
									rng.setEnd(container, offset);
									editor.selection.setRng(rng);
								}
							}
						});
					});
	
					mutationObserver.disconnect();
	
					// Remove any left over marks
					Tools.each(editor.dom.select('span[mce-data-marked]'), function(span) {
						span.removeAttribute('mce-data-marked');
					});
				}
	
				function transactCustomDelete(isForward) {
					editor.undoManager.transact(function () {
						customDelete(isForward);
					});
				}
	
				editor.on('keydown', function(e) {
					var isForward = e.keyCode == DELETE, isMetaOrCtrl = e.ctrlKey || e.metaKey;
	
					if (!isDefaultPrevented(e) && (isForward || e.keyCode == BACKSPACE)) {
						var rng = editor.selection.getRng(), container = rng.startContainer, offset = rng.startOffset;
	
						// Shift+Delete is cut
						if (isForward && e.shiftKey) {
							return;
						}
	
						if (handleLastBlockCharacterDelete(isForward, rng)) {
							e.preventDefault();
							return;
						}
	
						// Ignore non meta delete in the where there is text before/after the caret
						if (!isMetaOrCtrl && rng.collapsed && container.nodeType == 3) {
							if (isForward ? offset < container.data.length : offset > 0) {
								return;
							}
						}
	
						e.preventDefault();
	
						if (isMetaOrCtrl) {
							editor.selection.getSel().modify("extend", isForward ? "forward" : "backward", e.metaKey ? "lineboundary" : "word");
						}
	
						customDelete(isForward);
					}
				});
	
				// Handle case where text is deleted by typing over
				editor.on('keypress', function(e) {
					if (!isDefaultPrevented(e) && !selection.isCollapsed() && e.charCode > 31 && !VK.metaKeyPressed(e)) {
						var rng, currentFormatNodes, fragmentNode, blockParent, caretNode, charText;
	
						rng = editor.selection.getRng();
						charText = String.fromCharCode(e.charCode);
						e.preventDefault();
	
						// Keep track of current format nodes
						currentFormatNodes = $(rng.startContainer).parents().filter(function(idx, node) {
							return !!editor.schema.getTextInlineElements()[node.nodeName];
						});
	
						customDelete(true);
	
						// Check if the browser removed them
						currentFormatNodes = currentFormatNodes.filter(function(idx, node) {
							return !$.contains(editor.getBody(), node);
						});
	
						// Then re-add them
						if (currentFormatNodes.length) {
							fragmentNode = dom.createFragment();
	
							currentFormatNodes.each(function(idx, formatNode) {
								formatNode = formatNode.cloneNode(false);
	
								if (fragmentNode.hasChildNodes()) {
									formatNode.appendChild(fragmentNode.firstChild);
									fragmentNode.appendChild(formatNode);
								} else {
									caretNode = formatNode;
									fragmentNode.appendChild(formatNode);
								}
	
								fragmentNode.appendChild(formatNode);
							});
	
							caretNode.appendChild(editor.getDoc().createTextNode(charText));
	
							// Prevent edge case where older WebKit would add an extra BR element
							blockParent = dom.getParent(rng.startContainer, dom.isBlock);
							if (dom.isEmpty(blockParent)) {
								$(blockParent).empty().append(fragmentNode);
							} else {
								rng.insertNode(fragmentNode);
							}
	
							rng.setStart(caretNode.firstChild, 1);
							rng.setEnd(caretNode.firstChild, 1);
							editor.selection.setRng(rng);
						} else {
							editor.selection.setContent(charText);
						}
					}
				});
	
				editor.addCommand('Delete', function() {
					customDelete();
				});
	
				editor.addCommand('ForwardDelete', function() {
					customDelete(true);
				});
	
				// Older WebKits doesn't properly handle the clipboard so we can't add the rest
				if (olderWebKit) {
					return;
				}
	
				editor.on('dragstart', function(e) {
					dragStartRng = selection.getRng();
					setMceInternalContent(e);
				});
	
				editor.on('drop', function(e) {
					if (!isDefaultPrevented(e)) {
						var internalContent = getMceInternalContent(e);
	
						if (internalContent) {
							e.preventDefault();
	
							// Safari has a weird issue where drag/dropping images sometimes
							// produces a green plus icon. When this happens the caretRangeFromPoint
							// will return "null" even though the x, y coordinate is correct.
							// But if we detach the insert from the drop event we will get a proper range
							Delay.setEditorTimeout(editor, function() {
								var pointRng = RangeUtils.getCaretRangeFromPoint(e.x, e.y, doc);
	
								if (dragStartRng) {
									selection.setRng(dragStartRng);
									dragStartRng = null;
									transactCustomDelete();
								}
	
								selection.setRng(pointRng);
								insertClipboardContents(internalContent.html);
							});
						}
					}
				});
	
				editor.on('cut', function(e) {
					if (!isDefaultPrevented(e) && e.clipboardData && !editor.selection.isCollapsed()) {
						e.preventDefault();
						e.clipboardData.clearData();
						e.clipboardData.setData('text/html', editor.selection.getContent());
						e.clipboardData.setData('text/plain', editor.selection.getContent({format: 'text'}));
	
						// Needed delay for https://code.google.com/p/chromium/issues/detail?id=363288#c3
						// Nested delete/forwardDelete not allowed on execCommand("cut")
						// This is ugly but not sure how to work around it otherwise
						Delay.setEditorTimeout(editor, function() {
							transactCustomDelete(true);
						});
					}
				});
			}
	
			/**
			 * Makes sure that the editor body becomes empty when backspace or delete is pressed in empty editors.
			 *
			 * For example:
			 * <p><b>|</b></p>
			 *
			 * Or:
			 * <h1>|</h1>
			 *
			 * Or:
			 * [<h1></h1>]
			 */
			function emptyEditorWhenDeleting() {
				function serializeRng(rng) {
					var body = dom.create("body");
					var contents = rng.cloneContents();
					body.appendChild(contents);
					return selection.serializer.serialize(body, {format: 'html'});
				}
	
				function allContentsSelected(rng) {
					if (!rng.setStart) {
						if (rng.item) {
							return false;
						}
	
						var bodyRng = rng.duplicate();
						bodyRng.moveToElementText(editor.getBody());
						return RangeUtils.compareRanges(rng, bodyRng);
					}
	
					var selection = serializeRng(rng);
	
					var allRng = dom.createRng();
					allRng.selectNode(editor.getBody());
	
					var allSelection = serializeRng(allRng);
					return selection === allSelection;
				}
	
				editor.on('keydown', function(e) {
					var keyCode = e.keyCode, isCollapsed, body;
	
					// Empty the editor if it's needed for example backspace at <p><b>|</b></p>
					if (!isDefaultPrevented(e) && (keyCode == DELETE || keyCode == BACKSPACE)) {
						isCollapsed = editor.selection.isCollapsed();
						body = editor.getBody();
	
						// Selection is collapsed but the editor isn't empty
						if (isCollapsed && !dom.isEmpty(body)) {
							return;
						}
	
						// Selection isn't collapsed but not all the contents is selected
						if (!isCollapsed && !allContentsSelected(editor.selection.getRng())) {
							return;
						}
	
						// Manually empty the editor
						e.preventDefault();
						editor.setContent('');
	
						if (body.firstChild && dom.isBlock(body.firstChild)) {
							editor.selection.setCursorLocation(body.firstChild, 0);
						} else {
							editor.selection.setCursorLocation(body, 0);
						}
	
						editor.nodeChanged();
					}
				});
			}
	
			/**
			 * WebKit doesn't select all the nodes in the body when you press Ctrl+A.
			 * IE selects more than the contents <body>[<p>a</p>]</body> instead of <body><p>[a]</p]</body> see bug #6438
			 * This selects the whole body so that backspace/delete logic will delete everything
			 */
			function selectAll() {
				editor.shortcuts.add('meta+a', null, 'SelectAll');
			}
	
			/**
			 * WebKit has a weird issue where it some times fails to properly convert keypresses to input method keystrokes.
			 * The IME on Mac doesn't initialize when it doesn't fire a proper focus event.
			 *
			 * This seems to happen when the user manages to click the documentElement element then the window doesn't get proper focus until
			 * you enter a character into the editor.
			 *
			 * It also happens when the first focus in made to the body.
			 *
			 * See: https://bugs.webkit.org/show_bug.cgi?id=83566
			 */
			function inputMethodFocus() {
				if (!editor.settings.content_editable) {
					// Case 1 IME doesn't initialize if you focus the document
					// Disabled since it was interferring with the cE=false logic
					// Also coultn't reproduce the issue on Safari 9
					/*dom.bind(editor.getDoc(), 'focusin', function() {
						selection.setRng(selection.getRng());
					});*/
	
					// Case 2 IME doesn't initialize if you click the documentElement it also doesn't properly fire the focusin event
					// Needs to be both down/up due to weird rendering bug on Chrome Windows
					dom.bind(editor.getDoc(), 'mousedown mouseup', function(e) {
						var rng;
	
						if (e.target == editor.getDoc().documentElement) {
							rng = selection.getRng();
							editor.getBody().focus();
	
							if (e.type == 'mousedown') {
								if (CaretContainer.isCaretContainer(rng.startContainer)) {
									return;
								}
	
								// Edge case for mousedown, drag select and mousedown again within selection on Chrome Windows to render caret
								selection.placeCaretAt(e.clientX, e.clientY);
							} else {
								selection.setRng(rng);
							}
						}
					});
				}
			}
	
			/**
			 * Backspacing in FireFox/IE from a paragraph into a horizontal rule results in a floating text node because the
			 * browser just deletes the paragraph - the browser fails to merge the text node with a horizontal rule so it is
			 * left there. TinyMCE sees a floating text node and wraps it in a paragraph on the key up event (ForceBlocks.js
			 * addRootBlocks), meaning the action does nothing. With this code, FireFox/IE matche the behaviour of other
			 * browsers.
			 *
			 * It also fixes a bug on Firefox where it's impossible to delete HR elements.
			 */
			function removeHrOnBackspace() {
				editor.on('keydown', function(e) {
					if (!isDefaultPrevented(e) && e.keyCode === BACKSPACE) {
						// Check if there is any HR elements this is faster since getRng on IE 7 & 8 is slow
						if (!editor.getBody().getElementsByTagName('hr').length) {
							return;
						}
	
						if (selection.isCollapsed() && selection.getRng(true).startOffset === 0) {
							var node = selection.getNode();
							var previousSibling = node.previousSibling;
	
							if (node.nodeName == 'HR') {
								dom.remove(node);
								e.preventDefault();
								return;
							}
	
							if (previousSibling && previousSibling.nodeName && previousSibling.nodeName.toLowerCase() === "hr") {
								dom.remove(previousSibling);
								e.preventDefault();
							}
						}
					}
				});
			}
	
			/**
			 * Firefox 3.x has an issue where the body element won't get proper focus if you click out
			 * side it's rectangle.
			 */
			function focusBody() {
				// Fix for a focus bug in FF 3.x where the body element
				// wouldn't get proper focus if the user clicked on the HTML element
				if (!window.Range.prototype.getClientRects) { // Detect getClientRects got introduced in FF 4
					editor.on('mousedown', function(e) {
						if (!isDefaultPrevented(e) && e.target.nodeName === "HTML") {
							var body = editor.getBody();
	
							// Blur the body it's focused but not correctly focused
							body.blur();
	
							// Refocus the body after a little while
							Delay.setEditorTimeout(editor, function() {
								body.focus();
							});
						}
					});
				}
			}
	
			/**
			 * WebKit has a bug where it isn't possible to select image, hr or anchor elements
			 * by clicking on them so we need to fake that.
			 */
			function selectControlElements() {
				editor.on('click', function(e) {
					var target = e.target;
	
					// Workaround for bug, http://bugs.webkit.org/show_bug.cgi?id=12250
					// WebKit can't even do simple things like selecting an image
					// Needs to be the setBaseAndExtend or it will fail to select floated images
					if (/^(IMG|HR)$/.test(target.nodeName) && dom.getContentEditableParent(target) !== "false") {
						e.preventDefault();
						selection.getSel().setBaseAndExtent(target, 0, target, 1);
						editor.nodeChanged();
					}
	
					if (target.nodeName == 'A' && dom.hasClass(target, 'mce-item-anchor')) {
						e.preventDefault();
						selection.select(target);
					}
				});
			}
	
			/**
			 * Fixes a Gecko bug where the style attribute gets added to the wrong element when deleting between two block elements.
			 *
			 * Fixes do backspace/delete on this:
			 * <p>bla[ck</p><p style="color:red">r]ed</p>
			 *
			 * Would become:
			 * <p>bla|ed</p>
			 *
			 * Instead of:
			 * <p style="color:red">bla|ed</p>
			 */
			function removeStylesWhenDeletingAcrossBlockElements() {
				function getAttributeApplyFunction() {
					var template = dom.getAttribs(selection.getStart().cloneNode(false));
	
					return function() {
						var target = selection.getStart();
	
						if (target !== editor.getBody()) {
							dom.setAttrib(target, "style", null);
	
							each(template, function(attr) {
								target.setAttributeNode(attr.cloneNode(true));
							});
						}
					};
				}
	
				function isSelectionAcrossElements() {
					return !selection.isCollapsed() &&
						dom.getParent(selection.getStart(), dom.isBlock) != dom.getParent(selection.getEnd(), dom.isBlock);
				}
	
				editor.on('keypress', function(e) {
					var applyAttributes;
	
					if (!isDefaultPrevented(e) && (e.keyCode == 8 || e.keyCode == 46) && isSelectionAcrossElements()) {
						applyAttributes = getAttributeApplyFunction();
						editor.getDoc().execCommand('delete', false, null);
						applyAttributes();
						e.preventDefault();
						return false;
					}
				});
	
				dom.bind(editor.getDoc(), 'cut', function(e) {
					var applyAttributes;
	
					if (!isDefaultPrevented(e) && isSelectionAcrossElements()) {
						applyAttributes = getAttributeApplyFunction();
	
						Delay.setEditorTimeout(editor, function() {
							applyAttributes();
						});
					}
				});
			}
	
			/**
			 * Screen readers on IE needs to have the role application set on the body.
			 */
			function ensureBodyHasRoleApplication() {
				document.body.setAttribute("role", "application");
			}
	
			/**
			 * Backspacing into a table behaves differently depending upon browser type.
			 * Therefore, disable Backspace when cursor immediately follows a table.
			 */
			function disableBackspaceIntoATable() {
				editor.on('keydown', function(e) {
					if (!isDefaultPrevented(e) && e.keyCode === BACKSPACE) {
						if (selection.isCollapsed() && selection.getRng(true).startOffset === 0) {
							var previousSibling = selection.getNode().previousSibling;
							if (previousSibling && previousSibling.nodeName && previousSibling.nodeName.toLowerCase() === "table") {
								e.preventDefault();
								return false;
							}
						}
					}
				});
			}
	
			/**
			 * Old IE versions can't properly render BR elements in PRE tags white in contentEditable mode. So this
			 * logic adds a \n before the BR so that it will get rendered.
			 */
			function addNewLinesBeforeBrInPre() {
				// IE8+ rendering mode does the right thing with BR in PRE
				if (getDocumentMode() > 7) {
					return;
				}
	
				// Enable display: none in area and add a specific class that hides all BR elements in PRE to
				// avoid the caret from getting stuck at the BR elements while pressing the right arrow key
				setEditorCommandState('RespectVisibilityInDesign', true);
				editor.contentStyles.push('.mceHideBrInPre pre br {display: none}');
				dom.addClass(editor.getBody(), 'mceHideBrInPre');
	
				// Adds a \n before all BR elements in PRE to get them visual
				parser.addNodeFilter('pre', function(nodes) {
					var i = nodes.length, brNodes, j, brElm, sibling;
	
					while (i--) {
						brNodes = nodes[i].getAll('br');
						j = brNodes.length;
						while (j--) {
							brElm = brNodes[j];
	
							// Add \n before BR in PRE elements on older IE:s so the new lines get rendered
							sibling = brElm.prev;
							if (sibling && sibling.type === 3 && sibling.value.charAt(sibling.value - 1) != '\n') {
								sibling.value += '\n';
							} else {
								brElm.parent.insert(new Node('#text', 3), brElm, true).value = '\n';
							}
						}
					}
				});
	
				// Removes any \n before BR elements in PRE since other browsers and in contentEditable=false mode they will be visible
				serializer.addNodeFilter('pre', function(nodes) {
					var i = nodes.length, brNodes, j, brElm, sibling;
	
					while (i--) {
						brNodes = nodes[i].getAll('br');
						j = brNodes.length;
						while (j--) {
							brElm = brNodes[j];
							sibling = brElm.prev;
							if (sibling && sibling.type == 3) {
								sibling.value = sibling.value.replace(/\r?\n$/, '');
							}
						}
					}
				});
			}
	
			/**
			 * Moves style width/height to attribute width/height when the user resizes an image on IE.
			 */
			function removePreSerializedStylesWhenSelectingControls() {
				dom.bind(editor.getBody(), 'mouseup', function() {
					var value, node = selection.getNode();
	
					// Moved styles to attributes on IMG eements
					if (node.nodeName == 'IMG') {
						// Convert style width to width attribute
						if ((value = dom.getStyle(node, 'width'))) {
							dom.setAttrib(node, 'width', value.replace(/[^0-9%]+/g, ''));
							dom.setStyle(node, 'width', '');
						}
	
						// Convert style height to height attribute
						if ((value = dom.getStyle(node, 'height'))) {
							dom.setAttrib(node, 'height', value.replace(/[^0-9%]+/g, ''));
							dom.setStyle(node, 'height', '');
						}
					}
				});
			}
	
			/**
			 * Removes a blockquote when backspace is pressed at the beginning of it.
			 *
			 * For example:
			 * <blockquote><p>|x</p></blockquote>
			 *
			 * Becomes:
			 * <p>|x</p>
			 */
			function removeBlockQuoteOnBackSpace() {
				// Add block quote deletion handler
				editor.on('keydown', function(e) {
					var rng, container, offset, root, parent;
	
					if (isDefaultPrevented(e) || e.keyCode != VK.BACKSPACE) {
						return;
					}
	
					rng = selection.getRng();
					container = rng.startContainer;
					offset = rng.startOffset;
					root = dom.getRoot();
					parent = container;
	
					if (!rng.collapsed || offset !== 0) {
						return;
					}
	
					while (parent && parent.parentNode && parent.parentNode.firstChild == parent && parent.parentNode != root) {
						parent = parent.parentNode;
					}
	
					// Is the cursor at the beginning of a blockquote?
					if (parent.tagName === 'BLOCKQUOTE') {
						// Remove the blockquote
						editor.formatter.toggle('blockquote', null, parent);
	
						// Move the caret to the beginning of container
						rng = dom.createRng();
						rng.setStart(container, 0);
						rng.setEnd(container, 0);
						selection.setRng(rng);
					}
				});
			}
	
			/**
			 * Sets various Gecko editing options on mouse down and before a execCommand to disable inline table editing that is broken etc.
			 */
			function setGeckoEditingOptions() {
				function setOpts() {
					refreshContentEditable();
	
					setEditorCommandState("StyleWithCSS", false);
					setEditorCommandState("enableInlineTableEditing", false);
	
					if (!settings.object_resizing) {
						setEditorCommandState("enableObjectResizing", false);
					}
				}
	
				if (!settings.readonly) {
					editor.on('BeforeExecCommand MouseDown', setOpts);
				}
			}
	
			/**
			 * Fixes a gecko link bug, when a link is placed at the end of block elements there is
			 * no way to move the caret behind the link. This fix adds a bogus br element after the link.
			 *
			 * For example this:
			 * <p><b><a href="#">x</a></b></p>
			 *
			 * Becomes this:
			 * <p><b><a href="#">x</a></b><br></p>
			 */
			function addBrAfterLastLinks() {
				function fixLinks() {
					each(dom.select('a'), function(node) {
						var parentNode = node.parentNode, root = dom.getRoot();
	
						if (parentNode.lastChild === node) {
							while (parentNode && !dom.isBlock(parentNode)) {
								if (parentNode.parentNode.lastChild !== parentNode || parentNode === root) {
									return;
								}
	
								parentNode = parentNode.parentNode;
							}
	
							dom.add(parentNode, 'br', {'data-mce-bogus': 1});
						}
					});
				}
	
				editor.on('SetContent ExecCommand', function(e) {
					if (e.type == "setcontent" || e.command === 'mceInsertLink') {
						fixLinks();
					}
				});
			}
	
			/**
			 * WebKit will produce DIV elements here and there by default. But since TinyMCE uses paragraphs by
			 * default we want to change that behavior.
			 */
			function setDefaultBlockType() {
				if (settings.forced_root_block) {
					editor.on('init', function() {
						setEditorCommandState('DefaultParagraphSeparator', settings.forced_root_block);
					});
				}
			}
	
			/**
			 * Deletes the selected image on IE instead of navigating to previous page.
			 */
			function deleteControlItemOnBackSpace() {
				editor.on('keydown', function(e) {
					var rng;
	
					if (!isDefaultPrevented(e) && e.keyCode == BACKSPACE) {
						rng = editor.getDoc().selection.createRange();
						if (rng && rng.item) {
							e.preventDefault();
							editor.undoManager.beforeChange();
							dom.remove(rng.item(0));
							editor.undoManager.add();
						}
					}
				});
			}
	
			/**
			 * IE10 doesn't properly render block elements with the right height until you add contents to them.
			 * This fixes that by adding a padding-right to all empty text block elements.
			 * See: https://connect.microsoft.com/IE/feedback/details/743881
			 */
			function renderEmptyBlocksFix() {
				var emptyBlocksCSS;
	
				// IE10+
				if (getDocumentMode() >= 10) {
					emptyBlocksCSS = '';
					each('p div h1 h2 h3 h4 h5 h6'.split(' '), function(name, i) {
						emptyBlocksCSS += (i > 0 ? ',' : '') + name + ':empty';
					});
	
					editor.contentStyles.push(emptyBlocksCSS + '{padding-right: 1px !important}');
				}
			}
	
			/**
			 * Old IE versions can't retain contents within noscript elements so this logic will store the contents
			 * as a attribute and the insert that value as it's raw text when the DOM is serialized.
			 */
			function keepNoScriptContents() {
				if (getDocumentMode() < 9) {
					parser.addNodeFilter('noscript', function(nodes) {
						var i = nodes.length, node, textNode;
	
						while (i--) {
							node = nodes[i];
							textNode = node.firstChild;
	
							if (textNode) {
								node.attr('data-mce-innertext', textNode.value);
							}
						}
					});
	
					serializer.addNodeFilter('noscript', function(nodes) {
						var i = nodes.length, node, textNode, value;
	
						while (i--) {
							node = nodes[i];
							textNode = nodes[i].firstChild;
	
							if (textNode) {
								textNode.value = Entities.decode(textNode.value);
							} else {
								// Old IE can't retain noscript value so an attribute is used to store it
								value = node.attributes.map['data-mce-innertext'];
								if (value) {
									node.attr('data-mce-innertext', null);
									textNode = new Node('#text', 3);
									textNode.value = value;
									textNode.raw = true;
									node.append(textNode);
								}
							}
						}
					});
				}
			}
	
			/**
			 * IE has an issue where you can't select/move the caret by clicking outside the body if the document is in standards mode.
			 */
			function fixCaretSelectionOfDocumentElementOnIe() {
				var doc = dom.doc, body = doc.body, started, startRng, htmlElm;
	
				// Return range from point or null if it failed
				function rngFromPoint(x, y) {
					var rng = body.createTextRange();
	
					try {
						rng.moveToPoint(x, y);
					} catch (ex) {
						// IE sometimes throws and exception, so lets just ignore it
						rng = null;
					}
	
					return rng;
				}
	
				// Fires while the selection is changing
				function selectionChange(e) {
					var pointRng;
	
					// Check if the button is down or not
					if (e.button) {
						// Create range from mouse position
						pointRng = rngFromPoint(e.x, e.y);
	
						if (pointRng) {
							// Check if pointRange is before/after selection then change the endPoint
							if (pointRng.compareEndPoints('StartToStart', startRng) > 0) {
								pointRng.setEndPoint('StartToStart', startRng);
							} else {
								pointRng.setEndPoint('EndToEnd', startRng);
							}
	
							pointRng.select();
						}
					} else {
						endSelection();
					}
				}
	
				// Removes listeners
				function endSelection() {
					var rng = doc.selection.createRange();
	
					// If the range is collapsed then use the last start range
					if (startRng && !rng.item && rng.compareEndPoints('StartToEnd', rng) === 0) {
						startRng.select();
					}
	
					dom.unbind(doc, 'mouseup', endSelection);
					dom.unbind(doc, 'mousemove', selectionChange);
					startRng = started = 0;
				}
	
				// Make HTML element unselectable since we are going to handle selection by hand
				doc.documentElement.unselectable = true;
	
				// Detect when user selects outside BODY
				dom.bind(doc, 'mousedown contextmenu', function(e) {
					if (e.target.nodeName === 'HTML') {
						if (started) {
							endSelection();
						}
	
						// Detect vertical scrollbar, since IE will fire a mousedown on the scrollbar and have target set as HTML
						htmlElm = doc.documentElement;
						if (htmlElm.scrollHeight > htmlElm.clientHeight) {
							return;
						}
	
						started = 1;
						// Setup start position
						startRng = rngFromPoint(e.x, e.y);
						if (startRng) {
							// Listen for selection change events
							dom.bind(doc, 'mouseup', endSelection);
							dom.bind(doc, 'mousemove', selectionChange);
	
							dom.getRoot().focus();
							startRng.select();
						}
					}
				});
			}
	
			/**
			 * Fixes selection issues where the caret can be placed between two inline elements like <b>a</b>|<b>b</b>
			 * this fix will lean the caret right into the closest inline element.
			 */
			function normalizeSelection() {
				// Normalize selection for example <b>a</b><i>|a</i> becomes <b>a|</b><i>a</i> except for Ctrl+A since it selects everything
				editor.on('keyup focusin mouseup', function(e) {
					if (e.keyCode != 65 || !VK.metaKeyPressed(e)) {
						selection.normalize();
					}
				}, true);
			}
	
			/**
			 * Forces Gecko to render a broken image icon if it fails to load an image.
			 */
			function showBrokenImageIcon() {
				editor.contentStyles.push(
					'img:-moz-broken {' +
						'-moz-force-broken-image-icon:1;' +
						'min-width:24px;' +
						'min-height:24px' +
					'}'
				);
			}
	
			/**
			 * iOS has a bug where it's impossible to type if the document has a touchstart event
			 * bound and the user touches the document while having the on screen keyboard visible.
			 *
			 * The touch event moves the focus to the parent document while having the caret inside the iframe
			 * this fix moves the focus back into the iframe document.
			 */
			function restoreFocusOnKeyDown() {
				if (!editor.inline) {
					editor.on('keydown', function() {
						if (document.activeElement == document.body) {
							editor.getWin().focus();
						}
					});
				}
			}
	
			/**
			 * IE 11 has an annoying issue where you can't move focus into the editor
			 * by clicking on the white area HTML element. We used to be able to to fix this with
			 * the fixCaretSelectionOfDocumentElementOnIe fix. But since M$ removed the selection
			 * object it's not possible anymore. So we need to hack in a ungly CSS to force the
			 * body to be at least 150px. If the user clicks the HTML element out side this 150px region
			 * we simply move the focus into the first paragraph. Not ideal since you loose the
			 * positioning of the caret but goot enough for most cases.
			 */
			function bodyHeight() {
				if (!editor.inline) {
					editor.contentStyles.push('body {min-height: 150px}');
					editor.on('click', function(e) {
						var rng;
	
						if (e.target.nodeName == 'HTML') {
							// Edge seems to only need focus if we set the range
							// the caret will become invisible and moved out of the iframe!!
							if (Env.ie > 11) {
								editor.getBody().focus();
								return;
							}
	
							// Need to store away non collapsed ranges since the focus call will mess that up see #7382
							rng = editor.selection.getRng();
							editor.getBody().focus();
							editor.selection.setRng(rng);
							editor.selection.normalize();
							editor.nodeChanged();
						}
					});
				}
			}
	
			/**
			 * Firefox on Mac OS will move the browser back to the previous page if you press CMD+Left arrow.
			 * You might then loose all your work so we need to block that behavior and replace it with our own.
			 */
			function blockCmdArrowNavigation() {
				if (Env.mac) {
					editor.on('keydown', function(e) {
						if (VK.metaKeyPressed(e) && !e.shiftKey && (e.keyCode == 37 || e.keyCode == 39)) {
							e.preventDefault();
							editor.selection.getSel().modify('move', e.keyCode == 37 ? 'backward' : 'forward', 'lineboundary');
						}
					});
				}
			}
	
			/**
			 * Disables the autolinking in IE 9+ this is then re-enabled by the autolink plugin.
			 */
			function disableAutoUrlDetect() {
				setEditorCommandState("AutoUrlDetect", false);
			}
	
			/**
			 * iOS 7.1 introduced two new bugs:
			 * 1) It's possible to open links within a contentEditable area by clicking on them.
			 * 2) If you hold down the finger it will display the link/image touch callout menu.
			 */
			function tapLinksAndImages() {
				editor.on('click', function(e) {
					var elm = e.target;
	
					do {
						if (elm.tagName === 'A') {
							e.preventDefault();
							return;
						}
					} while ((elm = elm.parentNode));
				});
	
				editor.contentStyles.push('.mce-content-body {-webkit-touch-callout: none}');
			}
	
			/**
			 * iOS Safari and possible other browsers have a bug where it won't fire
			 * a click event when a contentEditable is focused. This function fakes click events
			 * by using touchstart/touchend and measuring the time and distance travelled.
			 */
			/*
			function touchClickEvent() {
				editor.on('touchstart', function(e) {
					var elm, time, startTouch, changedTouches;
	
					elm = e.target;
					time = new Date().getTime();
					changedTouches = e.changedTouches;
	
					if (!changedTouches || changedTouches.length > 1) {
						return;
					}
	
					startTouch = changedTouches[0];
	
					editor.once('touchend', function(e) {
						var endTouch = e.changedTouches[0], args;
	
						if (new Date().getTime() - time > 500) {
							return;
						}
	
						if (Math.abs(startTouch.clientX - endTouch.clientX) > 5) {
							return;
						}
	
						if (Math.abs(startTouch.clientY - endTouch.clientY) > 5) {
							return;
						}
	
						args = {
							target: elm
						};
	
						each('pageX pageY clientX clientY screenX screenY'.split(' '), function(key) {
							args[key] = endTouch[key];
						});
	
						args = editor.fire('click', args);
	
						if (!args.isDefaultPrevented()) {
							// iOS WebKit can't place the caret properly once
							// you bind touch events so we need to do this manually
							// TODO: Expand to the closest word? Touble tap still works.
							editor.selection.placeCaretAt(endTouch.clientX, endTouch.clientY);
							editor.nodeChanged();
						}
					});
				});
			}
			*/
	
			/**
			 * WebKit has a bug where it will allow forms to be submitted if they are inside a contentEditable element.
			 * For example this: <form><button></form>
			 */
			function blockFormSubmitInsideEditor() {
				editor.on('init', function() {
					editor.dom.bind(editor.getBody(), 'submit', function(e) {
						e.preventDefault();
					});
				});
			}
	
			/**
			 * Sometimes WebKit/Blink generates BR elements with the Apple-interchange-newline class.
			 *
			 * Scenario:
			 *  1) Create a table 2x2.
			 *  2) Select and copy cells A2-B2.
			 *  3) Paste and it will add BR element to table cell.
			 */
			function removeAppleInterchangeBrs() {
				parser.addNodeFilter('br', function(nodes) {
					var i = nodes.length;
	
					while (i--) {
						if (nodes[i].attr('class') == 'Apple-interchange-newline') {
							nodes[i].remove();
						}
					}
				});
			}
	
			/**
			 * IE cannot set custom contentType's on drag events, and also does not properly drag/drop between
			 * editors. This uses a special data:text/mce-internal URL to pass data when drag/drop between editors.
			 */
			function ieInternalDragAndDrop() {
				editor.on('dragstart', function(e) {
					setMceInternalContent(e);
				});
	
				editor.on('drop', function(e) {
					if (!isDefaultPrevented(e)) {
						var internalContent = getMceInternalContent(e);
	
						if (internalContent && internalContent.id != editor.id) {
							e.preventDefault();
	
							var rng = RangeUtils.getCaretRangeFromPoint(e.x, e.y, editor.getDoc());
							selection.setRng(rng);
							insertClipboardContents(internalContent.html);
						}
					}
				});
			}
	
			function refreshContentEditable() {
				// No-op since Mozilla seems to have fixed the caret repaint issues
			}
	
			function isHidden() {
				var sel;
	
				if (!isGecko) {
					return 0;
				}
	
				// Weird, wheres that cursor selection?
				sel = editor.selection.getSel();
				return (!sel || !sel.rangeCount || sel.rangeCount === 0);
			}
	
			/**
			 * Properly empties the editor if all contents is selected and deleted this to
			 * prevent empty paragraphs from being produced at beginning/end of contents.
			 */
			function emptyEditorOnDeleteEverything() {
				function isEverythingSelected(editor) {
					var caretWalker = new CaretWalker(editor.getBody());
					var rng = editor.selection.getRng();
					var startCaretPos = CaretPosition.fromRangeStart(rng);
					var endCaretPos = CaretPosition.fromRangeEnd(rng);
	
					return !editor.selection.isCollapsed() && !caretWalker.prev(startCaretPos) && !caretWalker.next(endCaretPos);
				}
	
				// Type over case delete and insert this won't cover typeover with a IME but at least it covers the common case
				editor.on('keypress', function (e) {
					if (!isDefaultPrevented(e) && !selection.isCollapsed() && e.charCode > 31 && !VK.metaKeyPressed(e)) {
						if (isEverythingSelected(editor)) {
							e.preventDefault();
							editor.setContent(String.fromCharCode(e.charCode));
							editor.selection.select(editor.getBody(), true);
							editor.selection.collapse(false);
							editor.nodeChanged();
						}
					}
				});
	
				editor.on('keydown', function (e) {
					var keyCode = e.keyCode;
	
					if (!isDefaultPrevented(e) && (keyCode == DELETE || keyCode == BACKSPACE)) {
						if (isEverythingSelected(editor)) {
							e.preventDefault();
							editor.setContent('');
							editor.nodeChanged();
						}
					}
				});
			}
	
			// All browsers
			removeBlockQuoteOnBackSpace();
			emptyEditorWhenDeleting();
	
			// Windows phone will return a range like [body, 0] on mousedown so
			// it will always normalize to the wrong location
			if (!Env.windowsPhone) {
				normalizeSelection();
			}
	
			// WebKit
			if (isWebKit) {
				emptyEditorOnDeleteEverything();
				cleanupStylesWhenDeleting();
				inputMethodFocus();
				selectControlElements();
				setDefaultBlockType();
				blockFormSubmitInsideEditor();
				disableBackspaceIntoATable();
				removeAppleInterchangeBrs();
	
				//touchClickEvent();
	
				// iOS
				if (Env.iOS) {
					restoreFocusOnKeyDown();
					bodyHeight();
					tapLinksAndImages();
				} else {
					selectAll();
				}
			}
	
			// IE
			if (isIE && Env.ie < 11) {
				removeHrOnBackspace();
				ensureBodyHasRoleApplication();
				addNewLinesBeforeBrInPre();
				removePreSerializedStylesWhenSelectingControls();
				deleteControlItemOnBackSpace();
				renderEmptyBlocksFix();
				keepNoScriptContents();
				fixCaretSelectionOfDocumentElementOnIe();
			}
	
			if (Env.ie >= 11) {
				bodyHeight();
				disableBackspaceIntoATable();
			}
	
			if (Env.ie) {
				selectAll();
				disableAutoUrlDetect();
				ieInternalDragAndDrop();
			}
	
			// Gecko
			if (isGecko) {
				emptyEditorOnDeleteEverything();
				removeHrOnBackspace();
				focusBody();
				removeStylesWhenDeletingAcrossBlockElements();
				setGeckoEditingOptions();
				addBrAfterLastLinks();
				showBrokenImageIcon();
				blockCmdArrowNavigation();
				disableBackspaceIntoATable();
			}
	
			return {
				refreshContentEditable: refreshContentEditable,
				isHidden: isHidden
			};
		};
	});
	
	// Included from: js/tinymce/classes/EditorObservable.js
	
	/**
	 * EditorObservable.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This mixin contains the event logic for the tinymce.Editor class.
	 *
	 * @mixin tinymce.EditorObservable
	 * @extends tinymce.util.Observable
	 */
	define("tinymce/EditorObservable", [
		"tinymce/util/Observable",
		"tinymce/dom/DOMUtils",
		"tinymce/util/Tools"
	], function(Observable, DOMUtils, Tools) {
		var DOM = DOMUtils.DOM, customEventRootDelegates;
	
		/**
		 * Returns the event target so for the specified event. Some events fire
		 * only on document, some fire on documentElement etc. This also handles the
		 * custom event root setting where it returns that element instead of the body.
		 *
		 * @private
		 * @param {tinymce.Editor} editor Editor instance to get event target from.
		 * @param {String} eventName Name of the event for example "click".
		 * @return {Element/Document} HTML Element or document target to bind on.
		 */
		function getEventTarget(editor, eventName) {
			if (eventName == 'selectionchange') {
				return editor.getDoc();
			}
	
			// Need to bind mousedown/mouseup etc to document not body in iframe mode
			// Since the user might click on the HTML element not the BODY
			if (!editor.inline && /^mouse|touch|click|contextmenu|drop|dragover|dragend/.test(eventName)) {
				return editor.getDoc().documentElement;
			}
	
			// Bind to event root instead of body if it's defined
			if (editor.settings.event_root) {
				if (!editor.eventRoot) {
					editor.eventRoot = DOM.select(editor.settings.event_root)[0];
				}
	
				return editor.eventRoot;
			}
	
			return editor.getBody();
		}
	
		/**
		 * Binds a event delegate for the specified name this delegate will fire
		 * the event to the editor dispatcher.
		 *
		 * @private
		 * @param {tinymce.Editor} editor Editor instance to get event target from.
		 * @param {String} eventName Name of the event for example "click".
		 */
		function bindEventDelegate(editor, eventName) {
			var eventRootElm = getEventTarget(editor, eventName), delegate;
	
			function isListening(editor) {
				return !editor.hidden && !editor.readonly;
			}
	
			if (!editor.delegates) {
				editor.delegates = {};
			}
	
			if (editor.delegates[eventName]) {
				return;
			}
	
			if (editor.settings.event_root) {
				if (!customEventRootDelegates) {
					customEventRootDelegates = {};
					editor.editorManager.on('removeEditor', function() {
						var name;
	
						if (!editor.editorManager.activeEditor) {
							if (customEventRootDelegates) {
								for (name in customEventRootDelegates) {
									editor.dom.unbind(getEventTarget(editor, name));
								}
	
								customEventRootDelegates = null;
							}
						}
					});
				}
	
				if (customEventRootDelegates[eventName]) {
					return;
				}
	
				delegate = function(e) {
					var target = e.target, editors = editor.editorManager.editors, i = editors.length;
	
					while (i--) {
						var body = editors[i].getBody();
	
						if (body === target || DOM.isChildOf(target, body)) {
							if (isListening(editors[i])) {
								editors[i].fire(eventName, e);
							}
						}
					}
				};
	
				customEventRootDelegates[eventName] = delegate;
				DOM.bind(eventRootElm, eventName, delegate);
			} else {
				delegate = function(e) {
					if (isListening(editor)) {
						editor.fire(eventName, e);
					}
				};
	
				DOM.bind(eventRootElm, eventName, delegate);
				editor.delegates[eventName] = delegate;
			}
		}
	
		var EditorObservable = {
			/**
			 * Bind any pending event delegates. This gets executed after the target body/document is created.
			 *
			 * @private
			 */
			bindPendingEventDelegates: function() {
				var self = this;
	
				Tools.each(self._pendingNativeEvents, function(name) {
					bindEventDelegate(self, name);
				});
			},
	
			/**
			 * Toggles a native event on/off this is called by the EventDispatcher when
			 * the first native event handler is added and when the last native event handler is removed.
			 *
			 * @private
			 */
			toggleNativeEvent: function(name, state) {
				var self = this;
	
				// Never bind focus/blur since the FocusManager fakes those
				if (name == "focus" || name == "blur") {
					return;
				}
	
				if (state) {
					if (self.initialized) {
						bindEventDelegate(self, name);
					} else {
						if (!self._pendingNativeEvents) {
							self._pendingNativeEvents = [name];
						} else {
							self._pendingNativeEvents.push(name);
						}
					}
				} else if (self.initialized) {
					self.dom.unbind(getEventTarget(self, name), name, self.delegates[name]);
					delete self.delegates[name];
				}
			},
	
			/**
			 * Unbinds all native event handlers that means delegates, custom events bound using the Events API etc.
			 *
			 * @private
			 */
			unbindAllNativeEvents: function() {
				var self = this, name;
	
				if (self.delegates) {
					for (name in self.delegates) {
						self.dom.unbind(getEventTarget(self, name), name, self.delegates[name]);
					}
	
					delete self.delegates;
				}
	
				if (!self.inline) {
					self.getBody().onload = null;
					self.dom.unbind(self.getWin());
					self.dom.unbind(self.getDoc());
				}
	
				self.dom.unbind(self.getBody());
				self.dom.unbind(self.getContainer());
			}
		};
	
		EditorObservable = Tools.extend({}, Observable, EditorObservable);
	
		return EditorObservable;
	});
	
	// Included from: js/tinymce/classes/Mode.js
	
	/**
	 * Mode.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Mode switcher logic.
	 *
	 * @private
	 * @class tinymce.Mode
	 */
	define("tinymce/Mode", [], function() {
		function setEditorCommandState(editor, cmd, state) {
			try {
				editor.getDoc().execCommand(cmd, false, state);
			} catch (ex) {
				// Ignore
			}
		}
	
		function clickBlocker(editor) {
			var target, handler;
	
			target = editor.getBody();
	
			handler = function(e) {
				if (editor.dom.getParents(e.target, 'a').length > 0) {
					e.preventDefault();
				}
			};
	
			editor.dom.bind(target, 'click', handler);
	
			return {
				unbind: function() {
					editor.dom.unbind(target, 'click', handler);
				}
			};
		}
	
		function toggleReadOnly(editor, state) {
			if (editor._clickBlocker) {
				editor._clickBlocker.unbind();
				editor._clickBlocker = null;
			}
	
			if (state) {
				editor._clickBlocker = clickBlocker(editor);
				editor.selection.controlSelection.hideResizeRect();
				editor.readonly = true;
				editor.getBody().contentEditable = false;
			} else {
				editor.readonly = false;
				editor.getBody().contentEditable = true;
				setEditorCommandState(editor, "StyleWithCSS", false);
				setEditorCommandState(editor, "enableInlineTableEditing", false);
				setEditorCommandState(editor, "enableObjectResizing", false);
				editor.focus();
				editor.nodeChanged();
			}
		}
	
		function setMode(editor, mode) {
			var currentMode = editor.readonly ? 'readonly' : 'design';
	
			if (mode == currentMode) {
				return;
			}
	
			if (editor.initialized) {
				toggleReadOnly(editor, mode == 'readonly');
			} else {
				editor.on('init', function() {
					toggleReadOnly(editor, mode == 'readonly');
				});
			}
	
			// Event is NOT preventable
			editor.fire('SwitchMode', {mode: mode});
		}
	
		return {
			setMode: setMode
		};
	});
	
	// Included from: js/tinymce/classes/Shortcuts.js
	
	/**
	 * Shortcuts.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Contains all logic for handling of keyboard shortcuts.
	 *
	 * @class tinymce.Shortcuts
	 * @example
	 * editor.shortcuts.add('ctrl+a', function() {});
	 * editor.shortcuts.add('meta+a', function() {}); // "meta" maps to Command on Mac and Ctrl on PC
	 * editor.shortcuts.add('ctrl+alt+a', function() {});
	 * editor.shortcuts.add('access+a', function() {}); // "access" maps to ctrl+alt on Mac and shift+alt on PC
	 */
	define("tinymce/Shortcuts", [
		"tinymce/util/Tools",
		"tinymce/Env"
	], function(Tools, Env) {
		var each = Tools.each, explode = Tools.explode;
	
		var keyCodeLookup = {
			"f9": 120,
			"f10": 121,
			"f11": 122
		};
	
		var modifierNames = Tools.makeMap('alt,ctrl,shift,meta,access');
	
		return function(editor) {
			var self = this, shortcuts = {}, pendingPatterns = [];
	
			function parseShortcut(pattern) {
				var id, key, shortcut = {};
	
				// Parse modifiers and keys ctrl+alt+b for example
				each(explode(pattern, '+'), function(value) {
					if (value in modifierNames) {
						shortcut[value] = true;
					} else {
						// Allow numeric keycodes like ctrl+219 for ctrl+[
						if (/^[0-9]{2,}$/.test(value)) {
							shortcut.keyCode = parseInt(value, 10);
						} else {
							shortcut.charCode = value.charCodeAt(0);
							shortcut.keyCode = keyCodeLookup[value] || value.toUpperCase().charCodeAt(0);
						}
					}
				});
	
				// Generate unique id for modifier combination and set default state for unused modifiers
				id = [shortcut.keyCode];
				for (key in modifierNames) {
					if (shortcut[key]) {
						id.push(key);
					} else {
						shortcut[key] = false;
					}
				}
				shortcut.id = id.join(',');
	
				// Handle special access modifier differently depending on Mac/Win
				if (shortcut.access) {
					shortcut.alt = true;
	
					if (Env.mac) {
						shortcut.ctrl = true;
					} else {
						shortcut.shift = true;
					}
				}
	
				// Handle special meta modifier differently depending on Mac/Win
				if (shortcut.meta) {
					if (Env.mac) {
						shortcut.meta = true;
					} else {
						shortcut.ctrl = true;
						shortcut.meta = false;
					}
				}
	
				return shortcut;
			}
	
			function createShortcut(pattern, desc, cmdFunc, scope) {
				var shortcuts;
	
				shortcuts = Tools.map(explode(pattern, '>'), parseShortcut);
				shortcuts[shortcuts.length - 1] = Tools.extend(shortcuts[shortcuts.length - 1], {
					func: cmdFunc,
					scope: scope || editor
				});
	
				return Tools.extend(shortcuts[0], {
					desc: editor.translate(desc),
					subpatterns: shortcuts.slice(1)
				});
			}
	
			function hasModifier(e) {
				return e.altKey || e.ctrlKey || e.metaKey;
			}
	
			function isFunctionKey(e) {
				return e.type === "keydown" && e.keyCode >= 112 && e.keyCode <= 123;
			}
	
			function matchShortcut(e, shortcut) {
				if (!shortcut) {
					return false;
				}
	
				if (shortcut.ctrl != e.ctrlKey || shortcut.meta != e.metaKey) {
					return false;
				}
	
				if (shortcut.alt != e.altKey || shortcut.shift != e.shiftKey) {
					return false;
				}
	
				if (e.keyCode == shortcut.keyCode || (e.charCode && e.charCode == shortcut.charCode)) {
					e.preventDefault();
					return true;
				}
	
				return false;
			}
	
			function executeShortcutAction(shortcut) {
				return shortcut.func ? shortcut.func.call(shortcut.scope) : null;
			}
	
			editor.on('keyup keypress keydown', function(e) {
				if ((hasModifier(e) || isFunctionKey(e)) && !e.isDefaultPrevented()) {
					each(shortcuts, function(shortcut) {
						if (matchShortcut(e, shortcut)) {
							pendingPatterns = shortcut.subpatterns.slice(0);
	
							if (e.type == "keydown") {
								executeShortcutAction(shortcut);
							}
	
							return true;
						}
					});
	
					if (matchShortcut(e, pendingPatterns[0])) {
						if (pendingPatterns.length === 1) {
							if (e.type == "keydown") {
								executeShortcutAction(pendingPatterns[0]);
							}
						}
	
						pendingPatterns.shift();
					}
				}
			});
	
			/**
			 * Adds a keyboard shortcut for some command or function.
			 *
			 * @method add
			 * @param {String} pattern Shortcut pattern. Like for example: ctrl+alt+o.
			 * @param {String} desc Text description for the command.
			 * @param {String/Function} cmdFunc Command name string or function to execute when the key is pressed.
			 * @param {Object} scope Optional scope to execute the function in.
			 * @return {Boolean} true/false state if the shortcut was added or not.
			 */
			self.add = function(pattern, desc, cmdFunc, scope) {
				var cmd;
	
				cmd = cmdFunc;
	
				if (typeof cmdFunc === 'string') {
					cmdFunc = function() {
						editor.execCommand(cmd, false, null);
					};
				} else if (Tools.isArray(cmd)) {
					cmdFunc = function() {
						editor.execCommand(cmd[0], cmd[1], cmd[2]);
					};
				}
	
				each(explode(Tools.trim(pattern.toLowerCase())), function(pattern) {
					var shortcut = createShortcut(pattern, desc, cmdFunc, scope);
					shortcuts[shortcut.id] = shortcut;
				});
	
				return true;
			};
	
			/**
			 * Remove a keyboard shortcut by pattern.
			 *
			 * @method remove
			 * @param {String} pattern Shortcut pattern. Like for example: ctrl+alt+o.
			 * @return {Boolean} true/false state if the shortcut was removed or not.
			 */
			self.remove = function(pattern) {
				var shortcut = createShortcut(pattern);
	
				if (shortcuts[shortcut.id]) {
					delete shortcuts[shortcut.id];
					return true;
				}
	
				return false;
			};
		};
	});
	
	// Included from: js/tinymce/classes/file/Uploader.js
	
	/**
	 * Uploader.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Upload blobs or blob infos to the specified URL or handler.
	 *
	 * @private
	 * @class tinymce.file.Uploader
	 * @example
	 * var uploader = new Uploader({
	 *     url: '/upload.php',
	 *     basePath: '/base/path',
	 *     credentials: true,
	 *     handler: function(data, success, failure) {
	 *         ...
	 *     }
	 * });
	 *
	 * uploader.upload(blobInfos).then(function(result) {
	 *     ...
	 * });
	 */
	define("tinymce/file/Uploader", [
		"tinymce/util/Promise",
		"tinymce/util/Tools",
		"tinymce/util/Fun"
	], function(Promise, Tools, Fun) {
		return function(uploadStatus, settings) {
			var pendingPromises = {};
	
			function filename(blobInfo) {
				var ext, extensions;
	
				extensions = {
					'image/jpeg': 'jpg',
					'image/jpg': 'jpg',
					'image/gif': 'gif',
					'image/png': 'png'
				};
	
				ext = extensions[blobInfo.blob().type.toLowerCase()] || 'dat';
	
				return blobInfo.filename() + '.' + ext;
			}
	
			function pathJoin(path1, path2) {
				if (path1) {
					return path1.replace(/\/$/, '') + '/' + path2.replace(/^\//, '');
				}
	
				return path2;
			}
	
			function blobInfoToData(blobInfo) {
				return {
					id: blobInfo.id,
					blob: blobInfo.blob,
					base64: blobInfo.base64,
					filename: Fun.constant(filename(blobInfo))
				};
			}
	
			function defaultHandler(blobInfo, success, failure, progress) {
				var xhr, formData;
	
				xhr = new XMLHttpRequest();
				xhr.open('POST', settings.url);
				xhr.withCredentials = settings.credentials;
	
				xhr.upload.onprogress = function(e) {
					progress(e.loaded / e.total * 100);
				};
	
				xhr.onerror = function() {
					failure("Image upload failed due to a XHR Transport error. Code: " + xhr.status);
				};
	
				xhr.onload = function() {
					var json;
	
					if (xhr.status != 200) {
						failure("HTTP Error: " + xhr.status);
						return;
					}
	
					json = JSON.parse(xhr.responseText);
	
					if (!json || typeof json.location != "string") {
						failure("Invalid JSON: " + xhr.responseText);
						return;
					}
	
					success(pathJoin(settings.basePath, json.location));
				};
	
				formData = new FormData();
				formData.append('file', blobInfo.blob(), blobInfo.filename());
	
				xhr.send(formData);
			}
	
			function noUpload() {
				return new Promise(function(resolve) {
					resolve([]);
				});
			}
	
			function handlerSuccess(blobInfo, url) {
				return {
					url: url,
					blobInfo: blobInfo,
					status: true
				};
			}
	
			function handlerFailure(blobInfo, error) {
				return {
					url: '',
					blobInfo: blobInfo,
					status: false,
					error: error
				};
			}
	
			function resolvePending(blobUri, result) {
				Tools.each(pendingPromises[blobUri], function(resolve) {
					resolve(result);
				});
	
				delete pendingPromises[blobUri];
			}
	
			function uploadBlobInfo(blobInfo, handler, openNotification) {
				uploadStatus.markPending(blobInfo.blobUri());
	
				return new Promise(function(resolve) {
					var notification, progress;
	
					var noop = function() {
					};
	
					try {
						var closeNotification = function() {
							if (notification) {
								notification.close();
								progress = noop; // Once it's closed it's closed
							}
						};
	
						var success = function(url) {
							closeNotification();
							uploadStatus.markUploaded(blobInfo.blobUri(), url);
							resolvePending(blobInfo.blobUri(), handlerSuccess(blobInfo, url));
							resolve(handlerSuccess(blobInfo, url));
						};
	
						var failure = function() {
							closeNotification();
							uploadStatus.removeFailed(blobInfo.blobUri());
							resolvePending(blobInfo.blobUri(), handlerFailure(blobInfo, failure));
							resolve(handlerFailure(blobInfo, failure));
						};
	
						progress = function(percent) {
							if (percent < 0 || percent > 100) {
								return;
							}
	
							if (!notification) {
								notification = openNotification();
							}
	
							notification.progressBar.value(percent);
						};
	
						handler(blobInfoToData(blobInfo), success, failure, progress);
					} catch (ex) {
						resolve(handlerFailure(blobInfo, ex.message));
					}
				});
			}
	
			function isDefaultHandler(handler) {
				return handler === defaultHandler;
			}
	
			function pendingUploadBlobInfo(blobInfo) {
				var blobUri = blobInfo.blobUri();
	
				return new Promise(function(resolve) {
					pendingPromises[blobUri] = pendingPromises[blobUri] || [];
					pendingPromises[blobUri].push(resolve);
				});
			}
	
			function uploadBlobs(blobInfos, openNotification) {
				blobInfos = Tools.grep(blobInfos, function(blobInfo) {
					return !uploadStatus.isUploaded(blobInfo.blobUri());
				});
	
				return Promise.all(Tools.map(blobInfos, function(blobInfo) {
					return uploadStatus.isPending(blobInfo.blobUri()) ?
						pendingUploadBlobInfo(blobInfo) : uploadBlobInfo(blobInfo, settings.handler, openNotification);
				}));
			}
	
			function upload(blobInfos, openNotification) {
				return (!settings.url && isDefaultHandler(settings.handler)) ? noUpload() : uploadBlobs(blobInfos, openNotification);
			}
	
			settings = Tools.extend({
				credentials: false,
				// We are adding a notify argument to this (at the moment, until it doesn't work)
				handler: defaultHandler
			}, settings);
	
			return {
				upload: upload
			};
		};
	});
	
	// Included from: js/tinymce/classes/file/Conversions.js
	
	/**
	 * Conversions.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Converts blob/uris back and forth.
	 *
	 * @private
	 * @class tinymce.file.Conversions
	 */
	define("tinymce/file/Conversions", [
		"tinymce/util/Promise"
	], function(Promise) {
		function blobUriToBlob(url) {
			return new Promise(function(resolve) {
				var xhr = new XMLHttpRequest();
	
				xhr.open('GET', url, true);
				xhr.responseType = 'blob';
	
				xhr.onload = function() {
					if (this.status == 200) {
						resolve(this.response);
					}
				};
	
				xhr.send();
			});
		}
	
		function parseDataUri(uri) {
			var type, matches;
	
			uri = decodeURIComponent(uri).split(',');
	
			matches = /data:([^;]+)/.exec(uri[0]);
			if (matches) {
				type = matches[1];
			}
	
			return {
				type: type,
				data: uri[1]
			};
		}
	
		function dataUriToBlob(uri) {
			return new Promise(function(resolve) {
				var str, arr, i;
	
				uri = parseDataUri(uri);
	
				// Might throw error if data isn't proper base64
				try {
					str = atob(uri.data);
				} catch (e) {
					resolve(new Blob([]));
					return;
				}
	
				arr = new Uint8Array(str.length);
	
				for (i = 0; i < arr.length; i++) {
					arr[i] = str.charCodeAt(i);
				}
	
				resolve(new Blob([arr], {type: uri.type}));
			});
		}
	
		function uriToBlob(url) {
			if (url.indexOf('blob:') === 0) {
				return blobUriToBlob(url);
			}
	
			if (url.indexOf('data:') === 0) {
				return dataUriToBlob(url);
			}
	
			return null;
		}
	
		function blobToDataUri(blob) {
			return new Promise(function(resolve) {
				var reader = new FileReader();
	
				reader.onloadend = function() {
					resolve(reader.result);
				};
	
				reader.readAsDataURL(blob);
			});
		}
	
		return {
			uriToBlob: uriToBlob,
			blobToDataUri: blobToDataUri,
			parseDataUri: parseDataUri
		};
	});
	
	// Included from: js/tinymce/classes/file/ImageScanner.js
	
	/**
	 * ImageScanner.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Finds images with data uris or blob uris. If data uris are found it will convert them into blob uris.
	 *
	 * @private
	 * @class tinymce.file.ImageScanner
	 */
	define("tinymce/file/ImageScanner", [
		"tinymce/util/Promise",
		"tinymce/util/Arr",
		"tinymce/util/Fun",
		"tinymce/file/Conversions",
		"tinymce/Env"
	], function(Promise, Arr, Fun, Conversions, Env) {
		var count = 0;
	
		return function(uploadStatus, blobCache) {
			var cachedPromises = {};
	
			function findAll(elm, predicate) {
				var images, promises;
	
				function imageToBlobInfo(img, resolve) {
					var base64, blobInfo;
	
					if (img.src.indexOf('blob:') === 0) {
						blobInfo = blobCache.getByUri(img.src);
	
						if (blobInfo) {
							resolve({
								image: img,
								blobInfo: blobInfo
							});
						}
	
						return;
					}
	
					base64 = Conversions.parseDataUri(img.src).data;
					blobInfo = blobCache.findFirst(function(cachedBlobInfo) {
						return cachedBlobInfo.base64() === base64;
					});
	
					if (blobInfo) {
						resolve({
							image: img,
							blobInfo: blobInfo
						});
					} else {
						Conversions.uriToBlob(img.src).then(function(blob) {
							var blobInfoId = 'blobid' + (count++),
								blobInfo = blobCache.create(blobInfoId, blob, base64);
	
							blobCache.add(blobInfo);
	
							resolve({
								image: img,
								blobInfo: blobInfo
							});
						});
					}
				}
	
				if (!predicate) {
					predicate = Fun.constant(true);
				}
	
				images = Arr.filter(elm.getElementsByTagName('img'), function(img) {
					var src = img.src;
	
					if (!Env.fileApi) {
						return false;
					}
	
					if (img.hasAttribute('data-mce-bogus')) {
						return false;
					}
	
					if (img.hasAttribute('data-mce-placeholder')) {
						return false;
					}
	
					if (!src || src == Env.transparentSrc) {
						return false;
					}
	
					if (src.indexOf('blob:') === 0) {
						return !uploadStatus.isUploaded(src);
					}
	
					if (src.indexOf('data:') === 0) {
						return predicate(img);
					}
	
					return false;
				});
	
				promises = Arr.map(images, function(img) {
					var newPromise;
	
					if (cachedPromises[img.src]) {
						// Since the cached promise will return the cached image
						// We need to wrap it and resolve with the actual image
						return new Promise(function(resolve) {
							cachedPromises[img.src].then(function(imageInfo) {
								resolve({
									image: img,
									blobInfo: imageInfo.blobInfo
								});
							});
						});
					}
	
					newPromise = new Promise(function(resolve) {
						imageToBlobInfo(img, resolve);
					}).then(function(result) {
						delete cachedPromises[result.image.src];
						return result;
					})['catch'](function(error) {
						delete cachedPromises[img.src];
						return error;
					});
	
					cachedPromises[img.src] = newPromise;
	
					return newPromise;
				});
	
				return Promise.all(promises);
			}
	
			return {
				findAll: findAll
			};
		};
	});
	
	// Included from: js/tinymce/classes/file/BlobCache.js
	
	/**
	 * BlobCache.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Hold blob info objects where a blob has extra internal information.
	 *
	 * @private
	 * @class tinymce.file.BlobCache
	 */
	define("tinymce/file/BlobCache", [
		"tinymce/util/Arr",
		"tinymce/util/Fun"
	], function(Arr, Fun) {
		return function() {
			var cache = [], constant = Fun.constant;
	
			function create(id, blob, base64, filename) {
				return {
					id: constant(id),
					filename: constant(filename || id),
					blob: constant(blob),
					base64: constant(base64),
					blobUri: constant(URL.createObjectURL(blob))
				};
			}
	
			function add(blobInfo) {
				if (!get(blobInfo.id())) {
					cache.push(blobInfo);
				}
			}
	
			function get(id) {
				return findFirst(function(cachedBlobInfo) {
					return cachedBlobInfo.id() === id;
				});
			}
	
			function findFirst(predicate) {
				return Arr.filter(cache, predicate)[0];
			}
	
			function getByUri(blobUri) {
				return findFirst(function(blobInfo) {
					return blobInfo.blobUri() == blobUri;
				});
			}
	
			function removeByUri(blobUri) {
				cache = Arr.filter(cache, function(blobInfo) {
					if (blobInfo.blobUri() === blobUri) {
						URL.revokeObjectURL(blobInfo.blobUri());
						return false;
					}
	
					return true;
				});
			}
	
			function destroy() {
				Arr.each(cache, function(cachedBlobInfo) {
					URL.revokeObjectURL(cachedBlobInfo.blobUri());
				});
	
				cache = [];
			}
	
			return {
				create: create,
				add: add,
				get: get,
				getByUri: getByUri,
				findFirst: findFirst,
				removeByUri: removeByUri,
				destroy: destroy
			};
		};
	});
	
	// Included from: js/tinymce/classes/file/UploadStatus.js
	
	/**
	 * UploadStatus.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2016 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Holds the current status of a blob uri, if it's pending or uploaded and what the result urls was.
	 *
	 * @private
	 * @class tinymce.file.UploadStatus
	 */
	define("tinymce/file/UploadStatus", [
	], function() {
		return function() {
			var PENDING = 1, UPLOADED = 2;
			var blobUriStatuses = {};
	
			function createStatus(status, resultUri) {
				return {
					status: status,
					resultUri: resultUri
				};
			}
	
			function hasBlobUri(blobUri) {
				return blobUri in blobUriStatuses;
			}
	
			function getResultUri(blobUri) {
				var result = blobUriStatuses[blobUri];
	
				return result ? result.resultUri : null;
			}
	
			function isPending(blobUri) {
				return hasBlobUri(blobUri) ? blobUriStatuses[blobUri].status === PENDING : false;
			}
	
			function isUploaded(blobUri) {
				return hasBlobUri(blobUri) ? blobUriStatuses[blobUri].status === UPLOADED : false;
			}
	
			function markPending(blobUri) {
				blobUriStatuses[blobUri] = createStatus(PENDING, null);
			}
	
			function markUploaded(blobUri, resultUri) {
				blobUriStatuses[blobUri] = createStatus(UPLOADED, resultUri);
			}
	
			function removeFailed(blobUri) {
				delete blobUriStatuses[blobUri];
			}
	
			function destroy() {
				blobUriStatuses = {};
			}
	
			return {
				hasBlobUri: hasBlobUri,
				getResultUri: getResultUri,
				isPending: isPending,
				isUploaded: isUploaded,
				markPending: markPending,
				markUploaded: markUploaded,
				removeFailed: removeFailed,
				destroy: destroy
			};
		};
	});
	
	// Included from: js/tinymce/classes/EditorUpload.js
	
	/**
	 * EditorUpload.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Handles image uploads, updates undo stack and patches over various internal functions.
	 *
	 * @private
	 * @class tinymce.EditorUpload
	 */
	define("tinymce/EditorUpload", [
		"tinymce/util/Arr",
		"tinymce/file/Uploader",
		"tinymce/file/ImageScanner",
		"tinymce/file/BlobCache",
		"tinymce/file/UploadStatus"
	], function(Arr, Uploader, ImageScanner, BlobCache, UploadStatus) {
		return function(editor) {
			var blobCache = new BlobCache(), uploader, imageScanner, settings = editor.settings;
			var uploadStatus = new UploadStatus();
	
			function aliveGuard(callback) {
				return function(result) {
					if (editor.selection) {
						return callback(result);
					}
	
					return [];
				};
			}
	
			function cacheInvalidator() {
				return '?' + (new Date()).getTime();
			}
	
			// Replaces strings without regexps to avoid FF regexp to big issue
			function replaceString(content, search, replace) {
				var index = 0;
	
				do {
					index = content.indexOf(search, index);
	
					if (index !== -1) {
						content = content.substring(0, index) + replace + content.substr(index + search.length);
						index += replace.length - search.length + 1;
					}
				} while (index !== -1);
	
				return content;
			}
	
			function replaceImageUrl(content, targetUrl, replacementUrl) {
				content = replaceString(content, 'src="' + targetUrl + '"', 'src="' + replacementUrl + '"');
				content = replaceString(content, 'data-mce-src="' + targetUrl + '"', 'data-mce-src="' + replacementUrl + '"');
	
				return content;
			}
	
			function replaceUrlInUndoStack(targetUrl, replacementUrl) {
				Arr.each(editor.undoManager.data, function(level) {
					if (level.type === 'fragmented') {
						level.fragments = Arr.map(level.fragments, function (fragment) {
							return replaceImageUrl(fragment, targetUrl, replacementUrl);
						});
					} else {
						level.content = replaceImageUrl(level.content, targetUrl, replacementUrl);
					}
				});
			}
	
			function openNotification() {
				return editor.notificationManager.open({
					text: editor.translate('Image uploading...'),
					type: 'info',
					timeout: -1,
					progressBar: true
				});
			}
	
			function replaceImageUri(image, resultUri) {
				blobCache.removeByUri(image.src);
				replaceUrlInUndoStack(image.src, resultUri);
	
				editor.$(image).attr({
					src: settings.images_reuse_filename ? resultUri + cacheInvalidator() : resultUri,
					'data-mce-src': editor.convertURL(resultUri, 'src')
				});
			}
	
			function uploadImages(callback) {
				if (!uploader) {
					uploader = new Uploader(uploadStatus, {
						url: settings.images_upload_url,
						basePath: settings.images_upload_base_path,
						credentials: settings.images_upload_credentials,
						handler: settings.images_upload_handler
					});
				}
	
				return scanForImages().then(aliveGuard(function(imageInfos) {
					var blobInfos;
	
					blobInfos = Arr.map(imageInfos, function(imageInfo) {
						return imageInfo.blobInfo;
					});
	
					return uploader.upload(blobInfos, openNotification).then(aliveGuard(function(result) {
						result = Arr.map(result, function(uploadInfo, index) {
							var image = imageInfos[index].image;
	
							if (uploadInfo.status && editor.settings.images_replace_blob_uris !== false) {
								replaceImageUri(image, uploadInfo.url);
							}
	
							return {
								element: image,
								status: uploadInfo.status
							};
						});
	
						if (callback) {
							callback(result);
						}
	
						return result;
					}));
				}));
			}
	
			function uploadImagesAuto(callback) {
				if (settings.automatic_uploads !== false) {
					return uploadImages(callback);
				}
			}
	
			function isValidDataUriImage(imgElm) {
				return settings.images_dataimg_filter ? settings.images_dataimg_filter(imgElm) : true;
			}
	
			function scanForImages() {
				if (!imageScanner) {
					imageScanner = new ImageScanner(uploadStatus, blobCache);
				}
	
				return imageScanner.findAll(editor.getBody(), isValidDataUriImage).then(aliveGuard(function(result) {
					Arr.each(result, function(resultItem) {
						replaceUrlInUndoStack(resultItem.image.src, resultItem.blobInfo.blobUri());
						resultItem.image.src = resultItem.blobInfo.blobUri();
						resultItem.image.removeAttribute('data-mce-src');
					});
	
					return result;
				}));
			}
	
			function destroy() {
				blobCache.destroy();
				uploadStatus.destroy();
				imageScanner = uploader = null;
			}
	
			function replaceBlobUris(content) {
				return content.replace(/src="(blob:[^"]+)"/g, function(match, blobUri) {
					var resultUri = uploadStatus.getResultUri(blobUri);
	
					if (resultUri) {
						return 'src="' + resultUri + '"';
					}
	
					var blobInfo = blobCache.getByUri(blobUri);
	
					if (!blobInfo) {
						blobInfo = Arr.reduce(editor.editorManager.editors, function(result, editor) {
							return result || editor.editorUpload.blobCache.getByUri(blobUri);
						}, null);
					}
	
					if (blobInfo) {
						return 'src="data:' + blobInfo.blob().type + ';base64,' + blobInfo.base64() + '"';
					}
	
					return match;
				});
			}
	
			editor.on('setContent', function() {
				if (editor.settings.automatic_uploads !== false) {
					uploadImagesAuto();
				} else {
					scanForImages();
				}
			});
	
			editor.on('RawSaveContent', function(e) {
				e.content = replaceBlobUris(e.content);
			});
	
			editor.on('getContent', function(e) {
				if (e.source_view || e.format == 'raw') {
					return;
				}
	
				e.content = replaceBlobUris(e.content);
			});
	
			editor.on('PostRender', function() {
				editor.parser.addNodeFilter('img', function(images) {
					Arr.each(images, function(img) {
						var src = img.attr('src');
	
						if (blobCache.getByUri(src)) {
							return;
						}
	
						var resultUri = uploadStatus.getResultUri(src);
						if (resultUri) {
							img.attr('src', resultUri);
						}
					});
				});
			});
	
			return {
				blobCache: blobCache,
				uploadImages: uploadImages,
				uploadImagesAuto: uploadImagesAuto,
				scanForImages: scanForImages,
				destroy: destroy
			};
		};
	});
	
	// Included from: js/tinymce/classes/caret/FakeCaret.js
	
	/**
	 * FakeCaret.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This module contains logic for rendering a fake visual caret.
	 *
	 * @private
	 * @class tinymce.caret.FakeCaret
	 */
	define("tinymce/caret/FakeCaret", [
		"tinymce/caret/CaretContainer",
		"tinymce/caret/CaretPosition",
		"tinymce/dom/NodeType",
		"tinymce/dom/RangeUtils",
		"tinymce/dom/DomQuery",
		"tinymce/geom/ClientRect",
		"tinymce/util/Delay"
	], function(CaretContainer, CaretPosition, NodeType, RangeUtils, $, ClientRect, Delay) {
		var isContentEditableFalse = NodeType.isContentEditableFalse;
	
		return function(rootNode, isBlock) {
			var cursorInterval, $lastVisualCaret, caretContainerNode;
	
			function getAbsoluteClientRect(node, before) {
				var clientRect = ClientRect.collapse(node.getBoundingClientRect(), before),
					docElm, scrollX, scrollY, margin, rootRect;
	
				if (rootNode.tagName == 'BODY') {
					docElm = rootNode.ownerDocument.documentElement;
					scrollX = rootNode.scrollLeft || docElm.scrollLeft;
					scrollY = rootNode.scrollTop || docElm.scrollTop;
				} else {
					rootRect = rootNode.getBoundingClientRect();
					scrollX = rootNode.scrollLeft - rootRect.left;
					scrollY = rootNode.scrollTop - rootRect.top;
				}
	
				clientRect.left += scrollX;
				clientRect.right += scrollX;
				clientRect.top += scrollY;
				clientRect.bottom += scrollY;
				clientRect.width = 1;
	
				margin = node.offsetWidth - node.clientWidth;
	
				if (margin > 0) {
					if (before) {
						margin *= -1;
					}
	
					clientRect.left += margin;
					clientRect.right += margin;
				}
	
				return clientRect;
			}
	
			function trimInlineCaretContainers() {
				var contentEditableFalseNodes, node, sibling, i, data;
	
				contentEditableFalseNodes = $('*[contentEditable=false]', rootNode);
				for (i = 0; i < contentEditableFalseNodes.length; i++) {
					node = contentEditableFalseNodes[i];
	
					sibling = node.previousSibling;
					if (CaretContainer.endsWithCaretContainer(sibling)) {
						data = sibling.data;
	
						if (data.length == 1) {
							sibling.parentNode.removeChild(sibling);
						} else {
							sibling.deleteData(data.length - 1, 1);
						}
					}
	
					sibling = node.nextSibling;
					if (CaretContainer.startsWithCaretContainer(sibling)) {
						data = sibling.data;
	
						if (data.length == 1) {
							sibling.parentNode.removeChild(sibling);
						} else {
							sibling.deleteData(0, 1);
						}
					}
				}
	
				return null;
			}
	
			function show(before, node) {
				var clientRect, rng;
	
				hide();
	
				if (isBlock(node)) {
					caretContainerNode = CaretContainer.insertBlock('p', node, before);
					clientRect = getAbsoluteClientRect(node, before);
					$(caretContainerNode).css('top', clientRect.top);
	
					$lastVisualCaret = $('<div class="mce-visual-caret" data-mce-bogus="all"></div>').css(clientRect).appendTo(rootNode);
	
					if (before) {
						$lastVisualCaret.addClass('mce-visual-caret-before');
					}
	
					startBlink();
	
					rng = node.ownerDocument.createRange();
					rng.setStart(caretContainerNode, 0);
					rng.setEnd(caretContainerNode, 0);
				} else {
					caretContainerNode = CaretContainer.insertInline(node, before);
					rng = node.ownerDocument.createRange();
	
					if (isContentEditableFalse(caretContainerNode.nextSibling)) {
						rng.setStart(caretContainerNode, 0);
						rng.setEnd(caretContainerNode, 0);
					} else {
						rng.setStart(caretContainerNode, 1);
						rng.setEnd(caretContainerNode, 1);
					}
	
					return rng;
				}
	
				return rng;
			}
	
			function hide() {
				trimInlineCaretContainers();
	
				if (caretContainerNode) {
					CaretContainer.remove(caretContainerNode);
					caretContainerNode = null;
				}
	
				if ($lastVisualCaret) {
					$lastVisualCaret.remove();
					$lastVisualCaret = null;
				}
	
				clearInterval(cursorInterval);
			}
	
			function startBlink() {
				cursorInterval = Delay.setInterval(function() {
					$('div.mce-visual-caret', rootNode).toggleClass('mce-visual-caret-hidden');
				}, 500);
			}
	
			function destroy() {
				Delay.clearInterval(cursorInterval);
			}
	
			function getCss() {
				return (
					'.mce-visual-caret {' +
						'position: absolute;' +
						'background-color: black;' +
						'background-color: currentcolor;' +
					'}' +
					'.mce-visual-caret-hidden {' +
						'display: none;' +
					'}' +
					'*[data-mce-caret] {' +
						'position: absolute;' +
						'left: -1000px;' +
						'right: auto;' +
						'top: 0;' +
						'margin: 0;' +
						'padding: 0;' +
					'}'
				);
			}
	
			return {
				show: show,
				hide: hide,
				getCss: getCss,
				destroy: destroy
			};
		};
	});
	
	// Included from: js/tinymce/classes/dom/Dimensions.js
	
	/**
	 * Dimensions.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This module measures nodes and returns client rects. The client rects has an
	 * extra node property.
	 *
	 * @private
	 * @class tinymce.dom.Dimensions
	 */
	define("tinymce/dom/Dimensions", [
		"tinymce/util/Arr",
		"tinymce/dom/NodeType",
		"tinymce/geom/ClientRect"
	], function(Arr, NodeType, ClientRect) {
	
		function getClientRects(node) {
			function toArrayWithNode(clientRects) {
				return Arr.map(clientRects, function(clientRect) {
					clientRect = ClientRect.clone(clientRect);
					clientRect.node = node;
	
					return clientRect;
				});
			}
	
			if (Arr.isArray(node)) {
				return Arr.reduce(node, function(result, node) {
					return result.concat(getClientRects(node));
				}, []);
			}
	
			if (NodeType.isElement(node)) {
				return toArrayWithNode(node.getClientRects());
			}
	
			if (NodeType.isText(node)) {
				var rng = node.ownerDocument.createRange();
	
				rng.setStart(node, 0);
				rng.setEnd(node, node.data.length);
	
				return toArrayWithNode(rng.getClientRects());
			}
		}
	
		return {
			/**
			 * Returns the client rects for a specific node.
			 *
			 * @method getClientRects
			 * @param {Array/DOMNode} node Node or array of nodes to get client rects on.
			 * @param {Array} Array of client rects with a extra node property.
			 */
			getClientRects: getClientRects
		};
	});
	
	// Included from: js/tinymce/classes/caret/LineWalker.js
	
	/**
	 * LineWalker.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This module lets you walk the document line by line
	 * returing nodes and client rects for each line.
	 *
	 * @private
	 * @class tinymce.caret.LineWalker
	 */
	define("tinymce/caret/LineWalker", [
		"tinymce/util/Fun",
		"tinymce/util/Arr",
		"tinymce/dom/Dimensions",
		"tinymce/caret/CaretCandidate",
		"tinymce/caret/CaretUtils",
		"tinymce/caret/CaretWalker",
		"tinymce/caret/CaretPosition",
		"tinymce/geom/ClientRect"
	], function(Fun, Arr, Dimensions, CaretCandidate, CaretUtils, CaretWalker, CaretPosition, ClientRect) {
		var curry = Fun.curry;
	
		function findUntil(direction, rootNode, predicateFn, node) {
			while ((node = CaretUtils.findNode(node, direction, CaretCandidate.isEditableCaretCandidate, rootNode))) {
				if (predicateFn(node)) {
					return;
				}
			}
		}
	
		function walkUntil(direction, isAboveFn, isBeflowFn, rootNode, predicateFn, caretPosition) {
			var line = 0, node, result = [], targetClientRect;
	
			function add(node) {
				var i, clientRect, clientRects;
	
				clientRects = Dimensions.getClientRects(node);
				if (direction == -1) {
					clientRects = clientRects.reverse();
				}
	
				for (i = 0; i < clientRects.length; i++) {
					clientRect = clientRects[i];
					if (isBeflowFn(clientRect, targetClientRect)) {
						continue;
					}
	
					if (result.length > 0 && isAboveFn(clientRect, Arr.last(result))) {
						line++;
					}
	
					clientRect.line = line;
	
					if (predicateFn(clientRect)) {
						return true;
					}
	
					result.push(clientRect);
				}
			}
	
			targetClientRect = Arr.last(caretPosition.getClientRects());
			if (!targetClientRect) {
				return result;
			}
	
			node = caretPosition.getNode();
			add(node);
			findUntil(direction, rootNode, add, node);
	
			return result;
		}
	
		function aboveLineNumber(lineNumber, clientRect) {
			return clientRect.line > lineNumber;
		}
	
		function isLine(lineNumber, clientRect) {
			return clientRect.line === lineNumber;
		}
	
		var upUntil = curry(walkUntil, -1, ClientRect.isAbove, ClientRect.isBelow);
		var downUntil = curry(walkUntil, 1, ClientRect.isBelow, ClientRect.isAbove);
	
		function positionsUntil(direction, rootNode, predicateFn, node) {
			var caretWalker = new CaretWalker(rootNode), walkFn, isBelowFn, isAboveFn,
				caretPosition, result = [], line = 0, clientRect, targetClientRect;
	
			function getClientRect(caretPosition) {
				if (direction == 1) {
					return Arr.last(caretPosition.getClientRects());
				}
	
				return Arr.last(caretPosition.getClientRects());
			}
	
			if (direction == 1) {
				walkFn = caretWalker.next;
				isBelowFn = ClientRect.isBelow;
				isAboveFn = ClientRect.isAbove;
				caretPosition = CaretPosition.after(node);
			} else {
				walkFn = caretWalker.prev;
				isBelowFn = ClientRect.isAbove;
				isAboveFn = ClientRect.isBelow;
				caretPosition = CaretPosition.before(node);
			}
	
			targetClientRect = getClientRect(caretPosition);
	
			do {
				if (!caretPosition.isVisible()) {
					continue;
				}
	
				clientRect = getClientRect(caretPosition);
	
				if (isAboveFn(clientRect, targetClientRect)) {
					continue;
				}
	
				if (result.length > 0 && isBelowFn(clientRect, Arr.last(result))) {
					line++;
				}
	
				clientRect = ClientRect.clone(clientRect);
				clientRect.position = caretPosition;
				clientRect.line = line;
	
				if (predicateFn(clientRect)) {
					return result;
				}
	
				result.push(clientRect);
			} while ((caretPosition = walkFn(caretPosition)));
	
			return result;
		}
	
		return {
			upUntil: upUntil,
			downUntil: downUntil,
	
			/**
			 * Find client rects with line and caret position until the predicate returns true.
			 *
			 * @method positionsUntil
			 * @param {Number} direction Direction forward/backward 1/-1.
			 * @param {DOMNode} rootNode Root node to walk within.
			 * @param {function} predicateFn Gets the client rect as it's input.
			 * @param {DOMNode} node Node to start walking from.
			 * @return {Array} Array of client rects with line and position properties.
			 */
			positionsUntil: positionsUntil,
	
			isAboveLine: curry(aboveLineNumber),
			isLine: curry(isLine)
		};
	});
	
	// Included from: js/tinymce/classes/caret/LineUtils.js
	
	/**
	 * LineUtils.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Utility functions for working with lines.
	 *
	 * @private
	 * @class tinymce.caret.LineUtils
	 */
	define("tinymce/caret/LineUtils", [
		"tinymce/util/Fun",
		"tinymce/util/Arr",
		"tinymce/dom/NodeType",
		"tinymce/dom/Dimensions",
		"tinymce/geom/ClientRect",
		"tinymce/caret/CaretUtils",
		"tinymce/caret/CaretCandidate"
	], function(Fun, Arr, NodeType, Dimensions, ClientRect, CaretUtils, CaretCandidate) {
		var isContentEditableFalse = NodeType.isContentEditableFalse,
			findNode = CaretUtils.findNode,
			curry = Fun.curry;
	
		function distanceToRectLeft(clientRect, clientX) {
			return Math.abs(clientRect.left - clientX);
		}
	
		function distanceToRectRight(clientRect, clientX) {
			return Math.abs(clientRect.right - clientX);
		}
	
		function findClosestClientRect(clientRects, clientX) {
			function isInside(clientX, clientRect) {
				return clientX >= clientRect.left && clientX <= clientRect.right;
			}
	
			return Arr.reduce(clientRects, function(oldClientRect, clientRect) {
				var oldDistance, newDistance;
	
				oldDistance = Math.min(distanceToRectLeft(oldClientRect, clientX), distanceToRectRight(oldClientRect, clientX));
				newDistance = Math.min(distanceToRectLeft(clientRect, clientX), distanceToRectRight(clientRect, clientX));
	
				if (isInside(clientX, clientRect)) {
					return clientRect;
				}
	
				if (isInside(clientX, oldClientRect)) {
					return oldClientRect;
				}
	
				// cE=false has higher priority
				if (newDistance == oldDistance && isContentEditableFalse(clientRect.node)) {
					return clientRect;
				}
	
				if (newDistance < oldDistance) {
					return clientRect;
				}
	
				return oldClientRect;
			});
		}
	
		function walkUntil(direction, rootNode, predicateFn, node) {
			while ((node = findNode(node, direction, CaretCandidate.isEditableCaretCandidate, rootNode))) {
				if (predicateFn(node)) {
					return;
				}
			}
		}
	
		function findLineNodeRects(rootNode, targetNodeRect) {
			var clientRects = [];
	
			function collect(checkPosFn, node) {
				var lineRects;
	
				lineRects = Arr.filter(Dimensions.getClientRects(node), function(clientRect) {
					return !checkPosFn(clientRect, targetNodeRect);
				});
	
				clientRects = clientRects.concat(lineRects);
	
				return lineRects.length === 0;
			}
	
			clientRects.push(targetNodeRect);
			walkUntil(-1, rootNode, curry(collect, ClientRect.isAbove), targetNodeRect.node);
			walkUntil(1, rootNode, curry(collect, ClientRect.isBelow), targetNodeRect.node);
	
			return clientRects;
		}
	
		function getContentEditableFalseChildren(rootNode) {
			return Arr.filter(Arr.toArray(rootNode.getElementsByTagName('*')), isContentEditableFalse);
		}
	
		function caretInfo(clientRect, clientX) {
			return {
				node: clientRect.node,
				before: distanceToRectLeft(clientRect, clientX) < distanceToRectRight(clientRect, clientX)
			};
		}
	
		function closestCaret(rootNode, clientX, clientY) {
			var contentEditableFalseNodeRects, closestNodeRect;
	
			contentEditableFalseNodeRects = Dimensions.getClientRects(getContentEditableFalseChildren(rootNode));
			contentEditableFalseNodeRects = Arr.filter(contentEditableFalseNodeRects, function(clientRect) {
				return clientY >= clientRect.top && clientY <= clientRect.bottom;
			});
	
			closestNodeRect = findClosestClientRect(contentEditableFalseNodeRects, clientX);
			if (closestNodeRect) {
				closestNodeRect = findClosestClientRect(findLineNodeRects(rootNode, closestNodeRect), clientX);
				if (closestNodeRect && isContentEditableFalse(closestNodeRect.node)) {
					return caretInfo(closestNodeRect, clientX);
				}
			}
	
			return null;
		}
	
		return {
			findClosestClientRect: findClosestClientRect,
			findLineNodeRects: findLineNodeRects,
			closestCaret: closestCaret
		};
	});
	
	// Included from: js/tinymce/classes/dom/MousePosition.js
	
	/**
	 * MousePosition.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2016 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This module calculates an absolute coordinate inside the editor body for both local and global mouse events.
	 *
	 * @private
	 * @class tinymce.dom.MousePosition
	 */
	define("tinymce/dom/MousePosition", [
	], function() {
		var getAbsolutePosition = function (elm) {
			var doc, docElem, win, clientRect;
	
			clientRect = elm.getBoundingClientRect();
			doc = elm.ownerDocument;
			docElem = doc.documentElement;
			win = doc.defaultView;
	
			return {
				top: clientRect.top + win.pageYOffset - docElem.clientTop,
				left: clientRect.left + win.pageXOffset - docElem.clientLeft
			};
		};
	
		var getBodyPosition = function (editor) {
			return editor.inline ? getAbsolutePosition(editor.getBody()) : {left: 0, top: 0};
		};
	
		var getScrollPosition = function (editor) {
			var body = editor.getBody();
			return editor.inline ? {left: body.scrollLeft, top: body.scrollTop} : {left: 0, top: 0};
		};
	
		var getBodyScroll = function (editor) {
			var body = editor.getBody(), docElm = editor.getDoc().documentElement;
			var inlineScroll = {left: body.scrollLeft, top: body.scrollTop};
			var iframeScroll = {left: body.scrollLeft || docElm.scrollLeft, top: body.scrollTop || docElm.scrollTop};
	
			return editor.inline ? inlineScroll : iframeScroll;
		};
	
		var getMousePosition = function (editor, event) {
			if (event.target.ownerDocument !== editor.getDoc()) {
				var iframePosition = getAbsolutePosition(editor.getContentAreaContainer());
				var scrollPosition = getBodyScroll(editor);
	
				return {
					left: event.pageX - iframePosition.left + scrollPosition.left,
					top: event.pageY - iframePosition.top + scrollPosition.top
				};
			}
	
			return {
				left: event.pageX,
				top: event.pageY
			};
		};
	
		var calculatePosition = function (bodyPosition, scrollPosition, mousePosition) {
			return {
				pageX: (mousePosition.left - bodyPosition.left) + scrollPosition.left,
				pageY: (mousePosition.top - bodyPosition.top) + scrollPosition.top
			};
		};
	
		var calc = function (editor, event) {
			return calculatePosition(getBodyPosition(editor), getScrollPosition(editor), getMousePosition(editor, event));
		};
	
		return {
			calc: calc
		};
	});
	
	// Included from: js/tinymce/classes/DragDropOverrides.js
	
	/**
	 * DragDropOverrides.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This module contains logic overriding the drag/drop logic of the editor.
	 *
	 * @private
	 * @class tinymce.DragDropOverrides
	 */
	define("tinymce/DragDropOverrides", [
		"tinymce/dom/NodeType",
		"tinymce/util/Arr",
		"tinymce/util/Fun",
		"tinymce/util/Delay",
		"tinymce/dom/DOMUtils",
		"tinymce/dom/MousePosition"
	], function(
		NodeType, Arr, Fun, Delay, DOMUtils, MousePosition
	) {
		var isContentEditableFalse = NodeType.isContentEditableFalse,
			isContentEditableTrue = NodeType.isContentEditableTrue;
	
		var isDraggable = function (elm) {
			return isContentEditableFalse(elm);
		};
	
		var isValidDropTarget = function (editor, targetElement, dragElement) {
			if (targetElement === dragElement || editor.dom.isChildOf(targetElement, dragElement)) {
				return false;
			}
	
			if (isContentEditableFalse(targetElement)) {
				return false;
			}
	
			return true;
		};
	
		var cloneElement = function (elm) {
			var cloneElm = elm.cloneNode(true);
			cloneElm.removeAttribute('data-mce-selected');
			return cloneElm;
		};
	
		var createGhost = function (editor, elm, width, height) {
			var clonedElm = elm.cloneNode(true);
	
			editor.dom.setStyles(clonedElm, {width: width, height: height});
			editor.dom.setAttrib(clonedElm, 'data-mce-selected', null);
	
			var ghostElm = editor.dom.create('div', {
				'class': 'mce-drag-container',
				'data-mce-bogus': 'all',
				unselectable: 'on',
				contenteditable: 'false'
			});
	
			editor.dom.setStyles(ghostElm, {
				position: 'absolute',
				opacity: 0.5,
				overflow: 'hidden',
				border: 0,
				padding: 0,
				margin: 0,
				width: width,
				height: height
			});
	
			editor.dom.setStyles(clonedElm, {
				margin: 0,
				boxSizing: 'border-box'
			});
	
			ghostElm.appendChild(clonedElm);
	
			return ghostElm;
		};
	
		var appendGhostToBody = function (ghostElm, bodyElm) {
			if (ghostElm.parentNode !== bodyElm) {
				bodyElm.appendChild(ghostElm);
			}
		};
	
		var moveGhost = function (ghostElm, position, width, height, maxX, maxY) {
			var overflowX = 0, overflowY = 0;
	
			ghostElm.style.left = position.pageX + 'px';
			ghostElm.style.top = position.pageY + 'px';
	
			if (position.pageX + width > maxX) {
				overflowX = (position.pageX + width) - maxX;
			}
	
			if (position.pageY + height > maxY) {
				overflowY = (position.pageY + height) - maxY;
			}
	
			ghostElm.style.width = (width - overflowX) + 'px';
			ghostElm.style.height = (height - overflowY) + 'px';
		};
	
		var removeElement = function (elm) {
			if (elm && elm.parentNode) {
				elm.parentNode.removeChild(elm);
			}
		};
	
		var isLeftMouseButtonPressed = function (e) {
			return e.button === 0;
		};
	
		var hasDraggableElement = function (state) {
			return state.element;
		};
	
		var applyRelPos = function (state, position) {
			return {
				pageX: position.pageX - state.relX,
				pageY: position.pageY + 5
			};
		};
	
		var start = function (state, editor) {
			return function (e) {
				if (isLeftMouseButtonPressed(e)) {
					var ceElm = Arr.find(editor.dom.getParents(e.target), Fun.or(isContentEditableFalse, isContentEditableTrue));
	
					if (isDraggable(ceElm)) {
						var elmPos = editor.dom.getPos(ceElm);
						var bodyElm = editor.getBody();
						var docElm = editor.getDoc().documentElement;
	
						state.element = ceElm;
						state.screenX = e.screenX;
						state.screenY = e.screenY;
						state.maxX = (editor.inline ? bodyElm.scrollWidth : docElm.offsetWidth) - 2;
						state.maxY = (editor.inline ? bodyElm.scrollHeight : docElm.offsetHeight) - 2;
						state.relX = e.pageX - elmPos.x;
						state.relY = e.pageY - elmPos.y;
						state.width = ceElm.offsetWidth;
						state.height = ceElm.offsetHeight;
						state.ghost = createGhost(editor, ceElm, state.width, state.height);
					}
				}
			};
		};
	
		var move = function (state, editor) {
			// Reduces laggy drag behavior on Gecko
			var throttledPlaceCaretAt = Delay.throttle(function (clientX, clientY) {
				editor._selectionOverrides.hideFakeCaret();
				editor.selection.placeCaretAt(clientX, clientY);
			}, 0);
	
			return function (e) {
				var movement = Math.max(Math.abs(e.screenX - state.screenX), Math.abs(e.screenY - state.screenY));
	
				if (hasDraggableElement(state) && !state.dragging && movement > 10) {
					var args = editor.fire('dragstart', {target: state.element});
					if (args.isDefaultPrevented()) {
						return;
					}
	
					state.dragging = true;
					editor.focus();
				}
	
				if (state.dragging) {
					var targetPos = applyRelPos(state, MousePosition.calc(editor, e));
	
					appendGhostToBody(state.ghost, editor.getBody());
					moveGhost(state.ghost, targetPos, state.width, state.height, state.maxX, state.maxY);
	
					throttledPlaceCaretAt(e.clientX, e.clientY);
				}
			};
		};
	
		// Returns the raw element instead of the fake cE=false element
		var getRawTarget = function (selection) {
			var rng = selection.getSel().getRangeAt(0);
			var startContainer = rng.startContainer;
			return startContainer.nodeType === 3 ? startContainer.parentNode : startContainer;
		};
	
		var drop = function (state, editor) {
			return function (e) {
				if (state.dragging) {
					if (isValidDropTarget(editor, getRawTarget(editor.selection), state.element)) {
						var targetClone = cloneElement(state.element);
	
						var args = editor.fire('drop', {
							targetClone: targetClone,
							clientX: e.clientX,
							clientY: e.clientY
						});
	
						if (!args.isDefaultPrevented()) {
							targetClone = args.targetClone;
	
							editor.undoManager.transact(function() {
								removeElement(state.element);
								editor.insertContent(editor.dom.getOuterHTML(targetClone));
								editor._selectionOverrides.hideFakeCaret();
							});
						}
					}
				}
	
				removeDragState(state);
			};
		};
	
		var stop = function (state, editor) {
			return function () {
				removeDragState(state);
				if (state.dragging) {
					editor.fire('dragend');
				}
			};
		};
	
		var removeDragState = function (state) {
			state.dragging = false;
			state.element = null;
			removeElement(state.ghost);
		};
	
		var bindFakeDragEvents = function (editor) {
			var state = {}, pageDom, dragStartHandler, dragHandler, dropHandler, dragEndHandler, rootDocument;
	
			pageDom = DOMUtils.DOM;
			rootDocument = document;
			dragStartHandler = start(state, editor);
			dragHandler = move(state, editor);
			dropHandler = drop(state, editor);
			dragEndHandler = stop(state, editor);
	
			editor.on('mousedown', dragStartHandler);
			editor.on('mousemove', dragHandler);
			editor.on('mouseup', dropHandler);
	
			pageDom.bind(rootDocument, 'mousemove', dragHandler);
			pageDom.bind(rootDocument, 'mouseup', dragEndHandler);
	
			editor.on('remove', function () {
				pageDom.unbind(rootDocument, 'mousemove', dragHandler);
				pageDom.unbind(rootDocument, 'mouseup', dragEndHandler);
			});
		};
	
		var blockIeDrop = function (editor) {
			editor.on('drop', function(e) {
				// FF doesn't pass out clientX/clientY for drop since this is for IE we just use null instead
				var realTarget = typeof e.clientX !== 'undefined' ? editor.getDoc().elementFromPoint(e.clientX, e.clientY) : null;
	
				if (isContentEditableFalse(realTarget) || isContentEditableFalse(editor.dom.getContentEditableParent(realTarget))) {
					e.preventDefault();
				}
			});
		};
	
		var init = function (editor) {
			bindFakeDragEvents(editor);
			blockIeDrop(editor);
		};
	
		return {
			init: init
		};
	});
	
	// Included from: js/tinymce/classes/SelectionOverrides.js
	
	/**
	 * SelectionOverrides.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This module contains logic overriding the selection with keyboard/mouse
	 * around contentEditable=false regions.
	 *
	 * @example
	 * // Disable the default cE=false selection
	 * tinymce.activeEditor.on('ShowCaret BeforeObjectSelected', function(e) {
	 *     e.preventDefault();
	 * });
	 *
	 * @private
	 * @class tinymce.SelectionOverrides
	 */
	define("tinymce/SelectionOverrides", [
		"tinymce/Env",
		"tinymce/caret/CaretWalker",
		"tinymce/caret/CaretPosition",
		"tinymce/caret/CaretContainer",
		"tinymce/caret/CaretUtils",
		"tinymce/caret/FakeCaret",
		"tinymce/caret/LineWalker",
		"tinymce/caret/LineUtils",
		"tinymce/dom/NodeType",
		"tinymce/dom/RangeUtils",
		"tinymce/geom/ClientRect",
		"tinymce/util/VK",
		"tinymce/util/Fun",
		"tinymce/util/Arr",
		"tinymce/util/Delay",
		"tinymce/DragDropOverrides"
	], function(
		Env, CaretWalker, CaretPosition, CaretContainer, CaretUtils, FakeCaret, LineWalker,
		LineUtils, NodeType, RangeUtils, ClientRect, VK, Fun, Arr, Delay, DragDropOverrides
	) {
		var curry = Fun.curry,
			isContentEditableTrue = NodeType.isContentEditableTrue,
			isContentEditableFalse = NodeType.isContentEditableFalse,
			isElement = NodeType.isElement,
			isAfterContentEditableFalse = CaretUtils.isAfterContentEditableFalse,
			isBeforeContentEditableFalse = CaretUtils.isBeforeContentEditableFalse,
			getSelectedNode = RangeUtils.getSelectedNode;
	
		function getVisualCaretPosition(walkFn, caretPosition) {
			while ((caretPosition = walkFn(caretPosition))) {
				if (caretPosition.isVisible()) {
					return caretPosition;
				}
			}
	
			return caretPosition;
		}
	
		function SelectionOverrides(editor) {
			var rootNode = editor.getBody(), caretWalker = new CaretWalker(rootNode);
			var getNextVisualCaretPosition = curry(getVisualCaretPosition, caretWalker.next);
			var getPrevVisualCaretPosition = curry(getVisualCaretPosition, caretWalker.prev),
				fakeCaret = new FakeCaret(editor.getBody(), isBlock),
				realSelectionId = 'sel-' + editor.dom.uniqueId(),
				selectedContentEditableNode, $ = editor.$;
	
			function isFakeSelectionElement(elm) {
				return editor.dom.hasClass(elm, 'mce-offscreen-selection');
			}
	
			function getRealSelectionElement() {
				var container = editor.dom.get(realSelectionId);
				return container ? container.getElementsByTagName('*')[0] : container;
			}
	
			function isBlock(node) {
				return editor.dom.isBlock(node);
			}
	
			function setRange(range) {
				//console.log('setRange', range);
				if (range) {
					editor.selection.setRng(range);
				}
			}
	
			function getRange() {
				return editor.selection.getRng();
			}
	
			function scrollIntoView(node, alignToTop) {
				editor.selection.scrollIntoView(node, alignToTop);
			}
	
			function showCaret(direction, node, before) {
				var e;
	
				e = editor.fire('ShowCaret', {
					target: node,
					direction: direction,
					before: before
				});
	
				if (e.isDefaultPrevented()) {
					return null;
				}
	
				scrollIntoView(node, direction === -1);
	
				return fakeCaret.show(before, node);
			}
	
			function selectNode(node) {
				var e;
	
				e = editor.fire('BeforeObjectSelected', {target: node});
				if (e.isDefaultPrevented()) {
					return null;
				}
	
				return getNodeRange(node);
			}
	
			function getNodeRange(node) {
				var rng = node.ownerDocument.createRange();
	
				rng.selectNode(node);
	
				return rng;
			}
	
			function isMoveInsideSameBlock(fromCaretPosition, toCaretPosition) {
				var inSameBlock = CaretUtils.isInSameBlock(fromCaretPosition, toCaretPosition);
	
				// Handle bogus BR <p>abc|<br></p>
				if (!inSameBlock && NodeType.isBr(fromCaretPosition.getNode())) {
					return true;
				}
	
				return inSameBlock;
			}
	
			function getNormalizedRangeEndPoint(direction, range) {
				range = CaretUtils.normalizeRange(direction, rootNode, range);
	
				if (direction == -1) {
					return CaretPosition.fromRangeStart(range);
				}
	
				return CaretPosition.fromRangeEnd(range);
			}
	
			function isRangeInCaretContainerBlock(range) {
				return CaretContainer.isCaretContainerBlock(range.startContainer);
			}
	
			function moveToCeFalseHorizontally(direction, getNextPosFn, isBeforeContentEditableFalseFn, range) {
				var node, caretPosition, peekCaretPosition, rangeIsInContainerBlock;
	
				if (!range.collapsed) {
					node = getSelectedNode(range);
					if (isContentEditableFalse(node)) {
						return showCaret(direction, node, direction == -1);
					}
				}
	
				rangeIsInContainerBlock = isRangeInCaretContainerBlock(range);
				caretPosition = getNormalizedRangeEndPoint(direction, range);
	
				if (isBeforeContentEditableFalseFn(caretPosition)) {
					return selectNode(caretPosition.getNode(direction == -1));
				}
	
				caretPosition = getNextPosFn(caretPosition);
				if (!caretPosition) {
					if (rangeIsInContainerBlock) {
						return range;
					}
	
					return null;
				}
	
				if (isBeforeContentEditableFalseFn(caretPosition)) {
					return showCaret(direction, caretPosition.getNode(direction == -1), direction == 1);
				}
	
				// Peek ahead for handling of ab|c<span cE=false> -> abc|<span cE=false>
				peekCaretPosition = getNextPosFn(caretPosition);
				if (isBeforeContentEditableFalseFn(peekCaretPosition)) {
					if (isMoveInsideSameBlock(caretPosition, peekCaretPosition)) {
						return showCaret(direction, peekCaretPosition.getNode(direction == -1), direction == 1);
					}
				}
	
				if (rangeIsInContainerBlock) {
					return renderRangeCaret(caretPosition.toRange());
				}
	
				return null;
			}
	
			function moveToCeFalseVertically(direction, walkerFn, range) {
				var caretPosition, linePositions, nextLinePositions,
					closestNextLineRect, caretClientRect, clientX,
					dist1, dist2, contentEditableFalseNode;
	
				contentEditableFalseNode = getSelectedNode(range);
				caretPosition = getNormalizedRangeEndPoint(direction, range);
				linePositions = walkerFn(rootNode, LineWalker.isAboveLine(1), caretPosition);
				nextLinePositions = Arr.filter(linePositions, LineWalker.isLine(1));
				caretClientRect = Arr.last(caretPosition.getClientRects());
	
				if (isBeforeContentEditableFalse(caretPosition)) {
					contentEditableFalseNode = caretPosition.getNode();
				}
	
				if (isAfterContentEditableFalse(caretPosition)) {
					contentEditableFalseNode = caretPosition.getNode(true);
				}
	
				if (!caretClientRect) {
					return null;
				}
	
				clientX = caretClientRect.left;
	
				closestNextLineRect = LineUtils.findClosestClientRect(nextLinePositions, clientX);
				if (closestNextLineRect) {
					if (isContentEditableFalse(closestNextLineRect.node)) {
						dist1 = Math.abs(clientX - closestNextLineRect.left);
						dist2 = Math.abs(clientX - closestNextLineRect.right);
	
						return showCaret(direction, closestNextLineRect.node, dist1 < dist2);
					}
				}
	
				if (contentEditableFalseNode) {
					var caretPositions = LineWalker.positionsUntil(direction, rootNode, LineWalker.isAboveLine(1), contentEditableFalseNode);
	
					closestNextLineRect = LineUtils.findClosestClientRect(Arr.filter(caretPositions, LineWalker.isLine(1)), clientX);
					if (closestNextLineRect) {
						return renderRangeCaret(closestNextLineRect.position.toRange());
					}
	
					closestNextLineRect = Arr.last(Arr.filter(caretPositions, LineWalker.isLine(0)));
					if (closestNextLineRect) {
						return renderRangeCaret(closestNextLineRect.position.toRange());
					}
				}
			}
	
			function exitPreBlock(direction, range) {
				var pre, caretPos, newBlock;
	
				function createTextBlock() {
					var textBlock = editor.dom.create(editor.settings.forced_root_block);
	
					if (!Env.ie || Env.ie >= 11) {
						textBlock.innerHTML = '<br data-mce-bogus="1">';
					}
	
					return textBlock;
				}
	
				if (range.collapsed && editor.settings.forced_root_block) {
					pre = editor.dom.getParent(range.startContainer, 'PRE');
					if (!pre) {
						return;
					}
	
					if (direction == 1) {
						caretPos = getNextVisualCaretPosition(CaretPosition.fromRangeStart(range));
					} else {
						caretPos = getPrevVisualCaretPosition(CaretPosition.fromRangeStart(range));
					}
	
					if (!caretPos) {
						newBlock = createTextBlock();
	
						if (direction == 1) {
							editor.$(pre).after(newBlock);
						} else {
							editor.$(pre).before(newBlock);
						}
	
						editor.selection.select(newBlock, true);
						editor.selection.collapse();
					}
				}
			}
	
			function moveH(direction, getNextPosFn, isBeforeContentEditableFalseFn, range) {
				var newRange;
	
				newRange = moveToCeFalseHorizontally(direction, getNextPosFn, isBeforeContentEditableFalseFn, range);
				if (newRange) {
					return newRange;
				}
	
				newRange = exitPreBlock(direction, range);
				if (newRange) {
					return newRange;
				}
	
				return null;
			}
	
			function moveV(direction, walkerFn, range) {
				var newRange;
	
				newRange = moveToCeFalseVertically(direction, walkerFn, range);
				if (newRange) {
					return newRange;
				}
	
				newRange = exitPreBlock(direction, range);
				if (newRange) {
					return newRange;
				}
	
				return null;
			}
	
			function getBlockCaretContainer() {
				return $('*[data-mce-caret]')[0];
			}
	
			function showBlockCaretContainer(blockCaretContainer) {
				if (blockCaretContainer.hasAttribute('data-mce-caret')) {
					CaretContainer.showCaretContainerBlock(blockCaretContainer);
					setRange(getRange()); // Removes control rect on IE
					scrollIntoView(blockCaretContainer[0]);
				}
			}
	
			function renderCaretAtRange(range) {
				var caretPosition, ceRoot;
	
				range = CaretUtils.normalizeRange(1, rootNode, range);
				caretPosition = CaretPosition.fromRangeStart(range);
	
				if (isContentEditableFalse(caretPosition.getNode())) {
					return showCaret(1, caretPosition.getNode(), !caretPosition.isAtEnd());
				}
	
				if (isContentEditableFalse(caretPosition.getNode(true))) {
					return showCaret(1, caretPosition.getNode(true), false);
				}
	
				// TODO: Should render caret before/after depending on where you click on the page forces after now
				ceRoot = editor.dom.getParent(caretPosition.getNode(), Fun.or(isContentEditableFalse, isContentEditableTrue));
				if (isContentEditableFalse(ceRoot)) {
					return showCaret(1, ceRoot, false);
				}
	
				return null;
			}
	
			function renderRangeCaret(range) {
				var caretRange;
	
				if (!range || !range.collapsed) {
					return range;
				}
	
				caretRange = renderCaretAtRange(range);
				if (caretRange) {
					return caretRange;
				}
	
				return range;
			}
	
			function deleteContentEditableNode(node) {
				var nextCaretPosition, prevCaretPosition, prevCeFalseElm, nextElement;
	
				if (!isContentEditableFalse(node)) {
					return null;
				}
	
				if (isContentEditableFalse(node.previousSibling)) {
					prevCeFalseElm = node.previousSibling;
				}
	
				prevCaretPosition = getPrevVisualCaretPosition(CaretPosition.before(node));
				if (!prevCaretPosition) {
					nextCaretPosition = getNextVisualCaretPosition(CaretPosition.after(node));
				}
	
				if (nextCaretPosition && isElement(nextCaretPosition.getNode())) {
					nextElement = nextCaretPosition.getNode();
				}
	
				CaretContainer.remove(node.previousSibling);
				CaretContainer.remove(node.nextSibling);
				editor.dom.remove(node);
	
				if (editor.dom.isEmpty(editor.getBody())) {
					editor.setContent('');
					editor.focus();
					return;
				}
	
				if (prevCeFalseElm) {
					return CaretPosition.after(prevCeFalseElm).toRange();
				}
	
				if (nextElement) {
					return CaretPosition.before(nextElement).toRange();
				}
	
				if (prevCaretPosition) {
					return prevCaretPosition.toRange();
				}
	
				if (nextCaretPosition) {
					return nextCaretPosition.toRange();
				}
	
				return null;
			}
	
			function isTextBlock(node) {
				var textBlocks = editor.schema.getTextBlockElements();
				return node.nodeName in textBlocks;
			}
	
			function isEmpty(elm) {
				return editor.dom.isEmpty(elm);
			}
	
			function mergeTextBlocks(direction, fromCaretPosition, toCaretPosition) {
				var dom = editor.dom, fromBlock, toBlock, node, ceTarget;
	
				fromBlock = dom.getParent(fromCaretPosition.getNode(), dom.isBlock);
				toBlock = dom.getParent(toCaretPosition.getNode(), dom.isBlock);
	
				if (direction === -1) {
					ceTarget = toCaretPosition.getNode(true);
					if (isAfterContentEditableFalse(toCaretPosition) && isBlock(ceTarget)) {
						if (isTextBlock(fromBlock)) {
							if (isEmpty(fromBlock)) {
								dom.remove(fromBlock);
							}
	
							return CaretPosition.after(ceTarget).toRange();
						}
	
						return deleteContentEditableNode(toCaretPosition.getNode(true));
					}
				} else {
					ceTarget = fromCaretPosition.getNode();
					if (isBeforeContentEditableFalse(fromCaretPosition) && isBlock(ceTarget)) {
						if (isTextBlock(toBlock)) {
							if (isEmpty(toBlock)) {
								dom.remove(toBlock);
							}
	
							return CaretPosition.before(ceTarget).toRange();
						}
	
						return deleteContentEditableNode(fromCaretPosition.getNode());
					}
				}
	
				// Verify that both blocks are text blocks
				if (fromBlock === toBlock || !isTextBlock(fromBlock) || !isTextBlock(toBlock)) {
					return null;
				}
	
				while ((node = fromBlock.firstChild)) {
					toBlock.appendChild(node);
				}
	
				editor.dom.remove(fromBlock);
	
				return toCaretPosition.toRange();
			}
	
			function backspaceDelete(direction, beforeFn, afterFn, range) {
				var node, caretPosition, peekCaretPosition, newCaretPosition;
	
				if (!range.collapsed) {
					node = getSelectedNode(range);
					if (isContentEditableFalse(node)) {
						return renderRangeCaret(deleteContentEditableNode(node));
					}
				}
	
				caretPosition = getNormalizedRangeEndPoint(direction, range);
	
				if (afterFn(caretPosition) && CaretContainer.isCaretContainerBlock(range.startContainer)) {
					newCaretPosition = direction == -1 ? caretWalker.prev(caretPosition) : caretWalker.next(caretPosition);
					return newCaretPosition ? renderRangeCaret(newCaretPosition.toRange()) : range;
				}
	
				if (beforeFn(caretPosition)) {
					return renderRangeCaret(deleteContentEditableNode(caretPosition.getNode(direction == -1)));
				}
	
				peekCaretPosition = direction == -1 ? caretWalker.prev(caretPosition) : caretWalker.next(caretPosition);
				if (beforeFn(peekCaretPosition)) {
					if (direction === -1) {
						return mergeTextBlocks(direction, caretPosition, peekCaretPosition);
					}
	
					return mergeTextBlocks(direction, peekCaretPosition, caretPosition);
				}
			}
	
			function registerEvents() {
				var right = curry(moveH, 1, getNextVisualCaretPosition, isBeforeContentEditableFalse);
				var left = curry(moveH, -1, getPrevVisualCaretPosition, isAfterContentEditableFalse);
				var deleteForward = curry(backspaceDelete, 1, isBeforeContentEditableFalse, isAfterContentEditableFalse);
				var backspace = curry(backspaceDelete, -1, isAfterContentEditableFalse, isBeforeContentEditableFalse);
				var up = curry(moveV, -1, LineWalker.upUntil);
				var down = curry(moveV, 1, LineWalker.downUntil);
	
				function override(evt, moveFn) {
					var range = moveFn(getRange());
	
					if (range && !evt.isDefaultPrevented()) {
						evt.preventDefault();
						setRange(range);
					}
				}
	
				function getContentEditableRoot(node) {
					var root = editor.getBody();
	
					while (node && node != root) {
						if (isContentEditableTrue(node) || isContentEditableFalse(node)) {
							return node;
						}
	
						node = node.parentNode;
					}
	
					return null;
				}
	
				function isXYWithinRange(clientX, clientY, range) {
					if (range.collapsed) {
						return false;
					}
	
					return Arr.reduce(range.getClientRects(), function(state, rect) {
						return state || ClientRect.containsXY(rect, clientX, clientY);
					}, false);
				}
	
				// Some browsers (Chrome) lets you place the caret after a cE=false
				// Make sure we render the caret container in this case
				editor.on('mouseup', function() {
					var range = getRange();
	
					if (range.collapsed) {
						setRange(renderCaretAtRange(range));
					}
				});
	
				editor.on('click', function(e) {
					var contentEditableRoot;
	
					contentEditableRoot	= getContentEditableRoot(e.target);
					if (contentEditableRoot) {
						// Prevent clicks on links in a cE=false element
						if (isContentEditableFalse(contentEditableRoot)) {
							e.preventDefault();
							editor.focus();
						}
	
						// Removes fake selection if a cE=true is clicked within a cE=false like the toc title
						if (isContentEditableTrue(contentEditableRoot)) {
							if (editor.dom.isChildOf(contentEditableRoot, editor.selection.getNode())) {
								removeContentEditableSelection();
							}
						}
					}
				});
	
				editor.on('blur NewBlock', function () {
					removeContentEditableSelection();
					hideFakeCaret();
				});
	
				function handleTouchSelect(editor) {
					var moved = false;
	
					editor.on('touchstart', function () {
						moved = false;
					});
	
					editor.on('touchmove', function () {
						moved = true;
					});
	
					editor.on('touchend', function (e) {
						var contentEditableRoot	= getContentEditableRoot(e.target);
	
						if (isContentEditableFalse(contentEditableRoot)) {
							if (!moved) {
								e.preventDefault();
								setContentEditableSelection(selectNode(contentEditableRoot));
							}
						}
					});
				}
	
				var hasNormalCaretPosition = function (elm) {
					var caretWalker = new CaretWalker(elm);
	
					if (!elm.firstChild) {
						return false;
					}
	
					var startPos = CaretPosition.before(elm.firstChild);
					var newPos = caretWalker.next(startPos);
	
					return newPos && !isBeforeContentEditableFalse(newPos) && !isAfterContentEditableFalse(newPos);
				};
	
				var isInSameBlock = function (node1, node2) {
					var block1 = editor.dom.getParent(node1, editor.dom.isBlock);
					var block2 = editor.dom.getParent(node2, editor.dom.isBlock);
					return block1 === block2;
				};
	
				var isContentKey = function (e) {
					if (e.keyCode >= 112 && e.keyCode <= 123) {
						return false;
					}
	
					return true;
				};
	
				// Checks if the target node is in a block and if that block has a caret position better than the
				// suggested caretNode this is to prevent the caret from being sucked in towards a cE=false block if
				// they are adjacent on the vertical axis
				var hasBetterMouseTarget = function (targetNode, caretNode) {
					var targetBlock = editor.dom.getParent(targetNode, editor.dom.isBlock);
					var caretBlock = editor.dom.getParent(caretNode, editor.dom.isBlock);
	
					return targetBlock && !isInSameBlock(targetBlock, caretBlock) && hasNormalCaretPosition(targetBlock);
				};
	
				handleTouchSelect(editor);
	
				editor.on('mousedown', function(e) {
					var contentEditableRoot;
	
					contentEditableRoot	= getContentEditableRoot(e.target);
					if (contentEditableRoot) {
						if (isContentEditableFalse(contentEditableRoot)) {
							e.preventDefault();
							setContentEditableSelection(selectNode(contentEditableRoot));
						} else {
							if (!isXYWithinRange(e.clientX, e.clientY, editor.selection.getRng())) {
								editor.selection.placeCaretAt(e.clientX, e.clientY);
							}
						}
					} else {
						// Remove needs to be called here since the mousedown might alter the selection without calling selection.setRng
						// and therefore not fire the AfterSetSelectionRange event.
						removeContentEditableSelection();
						hideFakeCaret();
	
						var caretInfo = LineUtils.closestCaret(rootNode, e.clientX, e.clientY);
						if (caretInfo) {
							if (!hasBetterMouseTarget(e.target, caretInfo.node)) {
								e.preventDefault();
								editor.getBody().focus();
								setRange(showCaret(1, caretInfo.node, caretInfo.before));
							}
						}
					}
				});
	
				editor.on('keydown', function(e) {
					if (VK.modifierPressed(e)) {
						return;
					}
	
					switch (e.keyCode) {
						case VK.RIGHT:
							override(e, right);
							break;
	
						case VK.DOWN:
							override(e, down);
							break;
	
						case VK.LEFT:
							override(e, left);
							break;
	
						case VK.UP:
							override(e, up);
							break;
	
						case VK.DELETE:
							override(e, deleteForward);
							break;
	
						case VK.BACKSPACE:
							override(e, backspace);
							break;
	
						default:
							if (isContentEditableFalse(editor.selection.getNode()) && isContentKey(e)) {
								e.preventDefault();
							}
							break;
					}
				});
	
				function paddEmptyContentEditableArea() {
					var br, ceRoot = getContentEditableRoot(editor.selection.getNode());
	
					if (isContentEditableTrue(ceRoot) && isBlock(ceRoot) && editor.dom.isEmpty(ceRoot)) {
						br = editor.dom.create('br', {"data-mce-bogus": "1"});
						editor.$(ceRoot).empty().append(br);
						editor.selection.setRng(CaretPosition.before(br).toRange());
					}
				}
	
				function handleBlockContainer(e) {
					var blockCaretContainer = getBlockCaretContainer();
	
					if (!blockCaretContainer) {
						return;
					}
	
					if (e.type == 'compositionstart') {
						e.preventDefault();
						e.stopPropagation();
						showBlockCaretContainer(blockCaretContainer);
						return;
					}
	
					if (CaretContainer.hasContent(blockCaretContainer)) {
						showBlockCaretContainer(blockCaretContainer);
					}
				}
	
				function handleEmptyBackspaceDelete(e) {
					var prevent;
	
					switch (e.keyCode) {
						case VK.DELETE:
							prevent = paddEmptyContentEditableArea();
							break;
	
						case VK.BACKSPACE:
							prevent = paddEmptyContentEditableArea();
							break;
					}
	
					if (prevent) {
						e.preventDefault();
					}
				}
	
				// Must be added to "top" since undoManager needs to be executed after
				editor.on('keyup compositionstart', function(e) {
					handleBlockContainer(e);
					handleEmptyBackspaceDelete(e);
				}, true);
	
				editor.on('cut', function() {
					var node = editor.selection.getNode();
	
					if (isContentEditableFalse(node)) {
						Delay.setEditorTimeout(editor, function() {
							setRange(renderRangeCaret(deleteContentEditableNode(node)));
						});
					}
				});
	
				editor.on('getSelectionRange', function(e) {
					var rng = e.range;
	
					if (selectedContentEditableNode) {
						if (!selectedContentEditableNode.parentNode) {
							selectedContentEditableNode = null;
							return;
						}
	
						rng = rng.cloneRange();
						rng.selectNode(selectedContentEditableNode);
						e.range = rng;
					}
				});
	
				editor.on('setSelectionRange', function(e) {
					var rng;
	
					rng = setContentEditableSelection(e.range);
					if (rng) {
						e.range = rng;
					}
				});
	
				editor.on('AfterSetSelectionRange', function(e) {
					var rng = e.range;
	
					if (!isRangeInCaretContainer(rng)) {
						hideFakeCaret();
					}
	
					if (!isFakeSelectionElement(rng.startContainer.parentNode)) {
						removeContentEditableSelection();
					}
				});
	
				editor.on('focus', function() {
					// Make sure we have a proper fake caret on focus
					Delay.setEditorTimeout(editor, function() {
						editor.selection.setRng(renderRangeCaret(editor.selection.getRng()));
					}, 0);
				});
	
				editor.on('copy', function (e) {
					var clipboardData = e.clipboardData;
	
					// Make sure we get proper html/text for the fake cE=false selection
					// Doesn't work at all on Edge since it doesn't have proper clipboardData support
					if (!e.isDefaultPrevented() && e.clipboardData && !Env.ie) {
						var realSelectionElement = getRealSelectionElement();
						if (realSelectionElement) {
							e.preventDefault();
							clipboardData.clearData();
							clipboardData.setData('text/html', realSelectionElement.outerHTML);
							clipboardData.setData('text/plain', realSelectionElement.outerText);
						}
					}
				});
	
				DragDropOverrides.init(editor);
			}
	
			function addCss() {
				var styles = editor.contentStyles, rootClass = '.mce-content-body';
	
				styles.push(fakeCaret.getCss());
				styles.push(
					rootClass + ' .mce-offscreen-selection {' +
						'position: absolute;' +
						'left: -9999999999px;' +
					'}' +
					rootClass + ' *[contentEditable=false] {' +
						'cursor: default;' +
					'}' +
					rootClass + ' *[contentEditable=true] {' +
						'cursor: text;' +
					'}'
				);
			}
	
			function isRangeInCaretContainer(rng) {
				return CaretContainer.isCaretContainer(rng.startContainer) || CaretContainer.isCaretContainer(rng.endContainer);
			}
	
			function setContentEditableSelection(range) {
				var node, $ = editor.$, dom = editor.dom, $realSelectionContainer, sel,
					startContainer, startOffset, endOffset, e, caretPosition, targetClone, origTargetClone;
	
				if (!range) {
					return null;
				}
	
				if (range.collapsed) {
					if (!isRangeInCaretContainer(range)) {
						caretPosition = getNormalizedRangeEndPoint(1, range);
	
						if (isContentEditableFalse(caretPosition.getNode())) {
							return showCaret(1, caretPosition.getNode(), !caretPosition.isAtEnd());
						}
	
						if (isContentEditableFalse(caretPosition.getNode(true))) {
							return showCaret(1, caretPosition.getNode(true), false);
						}
					}
	
					return null;
				}
	
				startContainer = range.startContainer;
				startOffset = range.startOffset;
				endOffset = range.endOffset;
	
				// Normalizes <span cE=false>[</span>] to [<span cE=false></span>]
				if (startContainer.nodeType == 3 && startOffset == 0 && isContentEditableFalse(startContainer.parentNode)) {
					startContainer = startContainer.parentNode;
					startOffset = dom.nodeIndex(startContainer);
					startContainer = startContainer.parentNode;
				}
	
				if (startContainer.nodeType != 1) {
					return null;
				}
	
				if (endOffset == startOffset + 1) {
					node = startContainer.childNodes[startOffset];
				}
	
				if (!isContentEditableFalse(node)) {
					return null;
				}
	
				targetClone = origTargetClone = node.cloneNode(true);
				e = editor.fire('ObjectSelected', {target: node, targetClone: targetClone});
				if (e.isDefaultPrevented()) {
					return null;
				}
	
				targetClone = e.targetClone;
				$realSelectionContainer = $('#' + realSelectionId);
				if ($realSelectionContainer.length === 0) {
					$realSelectionContainer = $(
						'<div data-mce-bogus="all" class="mce-offscreen-selection"></div>'
					).attr('id', realSelectionId);
	
					$realSelectionContainer.appendTo(editor.getBody());
				}
	
				range = editor.dom.createRng();
	
				// WHY is IE making things so hard! Copy on <i contentEditable="false">x</i> produces: <em>x</em>
				// This is a ridiculous hack where we place the selection from a block over the inline element
				// so that just the inline element is copied as is and not converted.
				if (targetClone === origTargetClone && Env.ie) {
					$realSelectionContainer.empty().append('<p style="font-size: 0" data-mce-bogus="all">\u00a0</p>').append(targetClone);
					range.setStartAfter($realSelectionContainer[0].firstChild.firstChild);
					range.setEndAfter(targetClone);
				} else {
					$realSelectionContainer.empty().append('\u00a0').append(targetClone).append('\u00a0');
					range.setStart($realSelectionContainer[0].firstChild, 1);
					range.setEnd($realSelectionContainer[0].lastChild, 0);
				}
	
				$realSelectionContainer.css({
					top: dom.getPos(node, editor.getBody()).y
				});
	
				$realSelectionContainer[0].focus();
				sel = editor.selection.getSel();
				sel.removeAllRanges();
				sel.addRange(range);
	
				editor.$('*[data-mce-selected]').removeAttr('data-mce-selected');
				node.setAttribute('data-mce-selected', 1);
				selectedContentEditableNode = node;
	
				return range;
			}
	
			function removeContentEditableSelection() {
				if (selectedContentEditableNode) {
					selectedContentEditableNode.removeAttribute('data-mce-selected');
					editor.$('#' + realSelectionId).remove();
					selectedContentEditableNode = null;
				}
			}
	
			function destroy() {
				fakeCaret.destroy();
				selectedContentEditableNode = null;
			}
	
			function hideFakeCaret() {
				fakeCaret.hide();
			}
	
			if (Env.ceFalse) {
				registerEvents();
				addCss();
			}
	
			return {
				showBlockCaretContainer: showBlockCaretContainer,
				hideFakeCaret: hideFakeCaret,
				destroy: destroy
			};
		}
	
		return SelectionOverrides;
	});
	
	// Included from: js/tinymce/classes/util/Uuid.js
	
	/**
	 * Uuid.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2016 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Generates unique ids.
	 *
	 * @class tinymce.util.Uuid
	 * @private
	 */
	define("tinymce/util/Uuid", [
	], function() {
		var count = 0;
	
		var seed = function () {
			var rnd = function () {
				return Math.round(Math.random() * 0xFFFFFFFF).toString(36);
			};
	
			var now = new Date().getTime();
			return 's' + now.toString(36) + rnd() + rnd() + rnd();
		};
	
		var uuid = function (prefix) {
			return prefix + (count++) + seed();
		};
	
		return {
			uuid: uuid
		};
	});
	
	// Included from: js/tinymce/classes/ui/Sidebar.js
	
	/**
	 * Sidebar.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This module handle sidebar instances for the editor.
	 *
	 * @class tinymce.ui.Sidebar
	 * @private
	 */
	define("tinymce/ui/Sidebar", [
	], function(
	) {
		var add = function (editor, name, settings) {
			var sidebars = editor.sidebars ? editor.sidebars : [];
			sidebars.push({name: name, settings: settings});
			editor.sidebars = sidebars;
		};
	
		return {
			add: add
		};
	});
	
	// Included from: js/tinymce/classes/Editor.js
	
	/**
	 * Editor.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/*jshint scripturl:true */
	
	/**
	 * Include the base event class documentation.
	 *
	 * @include ../../../tools/docs/tinymce.Event.js
	 */
	
	/**
	 * This class contains the core logic for a TinyMCE editor.
	 *
	 * @class tinymce.Editor
	 * @mixes tinymce.util.Observable
	 * @example
	 * // Add a class to all paragraphs in the editor.
	 * tinymce.activeEditor.dom.addClass(tinymce.activeEditor.dom.select('p'), 'someclass');
	 *
	 * // Gets the current editors selection as text
	 * tinymce.activeEditor.selection.getContent({format: 'text'});
	 *
	 * // Creates a new editor instance
	 * var ed = new tinymce.Editor('textareaid', {
	 *     some_setting: 1
	 * }, tinymce.EditorManager);
	 *
	 * // Select each item the user clicks on
	 * ed.on('click', function(e) {
	 *     ed.selection.select(e.target);
	 * });
	 *
	 * ed.render();
	 */
	define("tinymce/Editor", [
		"tinymce/dom/DOMUtils",
		"tinymce/dom/DomQuery",
		"tinymce/AddOnManager",
		"tinymce/NodeChange",
		"tinymce/html/Node",
		"tinymce/dom/Serializer",
		"tinymce/html/Serializer",
		"tinymce/dom/Selection",
		"tinymce/Formatter",
		"tinymce/UndoManager",
		"tinymce/EnterKey",
		"tinymce/ForceBlocks",
		"tinymce/EditorCommands",
		"tinymce/util/URI",
		"tinymce/dom/ScriptLoader",
		"tinymce/dom/EventUtils",
		"tinymce/WindowManager",
		"tinymce/NotificationManager",
		"tinymce/html/Schema",
		"tinymce/html/DomParser",
		"tinymce/util/Quirks",
		"tinymce/Env",
		"tinymce/util/Tools",
		"tinymce/util/Delay",
		"tinymce/EditorObservable",
		"tinymce/Mode",
		"tinymce/Shortcuts",
		"tinymce/EditorUpload",
		"tinymce/SelectionOverrides",
		"tinymce/util/Uuid",
		"tinymce/ui/Sidebar"
	], function(
		DOMUtils, DomQuery, AddOnManager, NodeChange, Node, DomSerializer, Serializer,
		Selection, Formatter, UndoManager, EnterKey, ForceBlocks, EditorCommands,
		URI, ScriptLoader, EventUtils, WindowManager, NotificationManager,
		Schema, DomParser, Quirks, Env, Tools, Delay, EditorObservable, Mode, Shortcuts, EditorUpload,
		SelectionOverrides, Uuid, Sidebar
	) {
		// Shorten these names
		var DOM = DOMUtils.DOM, ThemeManager = AddOnManager.ThemeManager, PluginManager = AddOnManager.PluginManager;
		var extend = Tools.extend, each = Tools.each, explode = Tools.explode;
		var inArray = Tools.inArray, trim = Tools.trim, resolve = Tools.resolve;
		var Event = EventUtils.Event;
		var isGecko = Env.gecko, ie = Env.ie;
	
		/**
		 * Include documentation for all the events.
		 *
		 * @include ../../../tools/docs/tinymce.Editor.js
		 */
	
		/**
		 * Constructs a editor instance by id.
		 *
		 * @constructor
		 * @method Editor
		 * @param {String} id Unique id for the editor.
		 * @param {Object} settings Settings for the editor.
		 * @param {tinymce.EditorManager} editorManager EditorManager instance.
		 */
		function Editor(id, settings, editorManager) {
			var self = this, documentBaseUrl, baseUri, defaultSettings;
	
			documentBaseUrl = self.documentBaseUrl = editorManager.documentBaseURL;
			baseUri = editorManager.baseURI;
			defaultSettings = editorManager.defaultSettings;
	
			/**
			 * Name/value collection with editor settings.
			 *
			 * @property settings
			 * @type Object
			 * @example
			 * // Get the value of the theme setting
			 * tinymce.activeEditor.windowManager.alert("You are using the " + tinymce.activeEditor.settings.theme + " theme");
			 */
			settings = extend({
				id: id,
				theme: 'modern',
				delta_width: 0,
				delta_height: 0,
				popup_css: '',
				plugins: '',
				document_base_url: documentBaseUrl,
				add_form_submit_trigger: true,
				submit_patch: true,
				add_unload_trigger: true,
				convert_urls: true,
				relative_urls: true,
				remove_script_host: true,
				object_resizing: true,
				doctype: '<!DOCTYPE html>',
				visual: true,
				font_size_style_values: 'xx-small,x-small,small,medium,large,x-large,xx-large',
	
				// See: http://www.w3.org/TR/CSS2/fonts.html#propdef-font-size
				font_size_legacy_values: 'xx-small,small,medium,large,x-large,xx-large,300%',
				forced_root_block: 'p',
				hidden_input: true,
				padd_empty_editor: true,
				render_ui: true,
				indentation: '30px',
				inline_styles: true,
				convert_fonts_to_spans: true,
				indent: 'simple',
				indent_before: 'p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,th,ul,ol,li,dl,dt,dd,area,table,thead,' +
					'tfoot,tbody,tr,section,article,hgroup,aside,figure,figcaption,option,optgroup,datalist',
				indent_after: 'p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,th,ul,ol,li,dl,dt,dd,area,table,thead,' +
					'tfoot,tbody,tr,section,article,hgroup,aside,figure,figcaption,option,optgroup,datalist',
				validate: true,
				entity_encoding: 'named',
				url_converter: self.convertURL,
				url_converter_scope: self,
				ie7_compat: true
			}, defaultSettings, settings);
	
			// Merge external_plugins
			if (defaultSettings && defaultSettings.external_plugins && settings.external_plugins) {
				settings.external_plugins = extend({}, defaultSettings.external_plugins, settings.external_plugins);
			}
	
			self.settings = settings;
			AddOnManager.language = settings.language || 'en';
			AddOnManager.languageLoad = settings.language_load;
			AddOnManager.baseURL = editorManager.baseURL;
	
			/**
			 * Editor instance id, normally the same as the div/textarea that was replaced.
			 *
			 * @property id
			 * @type String
			 */
			self.id = settings.id = id;
	
			/**
			 * State to force the editor to return false on a isDirty call.
			 *
			 * @property isNotDirty
			 * @type Boolean
			 * @deprecated Use editor.setDirty instead.
			 */
			self.setDirty(false);
	
			/**
			 * Name/Value object containing plugin instances.
			 *
			 * @property plugins
			 * @type Object
			 * @example
			 * // Execute a method inside a plugin directly
			 * tinymce.activeEditor.plugins.someplugin.someMethod();
			 */
			self.plugins = {};
	
			/**
			 * URI object to document configured for the TinyMCE instance.
			 *
			 * @property documentBaseURI
			 * @type tinymce.util.URI
			 * @example
			 * // Get relative URL from the location of document_base_url
			 * tinymce.activeEditor.documentBaseURI.toRelative('/somedir/somefile.htm');
			 *
			 * // Get absolute URL from the location of document_base_url
			 * tinymce.activeEditor.documentBaseURI.toAbsolute('somefile.htm');
			 */
			self.documentBaseURI = new URI(settings.document_base_url || documentBaseUrl, {
				base_uri: baseUri
			});
	
			/**
			 * URI object to current document that holds the TinyMCE editor instance.
			 *
			 * @property baseURI
			 * @type tinymce.util.URI
			 * @example
			 * // Get relative URL from the location of the API
			 * tinymce.activeEditor.baseURI.toRelative('/somedir/somefile.htm');
			 *
			 * // Get absolute URL from the location of the API
			 * tinymce.activeEditor.baseURI.toAbsolute('somefile.htm');
			 */
			self.baseURI = baseUri;
	
			/**
			 * Array with CSS files to load into the iframe.
			 *
			 * @property contentCSS
			 * @type Array
			 */
			self.contentCSS = [];
	
			/**
			 * Array of CSS styles to add to head of document when the editor loads.
			 *
			 * @property contentStyles
			 * @type Array
			 */
			self.contentStyles = [];
	
			// Creates all events like onClick, onSetContent etc see Editor.Events.js for the actual logic
			self.shortcuts = new Shortcuts(self);
			self.loadedCSS = {};
			self.editorCommands = new EditorCommands(self);
			self.suffix = editorManager.suffix;
			self.editorManager = editorManager;
			self.inline = settings.inline;
			self.settings.content_editable = self.inline;
	
			if (settings.cache_suffix) {
				Env.cacheSuffix = settings.cache_suffix.replace(/^[\?\&]+/, '');
			}
	
			if (settings.override_viewport === false) {
				Env.overrideViewPort = false;
			}
	
			// Call setup
			editorManager.fire('SetupEditor', self);
			self.execCallback('setup', self);
	
			/**
			 * Dom query instance with default scope to the editor document and default element is the body of the editor.
			 *
			 * @property $
			 * @type tinymce.dom.DomQuery
			 * @example
			 * tinymce.activeEditor.$('p').css('color', 'red');
			 * tinymce.activeEditor.$().append('<p>new</p>');
			 */
			self.$ = DomQuery.overrideDefaults(function() {
				return {
					context: self.inline ? self.getBody() : self.getDoc(),
					element: self.getBody()
				};
			});
		}
	
		Editor.prototype = {
			/**
			 * Renders the editor/adds it to the page.
			 *
			 * @method render
			 */
			render: function() {
				var self = this, settings = self.settings, id = self.id, suffix = self.suffix;
	
				function readyHandler() {
					DOM.unbind(window, 'ready', readyHandler);
					self.render();
				}
	
				// Page is not loaded yet, wait for it
				if (!Event.domLoaded) {
					DOM.bind(window, 'ready', readyHandler);
					return;
				}
	
				// Element not found, then skip initialization
				if (!self.getElement()) {
					return;
				}
	
				// No editable support old iOS versions etc
				if (!Env.contentEditable) {
					return;
				}
	
				// Hide target element early to prevent content flashing
				if (!settings.inline) {
					self.orgVisibility = self.getElement().style.visibility;
					self.getElement().style.visibility = 'hidden';
				} else {
					self.inline = true;
				}
	
				var form = self.getElement().form || DOM.getParent(id, 'form');
				if (form) {
					self.formElement = form;
	
					// Add hidden input for non input elements inside form elements
					if (settings.hidden_input && !/TEXTAREA|INPUT/i.test(self.getElement().nodeName)) {
						DOM.insertAfter(DOM.create('input', {type: 'hidden', name: id}), id);
						self.hasHiddenInput = true;
					}
	
					// Pass submit/reset from form to editor instance
					self.formEventDelegate = function(e) {
						self.fire(e.type, e);
					};
	
					DOM.bind(form, 'submit reset', self.formEventDelegate);
	
					// Reset contents in editor when the form is reset
					self.on('reset', function() {
						self.setContent(self.startContent, {format: 'raw'});
					});
	
					// Check page uses id="submit" or name="submit" for it's submit button
					if (settings.submit_patch && !form.submit.nodeType && !form.submit.length && !form._mceOldSubmit) {
						form._mceOldSubmit = form.submit;
						form.submit = function() {
							self.editorManager.triggerSave();
							self.setDirty(false);
	
							return form._mceOldSubmit(form);
						};
					}
				}
	
				/**
				 * Window manager reference, use this to open new windows and dialogs.
				 *
				 * @property windowManager
				 * @type tinymce.WindowManager
				 * @example
				 * // Shows an alert message
				 * tinymce.activeEditor.windowManager.alert('Hello world!');
				 *
				 * // Opens a new dialog with the file.htm file and the size 320x240
				 * // It also adds a custom parameter this can be retrieved by using tinyMCEPopup.getWindowArg inside the dialog.
				 * tinymce.activeEditor.windowManager.open({
				 *    url: 'file.htm',
				 *    width: 320,
				 *    height: 240
				 * }, {
				 *    custom_param: 1
				 * });
				 */
				self.windowManager = new WindowManager(self);
	
				/**
				 * Notification manager reference, use this to open new windows and dialogs.
				 *
				 * @property notificationManager
				 * @type tinymce.NotificationManager
				 * @example
				 * // Shows a notification info message.
				 * tinymce.activeEditor.notificationManager.open({text: 'Hello world!', type: 'info'});
				 */
				self.notificationManager = new NotificationManager(self);
	
				if (settings.encoding == 'xml') {
					self.on('GetContent', function(e) {
						if (e.save) {
							e.content = DOM.encode(e.content);
						}
					});
				}
	
				if (settings.add_form_submit_trigger) {
					self.on('submit', function() {
						if (self.initialized) {
							self.save();
						}
					});
				}
	
				if (settings.add_unload_trigger) {
					self._beforeUnload = function() {
						if (self.initialized && !self.destroyed && !self.isHidden()) {
							self.save({format: 'raw', no_events: true, set_dirty: false});
						}
					};
	
					self.editorManager.on('BeforeUnload', self._beforeUnload);
				}
	
				// Load scripts
				function loadScripts() {
					var scriptLoader = ScriptLoader.ScriptLoader;
	
					if (settings.language && settings.language != 'en' && !settings.language_url) {
						settings.language_url = self.editorManager.baseURL + '/langs/' + settings.language + '.js';
					}
	
					if (settings.language_url) {
						scriptLoader.add(settings.language_url);
					}
	
					if (settings.theme && typeof settings.theme != "function" &&
						settings.theme.charAt(0) != '-' && !ThemeManager.urls[settings.theme]) {
						var themeUrl = settings.theme_url;
	
						if (themeUrl) {
							themeUrl = self.documentBaseURI.toAbsolute(themeUrl);
						} else {
							themeUrl = 'themes/' + settings.theme + '/theme' + suffix + '.js';
						}
	
						ThemeManager.load(settings.theme, themeUrl);
					}
	
					if (Tools.isArray(settings.plugins)) {
						settings.plugins = settings.plugins.join(' ');
					}
	
					each(settings.external_plugins, function(url, name) {
						PluginManager.load(name, url);
						settings.plugins += ' ' + name;
					});
	
					each(settings.plugins.split(/[ ,]/), function(plugin) {
						plugin = trim(plugin);
	
						if (plugin && !PluginManager.urls[plugin]) {
							if (plugin.charAt(0) == '-') {
								plugin = plugin.substr(1, plugin.length);
	
								var dependencies = PluginManager.dependencies(plugin);
	
								each(dependencies, function(dep) {
									var defaultSettings = {
										prefix: 'plugins/',
										resource: dep,
										suffix: '/plugin' + suffix + '.js'
									};
	
									dep = PluginManager.createUrl(defaultSettings, dep);
									PluginManager.load(dep.resource, dep);
								});
							} else {
								PluginManager.load(plugin, {
									prefix: 'plugins/',
									resource: plugin,
									suffix: '/plugin' + suffix + '.js'
								});
							}
						}
					});
	
					scriptLoader.loadQueue(function() {
						if (!self.removed) {
							self.init();
						}
					});
				}
	
				self.editorManager.add(self);
				loadScripts();
			},
	
			/**
			 * Initializes the editor this will be called automatically when
			 * all plugins/themes and language packs are loaded by the rendered method.
			 * This method will setup the iframe and create the theme and plugin instances.
			 *
			 * @method init
			 */
			init: function() {
				var self = this, settings = self.settings, elm = self.getElement();
				var w, h, minHeight, n, o, Theme, url, bodyId, bodyClass, re, i, initializedPlugins = [];
	
				self.rtl = settings.rtl_ui || self.editorManager.i18n.rtl;
				self.editorManager.i18n.setCode(settings.language);
				settings.aria_label = settings.aria_label || DOM.getAttrib(elm, 'aria-label', self.getLang('aria.rich_text_area'));
	
				self.fire('ScriptsLoaded');
	
				/**
				 * Reference to the theme instance that was used to generate the UI.
				 *
				 * @property theme
				 * @type tinymce.Theme
				 * @example
				 * // Executes a method on the theme directly
				 * tinymce.activeEditor.theme.someMethod();
				 */
				if (settings.theme) {
					if (typeof settings.theme != "function") {
						settings.theme = settings.theme.replace(/-/, '');
						Theme = ThemeManager.get(settings.theme);
						self.theme = new Theme(self, ThemeManager.urls[settings.theme]);
	
						if (self.theme.init) {
							self.theme.init(self, ThemeManager.urls[settings.theme] || self.documentBaseUrl.replace(/\/$/, ''), self.$);
						}
					} else {
						self.theme = settings.theme;
					}
				}
	
				function initPlugin(plugin) {
					var Plugin = PluginManager.get(plugin), pluginUrl, pluginInstance;
	
					pluginUrl = PluginManager.urls[plugin] || self.documentBaseUrl.replace(/\/$/, '');
					plugin = trim(plugin);
					if (Plugin && inArray(initializedPlugins, plugin) === -1) {
						each(PluginManager.dependencies(plugin), function(dep) {
							initPlugin(dep);
						});
	
						if (self.plugins[plugin]) {
							return;
						}
	
						pluginInstance = new Plugin(self, pluginUrl, self.$);
	
						self.plugins[plugin] = pluginInstance;
	
						if (pluginInstance.init) {
							pluginInstance.init(self, pluginUrl);
							initializedPlugins.push(plugin);
						}
					}
				}
	
				// Create all plugins
				each(settings.plugins.replace(/\-/g, '').split(/[ ,]/), initPlugin);
	
				// Measure box
				if (settings.render_ui && self.theme) {
					self.orgDisplay = elm.style.display;
	
					if (typeof settings.theme != "function") {
						w = settings.width || elm.style.width || elm.offsetWidth;
						h = settings.height || elm.style.height || elm.offsetHeight;
						minHeight = settings.min_height || 100;
						re = /^[0-9\.]+(|px)$/i;
	
						if (re.test('' + w)) {
							w = Math.max(parseInt(w, 10), 100);
						}
	
						if (re.test('' + h)) {
							h = Math.max(parseInt(h, 10), minHeight);
						}
	
						// Render UI
						o = self.theme.renderUI({
							targetNode: elm,
							width: w,
							height: h,
							deltaWidth: settings.delta_width,
							deltaHeight: settings.delta_height
						});
	
						// Resize editor
						if (!settings.content_editable) {
							h = (o.iframeHeight || h) + (typeof h == 'number' ? (o.deltaHeight || 0) : '');
							if (h < minHeight) {
								h = minHeight;
							}
						}
					} else {
						o = settings.theme(self, elm);
	
						if (o.editorContainer.nodeType) {
							o.editorContainer.id = o.editorContainer.id || self.id + "_parent";
						}
	
						if (o.iframeContainer.nodeType) {
							o.iframeContainer.id = o.iframeContainer.id || self.id + "_iframecontainer";
						}
	
						// Use specified iframe height or the targets offsetHeight
						h = o.iframeHeight || elm.offsetHeight;
					}
	
					self.editorContainer = o.editorContainer;
				}
	
				// Load specified content CSS last
				if (settings.content_css) {
					each(explode(settings.content_css), function(u) {
						self.contentCSS.push(self.documentBaseURI.toAbsolute(u));
					});
				}
	
				// Load specified content CSS last
				if (settings.content_style) {
					self.contentStyles.push(settings.content_style);
				}
	
				// Content editable mode ends here
				if (settings.content_editable) {
					elm = n = o = null; // Fix IE leak
					return self.initContentBody();
				}
	
				self.iframeHTML = settings.doctype + '<html><head>';
	
				// We only need to override paths if we have to
				// IE has a bug where it remove site absolute urls to relative ones if this is specified
				if (settings.document_base_url != self.documentBaseUrl) {
					self.iframeHTML += '<base href="' + self.documentBaseURI.getURI() + '" />';
				}
	
				// IE8 doesn't support carets behind images setting ie7_compat would force IE8+ to run in IE7 compat mode.
				if (!Env.caretAfter && settings.ie7_compat) {
					self.iframeHTML += '<meta http-equiv="X-UA-Compatible" content="IE=7" />';
				}
	
				self.iframeHTML += '<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />';
	
				// Load the CSS by injecting them into the HTML this will reduce "flicker"
				// However we can't do that on Chrome since # will scroll to the editor for some odd reason see #2427
				if (!/#$/.test(document.location.href)) {
					for (i = 0; i < self.contentCSS.length; i++) {
						var cssUrl = self.contentCSS[i];
						self.iframeHTML += (
							'<link type="text/css" ' +
								'rel="stylesheet" ' +
								'href="' + Tools._addCacheSuffix(cssUrl) + '" />'
						);
						self.loadedCSS[cssUrl] = true;
					}
				}
	
				bodyId = settings.body_id || 'tinymce';
				if (bodyId.indexOf('=') != -1) {
					bodyId = self.getParam('body_id', '', 'hash');
					bodyId = bodyId[self.id] || bodyId;
				}
	
				bodyClass = settings.body_class || '';
				if (bodyClass.indexOf('=') != -1) {
					bodyClass = self.getParam('body_class', '', 'hash');
					bodyClass = bodyClass[self.id] || '';
				}
	
				if (settings.content_security_policy) {
					self.iframeHTML += '<meta http-equiv="Content-Security-Policy" content="' + settings.content_security_policy + '" />';
				}
	
				self.iframeHTML += '</head><body id="' + bodyId +
					'" class="mce-content-body ' + bodyClass +
					'" data-id="' + self.id + '"><br></body></html>';
	
				/*eslint no-script-url:0 */
				var domainRelaxUrl = 'javascript:(function(){' +
					'document.open();document.domain="' + document.domain + '";' +
					'var ed = window.parent.tinymce.get("' + self.id + '");document.write(ed.iframeHTML);' +
					'document.close();ed.initContentBody(true);})()';
	
				// Domain relaxing is required since the user has messed around with document.domain
				if (document.domain != location.hostname) {
					// Edge seems to be able to handle domain relaxing
					if (Env.ie && Env.ie < 12) {
						url = domainRelaxUrl;
					}
				}
	
				// Create iframe
				// TODO: ACC add the appropriate description on this.
				var ifr = DOM.create('iframe', {
					id: self.id + "_ifr",
					//src: url || 'javascript:""', // Workaround for HTTPS warning in IE6/7
					frameBorder: '0',
					allowTransparency: "true",
					title: self.editorManager.translate(
							"Rich Text Area. Press ALT-F9 for menu. " +
							"Press ALT-F10 for toolbar. Press ALT-0 for help"
					),
					style: {
						width: '100%',
						height: h,
						display: 'block' // Important for Gecko to render the iframe correctly
					}
				});
	
				ifr.onload = function() {
					ifr.onload = null;
					self.fire("load");
				};
	
				DOM.setAttrib(ifr, "src", url || 'javascript:""');
	
				self.contentAreaContainer = o.iframeContainer;
				self.iframeElement = ifr;
	
				n = DOM.add(o.iframeContainer, ifr);
	
				// Try accessing the document this will fail on IE when document.domain is set to the same as location.hostname
				// Then we have to force domain relaxing using the domainRelaxUrl approach very ugly!!
				if (ie) {
					try {
						self.getDoc();
					} catch (e) {
						n.src = url = domainRelaxUrl;
					}
				}
	
				if (o.editorContainer) {
					DOM.get(o.editorContainer).style.display = self.orgDisplay;
					self.hidden = DOM.isHidden(o.editorContainer);
				}
	
				self.getElement().style.display = 'none';
				DOM.setAttrib(self.id, 'aria-hidden', true);
	
				if (!url) {
					self.initContentBody();
				}
	
				elm = n = o = null; // Cleanup
			},
	
			/**
			 * This method get called by the init method once the iframe is loaded.
			 * It will fill the iframe with contents, sets up DOM and selection objects for the iframe.
			 *
			 * @method initContentBody
			 * @private
			 */
			initContentBody: function(skipWrite) {
				var self = this, settings = self.settings, targetElm = self.getElement(), doc = self.getDoc(), body, contentCssText;
	
				// Restore visibility on target element
				if (!settings.inline) {
					self.getElement().style.visibility = self.orgVisibility;
				}
	
				// Setup iframe body
				if (!skipWrite && !settings.content_editable) {
					doc.open();
					doc.write(self.iframeHTML);
					doc.close();
				}
	
				if (settings.content_editable) {
					self.on('remove', function() {
						var bodyEl = this.getBody();
	
						DOM.removeClass(bodyEl, 'mce-content-body');
						DOM.removeClass(bodyEl, 'mce-edit-focus');
						DOM.setAttrib(bodyEl, 'contentEditable', null);
					});
	
					DOM.addClass(targetElm, 'mce-content-body');
					self.contentDocument = doc = settings.content_document || document;
					self.contentWindow = settings.content_window || window;
					self.bodyElement = targetElm;
	
					// Prevent leak in IE
					settings.content_document = settings.content_window = null;
	
					// TODO: Fix this
					settings.root_name = targetElm.nodeName.toLowerCase();
				}
	
				// It will not steal focus while setting contentEditable
				body = self.getBody();
				body.disabled = true;
				self.readonly = settings.readonly;
	
				if (!self.readonly) {
					if (self.inline && DOM.getStyle(body, 'position', true) == 'static') {
						body.style.position = 'relative';
					}
	
					body.contentEditable = self.getParam('content_editable_state', true);
				}
	
				body.disabled = false;
	
				self.editorUpload = new EditorUpload(self);
	
				/**
				 * Schema instance, enables you to validate elements and its children.
				 *
				 * @property schema
				 * @type tinymce.html.Schema
				 */
				self.schema = new Schema(settings);
	
				/**
				 * DOM instance for the editor.
				 *
				 * @property dom
				 * @type tinymce.dom.DOMUtils
				 * @example
				 * // Adds a class to all paragraphs within the editor
				 * tinymce.activeEditor.dom.addClass(tinymce.activeEditor.dom.select('p'), 'someclass');
				 */
				self.dom = new DOMUtils(doc, {
					keep_values: true,
					url_converter: self.convertURL,
					url_converter_scope: self,
					hex_colors: settings.force_hex_style_colors,
					class_filter: settings.class_filter,
					update_styles: true,
					root_element: self.inline ? self.getBody() : null,
					collect: settings.content_editable,
					schema: self.schema,
					onSetAttrib: function(e) {
						self.fire('SetAttrib', e);
					}
				});
	
				/**
				 * HTML parser will be used when contents is inserted into the editor.
				 *
				 * @property parser
				 * @type tinymce.html.DomParser
				 */
				self.parser = new DomParser(settings, self.schema);
	
				// Convert src and href into data-mce-src, data-mce-href and data-mce-style
				self.parser.addAttributeFilter('src,href,style,tabindex', function(nodes, name) {
					var i = nodes.length, node, dom = self.dom, value, internalName;
	
					while (i--) {
						node = nodes[i];
						value = node.attr(name);
						internalName = 'data-mce-' + name;
	
						// Add internal attribute if we need to we don't on a refresh of the document
						if (!node.attributes.map[internalName]) {
							// Don't duplicate these since they won't get modified by any browser
							if (value.indexOf('data:') === 0 || value.indexOf('blob:') === 0) {
								continue;
							}
	
							if (name === "style") {
								value = dom.serializeStyle(dom.parseStyle(value), node.name);
	
								if (!value.length) {
									value = null;
								}
	
								node.attr(internalName, value);
								node.attr(name, value);
							} else if (name === "tabindex") {
								node.attr(internalName, value);
								node.attr(name, null);
							} else {
								node.attr(internalName, self.convertURL(value, name, node.name));
							}
						}
					}
				});
	
				// Keep scripts from executing
				self.parser.addNodeFilter('script', function(nodes) {
					var i = nodes.length, node, type;
	
					while (i--) {
						node = nodes[i];
						type = node.attr('type') || 'no/type';
						if (type.indexOf('mce-') !== 0) {
							node.attr('type', 'mce-' + type);
						}
					}
				});
	
				self.parser.addNodeFilter('#cdata', function(nodes) {
					var i = nodes.length, node;
	
					while (i--) {
						node = nodes[i];
						node.type = 8;
						node.name = '#comment';
						node.value = '[CDATA[' + node.value + ']]';
					}
				});
	
				self.parser.addNodeFilter('p,h1,h2,h3,h4,h5,h6,div', function(nodes) {
					var i = nodes.length, node, nonEmptyElements = self.schema.getNonEmptyElements();
	
					while (i--) {
						node = nodes[i];
	
						if (node.isEmpty(nonEmptyElements)) {
							node.append(new Node('br', 1)).shortEnded = true;
						}
					}
				});
	
				/**
				 * DOM serializer for the editor. Will be used when contents is extracted from the editor.
				 *
				 * @property serializer
				 * @type tinymce.dom.Serializer
				 * @example
				 * // Serializes the first paragraph in the editor into a string
				 * tinymce.activeEditor.serializer.serialize(tinymce.activeEditor.dom.select('p')[0]);
				 */
				self.serializer = new DomSerializer(settings, self);
	
				/**
				 * Selection instance for the editor.
				 *
				 * @property selection
				 * @type tinymce.dom.Selection
				 * @example
				 * // Sets some contents to the current selection in the editor
				 * tinymce.activeEditor.selection.setContent('Some contents');
				 *
				 * // Gets the current selection
				 * alert(tinymce.activeEditor.selection.getContent());
				 *
				 * // Selects the first paragraph found
				 * tinymce.activeEditor.selection.select(tinymce.activeEditor.dom.select('p')[0]);
				 */
				self.selection = new Selection(self.dom, self.getWin(), self.serializer, self);
	
				/**
				 * Formatter instance.
				 *
				 * @property formatter
				 * @type tinymce.Formatter
				 */
				self.formatter = new Formatter(self);
	
				/**
				 * Undo manager instance, responsible for handling undo levels.
				 *
				 * @property undoManager
				 * @type tinymce.UndoManager
				 * @example
				 * // Undoes the last modification to the editor
				 * tinymce.activeEditor.undoManager.undo();
				 */
				self.undoManager = new UndoManager(self);
	
				self.forceBlocks = new ForceBlocks(self);
				self.enterKey = new EnterKey(self);
				self._nodeChangeDispatcher = new NodeChange(self);
				self._selectionOverrides = new SelectionOverrides(self);
	
				self.fire('PreInit');
	
				if (!settings.browser_spellcheck && !settings.gecko_spellcheck) {
					doc.body.spellcheck = false; // Gecko
					DOM.setAttrib(body, "spellcheck", "false");
				}
	
				self.quirks = new Quirks(self);
				self.fire('PostRender');
	
				if (settings.directionality) {
					body.dir = settings.directionality;
				}
	
				if (settings.nowrap) {
					body.style.whiteSpace = "nowrap";
				}
	
				if (settings.protect) {
					self.on('BeforeSetContent', function(e) {
						each(settings.protect, function(pattern) {
							e.content = e.content.replace(pattern, function(str) {
								return '<!--mce:protected ' + escape(str) + '-->';
							});
						});
					});
				}
	
				self.on('SetContent', function() {
					self.addVisual(self.getBody());
				});
	
				// Remove empty contents
				if (settings.padd_empty_editor) {
					self.on('PostProcess', function(e) {
						e.content = e.content.replace(/^(<p[^>]*>(&nbsp;|&#160;|\s|\u00a0|)<\/p>[\r\n]*|<br \/>[\r\n]*)$/, '');
					});
				}
	
				self.load({initial: true, format: 'html'});
				self.startContent = self.getContent({format: 'raw'});
	
				/**
				 * Is set to true after the editor instance has been initialized
				 *
				 * @property initialized
				 * @type Boolean
				 * @example
				 * function isEditorInitialized(editor) {
				 *     return editor && editor.initialized;
				 * }
				 */
				self.initialized = true;
				self.bindPendingEventDelegates();
	
				self.fire('init');
				self.focus(true);
				self.nodeChanged({initial: true});
				self.execCallback('init_instance_callback', self);
	
				self.on('compositionstart compositionend', function(e) {
					self.composing = e.type === 'compositionstart';
				});
	
				// Add editor specific CSS styles
				if (self.contentStyles.length > 0) {
					contentCssText = '';
	
					each(self.contentStyles, function(style) {
						contentCssText += style + "\r\n";
					});
	
					self.dom.addStyle(contentCssText);
				}
	
				// Load specified content CSS last
				each(self.contentCSS, function(cssUrl) {
					if (!self.loadedCSS[cssUrl]) {
						self.dom.loadCSS(cssUrl);
						self.loadedCSS[cssUrl] = true;
					}
				});
	
				// Handle auto focus
				if (settings.auto_focus) {
					Delay.setEditorTimeout(self, function() {
						var editor;
	
						if (settings.auto_focus === true) {
							editor = self;
						} else {
							editor = self.editorManager.get(settings.auto_focus);
						}
	
						if (!editor.destroyed) {
							editor.focus();
						}
					}, 100);
				}
	
				// Clean up references for IE
				targetElm = doc = body = null;
			},
	
			/**
			 * Focuses/activates the editor. This will set this editor as the activeEditor in the tinymce collection
			 * it will also place DOM focus inside the editor.
			 *
			 * @method focus
			 * @param {Boolean} skipFocus Skip DOM focus. Just set is as the active editor.
			 */
			focus: function(skipFocus) {
				var self = this, selection = self.selection, contentEditable = self.settings.content_editable, rng;
				var controlElm, doc = self.getDoc(), body = self.getBody(), contentEditableHost;
	
				function getContentEditableHost(node) {
					return self.dom.getParent(node, function(node) {
						return self.dom.getContentEditable(node) === "true";
					});
				}
	
				if (!skipFocus) {
					// Get selected control element
					rng = selection.getRng();
					if (rng.item) {
						controlElm = rng.item(0);
					}
	
					self.quirks.refreshContentEditable();
	
					// Move focus to contentEditable=true child if needed
					contentEditableHost = getContentEditableHost(selection.getNode());
					if (self.$.contains(body, contentEditableHost)) {
						contentEditableHost.focus();
						selection.normalize();
						self.editorManager.setActive(self);
						return;
					}
	
					// Focus the window iframe
					if (!contentEditable) {
						// WebKit needs this call to fire focusin event properly see #5948
						// But Opera pre Blink engine will produce an empty selection so skip Opera
						if (!Env.opera) {
							self.getBody().focus();
						}
	
						self.getWin().focus();
					}
	
					// Focus the body as well since it's contentEditable
					if (isGecko || contentEditable) {
						// Check for setActive since it doesn't scroll to the element
						if (body.setActive) {
							// IE 11 sometimes throws "Invalid function" then fallback to focus
							try {
								body.setActive();
							} catch (ex) {
								body.focus();
							}
						} else {
							body.focus();
						}
	
						if (contentEditable) {
							selection.normalize();
						}
					}
	
					// Restore selected control element
					// This is needed when for example an image is selected within a
					// layer a call to focus will then remove the control selection
					if (controlElm && controlElm.ownerDocument == doc) {
						rng = doc.body.createControlRange();
						rng.addElement(controlElm);
						rng.select();
					}
				}
	
				self.editorManager.setActive(self);
			},
	
			/**
			 * Executes a legacy callback. This method is useful to call old 2.x option callbacks.
			 * There new event model is a better way to add callback so this method might be removed in the future.
			 *
			 * @method execCallback
			 * @param {String} name Name of the callback to execute.
			 * @return {Object} Return value passed from callback function.
			 */
			execCallback: function(name) {
				var self = this, callback = self.settings[name], scope;
	
				if (!callback) {
					return;
				}
	
				// Look through lookup
				if (self.callbackLookup && (scope = self.callbackLookup[name])) {
					callback = scope.func;
					scope = scope.scope;
				}
	
				if (typeof callback === 'string') {
					scope = callback.replace(/\.\w+$/, '');
					scope = scope ? resolve(scope) : 0;
					callback = resolve(callback);
					self.callbackLookup = self.callbackLookup || {};
					self.callbackLookup[name] = {func: callback, scope: scope};
				}
	
				return callback.apply(scope || self, Array.prototype.slice.call(arguments, 1));
			},
	
			/**
			 * Translates the specified string by replacing variables with language pack items it will also check if there is
			 * a key matching the input.
			 *
			 * @method translate
			 * @param {String} text String to translate by the language pack data.
			 * @return {String} Translated string.
			 */
			translate: function(text) {
				var lang = this.settings.language || 'en', i18n = this.editorManager.i18n;
	
				if (!text) {
					return '';
				}
	
				text = i18n.data[lang + '.' + text] || text.replace(/\{\#([^\}]+)\}/g, function(a, b) {
					return i18n.data[lang + '.' + b] || '{#' + b + '}';
				});
	
				return this.editorManager.translate(text);
			},
	
			/**
			 * Returns a language pack item by name/key.
			 *
			 * @method getLang
			 * @param {String} name Name/key to get from the language pack.
			 * @param {String} defaultVal Optional default value to retrieve.
			 */
			getLang: function(name, defaultVal) {
				return (
					this.editorManager.i18n.data[(this.settings.language || 'en') + '.' + name] ||
					(defaultVal !== undefined ? defaultVal : '{#' + name + '}')
				);
			},
	
			/**
			 * Returns a configuration parameter by name.
			 *
			 * @method getParam
			 * @param {String} name Configruation parameter to retrieve.
			 * @param {String} defaultVal Optional default value to return.
			 * @param {String} type Optional type parameter.
			 * @return {String} Configuration parameter value or default value.
			 * @example
			 * // Returns a specific config value from the currently active editor
			 * var someval = tinymce.activeEditor.getParam('myvalue');
			 *
			 * // Returns a specific config value from a specific editor instance by id
			 * var someval2 = tinymce.get('my_editor').getParam('myvalue');
			 */
			getParam: function(name, defaultVal, type) {
				var value = name in this.settings ? this.settings[name] : defaultVal, output;
	
				if (type === 'hash') {
					output = {};
	
					if (typeof value === 'string') {
						each(value.indexOf('=') > 0 ? value.split(/[;,](?![^=;,]*(?:[;,]|$))/) : value.split(','), function(value) {
							value = value.split('=');
	
							if (value.length > 1) {
								output[trim(value[0])] = trim(value[1]);
							} else {
								output[trim(value[0])] = trim(value);
							}
						});
					} else {
						output = value;
					}
	
					return output;
				}
	
				return value;
			},
	
			/**
			 * Dispatches out a onNodeChange event to all observers. This method should be called when you
			 * need to update the UI states or element path etc.
			 *
			 * @method nodeChanged
			 * @param {Object} args Optional args to pass to NodeChange event handlers.
			 */
			nodeChanged: function(args) {
				this._nodeChangeDispatcher.nodeChanged(args);
			},
	
			/**
			 * Adds a button that later gets created by the theme in the editors toolbars.
			 *
			 * @method addButton
			 * @param {String} name Button name to add.
			 * @param {Object} settings Settings object with title, cmd etc.
			 * @example
			 * // Adds a custom button to the editor that inserts contents when clicked
			 * tinymce.init({
			 *    ...
			 *
			 *    toolbar: 'example'
			 *
			 *    setup: function(ed) {
			 *       ed.addButton('example', {
			 *          title: 'My title',
			 *          image: '../js/tinymce/plugins/example/img/example.gif',
			 *          onclick: function() {
			 *             ed.insertContent('Hello world!!');
			 *          }
			 *       });
			 *    }
			 * });
			 */
			addButton: function(name, settings) {
				var self = this;
	
				if (settings.cmd) {
					settings.onclick = function() {
						self.execCommand(settings.cmd);
					};
				}
	
				if (!settings.text && !settings.icon) {
					settings.icon = name;
				}
	
				self.buttons = self.buttons || {};
				settings.tooltip = settings.tooltip || settings.title;
				self.buttons[name] = settings;
			},
	
			/**
			 * Adds a sidebar for the editor instance.
			 *
			 * @method addSidebar
			 * @param {String} name Sidebar name to add.
			 * @param {Object} settings Settings object with icon, onshow etc.
			 * @example
			 * // Adds a custom sidebar that when clicked logs the panel element
			 * tinymce.init({
			 *    ...
			 *    setup: function(ed) {
			 *       ed.addSidebar('example', {
			 *          tooltip: 'My sidebar',
			 *          icon: 'my-side-bar',
			 *          onshow: function(api) {
			 *             console.log(api.element());
			 *          }
			 *       });
			 *    }
			 * });
			 */
			addSidebar: function (name, settings) {
				return Sidebar.add(this, name, settings);
			},
	
			/**
			 * Adds a menu item to be used in the menus of the theme. There might be multiple instances
			 * of this menu item for example it might be used in the main menus of the theme but also in
			 * the context menu so make sure that it's self contained and supports multiple instances.
			 *
			 * @method addMenuItem
			 * @param {String} name Menu item name to add.
			 * @param {Object} settings Settings object with title, cmd etc.
			 * @example
			 * // Adds a custom menu item to the editor that inserts contents when clicked
			 * // The context option allows you to add the menu item to an existing default menu
			 * tinymce.init({
			 *    ...
			 *
			 *    setup: function(ed) {
			 *       ed.addMenuItem('example', {
			 *          text: 'My menu item',
			 *          context: 'tools',
			 *          onclick: function() {
			 *             ed.insertContent('Hello world!!');
			 *          }
			 *       });
			 *    }
			 * });
			 */
			addMenuItem: function(name, settings) {
				var self = this;
	
				if (settings.cmd) {
					settings.onclick = function() {
						self.execCommand(settings.cmd);
					};
				}
	
				self.menuItems = self.menuItems || {};
				self.menuItems[name] = settings;
			},
	
			/**
			 * Adds a contextual toolbar to be rendered when the selector matches.
			 *
			 * @method addContextToolbar
			 * @param {function/string} predicate Predicate that needs to return true if provided strings get converted into CSS predicates.
			 * @param {String/Array} items String or array with items to add to the context toolbar.
			 */
			addContextToolbar: function(predicate, items) {
				var self = this, selector;
	
				self.contextToolbars = self.contextToolbars || [];
	
				// Convert selector to predicate
				if (typeof predicate == "string") {
					selector = predicate;
					predicate = function(elm) {
						return self.dom.is(elm, selector);
					};
				}
	
				self.contextToolbars.push({
					id: Uuid.uuid('mcet'),
					predicate: predicate,
					items: items
				});
			},
	
			/**
			 * Adds a custom command to the editor, you can also override existing commands with this method.
			 * The command that you add can be executed with execCommand.
			 *
			 * @method addCommand
			 * @param {String} name Command name to add/override.
			 * @param {addCommandCallback} callback Function to execute when the command occurs.
			 * @param {Object} scope Optional scope to execute the function in.
			 * @example
			 * // Adds a custom command that later can be executed using execCommand
			 * tinymce.init({
			 *    ...
			 *
			 *    setup: function(ed) {
			 *       // Register example command
			 *       ed.addCommand('mycommand', function(ui, v) {
			 *          ed.windowManager.alert('Hello world!! Selection: ' + ed.selection.getContent({format: 'text'}));
			 *       });
			 *    }
			 * });
			 */
			addCommand: function(name, callback, scope) {
				/**
				 * Callback function that gets called when a command is executed.
				 *
				 * @callback addCommandCallback
				 * @param {Boolean} ui Display UI state true/false.
				 * @param {Object} value Optional value for command.
				 * @return {Boolean} True/false state if the command was handled or not.
				 */
				this.editorCommands.addCommand(name, callback, scope);
			},
	
			/**
			 * Adds a custom query state command to the editor, you can also override existing commands with this method.
			 * The command that you add can be executed with queryCommandState function.
			 *
			 * @method addQueryStateHandler
			 * @param {String} name Command name to add/override.
			 * @param {addQueryStateHandlerCallback} callback Function to execute when the command state retrieval occurs.
			 * @param {Object} scope Optional scope to execute the function in.
			 */
			addQueryStateHandler: function(name, callback, scope) {
				/**
				 * Callback function that gets called when a queryCommandState is executed.
				 *
				 * @callback addQueryStateHandlerCallback
				 * @return {Boolean} True/false state if the command is enabled or not like is it bold.
				 */
				this.editorCommands.addQueryStateHandler(name, callback, scope);
			},
	
			/**
			 * Adds a custom query value command to the editor, you can also override existing commands with this method.
			 * The command that you add can be executed with queryCommandValue function.
			 *
			 * @method addQueryValueHandler
			 * @param {String} name Command name to add/override.
			 * @param {addQueryValueHandlerCallback} callback Function to execute when the command value retrieval occurs.
			 * @param {Object} scope Optional scope to execute the function in.
			 */
			addQueryValueHandler: function(name, callback, scope) {
				/**
				 * Callback function that gets called when a queryCommandValue is executed.
				 *
				 * @callback addQueryValueHandlerCallback
				 * @return {Object} Value of the command or undefined.
				 */
				this.editorCommands.addQueryValueHandler(name, callback, scope);
			},
	
			/**
			 * Adds a keyboard shortcut for some command or function.
			 *
			 * @method addShortcut
			 * @param {String} pattern Shortcut pattern. Like for example: ctrl+alt+o.
			 * @param {String} desc Text description for the command.
			 * @param {String/Function} cmdFunc Command name string or function to execute when the key is pressed.
			 * @param {Object} sc Optional scope to execute the function in.
			 * @return {Boolean} true/false state if the shortcut was added or not.
			 */
			addShortcut: function(pattern, desc, cmdFunc, scope) {
				this.shortcuts.add(pattern, desc, cmdFunc, scope);
			},
	
			/**
			 * Executes a command on the current instance. These commands can be TinyMCE internal commands prefixed with "mce" or
			 * they can be build in browser commands such as "Bold". A compleate list of browser commands is available on MSDN or Mozilla.org.
			 * This function will dispatch the execCommand function on each plugin, theme or the execcommand_callback option if none of these
			 * return true it will handle the command as a internal browser command.
			 *
			 * @method execCommand
			 * @param {String} cmd Command name to execute, for example mceLink or Bold.
			 * @param {Boolean} ui True/false state if a UI (dialog) should be presented or not.
			 * @param {mixed} value Optional command value, this can be anything.
			 * @param {Object} args Optional arguments object.
			 */
			execCommand: function(cmd, ui, value, args) {
				return this.editorCommands.execCommand(cmd, ui, value, args);
			},
	
			/**
			 * Returns a command specific state, for example if bold is enabled or not.
			 *
			 * @method queryCommandState
			 * @param {string} cmd Command to query state from.
			 * @return {Boolean} Command specific state, for example if bold is enabled or not.
			 */
			queryCommandState: function(cmd) {
				return this.editorCommands.queryCommandState(cmd);
			},
	
			/**
			 * Returns a command specific value, for example the current font size.
			 *
			 * @method queryCommandValue
			 * @param {string} cmd Command to query value from.
			 * @return {Object} Command specific value, for example the current font size.
			 */
			queryCommandValue: function(cmd) {
				return this.editorCommands.queryCommandValue(cmd);
			},
	
			/**
			 * Returns true/false if the command is supported or not.
			 *
			 * @method queryCommandSupported
			 * @param {String} cmd Command that we check support for.
			 * @return {Boolean} true/false if the command is supported or not.
			 */
			queryCommandSupported: function(cmd) {
				return this.editorCommands.queryCommandSupported(cmd);
			},
	
			/**
			 * Shows the editor and hides any textarea/div that the editor is supposed to replace.
			 *
			 * @method show
			 */
			show: function() {
				var self = this;
	
				if (self.hidden) {
					self.hidden = false;
	
					if (self.inline) {
						self.getBody().contentEditable = true;
					} else {
						DOM.show(self.getContainer());
						DOM.hide(self.id);
					}
	
					self.load();
					self.fire('show');
				}
			},
	
			/**
			 * Hides the editor and shows any textarea/div that the editor is supposed to replace.
			 *
			 * @method hide
			 */
			hide: function() {
				var self = this, doc = self.getDoc();
	
				if (!self.hidden) {
					// Fixed bug where IE has a blinking cursor left from the editor
					if (ie && doc && !self.inline) {
						doc.execCommand('SelectAll');
					}
	
					// We must save before we hide so Safari doesn't crash
					self.save();
	
					if (self.inline) {
						self.getBody().contentEditable = false;
	
						// Make sure the editor gets blurred
						if (self == self.editorManager.focusedEditor) {
							self.editorManager.focusedEditor = null;
						}
					} else {
						DOM.hide(self.getContainer());
						DOM.setStyle(self.id, 'display', self.orgDisplay);
					}
	
					self.hidden = true;
					self.fire('hide');
				}
			},
	
			/**
			 * Returns true/false if the editor is hidden or not.
			 *
			 * @method isHidden
			 * @return {Boolean} True/false if the editor is hidden or not.
			 */
			isHidden: function() {
				return !!this.hidden;
			},
	
			/**
			 * Sets the progress state, this will display a throbber/progess for the editor.
			 * This is ideal for asynchronous operations like an AJAX save call.
			 *
			 * @method setProgressState
			 * @param {Boolean} state Boolean state if the progress should be shown or hidden.
			 * @param {Number} time Optional time to wait before the progress gets shown.
			 * @return {Boolean} Same as the input state.
			 * @example
			 * // Show progress for the active editor
			 * tinymce.activeEditor.setProgressState(true);
			 *
			 * // Hide progress for the active editor
			 * tinymce.activeEditor.setProgressState(false);
			 *
			 * // Show progress after 3 seconds
			 * tinymce.activeEditor.setProgressState(true, 3000);
			 */
			setProgressState: function(state, time) {
				this.fire('ProgressState', {state: state, time: time});
			},
	
			/**
			 * Loads contents from the textarea or div element that got converted into an editor instance.
			 * This method will move the contents from that textarea or div into the editor by using setContent
			 * so all events etc that method has will get dispatched as well.
			 *
			 * @method load
			 * @param {Object} args Optional content object, this gets passed around through the whole load process.
			 * @return {String} HTML string that got set into the editor.
			 */
			load: function(args) {
				var self = this, elm = self.getElement(), html;
	
				if (elm) {
					args = args || {};
					args.load = true;
	
					html = self.setContent(elm.value !== undefined ? elm.value : elm.innerHTML, args);
					args.element = elm;
	
					if (!args.no_events) {
						self.fire('LoadContent', args);
					}
	
					args.element = elm = null;
	
					return html;
				}
			},
	
			/**
			 * Saves the contents from a editor out to the textarea or div element that got converted into an editor instance.
			 * This method will move the HTML contents from the editor into that textarea or div by getContent
			 * so all events etc that method has will get dispatched as well.
			 *
			 * @method save
			 * @param {Object} args Optional content object, this gets passed around through the whole save process.
			 * @return {String} HTML string that got set into the textarea/div.
			 */
			save: function(args) {
				var self = this, elm = self.getElement(), html, form;
	
				if (!elm || !self.initialized) {
					return;
				}
	
				args = args || {};
				args.save = true;
	
				args.element = elm;
				html = args.content = self.getContent(args);
	
				if (!args.no_events) {
					self.fire('SaveContent', args);
				}
	
				// Always run this internal event
				if (args.format == 'raw') {
					self.fire('RawSaveContent', args);
				}
	
				html = args.content;
	
				if (!/TEXTAREA|INPUT/i.test(elm.nodeName)) {
					// Update DIV element when not in inline mode
					if (!self.inline) {
						elm.innerHTML = html;
					}
	
					// Update hidden form element
					if ((form = DOM.getParent(self.id, 'form'))) {
						each(form.elements, function(elm) {
							if (elm.name == self.id) {
								elm.value = html;
								return false;
							}
						});
					}
				} else {
					elm.value = html;
				}
	
				args.element = elm = null;
	
				if (args.set_dirty !== false) {
					self.setDirty(false);
				}
	
				return html;
			},
	
			/**
			 * Sets the specified content to the editor instance, this will cleanup the content before it gets set using
			 * the different cleanup rules options.
			 *
			 * @method setContent
			 * @param {String} content Content to set to editor, normally HTML contents but can be other formats as well.
			 * @param {Object} args Optional content object, this gets passed around through the whole set process.
			 * @return {String} HTML string that got set into the editor.
			 * @example
			 * // Sets the HTML contents of the activeEditor editor
			 * tinymce.activeEditor.setContent('<span>some</span> html');
			 *
			 * // Sets the raw contents of the activeEditor editor
			 * tinymce.activeEditor.setContent('<span>some</span> html', {format: 'raw'});
			 *
			 * // Sets the content of a specific editor (my_editor in this example)
			 * tinymce.get('my_editor').setContent(data);
			 *
			 * // Sets the bbcode contents of the activeEditor editor if the bbcode plugin was added
			 * tinymce.activeEditor.setContent('[b]some[/b] html', {format: 'bbcode'});
			 */
			setContent: function(content, args) {
				var self = this, body = self.getBody(), forcedRootBlockName, padd;
	
				// Setup args object
				args = args || {};
				args.format = args.format || 'html';
				args.set = true;
				args.content = content;
	
				// Do preprocessing
				if (!args.no_events) {
					self.fire('BeforeSetContent', args);
				}
	
				content = args.content;
	
				// Padd empty content in Gecko and Safari. Commands will otherwise fail on the content
				// It will also be impossible to place the caret in the editor unless there is a BR element present
				if (content.length === 0 || /^\s+$/.test(content)) {
					padd = ie && ie < 11 ? '' : '<br data-mce-bogus="1">';
	
					// Todo: There is a lot more root elements that need special padding
					// so separate this and add all of them at some point.
					if (body.nodeName == 'TABLE') {
						content = '<tr><td>' + padd + '</td></tr>';
					} else if (/^(UL|OL)$/.test(body.nodeName)) {
						content = '<li>' + padd + '</li>';
					}
	
					forcedRootBlockName = self.settings.forced_root_block;
	
					// Check if forcedRootBlock is configured and that the block is a valid child of the body
					if (forcedRootBlockName && self.schema.isValidChild(body.nodeName.toLowerCase(), forcedRootBlockName.toLowerCase())) {
						// Padd with bogus BR elements on modern browsers and IE 7 and 8 since they don't render empty P tags properly
						content = padd;
						content = self.dom.createHTML(forcedRootBlockName, self.settings.forced_root_block_attrs, content);
					} else if (!ie && !content) {
						// We need to add a BR when forced_root_block is disabled on non IE browsers to place the caret
						content = '<br data-mce-bogus="1">';
					}
	
					self.dom.setHTML(body, content);
	
					self.fire('SetContent', args);
				} else {
					// Parse and serialize the html
					if (args.format !== 'raw') {
						content = new Serializer({
							validate: self.validate
						}, self.schema).serialize(
							self.parser.parse(content, {isRootContent: true})
						);
					}
	
					// Set the new cleaned contents to the editor
					args.content = trim(content);
					self.dom.setHTML(body, args.content);
	
					// Do post processing
					if (!args.no_events) {
						self.fire('SetContent', args);
					}
	
					// Don't normalize selection if the focused element isn't the body in
					// content editable mode since it will steal focus otherwise
					/*if (!self.settings.content_editable || document.activeElement === self.getBody()) {
						self.selection.normalize();
					}*/
				}
	
				return args.content;
			},
	
			/**
			 * Gets the content from the editor instance, this will cleanup the content before it gets returned using
			 * the different cleanup rules options.
			 *
			 * @method getContent
			 * @param {Object} args Optional content object, this gets passed around through the whole get process.
			 * @return {String} Cleaned content string, normally HTML contents.
			 * @example
			 * // Get the HTML contents of the currently active editor
			 * console.debug(tinymce.activeEditor.getContent());
			 *
			 * // Get the raw contents of the currently active editor
			 * tinymce.activeEditor.getContent({format: 'raw'});
			 *
			 * // Get content of a specific editor:
			 * tinymce.get('content id').getContent()
			 */
			getContent: function(args) {
				var self = this, content, body = self.getBody();
	
				// Setup args object
				args = args || {};
				args.format = args.format || 'html';
				args.get = true;
				args.getInner = true;
	
				// Do preprocessing
				if (!args.no_events) {
					self.fire('BeforeGetContent', args);
				}
	
				// Get raw contents or by default the cleaned contents
				if (args.format == 'raw') {
					content = self.serializer.getTrimmedContent();
				} else if (args.format == 'text') {
					content = body.innerText || body.textContent;
				} else {
					content = self.serializer.serialize(body, args);
				}
	
				// Trim whitespace in beginning/end of HTML
				if (args.format != 'text') {
					args.content = trim(content);
				} else {
					args.content = content;
				}
	
				// Do post processing
				if (!args.no_events) {
					self.fire('GetContent', args);
				}
	
				return args.content;
			},
	
			/**
			 * Inserts content at caret position.
			 *
			 * @method insertContent
			 * @param {String} content Content to insert.
			 * @param {Object} args Optional args to pass to insert call.
			 */
			insertContent: function(content, args) {
				if (args) {
					content = extend({content: content}, args);
				}
	
				this.execCommand('mceInsertContent', false, content);
			},
	
			/**
			 * Returns true/false if the editor is dirty or not. It will get dirty if the user has made modifications to the contents.
			 *
			 * The dirty state is automatically set to true if you do modifications to the content in other
			 * words when new undo levels is created or if you undo/redo to update the contents of the editor. It will also be set
			 * to false if you call editor.save().
			 *
			 * @method isDirty
			 * @return {Boolean} True/false if the editor is dirty or not. It will get dirty if the user has made modifications to the contents.
			 * @example
			 * if (tinymce.activeEditor.isDirty())
			 *     alert("You must save your contents.");
			 */
			isDirty: function() {
				return !this.isNotDirty;
			},
	
			/**
			 * Explicitly sets the dirty state. This will fire the dirty event if the editor dirty state is changed from false to true
			 * by invoking this method.
			 *
			 * @method setDirty
			 * @param {Boolean} state True/false if the editor is considered dirty.
			 * @example
			 * function ajaxSave() {
			 *     var editor = tinymce.get('elm1');
			 *
			 *     // Save contents using some XHR call
			 *     alert(editor.getContent());
			 *
			 *     editor.setDirty(false); // Force not dirty state
			 * }
			 */
			setDirty: function(state) {
				var oldState = !this.isNotDirty;
	
				this.isNotDirty = !state;
	
				if (state && state != oldState) {
					this.fire('dirty');
				}
			},
	
			/**
			 * Sets the editor mode. Mode can be for example "design", "code" or "readonly".
			 *
			 * @method setMode
			 * @param {String} mode Mode to set the editor in.
			 */
			setMode: function(mode) {
				Mode.setMode(this, mode);
			},
	
			/**
			 * Returns the editors container element. The container element wrappes in
			 * all the elements added to the page for the editor. Such as UI, iframe etc.
			 *
			 * @method getContainer
			 * @return {Element} HTML DOM element for the editor container.
			 */
			getContainer: function() {
				var self = this;
	
				if (!self.container) {
					self.container = DOM.get(self.editorContainer || self.id + '_parent');
				}
	
				return self.container;
			},
	
			/**
			 * Returns the editors content area container element. The this element is the one who
			 * holds the iframe or the editable element.
			 *
			 * @method getContentAreaContainer
			 * @return {Element} HTML DOM element for the editor area container.
			 */
			getContentAreaContainer: function() {
				return this.contentAreaContainer;
			},
	
			/**
			 * Returns the target element/textarea that got replaced with a TinyMCE editor instance.
			 *
			 * @method getElement
			 * @return {Element} HTML DOM element for the replaced element.
			 */
			getElement: function() {
				if (!this.targetElm) {
					this.targetElm = DOM.get(this.id);
				}
	
				return this.targetElm;
			},
	
			/**
			 * Returns the iframes window object.
			 *
			 * @method getWin
			 * @return {Window} Iframe DOM window object.
			 */
			getWin: function() {
				var self = this, elm;
	
				if (!self.contentWindow) {
					elm = self.iframeElement;
	
					if (elm) {
						self.contentWindow = elm.contentWindow;
					}
				}
	
				return self.contentWindow;
			},
	
			/**
			 * Returns the iframes document object.
			 *
			 * @method getDoc
			 * @return {Document} Iframe DOM document object.
			 */
			getDoc: function() {
				var self = this, win;
	
				if (!self.contentDocument) {
					win = self.getWin();
	
					if (win) {
						self.contentDocument = win.document;
					}
				}
	
				return self.contentDocument;
			},
	
			/**
			 * Returns the root element of the editable area.
			 * For a non-inline iframe-based editor, returns the iframe's body element.
			 *
			 * @method getBody
			 * @return {Element} The root element of the editable area.
			 */
			getBody: function() {
				var doc = this.getDoc();
				return this.bodyElement || (doc ? doc.body : null);
			},
	
			/**
			 * URL converter function this gets executed each time a user adds an img, a or
			 * any other element that has a URL in it. This will be called both by the DOM and HTML
			 * manipulation functions.
			 *
			 * @method convertURL
			 * @param {string} url URL to convert.
			 * @param {string} name Attribute name src, href etc.
			 * @param {string/HTMLElement} elm Tag name or HTML DOM element depending on HTML or DOM insert.
			 * @return {string} Converted URL string.
			 */
			convertURL: function(url, name, elm) {
				var self = this, settings = self.settings;
	
				// Use callback instead
				if (settings.urlconverter_callback) {
					return self.execCallback('urlconverter_callback', url, elm, true, name);
				}
	
				// Don't convert link href since thats the CSS files that gets loaded into the editor also skip local file URLs
				if (!settings.convert_urls || (elm && elm.nodeName == 'LINK') || url.indexOf('file:') === 0 || url.length === 0) {
					return url;
				}
	
				// Convert to relative
				if (settings.relative_urls) {
					return self.documentBaseURI.toRelative(url);
				}
	
				// Convert to absolute
				url = self.documentBaseURI.toAbsolute(url, settings.remove_script_host);
	
				return url;
			},
	
			/**
			 * Adds visual aid for tables, anchors etc so they can be more easily edited inside the editor.
			 *
			 * @method addVisual
			 * @param {Element} elm Optional root element to loop though to find tables etc that needs the visual aid.
			 */
			addVisual: function(elm) {
				var self = this, settings = self.settings, dom = self.dom, cls;
	
				elm = elm || self.getBody();
	
				if (self.hasVisual === undefined) {
					self.hasVisual = settings.visual;
				}
	
				each(dom.select('table,a', elm), function(elm) {
					var value;
	
					switch (elm.nodeName) {
						case 'TABLE':
							cls = settings.visual_table_class || 'mce-item-table';
							value = dom.getAttrib(elm, 'border');
	
							if ((!value || value == '0') && self.hasVisual) {
								dom.addClass(elm, cls);
							} else {
								dom.removeClass(elm, cls);
							}
	
							return;
	
						case 'A':
							if (!dom.getAttrib(elm, 'href', false)) {
								value = dom.getAttrib(elm, 'name') || elm.id;
								cls = settings.visual_anchor_class || 'mce-item-anchor';
	
								if (value && self.hasVisual) {
									dom.addClass(elm, cls);
								} else {
									dom.removeClass(elm, cls);
								}
							}
	
							return;
					}
				});
	
				self.fire('VisualAid', {element: elm, hasVisual: self.hasVisual});
			},
	
			/**
			 * Removes the editor from the dom and tinymce collection.
			 *
			 * @method remove
			 */
			remove: function() {
				var self = this;
	
				if (!self.removed) {
					self.save();
					self.removed = 1;
					self.unbindAllNativeEvents();
	
					// Remove any hidden input
					if (self.hasHiddenInput) {
						DOM.remove(self.getElement().nextSibling);
					}
	
					if (!self.inline) {
						// IE 9 has a bug where the selection stops working if you place the
						// caret inside the editor then remove the iframe
						if (ie && ie < 10) {
							self.getDoc().execCommand('SelectAll', false, null);
						}
	
						DOM.setStyle(self.id, 'display', self.orgDisplay);
						self.getBody().onload = null; // Prevent #6816
					}
	
					self.fire('remove');
	
					self.editorManager.remove(self);
					DOM.remove(self.getContainer());
					self._selectionOverrides.destroy();
					self.editorUpload.destroy();
					self.destroy();
				}
			},
	
			/**
			 * Destroys the editor instance by removing all events, element references or other resources
			 * that could leak memory. This method will be called automatically when the page is unloaded
			 * but you can also call it directly if you know what you are doing.
			 *
			 * @method destroy
			 * @param {Boolean} automatic Optional state if the destroy is an automatic destroy or user called one.
			 */
			destroy: function(automatic) {
				var self = this, form;
	
				// One time is enough
				if (self.destroyed) {
					return;
				}
	
				// If user manually calls destroy and not remove
				// Users seems to have logic that calls destroy instead of remove
				if (!automatic && !self.removed) {
					self.remove();
					return;
				}
	
				if (!automatic) {
					self.editorManager.off('beforeunload', self._beforeUnload);
	
					// Manual destroy
					if (self.theme && self.theme.destroy) {
						self.theme.destroy();
					}
	
					// Destroy controls, selection and dom
					self.selection.destroy();
					self.dom.destroy();
				}
	
				form = self.formElement;
				if (form) {
					if (form._mceOldSubmit) {
						form.submit = form._mceOldSubmit;
						form._mceOldSubmit = null;
					}
	
					DOM.unbind(form, 'submit reset', self.formEventDelegate);
				}
	
				self.contentAreaContainer = self.formElement = self.container = self.editorContainer = null;
				self.bodyElement = self.contentDocument = self.contentWindow = null;
				self.iframeElement = self.targetElm = null;
	
				if (self.selection) {
					self.selection = self.selection.win = self.selection.dom = self.selection.dom.doc = null;
				}
	
				self.destroyed = 1;
			},
	
			/**
			 * Uploads all data uri/blob uri images in the editor contents to server.
			 *
			 * @method uploadImages
			 * @param {function} callback Optional callback with images and status for each image.
			 * @return {tinymce.util.Promise} Promise instance.
			 */
			uploadImages: function(callback) {
				return this.editorUpload.uploadImages(callback);
			},
	
			// Internal functions
	
			_scanForImages: function() {
				return this.editorUpload.scanForImages();
			}
		};
	
		extend(Editor.prototype, EditorObservable);
	
		return Editor;
	});
	
	// Included from: js/tinymce/classes/util/I18n.js
	
	/**
	 * I18n.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * I18n class that handles translation of TinyMCE UI.
	 * Uses po style with csharp style parameters.
	 *
	 * @class tinymce.util.I18n
	 */
	define("tinymce/util/I18n", [
		"tinymce/util/Tools"
	], function(Tools) {
		"use strict";
	
		var data = {}, code = "en";
	
		return {
			/**
			 * Sets the current language code.
			 *
			 * @method setCode
			 * @param {String} newCode Current language code.
			 */
			setCode: function(newCode) {
				if (newCode) {
					code = newCode;
					this.rtl = this.data[newCode] ? this.data[newCode]._dir === 'rtl' : false;
				}
			},
	
			/**
			 * Returns the current language code.
			 *
			 * @method getCode
			 * @return {String} Current language code.
			 */
			getCode: function() {
				return code;
			},
	
			/**
			 * Property gets set to true if a RTL language pack was loaded.
			 *
			 * @property rtl
			 * @type Boolean
			 */
			rtl: false,
	
			/**
			 * Adds translations for a specific language code.
			 *
			 * @method add
			 * @param {String} code Language code like sv_SE.
			 * @param {Array} items Name/value array with English en_US to sv_SE.
			 */
			add: function(code, items) {
				var langData = data[code];
	
				if (!langData) {
					data[code] = langData = {};
				}
	
				for (var name in items) {
					langData[name] = items[name];
				}
	
				this.setCode(code);
			},
	
			/**
			 * Translates the specified text.
			 *
			 * It has a few formats:
			 * I18n.translate("Text");
			 * I18n.translate(["Text {0}/{1}", 0, 1]);
			 * I18n.translate({raw: "Raw string"});
			 *
			 * @method translate
			 * @param {String/Object/Array} text Text to translate.
			 * @return {String} String that got translated.
			 */
			translate: function(text) {
				var langData = data[code] || {};
	
				/**
				 * number - string
				 * null, undefined and empty string - empty string
				 * array - comma-delimited string
				 * object - in [object Object]
				 * function - in [object Function]
				 *
				 * @param obj
				 * @returns {string}
				 */
				function toString(obj) {
					if (Tools.is(obj, 'function')) {
						return Object.prototype.toString.call(obj);
					}
					return !isEmpty(obj) ? '' + obj : '';
				}
	
				function isEmpty(text) {
					return text === '' || text === null || Tools.is(text, 'undefined');
				}
	
				function getLangData(text) {
					// make sure we work on a string and return a string
					text = toString(text);
					return Tools.hasOwn(langData, text) ? toString(langData[text]) : text;
				}
	
	
				if (isEmpty(text)) {
					return '';
				}
	
				if (Tools.is(text, 'object') && Tools.hasOwn(text, 'raw')) {
					return toString(text.raw);
				}
	
				if (Tools.is(text, 'array')) {
					var values = text.slice(1);
					text = getLangData(text[0]).replace(/\{([0-9]+)\}/g, function($1, $2) {
						return Tools.hasOwn(values, $2) ? toString(values[$2]) : $1;
					});
				}
	
				return getLangData(text).replace(/{context:\w+}$/, '');
			},
	
			data: data
		};
	});
	
	// Included from: js/tinymce/classes/FocusManager.js
	
	/**
	 * FocusManager.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This class manages the focus/blur state of the editor. This class is needed since some
	 * browsers fire false focus/blur states when the selection is moved to a UI dialog or similar.
	 *
	 * This class will fire two events focus and blur on the editor instances that got affected.
	 * It will also handle the restore of selection when the focus is lost and returned.
	 *
	 * @class tinymce.FocusManager
	 */
	define("tinymce/FocusManager", [
		"tinymce/dom/DOMUtils",
		"tinymce/util/Delay",
		"tinymce/Env"
	], function(DOMUtils, Delay, Env) {
		var selectionChangeHandler, documentFocusInHandler, documentMouseUpHandler, DOM = DOMUtils.DOM;
	
		/**
		 * Constructs a new focus manager instance.
		 *
		 * @constructor FocusManager
		 * @param {tinymce.EditorManager} editorManager Editor manager instance to handle focus for.
		 */
		function FocusManager(editorManager) {
			function getActiveElement() {
				try {
					return document.activeElement;
				} catch (ex) {
					// IE sometimes fails to get the activeElement when resizing table
					// TODO: Investigate this
					return document.body;
				}
			}
	
			// We can't store a real range on IE 11 since it gets mutated so we need to use a bookmark object
			// TODO: Move this to a separate range utils class since it's it's logic is present in Selection as well.
			function createBookmark(dom, rng) {
				if (rng && rng.startContainer) {
					// Verify that the range is within the root of the editor
					if (!dom.isChildOf(rng.startContainer, dom.getRoot()) || !dom.isChildOf(rng.endContainer, dom.getRoot())) {
						return;
					}
	
					return {
						startContainer: rng.startContainer,
						startOffset: rng.startOffset,
						endContainer: rng.endContainer,
						endOffset: rng.endOffset
					};
				}
	
				return rng;
			}
	
			function bookmarkToRng(editor, bookmark) {
				var rng;
	
				if (bookmark.startContainer) {
					rng = editor.getDoc().createRange();
					rng.setStart(bookmark.startContainer, bookmark.startOffset);
					rng.setEnd(bookmark.endContainer, bookmark.endOffset);
				} else {
					rng = bookmark;
				}
	
				return rng;
			}
	
			function isUIElement(elm) {
				return !!DOM.getParent(elm, FocusManager.isEditorUIElement);
			}
	
			function registerEvents(e) {
				var editor = e.editor;
	
				editor.on('init', function() {
					// Gecko/WebKit has ghost selections in iframes and IE only has one selection per browser tab
					if (editor.inline || Env.ie) {
						// Use the onbeforedeactivate event when available since it works better see #7023
						if ("onbeforedeactivate" in document && Env.ie < 9) {
							editor.dom.bind(editor.getBody(), 'beforedeactivate', function(e) {
								if (e.target != editor.getBody()) {
									return;
								}
	
								try {
									editor.lastRng = editor.selection.getRng();
								} catch (ex) {
									// IE throws "Unexcpected call to method or property access" some times so lets ignore it
								}
							});
						} else {
							// On other browsers take snapshot on nodechange in inline mode since they have Ghost selections for iframes
							editor.on('nodechange mouseup keyup', function(e) {
								var node = getActiveElement();
	
								// Only act on manual nodechanges
								if (e.type == 'nodechange' && e.selectionChange) {
									return;
								}
	
								// IE 11 reports active element as iframe not body of iframe
								if (node && node.id == editor.id + '_ifr') {
									node = editor.getBody();
								}
	
								if (editor.dom.isChildOf(node, editor.getBody())) {
									editor.lastRng = editor.selection.getRng();
								}
							});
						}
	
						// Handles the issue with WebKit not retaining selection within inline document
						// If the user releases the mouse out side the body since a mouse up event wont occur on the body
						if (Env.webkit && !selectionChangeHandler) {
							selectionChangeHandler = function() {
								var activeEditor = editorManager.activeEditor;
	
								if (activeEditor && activeEditor.selection) {
									var rng = activeEditor.selection.getRng();
	
									// Store when it's non collapsed
									if (rng && !rng.collapsed) {
										editor.lastRng = rng;
									}
								}
							};
	
							DOM.bind(document, 'selectionchange', selectionChangeHandler);
						}
					}
				});
	
				editor.on('setcontent', function() {
					editor.lastRng = null;
				});
	
				// Remove last selection bookmark on mousedown see #6305
				editor.on('mousedown', function() {
					editor.selection.lastFocusBookmark = null;
				});
	
				editor.on('focusin', function() {
					var focusedEditor = editorManager.focusedEditor, lastRng;
	
					if (editor.selection.lastFocusBookmark) {
						lastRng = bookmarkToRng(editor, editor.selection.lastFocusBookmark);
						editor.selection.lastFocusBookmark = null;
						editor.selection.setRng(lastRng);
					}
	
					if (focusedEditor != editor) {
						if (focusedEditor) {
							focusedEditor.fire('blur', {focusedEditor: editor});
						}
	
						editorManager.setActive(editor);
						editorManager.focusedEditor = editor;
						editor.fire('focus', {blurredEditor: focusedEditor});
						editor.focus(true);
					}
	
					editor.lastRng = null;
				});
	
				editor.on('focusout', function() {
					Delay.setEditorTimeout(editor, function() {
						var focusedEditor = editorManager.focusedEditor;
	
						// Still the same editor the blur was outside any editor UI
						if (!isUIElement(getActiveElement()) && focusedEditor == editor) {
							editor.fire('blur', {focusedEditor: null});
							editorManager.focusedEditor = null;
	
							// Make sure selection is valid could be invalid if the editor is blured and removed before the timeout occurs
							if (editor.selection) {
								editor.selection.lastFocusBookmark = null;
							}
						}
					});
				});
	
				// Check if focus is moved to an element outside the active editor by checking if the target node
				// isn't within the body of the activeEditor nor a UI element such as a dialog child control
				if (!documentFocusInHandler) {
					documentFocusInHandler = function(e) {
						var activeEditor = editorManager.activeEditor, target;
	
						target = e.target;
	
						if (activeEditor && target.ownerDocument == document) {
							// Check to make sure we have a valid selection don't update the bookmark if it's
							// a focusin to the body of the editor see #7025
							if (activeEditor.selection && target != activeEditor.getBody()) {
								activeEditor.selection.lastFocusBookmark = createBookmark(activeEditor.dom, activeEditor.lastRng);
							}
	
							// Fire a blur event if the element isn't a UI element
							if (target != document.body && !isUIElement(target) && editorManager.focusedEditor == activeEditor) {
								activeEditor.fire('blur', {focusedEditor: null});
								editorManager.focusedEditor = null;
							}
						}
					};
	
					DOM.bind(document, 'focusin', documentFocusInHandler);
				}
	
				// Handle edge case when user starts the selection inside the editor and releases
				// the mouse outside the editor producing a new selection. This weird workaround is needed since
				// Gecko doesn't have the "selectionchange" event we need to do this. Fixes: #6843
				if (editor.inline && !documentMouseUpHandler) {
					documentMouseUpHandler = function(e) {
						var activeEditor = editorManager.activeEditor, dom = activeEditor.dom;
	
						if (activeEditor.inline && dom && !dom.isChildOf(e.target, activeEditor.getBody())) {
							var rng = activeEditor.selection.getRng();
	
							if (!rng.collapsed) {
								activeEditor.lastRng = rng;
							}
						}
					};
	
					DOM.bind(document, 'mouseup', documentMouseUpHandler);
				}
			}
	
			function unregisterDocumentEvents(e) {
				if (editorManager.focusedEditor == e.editor) {
					editorManager.focusedEditor = null;
				}
	
				if (!editorManager.activeEditor) {
					DOM.unbind(document, 'selectionchange', selectionChangeHandler);
					DOM.unbind(document, 'focusin', documentFocusInHandler);
					DOM.unbind(document, 'mouseup', documentMouseUpHandler);
					selectionChangeHandler = documentFocusInHandler = documentMouseUpHandler = null;
				}
			}
	
			editorManager.on('AddEditor', registerEvents);
			editorManager.on('RemoveEditor', unregisterDocumentEvents);
		}
	
		/**
		 * Returns true if the specified element is part of the UI for example an button or text input.
		 *
		 * @method isEditorUIElement
		 * @param  {Element} elm Element to check if it's part of the UI or not.
		 * @return {Boolean} True/false state if the element is part of the UI or not.
		 */
		FocusManager.isEditorUIElement = function(elm) {
			// Needs to be converted to string since svg can have focus: #6776
			return elm.className.toString().indexOf('mce-') !== -1;
		};
	
		return FocusManager;
	});
	
	// Included from: js/tinymce/classes/EditorManager.js
	
	/**
	 * EditorManager.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This class used as a factory for manager for tinymce.Editor instances.
	 *
	 * @example
	 * tinymce.EditorManager.init({});
	 *
	 * @class tinymce.EditorManager
	 * @mixes tinymce.util.Observable
	 * @static
	 */
	define("tinymce/EditorManager", [
		"tinymce/Editor",
		"tinymce/dom/DomQuery",
		"tinymce/dom/DOMUtils",
		"tinymce/util/URI",
		"tinymce/Env",
		"tinymce/util/Tools",
		"tinymce/util/Promise",
		"tinymce/util/Observable",
		"tinymce/util/I18n",
		"tinymce/FocusManager",
		"tinymce/AddOnManager"
	], function(Editor, $, DOMUtils, URI, Env, Tools, Promise, Observable, I18n, FocusManager, AddOnManager) {
		var DOM = DOMUtils.DOM;
		var explode = Tools.explode, each = Tools.each, extend = Tools.extend;
		var instanceCounter = 0, beforeUnloadDelegate, EditorManager, boundGlobalEvents = false;
	
		function globalEventDelegate(e) {
			each(EditorManager.editors, function(editor) {
				if (e.type === 'scroll') {
					editor.fire('ScrollWindow', e);
				} else {
					editor.fire('ResizeWindow', e);
				}
			});
		}
	
		function toggleGlobalEvents(editors, state) {
			if (state !== boundGlobalEvents) {
				if (state) {
					$(window).on('resize scroll', globalEventDelegate);
				} else {
					$(window).off('resize scroll', globalEventDelegate);
				}
	
				boundGlobalEvents = state;
			}
		}
	
		function removeEditorFromList(editor) {
			var editors = EditorManager.editors, removedFromList;
	
			delete editors[editor.id];
	
			for (var i = 0; i < editors.length; i++) {
				if (editors[i] == editor) {
					editors.splice(i, 1);
					removedFromList = true;
					break;
				}
			}
	
			// Select another editor since the active one was removed
			if (EditorManager.activeEditor == editor) {
				EditorManager.activeEditor = editors[0];
			}
	
			// Clear focusedEditor if necessary, so that we don't try to blur the destroyed editor
			if (EditorManager.focusedEditor == editor) {
				EditorManager.focusedEditor = null;
			}
	
			return removedFromList;
		}
	
		function purgeDestroyedEditor(editor) {
			// User has manually destroyed the editor lets clean up the mess
			if (editor && editor.initialized && !(editor.getContainer() || editor.getBody()).parentNode) {
				removeEditorFromList(editor);
				editor.unbindAllNativeEvents();
				editor.destroy(true);
				editor.removed = true;
				editor = null;
			}
	
			return editor;
		}
	
		EditorManager = {
			/**
			 * Dom query instance.
			 *
			 * @property $
			 * @type tinymce.dom.DomQuery
			 */
			$: $,
	
			/**
			 * Major version of TinyMCE build.
			 *
			 * @property majorVersion
			 * @type String
			 */
			majorVersion: '4',
	
			/**
			 * Minor version of TinyMCE build.
			 *
			 * @property minorVersion
			 * @type String
			 */
			minorVersion: '5.0',
	
			/**
			 * Release date of TinyMCE build.
			 *
			 * @property releaseDate
			 * @type String
			 */
			releaseDate: '2016-11-23',
	
			/**
			 * Collection of editor instances.
			 *
			 * @property editors
			 * @type Object
			 * @example
			 * for (edId in tinymce.editors)
			 *     tinymce.editors[edId].save();
			 */
			editors: [],
	
			/**
			 * Collection of language pack data.
			 *
			 * @property i18n
			 * @type Object
			 */
			i18n: I18n,
	
			/**
			 * Currently active editor instance.
			 *
			 * @property activeEditor
			 * @type tinymce.Editor
			 * @example
			 * tinyMCE.activeEditor.selection.getContent();
			 * tinymce.EditorManager.activeEditor.selection.getContent();
			 */
			activeEditor: null,
	
			setup: function() {
				var self = this, baseURL, documentBaseURL, suffix = "", preInit, src;
	
				// Get base URL for the current document
				documentBaseURL = URI.getDocumentBaseUrl(document.location);
	
				// Check if the URL is a document based format like: http://site/dir/file and file:///
				// leave other formats like applewebdata://... intact
				if (/^[^:]+:\/\/\/?[^\/]+\//.test(documentBaseURL)) {
					documentBaseURL = documentBaseURL.replace(/[\?#].*$/, '').replace(/[\/\\][^\/]+$/, '');
	
					if (!/[\/\\]$/.test(documentBaseURL)) {
						documentBaseURL += '/';
					}
				}
	
				// If tinymce is defined and has a base use that or use the old tinyMCEPreInit
				preInit = window.tinymce || window.tinyMCEPreInit;
				if (preInit) {
					baseURL = preInit.base || preInit.baseURL;
					suffix = preInit.suffix;
				} else {
					// Get base where the tinymce script is located
					var scripts = document.getElementsByTagName('script');
					for (var i = 0; i < scripts.length; i++) {
						src = scripts[i].src;
	
						// Script types supported:
						// tinymce.js tinymce.min.js tinymce.dev.js
						// tinymce.jquery.js tinymce.jquery.min.js tinymce.jquery.dev.js
						// tinymce.full.js tinymce.full.min.js tinymce.full.dev.js
						var srcScript = src.substring(src.lastIndexOf('/'));
						if (/tinymce(\.full|\.jquery|)(\.min|\.dev|)\.js/.test(src)) {
							if (srcScript.indexOf('.min') != -1) {
								suffix = '.min';
							}
	
							baseURL = src.substring(0, src.lastIndexOf('/'));
							break;
						}
					}
	
					// We didn't find any baseURL by looking at the script elements
					// Try to use the document.currentScript as a fallback
					if (!baseURL && document.currentScript) {
						src = document.currentScript.src;
	
						if (src.indexOf('.min') != -1) {
							suffix = '.min';
						}
	
						baseURL = src.substring(0, src.lastIndexOf('/'));
					}
				}
	
				/**
				 * Base URL where the root directory if TinyMCE is located.
				 *
				 * @property baseURL
				 * @type String
				 */
				self.baseURL = new URI(documentBaseURL).toAbsolute(baseURL);
	
				/**
				 * Document base URL where the current document is located.
				 *
				 * @property documentBaseURL
				 * @type String
				 */
				self.documentBaseURL = documentBaseURL;
	
				/**
				 * Absolute baseURI for the installation path of TinyMCE.
				 *
				 * @property baseURI
				 * @type tinymce.util.URI
				 */
				self.baseURI = new URI(self.baseURL);
	
				/**
				 * Current suffix to add to each plugin/theme that gets loaded for example ".min".
				 *
				 * @property suffix
				 * @type String
				 */
				self.suffix = suffix;
	
				self.focusManager = new FocusManager(self);
			},
	
			/**
			 * Overrides the default settings for editor instances.
			 *
			 * @method overrideDefaults
			 * @param {Object} defaultSettings Defaults settings object.
			 */
			overrideDefaults: function(defaultSettings) {
				var baseUrl, suffix;
	
				baseUrl = defaultSettings.base_url;
				if (baseUrl) {
					this.baseURL = new URI(this.documentBaseURL).toAbsolute(baseUrl.replace(/\/+$/, ''));
					this.baseURI = new URI(this.baseURL);
				}
	
				suffix = defaultSettings.suffix;
				if (defaultSettings.suffix) {
					this.suffix = suffix;
				}
	
				this.defaultSettings = defaultSettings;
	
				var pluginBaseUrls = defaultSettings.plugin_base_urls;
				for (var name in pluginBaseUrls) {
					AddOnManager.PluginManager.urls[name] = pluginBaseUrls[name];
				}
			},
	
			/**
			 * Initializes a set of editors. This method will create editors based on various settings.
			 *
			 * @method init
			 * @param {Object} settings Settings object to be passed to each editor instance.
			 * @return {tinymce.util.Promise} Promise that gets resolved with an array of editors when all editor instances are initialized.
			 * @example
			 * // Initializes a editor using the longer method
			 * tinymce.EditorManager.init({
			 *    some_settings : 'some value'
			 * });
			 *
			 * // Initializes a editor instance using the shorter version and with a promise
			 * tinymce.init({
			 *    some_settings : 'some value'
			 * }).then(function(editors) {
			 *    ...
			 * });
			 */
			init: function(settings) {
				var self = this, result, invalidInlineTargets;
	
				invalidInlineTargets = Tools.makeMap(
					'area base basefont br col frame hr img input isindex link meta param embed source wbr track ' +
					'colgroup option tbody tfoot thead tr script noscript style textarea video audio iframe object menu',
					' '
				);
	
				function isInvalidInlineTarget(settings, elm) {
					return settings.inline && elm.tagName.toLowerCase() in invalidInlineTargets;
				}
	
				function report(msg, elm) {
					// Log in a non test environment
					if (window.console && !window.test) {
						window.console.log(msg, elm);
					}
				}
	
				function createId(elm) {
					var id = elm.id;
	
					// Use element id, or unique name or generate a unique id
					if (!id) {
						id = elm.name;
	
						if (id && !DOM.get(id)) {
							id = elm.name;
						} else {
							// Generate unique name
							id = DOM.uniqueId();
						}
	
						elm.setAttribute('id', id);
					}
	
					return id;
				}
	
				function execCallback(name) {
					var callback = settings[name];
	
					if (!callback) {
						return;
					}
	
					return callback.apply(self, Array.prototype.slice.call(arguments, 2));
				}
	
				function hasClass(elm, className) {
					return className.constructor === RegExp ? className.test(elm.className) : DOM.hasClass(elm, className);
				}
	
				function findTargets(settings) {
					var l, targets = [];
	
					if (settings.types) {
						each(settings.types, function(type) {
							targets = targets.concat(DOM.select(type.selector));
						});
	
						return targets;
					} else if (settings.selector) {
						return DOM.select(settings.selector);
					} else if (settings.target) {
						return [settings.target];
					}
	
					// Fallback to old setting
					switch (settings.mode) {
						case "exact":
							l = settings.elements || '';
	
							if (l.length > 0) {
								each(explode(l), function(id) {
									var elm;
	
									if ((elm = DOM.get(id))) {
										targets.push(elm);
									} else {
										each(document.forms, function(f) {
											each(f.elements, function(e) {
												if (e.name === id) {
													id = 'mce_editor_' + instanceCounter++;
													DOM.setAttrib(e, 'id', id);
													targets.push(e);
												}
											});
										});
									}
								});
							}
							break;
	
						case "textareas":
						case "specific_textareas":
							each(DOM.select('textarea'), function(elm) {
								if (settings.editor_deselector && hasClass(elm, settings.editor_deselector)) {
									return;
								}
	
								if (!settings.editor_selector || hasClass(elm, settings.editor_selector)) {
									targets.push(elm);
								}
							});
							break;
					}
	
					return targets;
				}
	
				var provideResults = function(editors) {
					result = editors;
				};
	
				function initEditors() {
					var initCount = 0, editors = [], targets;
	
					function createEditor(id, settings, targetElm) {
						var editor = new Editor(id, settings, self);
	
						editors.push(editor);
	
						editor.on('init', function() {
							if (++initCount === targets.length) {
								provideResults(editors);
							}
						});
	
						editor.targetElm = editor.targetElm || targetElm;
						editor.render();
					}
	
					DOM.unbind(window, 'ready', initEditors);
					execCallback('onpageload');
	
					targets = $.unique(findTargets(settings));
	
					// TODO: Deprecate this one
					if (settings.types) {
						each(settings.types, function(type) {
							Tools.each(targets, function(elm) {
								if (DOM.is(elm, type.selector)) {
									createEditor(createId(elm), extend({}, settings, type), elm);
									return false;
								}
	
								return true;
							});
						});
	
						return;
					}
	
					Tools.each(targets, function(elm) {
						purgeDestroyedEditor(self.get(elm.id));
					});
	
					targets = Tools.grep(targets, function(elm) {
						return !self.get(elm.id);
					});
	
					each(targets, function(elm) {
						if (isInvalidInlineTarget(settings, elm)) {
							report('Could not initialize inline editor on invalid inline target element', elm);
						} else {
							createEditor(createId(elm), settings, elm);
						}
					});
				}
	
				self.settings = settings;
				DOM.bind(window, 'ready', initEditors);
	
				return new Promise(function(resolve) {
					if (result) {
						resolve(result);
					} else {
						provideResults = function(editors) {
							resolve(editors);
						};
					}
				});
			},
	
			/**
			 * Returns a editor instance by id.
			 *
			 * @method get
			 * @param {String/Number} id Editor instance id or index to return.
			 * @return {tinymce.Editor} Editor instance to return.
			 * @example
			 * // Adds an onclick event to an editor by id (shorter version)
			 * tinymce.get('mytextbox').on('click', function(e) {
			 *    ed.windowManager.alert('Hello world!');
			 * });
			 *
			 * // Adds an onclick event to an editor by id (longer version)
			 * tinymce.EditorManager.get('mytextbox').on('click', function(e) {
			 *    ed.windowManager.alert('Hello world!');
			 * });
			 */
			get: function(id) {
				if (!arguments.length) {
					return this.editors;
				}
	
				return id in this.editors ? this.editors[id] : null;
			},
	
			/**
			 * Adds an editor instance to the editor collection. This will also set it as the active editor.
			 *
			 * @method add
			 * @param {tinymce.Editor} editor Editor instance to add to the collection.
			 * @return {tinymce.Editor} The same instance that got passed in.
			 */
			add: function(editor) {
				var self = this, editors = self.editors;
	
				// Add named and index editor instance
				editors[editor.id] = editor;
				editors.push(editor);
	
				toggleGlobalEvents(editors, true);
	
				// Doesn't call setActive method since we don't want
				// to fire a bunch of activate/deactivate calls while initializing
				self.activeEditor = editor;
	
				self.fire('AddEditor', {editor: editor});
	
				if (!beforeUnloadDelegate) {
					beforeUnloadDelegate = function() {
						self.fire('BeforeUnload');
					};
	
					DOM.bind(window, 'beforeunload', beforeUnloadDelegate);
				}
	
				return editor;
			},
	
			/**
			 * Creates an editor instance and adds it to the EditorManager collection.
			 *
			 * @method createEditor
			 * @param {String} id Instance id to use for editor.
			 * @param {Object} settings Editor instance settings.
			 * @return {tinymce.Editor} Editor instance that got created.
			 */
			createEditor: function(id, settings) {
				return this.add(new Editor(id, settings, this));
			},
	
			/**
			 * Removes a editor or editors form page.
			 *
			 * @example
			 * // Remove all editors bound to divs
			 * tinymce.remove('div');
			 *
			 * // Remove all editors bound to textareas
			 * tinymce.remove('textarea');
			 *
			 * // Remove all editors
			 * tinymce.remove();
			 *
			 * // Remove specific instance by id
			 * tinymce.remove('#id');
			 *
			 * @method remove
			 * @param {tinymce.Editor/String/Object} [selector] CSS selector or editor instance to remove.
			 * @return {tinymce.Editor} The editor that got passed in will be return if it was found otherwise null.
			 */
			remove: function(selector) {
				var self = this, i, editors = self.editors, editor;
	
				// Remove all editors
				if (!selector) {
					for (i = editors.length - 1; i >= 0; i--) {
						self.remove(editors[i]);
					}
	
					return;
				}
	
				// Remove editors by selector
				if (typeof selector == "string") {
					selector = selector.selector || selector;
	
					each(DOM.select(selector), function(elm) {
						editor = editors[elm.id];
	
						if (editor) {
							self.remove(editor);
						}
					});
	
					return;
				}
	
				// Remove specific editor
				editor = selector;
	
				// Not in the collection
				if (!editors[editor.id]) {
					return null;
				}
	
				if (removeEditorFromList(editor)) {
					self.fire('RemoveEditor', {editor: editor});
				}
	
				if (!editors.length) {
					DOM.unbind(window, 'beforeunload', beforeUnloadDelegate);
				}
	
				editor.remove();
	
				toggleGlobalEvents(editors, editors.length > 0);
	
				return editor;
			},
	
			/**
			 * Executes a specific command on the currently active editor.
			 *
			 * @method execCommand
			 * @param {String} cmd Command to perform for example Bold.
			 * @param {Boolean} ui Optional boolean state if a UI should be presented for the command or not.
			 * @param {String} value Optional value parameter like for example an URL to a link.
			 * @return {Boolean} true/false if the command was executed or not.
			 */
			execCommand: function(cmd, ui, value) {
				var self = this, editor = self.get(value);
	
				// Manager commands
				switch (cmd) {
					case "mceAddEditor":
						if (!self.get(value)) {
							new Editor(value, self.settings, self).render();
						}
	
						return true;
	
					case "mceRemoveEditor":
						if (editor) {
							editor.remove();
						}
	
						return true;
	
					case 'mceToggleEditor':
						if (!editor) {
							self.execCommand('mceAddEditor', 0, value);
							return true;
						}
	
						if (editor.isHidden()) {
							editor.show();
						} else {
							editor.hide();
						}
	
						return true;
				}
	
				// Run command on active editor
				if (self.activeEditor) {
					return self.activeEditor.execCommand(cmd, ui, value);
				}
	
				return false;
			},
	
			/**
			 * Calls the save method on all editor instances in the collection. This can be useful when a form is to be submitted.
			 *
			 * @method triggerSave
			 * @example
			 * // Saves all contents
			 * tinyMCE.triggerSave();
			 */
			triggerSave: function() {
				each(this.editors, function(editor) {
					editor.save();
				});
			},
	
			/**
			 * Adds a language pack, this gets called by the loaded language files like en.js.
			 *
			 * @method addI18n
			 * @param {String} code Optional language code.
			 * @param {Object} items Name/value object with translations.
			 */
			addI18n: function(code, items) {
				I18n.add(code, items);
			},
	
			/**
			 * Translates the specified string using the language pack items.
			 *
			 * @method translate
			 * @param {String/Array/Object} text String to translate
			 * @return {String} Translated string.
			 */
			translate: function(text) {
				return I18n.translate(text);
			},
	
			/**
			 * Sets the active editor instance and fires the deactivate/activate events.
			 *
			 * @method setActive
			 * @param {tinymce.Editor} editor Editor instance to set as the active instance.
			 */
			setActive: function(editor) {
				var activeEditor = this.activeEditor;
	
				if (this.activeEditor != editor) {
					if (activeEditor) {
						activeEditor.fire('deactivate', {relatedTarget: editor});
					}
	
					editor.fire('activate', {relatedTarget: activeEditor});
				}
	
				this.activeEditor = editor;
			}
		};
	
		extend(EditorManager, Observable);
	
		EditorManager.setup();
	
		// Export EditorManager as tinymce/tinymce in global namespace
		window.tinymce = window.tinyMCE = EditorManager;
	
		return EditorManager;
	});
	
	// Included from: js/tinymce/classes/LegacyInput.js
	
	/**
	 * LegacyInput.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Converts legacy input to modern HTML.
	 *
	 * @class tinymce.LegacyInput
	 * @private
	 */
	define("tinymce/LegacyInput", [
		"tinymce/EditorManager",
		"tinymce/util/Tools"
	], function(EditorManager, Tools) {
		var each = Tools.each, explode = Tools.explode;
	
		EditorManager.on('AddEditor', function(e) {
			var editor = e.editor;
	
			editor.on('preInit', function() {
				var filters, fontSizes, dom, settings = editor.settings;
	
				function replaceWithSpan(node, styles) {
					each(styles, function(value, name) {
						if (value) {
							dom.setStyle(node, name, value);
						}
					});
	
					dom.rename(node, 'span');
				}
	
				function convert(e) {
					dom = editor.dom;
	
					if (settings.convert_fonts_to_spans) {
						each(dom.select('font,u,strike', e.node), function(node) {
							filters[node.nodeName.toLowerCase()](dom, node);
						});
					}
				}
	
				if (settings.inline_styles) {
					fontSizes = explode(settings.font_size_legacy_values);
	
					filters = {
						font: function(dom, node) {
							replaceWithSpan(node, {
								backgroundColor: node.style.backgroundColor,
								color: node.color,
								fontFamily: node.face,
								fontSize: fontSizes[parseInt(node.size, 10) - 1]
							});
						},
	
						u: function(dom, node) {
							// HTML5 allows U element
							if (editor.settings.schema === "html4") {
								replaceWithSpan(node, {
									textDecoration: 'underline'
								});
							}
						},
	
						strike: function(dom, node) {
							replaceWithSpan(node, {
								textDecoration: 'line-through'
							});
						}
					};
	
					editor.on('PreProcess SetContent', convert);
				}
			});
		});
	});
	
	// Included from: js/tinymce/classes/util/XHR.js
	
	/**
	 * XHR.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This class enables you to send XMLHTTPRequests cross browser.
	 * @class tinymce.util.XHR
	 * @mixes tinymce.util.Observable
	 * @static
	 * @example
	 * // Sends a low level Ajax request
	 * tinymce.util.XHR.send({
	 *    url: 'someurl',
	 *    success: function(text) {
	 *       console.debug(text);
	 *    }
	 * });
	 *
	 * // Add custom header to XHR request
	 * tinymce.util.XHR.on('beforeSend', function(e) {
	 *     e.xhr.setRequestHeader('X-Requested-With', 'Something');
	 * });
	 */
	define("tinymce/util/XHR", [
		"tinymce/util/Observable",
		"tinymce/util/Tools"
	], function(Observable, Tools) {
		var XHR = {
			/**
			 * Sends a XMLHTTPRequest.
			 * Consult the Wiki for details on what settings this method takes.
			 *
			 * @method send
			 * @param {Object} settings Object will target URL, callbacks and other info needed to make the request.
			 */
			send: function(settings) {
				var xhr, count = 0;
	
				function ready() {
					if (!settings.async || xhr.readyState == 4 || count++ > 10000) {
						if (settings.success && count < 10000 && xhr.status == 200) {
							settings.success.call(settings.success_scope, '' + xhr.responseText, xhr, settings);
						} else if (settings.error) {
							settings.error.call(settings.error_scope, count > 10000 ? 'TIMED_OUT' : 'GENERAL', xhr, settings);
						}
	
						xhr = null;
					} else {
						setTimeout(ready, 10);
					}
				}
	
				// Default settings
				settings.scope = settings.scope || this;
				settings.success_scope = settings.success_scope || settings.scope;
				settings.error_scope = settings.error_scope || settings.scope;
				settings.async = settings.async === false ? false : true;
				settings.data = settings.data || '';
	
				XHR.fire('beforeInitialize', {settings: settings});
	
				xhr = new XMLHttpRequest();
	
				if (xhr) {
					if (xhr.overrideMimeType) {
						xhr.overrideMimeType(settings.content_type);
					}
	
					xhr.open(settings.type || (settings.data ? 'POST' : 'GET'), settings.url, settings.async);
	
					if (settings.crossDomain) {
						xhr.withCredentials = true;
					}
	
					if (settings.content_type) {
						xhr.setRequestHeader('Content-Type', settings.content_type);
					}
	
					if (settings.requestheaders) {
						Tools.each(settings.requestheaders, function(header) {
							xhr.setRequestHeader(header.key, header.value);
						});
					}
	
					xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');
	
					xhr = XHR.fire('beforeSend', {xhr: xhr, settings: settings}).xhr;
					xhr.send(settings.data);
	
					// Syncronous request
					if (!settings.async) {
						return ready();
					}
	
					// Wait for response, onReadyStateChange can not be used since it leaks memory in IE
					setTimeout(ready, 10);
				}
			}
		};
	
		Tools.extend(XHR, Observable);
	
		return XHR;
	});
	
	// Included from: js/tinymce/classes/util/JSON.js
	
	/**
	 * JSON.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * JSON parser and serializer class.
	 *
	 * @class tinymce.util.JSON
	 * @static
	 * @example
	 * // JSON parse a string into an object
	 * var obj = tinymce.util.JSON.parse(somestring);
	 *
	 * // JSON serialize a object into an string
	 * var str = tinymce.util.JSON.serialize(obj);
	 */
	define("tinymce/util/JSON", [], function() {
		function serialize(o, quote) {
			var i, v, t, name;
	
			quote = quote || '"';
	
			if (o === null) {
				return 'null';
			}
	
			t = typeof o;
	
			if (t == 'string') {
				v = '\bb\tt\nn\ff\rr\""\'\'\\\\';
	
				/*eslint no-control-regex:0 */
				return quote + o.replace(/([\u0080-\uFFFF\x00-\x1f\"\'\\])/g, function(a, b) {
					// Make sure single quotes never get encoded inside double quotes for JSON compatibility
					if (quote === '"' && a === "'") {
						return a;
					}
	
					i = v.indexOf(b);
	
					if (i + 1) {
						return '\\' + v.charAt(i + 1);
					}
	
					a = b.charCodeAt().toString(16);
	
					return '\\u' + '0000'.substring(a.length) + a;
				}) + quote;
			}
	
			if (t == 'object') {
				if (o.hasOwnProperty && Object.prototype.toString.call(o) === '[object Array]') {
					for (i = 0, v = '['; i < o.length; i++) {
						v += (i > 0 ? ',' : '') + serialize(o[i], quote);
					}
	
					return v + ']';
				}
	
				v = '{';
	
				for (name in o) {
					if (o.hasOwnProperty(name)) {
						v += typeof o[name] != 'function' ? (v.length > 1 ? ',' + quote : quote) + name +
							quote + ':' + serialize(o[name], quote) : '';
					}
				}
	
				return v + '}';
			}
	
			return '' + o;
		}
	
		return {
			/**
			 * Serializes the specified object as a JSON string.
			 *
			 * @method serialize
			 * @param {Object} obj Object to serialize as a JSON string.
			 * @param {String} quote Optional quote string defaults to ".
			 * @return {string} JSON string serialized from input.
			 */
			serialize: serialize,
	
			/**
			 * Unserializes/parses the specified JSON string into a object.
			 *
			 * @method parse
			 * @param {string} s JSON String to parse into a JavaScript object.
			 * @return {Object} Object from input JSON string or undefined if it failed.
			 */
			parse: function(text) {
				try {
					// Trick uglify JS
					return window[String.fromCharCode(101) + 'val']('(' + text + ')');
				} catch (ex) {
					// Ignore
				}
			}
	
			/**#@-*/
		};
	});
	
	// Included from: js/tinymce/classes/util/JSONRequest.js
	
	/**
	 * JSONRequest.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This class enables you to use JSON-RPC to call backend methods.
	 *
	 * @class tinymce.util.JSONRequest
	 * @example
	 * var json = new tinymce.util.JSONRequest({
	 *     url: 'somebackend.php'
	 * });
	 *
	 * // Send RPC call 1
	 * json.send({
	 *     method: 'someMethod1',
	 *     params: ['a', 'b'],
	 *     success: function(result) {
	 *         console.dir(result);
	 *     }
	 * });
	 *
	 * // Send RPC call 2
	 * json.send({
	 *     method: 'someMethod2',
	 *     params: ['a', 'b'],
	 *     success: function(result) {
	 *         console.dir(result);
	 *     }
	 * });
	 */
	define("tinymce/util/JSONRequest", [
		"tinymce/util/JSON",
		"tinymce/util/XHR",
		"tinymce/util/Tools"
	], function(JSON, XHR, Tools) {
		var extend = Tools.extend;
	
		function JSONRequest(settings) {
			this.settings = extend({}, settings);
			this.count = 0;
		}
	
		/**
		 * Simple helper function to send a JSON-RPC request without the need to initialize an object.
		 * Consult the Wiki API documentation for more details on what you can pass to this function.
		 *
		 * @method sendRPC
		 * @static
		 * @param {Object} o Call object where there are three field id, method and params this object should also contain callbacks etc.
		 */
		JSONRequest.sendRPC = function(o) {
			return new JSONRequest().send(o);
		};
	
		JSONRequest.prototype = {
			/**
			 * Sends a JSON-RPC call. Consult the Wiki API documentation for more details on what you can pass to this function.
			 *
			 * @method send
			 * @param {Object} args Call object where there are three field id, method and params this object should also contain callbacks etc.
			 */
			send: function(args) {
				var ecb = args.error, scb = args.success;
	
				args = extend(this.settings, args);
	
				args.success = function(c, x) {
					c = JSON.parse(c);
	
					if (typeof c == 'undefined') {
						c = {
							error: 'JSON Parse error.'
						};
					}
	
					if (c.error) {
						ecb.call(args.error_scope || args.scope, c.error, x);
					} else {
						scb.call(args.success_scope || args.scope, c.result);
					}
				};
	
				args.error = function(ty, x) {
					if (ecb) {
						ecb.call(args.error_scope || args.scope, ty, x);
					}
				};
	
				args.data = JSON.serialize({
					id: args.id || 'c' + (this.count++),
					method: args.method,
					params: args.params
				});
	
				// JSON content type for Ruby on rails. Bug: #1883287
				args.content_type = 'application/json';
	
				XHR.send(args);
			}
		};
	
		return JSONRequest;
	});
	
	// Included from: js/tinymce/classes/util/JSONP.js
	
	/**
	 * JSONP.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	define("tinymce/util/JSONP", [
		"tinymce/dom/DOMUtils"
	], function(DOMUtils) {
		return {
			callbacks: {},
			count: 0,
	
			send: function(settings) {
				var self = this, dom = DOMUtils.DOM, count = settings.count !== undefined ? settings.count : self.count;
				var id = 'tinymce_jsonp_' + count;
	
				self.callbacks[count] = function(json) {
					dom.remove(id);
					delete self.callbacks[count];
	
					settings.callback(json);
				};
	
				dom.add(dom.doc.body, 'script', {
					id: id,
					src: settings.url,
					type: 'text/javascript'
				});
	
				self.count++;
			}
		};
	});
	
	// Included from: js/tinymce/classes/util/LocalStorage.js
	
	/**
	 * LocalStorage.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This class will simulate LocalStorage on IE 7 and return the native version on modern browsers.
	 * Storage is done using userData on IE 7 and a special serialization format. The format is designed
	 * to be as small as possible by making sure that the keys and values doesn't need to be encoded. This
	 * makes it possible to store for example HTML data.
	 *
	 * Storage format for userData:
	 * <base 32 key length>,<key string>,<base 32 value length>,<value>,...
	 *
	 * For example this data key1=value1,key2=value2 would be:
	 * 4,key1,6,value1,4,key2,6,value2
	 *
	 * @class tinymce.util.LocalStorage
	 * @static
	 * @version 4.0
	 * @example
	 * tinymce.util.LocalStorage.setItem('key', 'value');
	 * var value = tinymce.util.LocalStorage.getItem('key');
	 */
	define("tinymce/util/LocalStorage", [], function() {
		var LocalStorage, storageElm, items, keys, userDataKey, hasOldIEDataSupport;
	
		// Check for native support
		try {
			if (window.localStorage) {
				return localStorage;
			}
		} catch (ex) {
			// Ignore
		}
	
		userDataKey = "tinymce";
		storageElm = document.documentElement;
		hasOldIEDataSupport = !!storageElm.addBehavior;
	
		if (hasOldIEDataSupport) {
			storageElm.addBehavior('#default#userData');
		}
	
		/**
		 * Gets the keys names and updates LocalStorage.length property. Since IE7 doesn't have any getters/setters.
		 */
		function updateKeys() {
			keys = [];
	
			for (var key in items) {
				keys.push(key);
			}
	
			LocalStorage.length = keys.length;
		}
	
		/**
		 * Loads the userData string and parses it into the items structure.
		 */
		function load() {
			var key, data, value, pos = 0;
	
			items = {};
	
			// localStorage can be disabled on WebKit/Gecko so make a dummy storage
			if (!hasOldIEDataSupport) {
				return;
			}
	
			function next(end) {
				var value, nextPos;
	
				nextPos = end !== undefined ? pos + end : data.indexOf(',', pos);
				if (nextPos === -1 || nextPos > data.length) {
					return null;
				}
	
				value = data.substring(pos, nextPos);
				pos = nextPos + 1;
	
				return value;
			}
	
			storageElm.load(userDataKey);
			data = storageElm.getAttribute(userDataKey) || '';
	
			do {
				var offset = next();
				if (offset === null) {
					break;
				}
	
				key = next(parseInt(offset, 32) || 0);
				if (key !== null) {
					offset = next();
					if (offset === null) {
						break;
					}
	
					value = next(parseInt(offset, 32) || 0);
	
					if (key) {
						items[key] = value;
					}
				}
			} while (key !== null);
	
			updateKeys();
		}
	
		/**
		 * Saves the items structure into a the userData format.
		 */
		function save() {
			var value, data = '';
	
			// localStorage can be disabled on WebKit/Gecko so make a dummy storage
			if (!hasOldIEDataSupport) {
				return;
			}
	
			for (var key in items) {
				value = items[key];
				data += (data ? ',' : '') + key.length.toString(32) + ',' + key + ',' + value.length.toString(32) + ',' + value;
			}
	
			storageElm.setAttribute(userDataKey, data);
	
			try {
				storageElm.save(userDataKey);
			} catch (ex) {
				// Ignore disk full
			}
	
			updateKeys();
		}
	
		LocalStorage = {
			/**
			 * Length of the number of items in storage.
			 *
			 * @property length
			 * @type Number
			 * @return {Number} Number of items in storage.
			 */
			//length:0,
	
			/**
			 * Returns the key name by index.
			 *
			 * @method key
			 * @param {Number} index Index of key to return.
			 * @return {String} Key value or null if it wasn't found.
			 */
			key: function(index) {
				return keys[index];
			},
	
			/**
			 * Returns the value if the specified key or null if it wasn't found.
			 *
			 * @method getItem
			 * @param {String} key Key of item to retrieve.
			 * @return {String} Value of the specified item or null if it wasn't found.
			 */
			getItem: function(key) {
				return key in items ? items[key] : null;
			},
	
			/**
			 * Sets the value of the specified item by it's key.
			 *
			 * @method setItem
			 * @param {String} key Key of the item to set.
			 * @param {String} value Value of the item to set.
			 */
			setItem: function(key, value) {
				items[key] = "" + value;
				save();
			},
	
			/**
			 * Removes the specified item by key.
			 *
			 * @method removeItem
			 * @param {String} key Key of item to remove.
			 */
			removeItem: function(key) {
				delete items[key];
				save();
			},
	
			/**
			 * Removes all items.
			 *
			 * @method clear
			 */
			clear: function() {
				items = {};
				save();
			}
		};
	
		load();
	
		return LocalStorage;
	});
	
	// Included from: js/tinymce/classes/Compat.js
	
	/**
	 * Compat.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * TinyMCE core class.
	 *
	 * @static
	 * @class tinymce
	 * @borrow-members tinymce.EditorManager
	 * @borrow-members tinymce.util.Tools
	 */
	define("tinymce/Compat", [
		"tinymce/dom/DOMUtils",
		"tinymce/dom/EventUtils",
		"tinymce/dom/ScriptLoader",
		"tinymce/AddOnManager",
		"tinymce/util/Tools",
		"tinymce/Env"
	], function(DOMUtils, EventUtils, ScriptLoader, AddOnManager, Tools, Env) {
		var tinymce = window.tinymce;
	
		/**
		 * @property {tinymce.dom.DOMUtils} DOM Global DOM instance.
		 * @property {tinymce.dom.ScriptLoader} ScriptLoader Global ScriptLoader instance.
		 * @property {tinymce.AddOnManager} PluginManager Global PluginManager instance.
		 * @property {tinymce.AddOnManager} ThemeManager Global ThemeManager instance.
		 */
		tinymce.DOM = DOMUtils.DOM;
		tinymce.ScriptLoader = ScriptLoader.ScriptLoader;
		tinymce.PluginManager = AddOnManager.PluginManager;
		tinymce.ThemeManager = AddOnManager.ThemeManager;
	
		tinymce.dom = tinymce.dom || {};
		tinymce.dom.Event = EventUtils.Event;
	
		Tools.each(
			'trim isArray is toArray makeMap each map grep inArray extend create walk createNS resolve explode _addCacheSuffix'.split(' '),
			function(key) {
				tinymce[key] = Tools[key];
			}
		);
	
		Tools.each('isOpera isWebKit isIE isGecko isMac'.split(' '), function(name) {
			tinymce[name] = Env[name.substr(2).toLowerCase()];
		});
	
		return {};
	});
	
	// Describe the different namespaces
	
	/**
	 * Root level namespace this contains classes directly related to the TinyMCE editor.
	 *
	 * @namespace tinymce
	 */
	
	/**
	 * Contains classes for handling the browsers DOM.
	 *
	 * @namespace tinymce.dom
	 */
	
	/**
	 * Contains html parser and serializer logic.
	 *
	 * @namespace tinymce.html
	 */
	
	/**
	 * Contains the different UI types such as buttons, listboxes etc.
	 *
	 * @namespace tinymce.ui
	 */
	
	/**
	 * Contains various utility classes such as json parser, cookies etc.
	 *
	 * @namespace tinymce.util
	 */
	
	/**
	 * Contains modules to handle data binding.
	 *
	 * @namespace tinymce.data
	 */
	
	// Included from: js/tinymce/classes/ui/Layout.js
	
	/**
	 * Layout.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Base layout manager class.
	 *
	 * @class tinymce.ui.Layout
	 */
	define("tinymce/ui/Layout", [
		"tinymce/util/Class",
		"tinymce/util/Tools"
	], function(Class, Tools) {
		"use strict";
	
		return Class.extend({
			Defaults: {
				firstControlClass: 'first',
				lastControlClass: 'last'
			},
	
			/**
			 * Constructs a layout instance with the specified settings.
			 *
			 * @constructor
			 * @param {Object} settings Name/value object with settings.
			 */
			init: function(settings) {
				this.settings = Tools.extend({}, this.Defaults, settings);
			},
	
			/**
			 * This method gets invoked before the layout renders the controls.
			 *
			 * @method preRender
			 * @param {tinymce.ui.Container} container Container instance to preRender.
			 */
			preRender: function(container) {
				container.bodyClasses.add(this.settings.containerClass);
			},
	
			/**
			 * Applies layout classes to the container.
			 *
			 * @private
			 */
			applyClasses: function(items) {
				var self = this, settings = self.settings, firstClass, lastClass, firstItem, lastItem;
	
				firstClass = settings.firstControlClass;
				lastClass = settings.lastControlClass;
	
				items.each(function(item) {
					item.classes.remove(firstClass).remove(lastClass).add(settings.controlClass);
	
					if (item.visible()) {
						if (!firstItem) {
							firstItem = item;
						}
	
						lastItem = item;
					}
				});
	
				if (firstItem) {
					firstItem.classes.add(firstClass);
				}
	
				if (lastItem) {
					lastItem.classes.add(lastClass);
				}
			},
	
			/**
			 * Renders the specified container and any layout specific HTML.
			 *
			 * @method renderHtml
			 * @param {tinymce.ui.Container} container Container to render HTML for.
			 */
			renderHtml: function(container) {
				var self = this, html = '';
	
				self.applyClasses(container.items());
	
				container.items().each(function(item) {
					html += item.renderHtml();
				});
	
				return html;
			},
	
			/**
			 * Recalculates the positions of the controls in the specified container.
			 *
			 * @method recalc
			 * @param {tinymce.ui.Container} container Container instance to recalc.
			 */
			recalc: function() {
			},
	
			/**
			 * This method gets invoked after the layout renders the controls.
			 *
			 * @method postRender
			 * @param {tinymce.ui.Container} container Container instance to postRender.
			 */
			postRender: function() {
			},
	
			isNative: function() {
				return false;
			}
		});
	});
	
	// Included from: js/tinymce/classes/ui/AbsoluteLayout.js
	
	/**
	 * AbsoluteLayout.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * LayoutManager for absolute positioning. This layout manager is more of
	 * a base class for other layouts but can be created and used directly.
	 *
	 * @-x-less AbsoluteLayout.less
	 * @class tinymce.ui.AbsoluteLayout
	 * @extends tinymce.ui.Layout
	 */
	define("tinymce/ui/AbsoluteLayout", [
		"tinymce/ui/Layout"
	], function(Layout) {
		"use strict";
	
		return Layout.extend({
			Defaults: {
				containerClass: 'abs-layout',
				controlClass: 'abs-layout-item'
			},
	
			/**
			 * Recalculates the positions of the controls in the specified container.
			 *
			 * @method recalc
			 * @param {tinymce.ui.Container} container Container instance to recalc.
			 */
			recalc: function(container) {
				container.items().filter(':visible').each(function(ctrl) {
					var settings = ctrl.settings;
	
					ctrl.layoutRect({
						x: settings.x,
						y: settings.y,
						w: settings.w,
						h: settings.h
					});
	
					if (ctrl.recalc) {
						ctrl.recalc();
					}
				});
			},
	
			/**
			 * Renders the specified container and any layout specific HTML.
			 *
			 * @method renderHtml
			 * @param {tinymce.ui.Container} container Container to render HTML for.
			 */
			renderHtml: function(container) {
				return '<div id="' + container._id + '-absend" class="' + container.classPrefix + 'abs-end"></div>' + this._super(container);
			}
		});
	});
	
	// Included from: js/tinymce/classes/ui/Button.js
	
	/**
	 * Button.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This class is used to create buttons. You can create them directly or through the Factory.
	 *
	 * @example
	 * // Create and render a button to the body element
	 * tinymce.ui.Factory.create({
	 *     type: 'button',
	 *     text: 'My button'
	 * }).renderTo(document.body);
	 *
	 * @-x-less Button.less
	 * @class tinymce.ui.Button
	 * @extends tinymce.ui.Widget
	 */
	define("tinymce/ui/Button", [
		"tinymce/ui/Widget"
	], function(Widget) {
		"use strict";
	
		return Widget.extend({
			Defaults: {
				classes: "widget btn",
				role: "button"
			},
	
			/**
			 * Constructs a new button instance with the specified settings.
			 *
			 * @constructor
			 * @param {Object} settings Name/value object with settings.
			 * @setting {String} size Size of the button small|medium|large.
			 * @setting {String} image Image to use for icon.
			 * @setting {String} icon Icon to use for button.
			 */
			init: function(settings) {
				var self = this, size;
	
				self._super(settings);
				settings = self.settings;
	
				size = self.settings.size;
	
				self.on('click mousedown', function(e) {
					e.preventDefault();
				});
	
				self.on('touchstart', function(e) {
					self.fire('click', e);
					e.preventDefault();
				});
	
				if (settings.subtype) {
					self.classes.add(settings.subtype);
				}
	
				if (size) {
					self.classes.add('btn-' + size);
				}
	
				if (settings.icon) {
					self.icon(settings.icon);
				}
			},
	
			/**
			 * Sets/gets the current button icon.
			 *
			 * @method icon
			 * @param {String} [icon] New icon identifier.
			 * @return {String|tinymce.ui.MenuButton} Current icon or current MenuButton instance.
			 */
			icon: function(icon) {
				if (!arguments.length) {
					return this.state.get('icon');
				}
	
				this.state.set('icon', icon);
	
				return this;
			},
	
			/**
			 * Repaints the button for example after it's been resizes by a layout engine.
			 *
			 * @method repaint
			 */
			repaint: function() {
				var btnElm = this.getEl().firstChild,
					btnStyle;
	
				if (btnElm) {
					btnStyle = btnElm.style;
					btnStyle.width = btnStyle.height = "100%";
				}
	
				this._super();
			},
	
			/**
			 * Renders the control as a HTML string.
			 *
			 * @method renderHtml
			 * @return {String} HTML representing the control.
			 */
			renderHtml: function() {
				var self = this, id = self._id, prefix = self.classPrefix;
				var icon = self.state.get('icon'), image, text = self.state.get('text'), textHtml = '';
	
				image = self.settings.image;
				if (image) {
					icon = 'none';
	
					// Support for [high dpi, low dpi] image sources
					if (typeof image != "string") {
						image = window.getSelection ? image[0] : image[1];
					}
	
					image = ' style="background-image: url(\'' + image + '\')"';
				} else {
					image = '';
				}
	
				if (text) {
					self.classes.add('btn-has-text');
					textHtml = '<span class="' + prefix + 'txt">' + self.encode(text) + '</span>';
				}
	
				icon = icon ? prefix + 'ico ' + prefix + 'i-' + icon : '';
	
				return (
					'<div id="' + id + '" class="' + self.classes + '" tabindex="-1" aria-labelledby="' + id + '">' +
						'<button role="presentation" type="button" tabindex="-1">' +
							(icon ? '<i class="' + icon + '"' + image + '></i>' : '') +
							textHtml +
						'</button>' +
					'</div>'
				);
			},
	
			bindStates: function() {
				var self = this, $ = self.$, textCls = self.classPrefix + 'txt';
	
				function setButtonText(text) {
					var $span = $('span.' + textCls, self.getEl());
	
					if (text) {
						if (!$span[0]) {
							$('button:first', self.getEl()).append('<span class="' + textCls + '"></span>');
							$span = $('span.' + textCls, self.getEl());
						}
	
						$span.html(self.encode(text));
					} else {
						$span.remove();
					}
	
					self.classes.toggle('btn-has-text', !!text);
				}
	
				self.state.on('change:text', function(e) {
					setButtonText(e.value);
				});
	
				self.state.on('change:icon', function(e) {
					var icon = e.value, prefix = self.classPrefix;
	
					self.settings.icon = icon;
					icon = icon ? prefix + 'ico ' + prefix + 'i-' + self.settings.icon : '';
	
					var btnElm = self.getEl().firstChild, iconElm = btnElm.getElementsByTagName('i')[0];
	
					if (icon) {
						if (!iconElm || iconElm != btnElm.firstChild) {
							iconElm = document.createElement('i');
							btnElm.insertBefore(iconElm, btnElm.firstChild);
						}
	
						iconElm.className = icon;
					} else if (iconElm) {
						btnElm.removeChild(iconElm);
					}
	
					setButtonText(self.state.get('text'));
				});
	
				return self._super();
			}
		});
	});
	
	// Included from: js/tinymce/classes/ui/ButtonGroup.js
	
	/**
	 * ButtonGroup.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This control enables you to put multiple buttons into a group. This is
	 * useful when you want to combine similar toolbar buttons into a group.
	 *
	 * @example
	 * // Create and render a buttongroup with two buttons to the body element
	 * tinymce.ui.Factory.create({
	 *     type: 'buttongroup',
	 *     items: [
	 *         {text: 'Button A'},
	 *         {text: 'Button B'}
	 *     ]
	 * }).renderTo(document.body);
	 *
	 * @-x-less ButtonGroup.less
	 * @class tinymce.ui.ButtonGroup
	 * @extends tinymce.ui.Container
	 */
	define("tinymce/ui/ButtonGroup", [
		"tinymce/ui/Container"
	], function(Container) {
		"use strict";
	
		return Container.extend({
			Defaults: {
				defaultType: 'button',
				role: 'group'
			},
	
			/**
			 * Renders the control as a HTML string.
			 *
			 * @method renderHtml
			 * @return {String} HTML representing the control.
			 */
			renderHtml: function() {
				var self = this, layout = self._layout;
	
				self.classes.add('btn-group');
				self.preRender();
				layout.preRender(self);
	
				return (
					'<div id="' + self._id + '" class="' + self.classes + '">' +
						'<div id="' + self._id + '-body">' +
							(self.settings.html || '') + layout.renderHtml(self) +
						'</div>' +
					'</div>'
				);
			}
		});
	});
	
	// Included from: js/tinymce/classes/ui/Checkbox.js
	
	/**
	 * Checkbox.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This control creates a custom checkbox.
	 *
	 * @example
	 * // Create and render a checkbox to the body element
	 * tinymce.ui.Factory.create({
	 *     type: 'checkbox',
	 *     checked: true,
	 *     text: 'My checkbox'
	 * }).renderTo(document.body);
	 *
	 * @-x-less Checkbox.less
	 * @class tinymce.ui.Checkbox
	 * @extends tinymce.ui.Widget
	 */
	define("tinymce/ui/Checkbox", [
		"tinymce/ui/Widget"
	], function(Widget) {
		"use strict";
	
		return Widget.extend({
			Defaults: {
				classes: "checkbox",
				role: "checkbox",
				checked: false
			},
	
			/**
			 * Constructs a new Checkbox instance with the specified settings.
			 *
			 * @constructor
			 * @param {Object} settings Name/value object with settings.
			 * @setting {Boolean} checked True if the checkbox should be checked by default.
			 */
			init: function(settings) {
				var self = this;
	
				self._super(settings);
	
				self.on('click mousedown', function(e) {
					e.preventDefault();
				});
	
				self.on('click', function(e) {
					e.preventDefault();
	
					if (!self.disabled()) {
						self.checked(!self.checked());
					}
				});
	
				self.checked(self.settings.checked);
			},
	
			/**
			 * Getter/setter function for the checked state.
			 *
			 * @method checked
			 * @param {Boolean} [state] State to be set.
			 * @return {Boolean|tinymce.ui.Checkbox} True/false or checkbox if it's a set operation.
			 */
			checked: function(state) {
				if (!arguments.length) {
					return this.state.get('checked');
				}
	
				this.state.set('checked', state);
	
				return this;
			},
	
			/**
			 * Getter/setter function for the value state.
			 *
			 * @method value
			 * @param {Boolean} [state] State to be set.
			 * @return {Boolean|tinymce.ui.Checkbox} True/false or checkbox if it's a set operation.
			 */
			value: function(state) {
				if (!arguments.length) {
					return this.checked();
				}
	
				return this.checked(state);
			},
	
			/**
			 * Renders the control as a HTML string.
			 *
			 * @method renderHtml
			 * @return {String} HTML representing the control.
			 */
			renderHtml: function() {
				var self = this, id = self._id, prefix = self.classPrefix;
	
				return (
					'<div id="' + id + '" class="' + self.classes + '" unselectable="on" aria-labelledby="' + id + '-al" tabindex="-1">' +
						'<i class="' + prefix + 'ico ' + prefix + 'i-checkbox"></i>' +
						'<span id="' + id + '-al" class="' + prefix + 'label">' + self.encode(self.state.get('text')) + '</span>' +
					'</div>'
				);
			},
	
			bindStates: function() {
				var self = this;
	
				function checked(state) {
					self.classes.toggle("checked", state);
					self.aria('checked', state);
				}
	
				self.state.on('change:text', function(e) {
					self.getEl('al').firstChild.data = self.translate(e.value);
				});
	
				self.state.on('change:checked change:value', function(e) {
					self.fire('change');
					checked(e.value);
				});
	
				self.state.on('change:icon', function(e) {
					var icon = e.value, prefix = self.classPrefix;
	
					if (typeof icon == 'undefined') {
						return self.settings.icon;
					}
	
					self.settings.icon = icon;
					icon = icon ? prefix + 'ico ' + prefix + 'i-' + self.settings.icon : '';
	
					var btnElm = self.getEl().firstChild, iconElm = btnElm.getElementsByTagName('i')[0];
	
					if (icon) {
						if (!iconElm || iconElm != btnElm.firstChild) {
							iconElm = document.createElement('i');
							btnElm.insertBefore(iconElm, btnElm.firstChild);
						}
	
						iconElm.className = icon;
					} else if (iconElm) {
						btnElm.removeChild(iconElm);
					}
				});
	
				if (self.state.get('checked')) {
					checked(true);
				}
	
				return self._super();
			}
		});
	});
	
	// Included from: js/tinymce/classes/ui/ComboBox.js
	
	/**
	 * ComboBox.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This class creates a combobox control. Select box that you select a value from or
	 * type a value into.
	 *
	 * @-x-less ComboBox.less
	 * @class tinymce.ui.ComboBox
	 * @extends tinymce.ui.Widget
	 */
	define("tinymce/ui/ComboBox", [
		"tinymce/ui/Widget",
		"tinymce/ui/Factory",
		"tinymce/ui/DomUtils",
		"tinymce/dom/DomQuery",
		"tinymce/util/VK",
		"tinymce/util/Tools"
	], function(Widget, Factory, DomUtils, $, VK, Tools) {
		"use strict";
	
		return Widget.extend({
			/**
			 * Constructs a new control instance with the specified settings.
			 *
			 * @constructor
			 * @param {Object} settings Name/value object with settings.
			 * @setting {String} placeholder Placeholder text to display.
			 */
			init: function(settings) {
				var self = this;
	
				self._super(settings);
				settings = self.settings;
	
				self.classes.add('combobox');
				self.subinput = true;
				self.ariaTarget = 'inp'; // TODO: Figure out a better way
	
				settings.menu = settings.menu || settings.values;
	
				if (settings.menu) {
					settings.icon = 'caret';
				}
	
				self.on('click', function(e) {
					var elm = e.target, root = self.getEl();
	
					if (!$.contains(root, elm) && elm != root) {
						return;
					}
	
					while (elm && elm != root) {
						if (elm.id && elm.id.indexOf('-open') != -1) {
							self.fire('action');
	
							if (settings.menu) {
								self.showMenu();
	
								if (e.aria) {
									self.menu.items()[0].focus();
								}
							}
						}
	
						elm = elm.parentNode;
					}
				});
	
				// TODO: Rework this
				self.on('keydown', function(e) {
					var rootControl;
	
					if (e.keyCode == 13 && e.target.nodeName === 'INPUT') {
						e.preventDefault();
	
						// Find root control that we can do toJSON on
						self.parents().reverse().each(function(ctrl) {
							if (ctrl.toJSON) {
								rootControl = ctrl;
								return false;
							}
						});
	
						// Fire event on current text box with the serialized data of the whole form
						self.fire('submit', {data: rootControl.toJSON()});
					}
				});
	
				self.on('keyup', function(e) {
					if (e.target.nodeName == "INPUT") {
						var oldValue = self.state.get('value');
						var newValue = e.target.value;
	
						if (newValue !== oldValue) {
							self.state.set('value', newValue);
							self.fire('autocomplete', e);
						}
					}
				});
	
				self.on('mouseover', function(e) {
					var tooltip = self.tooltip().moveTo(-0xFFFF);
	
					if (self.statusLevel() && e.target.className.indexOf(self.classPrefix + 'status') !== -1) {
						var statusMessage = self.statusMessage() || 'Ok';
						var rel = tooltip.text(statusMessage).show().testMoveRel(e.target, ['bc-tc', 'bc-tl', 'bc-tr']);
	
						tooltip.classes.toggle('tooltip-n', rel == 'bc-tc');
						tooltip.classes.toggle('tooltip-nw', rel == 'bc-tl');
						tooltip.classes.toggle('tooltip-ne', rel == 'bc-tr');
	
						tooltip.moveRel(e.target, rel);
					}
				});
			},
	
			statusLevel: function (value) {
				if (arguments.length > 0) {
					this.state.set('statusLevel', value);
				}
	
				return this.state.get('statusLevel');
			},
	
			statusMessage: function (value) {
				if (arguments.length > 0) {
					this.state.set('statusMessage', value);
				}
	
				return this.state.get('statusMessage');
			},
	
			showMenu: function() {
				var self = this, settings = self.settings, menu;
	
				if (!self.menu) {
					menu = settings.menu || [];
	
					// Is menu array then auto constuct menu control
					if (menu.length) {
						menu = {
							type: 'menu',
							items: menu
						};
					} else {
						menu.type = menu.type || 'menu';
					}
	
					self.menu = Factory.create(menu).parent(self).renderTo(self.getContainerElm());
					self.fire('createmenu');
					self.menu.reflow();
					self.menu.on('cancel', function(e) {
						if (e.control === self.menu) {
							self.focus();
						}
					});
	
					self.menu.on('show hide', function(e) {
						e.control.items().each(function(ctrl) {
							ctrl.active(ctrl.value() == self.value());
						});
					}).fire('show');
	
					self.menu.on('select', function(e) {
						self.value(e.control.value());
					});
	
					self.on('focusin', function(e) {
						if (e.target.tagName.toUpperCase() == 'INPUT') {
							self.menu.hide();
						}
					});
	
					self.aria('expanded', true);
				}
	
				self.menu.show();
				self.menu.layoutRect({w: self.layoutRect().w});
				self.menu.moveRel(self.getEl(), self.isRtl() ? ['br-tr', 'tr-br'] : ['bl-tl', 'tl-bl']);
			},
	
			/**
			 * Focuses the input area of the control.
			 *
			 * @method focus
			 */
			focus: function() {
				this.getEl('inp').focus();
			},
	
			/**
			 * Repaints the control after a layout operation.
			 *
			 * @method repaint
			 */
			repaint: function() {
				var self = this, elm = self.getEl(), openElm = self.getEl('open'), rect = self.layoutRect();
				var width, lineHeight, innerPadding = 0, inputElm = elm.firstChild;
	
				if (self.statusLevel() && self.statusLevel() !== 'none') {
					innerPadding = (
						parseInt(DomUtils.getRuntimeStyle(inputElm, 'padding-right'), 10) -
						parseInt(DomUtils.getRuntimeStyle(inputElm, 'padding-left'), 10)
					);
				}
	
				if (openElm) {
					width = rect.w - DomUtils.getSize(openElm).width - 10;
				} else {
					width = rect.w - 10;
				}
	
				// Detect old IE 7+8 add lineHeight to align caret vertically in the middle
				var doc = document;
				if (doc.all && (!doc.documentMode || doc.documentMode <= 8)) {
					lineHeight = (self.layoutRect().h - 2) + 'px';
				}
	
				$(inputElm).css({
					width: width - innerPadding,
					lineHeight: lineHeight
				});
	
				self._super();
	
				return self;
			},
	
			/**
			 * Post render method. Called after the control has been rendered to the target.
			 *
			 * @method postRender
			 * @return {tinymce.ui.ComboBox} Current combobox instance.
			 */
			postRender: function() {
				var self = this;
	
				$(this.getEl('inp')).on('change', function(e) {
					self.state.set('value', e.target.value);
					self.fire('change', e);
				});
	
				return self._super();
			},
	
			/**
			 * Renders the control as a HTML string.
			 *
			 * @method renderHtml
			 * @return {String} HTML representing the control.
			 */
			renderHtml: function() {
				var self = this, id = self._id, settings = self.settings, prefix = self.classPrefix;
				var value = self.state.get('value') || '';
				var icon, text, openBtnHtml = '', extraAttrs = '', statusHtml = '';
	
				if ("spellcheck" in settings) {
					extraAttrs += ' spellcheck="' + settings.spellcheck + '"';
				}
	
				if (settings.maxLength) {
					extraAttrs += ' maxlength="' + settings.maxLength + '"';
				}
	
				if (settings.size) {
					extraAttrs += ' size="' + settings.size + '"';
				}
	
				if (settings.subtype) {
					extraAttrs += ' type="' + settings.subtype + '"';
				}
	
				statusHtml = '<i id="' + id + '-status" class="mce-status mce-ico" style="display: none"></i>';
	
				if (self.disabled()) {
					extraAttrs += ' disabled="disabled"';
				}
	
				icon = settings.icon;
				if (icon && icon != 'caret') {
					icon = prefix + 'ico ' + prefix + 'i-' + settings.icon;
				}
	
				text = self.state.get('text');
	
				if (icon || text) {
					openBtnHtml = (
						'<div id="' + id + '-open" class="' + prefix + 'btn ' + prefix + 'open" tabIndex="-1" role="button">' +
							'<button id="' + id + '-action" type="button" hidefocus="1" tabindex="-1">' +
								(icon != 'caret' ? '<i class="' + icon + '"></i>' : '<i class="' + prefix + 'caret"></i>') +
								(text ? (icon ? ' ' : '') + text : '') +
							'</button>' +
						'</div>'
					);
	
					self.classes.add('has-open');
				}
	
				return (
					'<div id="' + id + '" class="' + self.classes + '">' +
						'<input id="' + id + '-inp" class="' + prefix + 'textbox" value="' +
						self.encode(value, false) + '" hidefocus="1"' + extraAttrs + ' placeholder="' +
						self.encode(settings.placeholder) + '" />' +
						statusHtml +
						openBtnHtml +
					'</div>'
				);
			},
	
			value: function(value) {
				if (arguments.length) {
					this.state.set('value', value);
					return this;
				}
	
				// Make sure the real state is in sync
				if (this.state.get('rendered')) {
					this.state.set('value', this.getEl('inp').value);
				}
	
				return this.state.get('value');
			},
	
			showAutoComplete: function (items, term) {
				var self = this;
	
				if (items.length === 0) {
					self.hideMenu();
					return;
				}
	
				var insert = function (value, title) {
					return function () {
						self.fire('selectitem', {
							title: title,
							value: value
						});
					};
				};
	
				if (self.menu) {
					self.menu.items().remove();
				} else {
					self.menu = Factory.create({
						type: 'menu',
						classes: 'combobox-menu',
						layout: 'flow'
					}).parent(self).renderTo();
				}
	
				Tools.each(items, function (item) {
					self.menu.add({
						text: item.title,
						url: item.previewUrl,
						match: term,
						classes: 'menu-item-ellipsis',
						onclick: insert(item.value, item.title)
					});
				});
	
				self.menu.renderNew();
				self.hideMenu();
	
				self.menu.on('cancel', function(e) {
					if (e.control.parent() === self.menu) {
						e.stopPropagation();
						self.focus();
						self.hideMenu();
					}
				});
	
				self.menu.on('select', function() {
					self.focus();
				});
	
				var maxW = self.layoutRect().w;
				self.menu.layoutRect({w: maxW, minW: 0, maxW: maxW});
				self.menu.reflow();
				self.menu.show();
				self.menu.moveRel(self.getEl(), self.isRtl() ? ['br-tr', 'tr-br'] : ['bl-tl', 'tl-bl']);
			},
	
			hideMenu: function() {
				if (this.menu) {
					this.menu.hide();
				}
			},
	
			bindStates: function() {
				var self = this;
	
				self.state.on('change:value', function(e) {
					if (self.getEl('inp').value != e.value) {
						self.getEl('inp').value = e.value;
					}
				});
	
				self.state.on('change:disabled', function(e) {
					self.getEl('inp').disabled = e.value;
				});
	
				self.state.on('change:statusLevel', function(e) {
					var statusIconElm = self.getEl('status');
					var prefix = self.classPrefix, value = e.value;
	
					DomUtils.css(statusIconElm, 'display', value === 'none' ? 'none' : '');
					DomUtils.toggleClass(statusIconElm, prefix + 'i-checkmark', value === 'ok');
					DomUtils.toggleClass(statusIconElm, prefix + 'i-warning', value === 'warn');
					DomUtils.toggleClass(statusIconElm, prefix + 'i-error', value === 'error');
					self.classes.toggle('has-status', value !== 'none');
					self.repaint();
				});
	
				DomUtils.on(self.getEl('status'), 'mouseleave', function () {
					self.tooltip().hide();
				});
	
				self.on('cancel', function (e) {
					if (self.menu && self.menu.visible()) {
						e.stopPropagation();
						self.hideMenu();
					}
				});
	
				var focusIdx = function (idx, menu) {
					if (menu && menu.items().length > 0) {
						menu.items().eq(idx)[0].focus();
					}
				};
	
				self.on('keydown', function (e) {
					var keyCode = e.keyCode;
	
					if (e.target.nodeName === 'INPUT') {
						if (keyCode === VK.DOWN) {
							e.preventDefault();
							self.fire('autocomplete');
							focusIdx(0, self.menu);
						} else if (keyCode === VK.UP) {
							e.preventDefault();
							focusIdx(-1, self.menu);
						}
					}
				});
	
				return self._super();
			},
	
			remove: function() {
				$(this.getEl('inp')).off();
	
				if (this.menu) {
					this.menu.remove();
				}
	
				this._super();
			}
		});
	});
	
	// Included from: js/tinymce/classes/ui/ColorBox.js
	
	/**
	 * ColorBox.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This widget lets you enter colors and browse for colors by pressing the color button. It also displays
	 * a preview of the current color.
	 *
	 * @-x-less ColorBox.less
	 * @class tinymce.ui.ColorBox
	 * @extends tinymce.ui.ComboBox
	 */
	define("tinymce/ui/ColorBox", [
		"tinymce/ui/ComboBox"
	], function(ComboBox) {
		"use strict";
	
		return ComboBox.extend({
			/**
			 * Constructs a new control instance with the specified settings.
			 *
			 * @constructor
			 * @param {Object} settings Name/value object with settings.
			 */
			init: function(settings) {
				var self = this;
	
				settings.spellcheck = false;
	
				if (settings.onaction) {
					settings.icon = 'none';
				}
	
				self._super(settings);
	
				self.classes.add('colorbox');
				self.on('change keyup postrender', function() {
					self.repaintColor(self.value());
				});
			},
	
			repaintColor: function(value) {
				var openElm = this.getEl('open');
				var elm = openElm ? openElm.getElementsByTagName('i')[0] : null;
	
				if (elm) {
					try {
						elm.style.background = value;
					} catch (ex) {
						// Ignore
					}
				}
			},
	
			bindStates: function() {
				var self = this;
	
				self.state.on('change:value', function(e) {
					if (self.state.get('rendered')) {
						self.repaintColor(e.value);
					}
				});
	
				return self._super();
			}
		});
	});
	
	// Included from: js/tinymce/classes/ui/PanelButton.js
	
	/**
	 * PanelButton.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Creates a new panel button.
	 *
	 * @class tinymce.ui.PanelButton
	 * @extends tinymce.ui.Button
	 */
	define("tinymce/ui/PanelButton", [
		"tinymce/ui/Button",
		"tinymce/ui/FloatPanel"
	], function(Button, FloatPanel) {
		"use strict";
	
		return Button.extend({
			/**
			 * Shows the panel for the button.
			 *
			 * @method showPanel
			 */
			showPanel: function() {
				var self = this, settings = self.settings;
	
				self.active(true);
	
				if (!self.panel) {
					var panelSettings = settings.panel;
	
					// Wrap panel in grid layout if type if specified
					// This makes it possible to add forms or other containers directly in the panel option
					if (panelSettings.type) {
						panelSettings = {
							layout: 'grid',
							items: panelSettings
						};
					}
	
					panelSettings.role = panelSettings.role || 'dialog';
					panelSettings.popover = true;
					panelSettings.autohide = true;
					panelSettings.ariaRoot = true;
	
					self.panel = new FloatPanel(panelSettings).on('hide', function() {
						self.active(false);
					}).on('cancel', function(e) {
						e.stopPropagation();
						self.focus();
						self.hidePanel();
					}).parent(self).renderTo(self.getContainerElm());
	
					self.panel.fire('show');
					self.panel.reflow();
				} else {
					self.panel.show();
				}
	
				self.panel.moveRel(self.getEl(), settings.popoverAlign || (self.isRtl() ? ['bc-tr', 'bc-tc'] : ['bc-tl', 'bc-tc']));
			},
	
			/**
			 * Hides the panel for the button.
			 *
			 * @method hidePanel
			 */
			hidePanel: function() {
				var self = this;
	
				if (self.panel) {
					self.panel.hide();
				}
			},
	
			/**
			 * Called after the control has been rendered.
			 *
			 * @method postRender
			 */
			postRender: function() {
				var self = this;
	
				self.aria('haspopup', true);
	
				self.on('click', function(e) {
					if (e.control === self) {
						if (self.panel && self.panel.visible()) {
							self.hidePanel();
						} else {
							self.showPanel();
							self.panel.focus(!!e.aria);
						}
					}
				});
	
				return self._super();
			},
	
			remove: function() {
				if (this.panel) {
					this.panel.remove();
					this.panel = null;
				}
	
				return this._super();
			}
		});
	});
	
	// Included from: js/tinymce/classes/ui/ColorButton.js
	
	/**
	 * ColorButton.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This class creates a color button control. This is a split button in which the main
	 * button has a visual representation of the currently selected color. When clicked
	 * the caret button displays a color picker, allowing the user to select a new color.
	 *
	 * @-x-less ColorButton.less
	 * @class tinymce.ui.ColorButton
	 * @extends tinymce.ui.PanelButton
	 */
	define("tinymce/ui/ColorButton", [
		"tinymce/ui/PanelButton",
		"tinymce/dom/DOMUtils"
	], function(PanelButton, DomUtils) {
		"use strict";
	
		var DOM = DomUtils.DOM;
	
		return PanelButton.extend({
			/**
			 * Constructs a new ColorButton instance with the specified settings.
			 *
			 * @constructor
			 * @param {Object} settings Name/value object with settings.
			 */
			init: function(settings) {
				this._super(settings);
				this.classes.add('colorbutton');
			},
	
			/**
			 * Getter/setter for the current color.
			 *
			 * @method color
			 * @param {String} [color] Color to set.
			 * @return {String|tinymce.ui.ColorButton} Current color or current instance.
			 */
			color: function(color) {
				if (color) {
					this._color = color;
					this.getEl('preview').style.backgroundColor = color;
					return this;
				}
	
				return this._color;
			},
	
			/**
			 * Resets the current color.
			 *
			 * @method resetColor
			 * @return {tinymce.ui.ColorButton} Current instance.
			 */
			resetColor: function() {
				this._color = null;
				this.getEl('preview').style.backgroundColor = null;
				return this;
			},
	
			/**
			 * Renders the control as a HTML string.
			 *
			 * @method renderHtml
			 * @return {String} HTML representing the control.
			 */
			renderHtml: function() {
				var self = this, id = self._id, prefix = self.classPrefix, text = self.state.get('text');
				var icon = self.settings.icon ? prefix + 'ico ' + prefix + 'i-' + self.settings.icon : '';
				var image = self.settings.image ? ' style="background-image: url(\'' + self.settings.image + '\')"' : '',
					textHtml = '';
	
				if (text) {
					self.classes.add('btn-has-text');
					textHtml = '<span class="' + prefix + 'txt">' + self.encode(text) + '</span>';
				}
	
				return (
					'<div id="' + id + '" class="' + self.classes + '" role="button" tabindex="-1" aria-haspopup="true">' +
						'<button role="presentation" hidefocus="1" type="button" tabindex="-1">' +
							(icon ? '<i class="' + icon + '"' + image + '></i>' : '') +
							'<span id="' + id + '-preview" class="' + prefix + 'preview"></span>' +
							textHtml +
						'</button>' +
						'<button type="button" class="' + prefix + 'open" hidefocus="1" tabindex="-1">' +
							' <i class="' + prefix + 'caret"></i>' +
						'</button>' +
					'</div>'
				);
			},
	
			/**
			 * Called after the control has been rendered.
			 *
			 * @method postRender
			 */
			postRender: function() {
				var self = this, onClickHandler = self.settings.onclick;
	
				self.on('click', function(e) {
					if (e.aria && e.aria.key == 'down') {
						return;
					}
	
					if (e.control == self && !DOM.getParent(e.target, '.' + self.classPrefix + 'open')) {
						e.stopImmediatePropagation();
						onClickHandler.call(self, e);
					}
				});
	
				delete self.settings.onclick;
	
				return self._super();
			}
		});
	});
	
	// Included from: js/tinymce/classes/util/Color.js
	
	/**
	 * Color.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This class lets you parse/serialize colors and convert rgb/hsb.
	 *
	 * @class tinymce.util.Color
	 * @example
	 * var white = new tinymce.util.Color({r: 255, g: 255, b: 255});
	 * var red = new tinymce.util.Color('#FF0000');
	 *
	 * console.log(white.toHex(), red.toHsv());
	 */
	define("tinymce/util/Color", [], function() {
		var min = Math.min, max = Math.max, round = Math.round;
	
		/**
		 * Constructs a new color instance.
		 *
		 * @constructor
		 * @method Color
		 * @param {String} value Optional initial value to parse.
		 */
		function Color(value) {
			var self = this, r = 0, g = 0, b = 0;
	
			function rgb2hsv(r, g, b) {
				var h, s, v, d, minRGB, maxRGB;
	
				h = 0;
				s = 0;
				v = 0;
				r = r / 255;
				g = g / 255;
				b = b / 255;
	
				minRGB = min(r, min(g, b));
				maxRGB = max(r, max(g, b));
	
				if (minRGB == maxRGB) {
					v = minRGB;
	
					return {
						h: 0,
						s: 0,
						v: v * 100
					};
				}
	
				/*eslint no-nested-ternary:0 */
				d = (r == minRGB) ? g - b : ((b == minRGB) ? r - g : b - r);
				h = (r == minRGB) ? 3 : ((b == minRGB) ? 1 : 5);
				h = 60 * (h - d / (maxRGB - minRGB));
				s = (maxRGB - minRGB) / maxRGB;
				v = maxRGB;
	
				return {
					h: round(h),
					s: round(s * 100),
					v: round(v * 100)
				};
			}
	
			function hsvToRgb(hue, saturation, brightness) {
				var side, chroma, x, match;
	
				hue = (parseInt(hue, 10) || 0) % 360;
				saturation = parseInt(saturation, 10) / 100;
				brightness = parseInt(brightness, 10) / 100;
				saturation = max(0, min(saturation, 1));
				brightness = max(0, min(brightness, 1));
	
				if (saturation === 0) {
					r = g = b = round(255 * brightness);
					return;
				}
	
				side = hue / 60;
				chroma = brightness * saturation;
				x = chroma * (1 - Math.abs(side % 2 - 1));
				match = brightness - chroma;
	
				switch (Math.floor(side)) {
					case 0:
						r = chroma;
						g = x;
						b = 0;
						break;
	
					case 1:
						r = x;
						g = chroma;
						b = 0;
						break;
	
					case 2:
						r = 0;
						g = chroma;
						b = x;
						break;
	
					case 3:
						r = 0;
						g = x;
						b = chroma;
						break;
	
					case 4:
						r = x;
						g = 0;
						b = chroma;
						break;
	
					case 5:
						r = chroma;
						g = 0;
						b = x;
						break;
	
					default:
						r = g = b = 0;
				}
	
				r = round(255 * (r + match));
				g = round(255 * (g + match));
				b = round(255 * (b + match));
			}
	
			/**
			 * Returns the hex string of the current color. For example: #ff00ff
			 *
			 * @method toHex
			 * @return {String} Hex string of current color.
			 */
			function toHex() {
				function hex(val) {
					val = parseInt(val, 10).toString(16);
	
					return val.length > 1 ? val : '0' + val;
				}
	
				return '#' + hex(r) + hex(g) + hex(b);
			}
	
			/**
			 * Returns the r, g, b values of the color. Each channel has a range from 0-255.
			 *
			 * @method toRgb
			 * @return {Object} Object with r, g, b fields.
			 */
			function toRgb() {
				return {
					r: r,
					g: g,
					b: b
				};
			}
	
			/**
			 * Returns the h, s, v values of the color. Ranges: h=0-360, s=0-100, v=0-100.
			 *
			 * @method toHsv
			 * @return {Object} Object with h, s, v fields.
			 */
			function toHsv() {
				return rgb2hsv(r, g, b);
			}
	
			/**
			 * Parses the specified value and populates the color instance.
			 *
			 * Supported format examples:
			 *  * rbg(255,0,0)
			 *  * #ff0000
			 *  * #fff
			 *  * {r: 255, g: 0, b: 0}
			 *  * {h: 360, s: 100, v: 100}
			 *
			 * @method parse
			 * @param {Object/String} value Color value to parse.
			 * @return {tinymce.util.Color} Current color instance.
			 */
			function parse(value) {
				var matches;
	
				if (typeof value == 'object') {
					if ("r" in value) {
						r = value.r;
						g = value.g;
						b = value.b;
					} else if ("v" in value) {
						hsvToRgb(value.h, value.s, value.v);
					}
				} else {
					if ((matches = /rgb\s*\(\s*([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)[^\)]*\)/gi.exec(value))) {
						r = parseInt(matches[1], 10);
						g = parseInt(matches[2], 10);
						b = parseInt(matches[3], 10);
					} else if ((matches = /#([0-F]{2})([0-F]{2})([0-F]{2})/gi.exec(value))) {
						r = parseInt(matches[1], 16);
						g = parseInt(matches[2], 16);
						b = parseInt(matches[3], 16);
					} else if ((matches = /#([0-F])([0-F])([0-F])/gi.exec(value))) {
						r = parseInt(matches[1] + matches[1], 16);
						g = parseInt(matches[2] + matches[2], 16);
						b = parseInt(matches[3] + matches[3], 16);
					}
				}
	
				r = r < 0 ? 0 : (r > 255 ? 255 : r);
				g = g < 0 ? 0 : (g > 255 ? 255 : g);
				b = b < 0 ? 0 : (b > 255 ? 255 : b);
	
				return self;
			}
	
			if (value) {
				parse(value);
			}
	
			self.toRgb = toRgb;
			self.toHsv = toHsv;
			self.toHex = toHex;
			self.parse = parse;
		}
	
		return Color;
	});
	
	// Included from: js/tinymce/classes/ui/ColorPicker.js
	
	/**
	 * ColorPicker.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Color picker widget lets you select colors.
	 *
	 * @-x-less ColorPicker.less
	 * @class tinymce.ui.ColorPicker
	 * @extends tinymce.ui.Widget
	 */
	define("tinymce/ui/ColorPicker", [
		"tinymce/ui/Widget",
		"tinymce/ui/DragHelper",
		"tinymce/ui/DomUtils",
		"tinymce/util/Color"
	], function(Widget, DragHelper, DomUtils, Color) {
		"use strict";
	
		return Widget.extend({
			Defaults: {
				classes: "widget colorpicker"
			},
	
			/**
			 * Constructs a new colorpicker instance with the specified settings.
			 *
			 * @constructor
			 * @param {Object} settings Name/value object with settings.
			 * @setting {String} color Initial color value.
			 */
			init: function(settings) {
				this._super(settings);
			},
	
			postRender: function() {
				var self = this, color = self.color(), hsv, hueRootElm, huePointElm, svRootElm, svPointElm;
	
				hueRootElm = self.getEl('h');
				huePointElm = self.getEl('hp');
				svRootElm = self.getEl('sv');
				svPointElm = self.getEl('svp');
	
				function getPos(elm, event) {
					var pos = DomUtils.getPos(elm), x, y;
	
					x = event.pageX - pos.x;
					y = event.pageY - pos.y;
	
					x = Math.max(0, Math.min(x / elm.clientWidth, 1));
					y = Math.max(0, Math.min(y / elm.clientHeight, 1));
	
					return {
						x: x,
						y: y
					};
				}
	
				function updateColor(hsv, hueUpdate) {
					var hue = (360 - hsv.h) / 360;
	
					DomUtils.css(huePointElm, {
						top: (hue * 100) + '%'
					});
	
					if (!hueUpdate) {
						DomUtils.css(svPointElm, {
							left: hsv.s + '%',
							top: (100 - hsv.v) + '%'
						});
					}
	
					svRootElm.style.background = new Color({s: 100, v: 100, h: hsv.h}).toHex();
					self.color().parse({s: hsv.s, v: hsv.v, h: hsv.h});
				}
	
				function updateSaturationAndValue(e) {
					var pos;
	
					pos = getPos(svRootElm, e);
					hsv.s = pos.x * 100;
					hsv.v = (1 - pos.y) * 100;
	
					updateColor(hsv);
					self.fire('change');
				}
	
				function updateHue(e) {
					var pos;
	
					pos = getPos(hueRootElm, e);
					hsv = color.toHsv();
					hsv.h = (1 - pos.y) * 360;
					updateColor(hsv, true);
					self.fire('change');
				}
	
				self._repaint = function() {
					hsv = color.toHsv();
					updateColor(hsv);
				};
	
				self._super();
	
				self._svdraghelper = new DragHelper(self._id + '-sv', {
					start: updateSaturationAndValue,
					drag: updateSaturationAndValue
				});
	
				self._hdraghelper = new DragHelper(self._id + '-h', {
					start: updateHue,
					drag: updateHue
				});
	
				self._repaint();
			},
	
			rgb: function() {
				return this.color().toRgb();
			},
	
			value: function(value) {
				var self = this;
	
				if (arguments.length) {
					self.color().parse(value);
	
					if (self._rendered) {
						self._repaint();
					}
				} else {
					return self.color().toHex();
				}
			},
	
			color: function() {
				if (!this._color) {
					this._color = new Color();
				}
	
				return this._color;
			},
	
			/**
			 * Renders the control as a HTML string.
			 *
			 * @method renderHtml
			 * @return {String} HTML representing the control.
			 */
			renderHtml: function() {
				var self = this, id = self._id, prefix = self.classPrefix, hueHtml;
				var stops = '#ff0000,#ff0080,#ff00ff,#8000ff,#0000ff,#0080ff,#00ffff,#00ff80,#00ff00,#80ff00,#ffff00,#ff8000,#ff0000';
	
				function getOldIeFallbackHtml() {
					var i, l, html = '', gradientPrefix, stopsList;
	
					gradientPrefix = 'filter:progid:DXImageTransform.Microsoft.gradient(GradientType=0,startColorstr=';
					stopsList = stops.split(',');
					for (i = 0, l = stopsList.length - 1; i < l; i++) {
						html += (
							'<div class="' + prefix + 'colorpicker-h-chunk" style="' +
								'height:' + (100 / l) + '%;' +
								gradientPrefix + stopsList[i] + ',endColorstr=' + stopsList[i + 1] + ');' +
								'-ms-' + gradientPrefix + stopsList[i] + ',endColorstr=' + stopsList[i + 1] + ')' +
							'"></div>'
						);
					}
	
					return html;
				}
	
				var gradientCssText = (
					'background: -ms-linear-gradient(top,' + stops + ');' +
					'background: linear-gradient(to bottom,' + stops + ');'
				);
	
				hueHtml = (
					'<div id="' + id + '-h" class="' + prefix + 'colorpicker-h" style="' + gradientCssText + '">' +
						getOldIeFallbackHtml() +
						'<div id="' + id + '-hp" class="' + prefix + 'colorpicker-h-marker"></div>' +
					'</div>'
				);
	
				return (
					'<div id="' + id + '" class="' + self.classes + '">' +
						'<div id="' + id + '-sv" class="' + prefix + 'colorpicker-sv">' +
							'<div class="' + prefix + 'colorpicker-overlay1">' +
								'<div class="' + prefix + 'colorpicker-overlay2">' +
									'<div id="' + id + '-svp" class="' + prefix + 'colorpicker-selector1">' +
										'<div class="' + prefix + 'colorpicker-selector2"></div>' +
									'</div>' +
								'</div>' +
							'</div>' +
						'</div>' +
						hueHtml +
					'</div>'
				);
			}
		});
	});
	
	// Included from: js/tinymce/classes/ui/Path.js
	
	/**
	 * Path.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Creates a new path control.
	 *
	 * @-x-less Path.less
	 * @class tinymce.ui.Path
	 * @extends tinymce.ui.Widget
	 */
	define("tinymce/ui/Path", [
		"tinymce/ui/Widget"
	], function(Widget) {
		"use strict";
	
		return Widget.extend({
			/**
			 * Constructs a instance with the specified settings.
			 *
			 * @constructor
			 * @param {Object} settings Name/value object with settings.
			 * @setting {String} delimiter Delimiter to display between row in path.
			 */
			init: function(settings) {
				var self = this;
	
				if (!settings.delimiter) {
					settings.delimiter = '\u00BB';
				}
	
				self._super(settings);
				self.classes.add('path');
				self.canFocus = true;
	
				self.on('click', function(e) {
					var index, target = e.target;
	
					if ((index = target.getAttribute('data-index'))) {
						self.fire('select', {value: self.row()[index], index: index});
					}
				});
	
				self.row(self.settings.row);
			},
	
			/**
			 * Focuses the current control.
			 *
			 * @method focus
			 * @return {tinymce.ui.Control} Current control instance.
			 */
			focus: function() {
				var self = this;
	
				self.getEl().firstChild.focus();
	
				return self;
			},
	
			/**
			 * Sets/gets the data to be used for the path.
			 *
			 * @method row
			 * @param {Array} row Array with row name is rendered to path.
			 */
			row: function(row) {
				if (!arguments.length) {
					return this.state.get('row');
				}
	
				this.state.set('row', row);
	
				return this;
			},
	
			/**
			 * Renders the control as a HTML string.
			 *
			 * @method renderHtml
			 * @return {String} HTML representing the control.
			 */
			renderHtml: function() {
				var self = this;
	
				return (
					'<div id="' + self._id + '" class="' + self.classes + '">' +
						self._getDataPathHtml(self.state.get('row')) +
					'</div>'
				);
			},
	
			bindStates: function() {
				var self = this;
	
				self.state.on('change:row', function(e) {
					self.innerHtml(self._getDataPathHtml(e.value));
				});
	
				return self._super();
			},
	
			_getDataPathHtml: function(data) {
				var self = this, parts = data || [], i, l, html = '', prefix = self.classPrefix;
	
				for (i = 0, l = parts.length; i < l; i++) {
					html += (
						(i > 0 ? '<div class="' + prefix + 'divider" aria-hidden="true"> ' + self.settings.delimiter + ' </div>' : '') +
						'<div role="button" class="' + prefix + 'path-item' + (i == l - 1 ? ' ' + prefix + 'last' : '') + '" data-index="' +
						i + '" tabindex="-1" id="' + self._id + '-' + i + '" aria-level="' + i + '">' + parts[i].name + '</div>'
					);
				}
	
				if (!html) {
					html = '<div class="' + prefix + 'path-item">\u00a0</div>';
				}
	
				return html;
			}
		});
	});
	
	// Included from: js/tinymce/classes/ui/ElementPath.js
	
	/**
	 * ElementPath.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This control creates an path for the current selections parent elements in TinyMCE.
	 *
	 * @class tinymce.ui.ElementPath
	 * @extends tinymce.ui.Path
	 */
	define("tinymce/ui/ElementPath", [
		"tinymce/ui/Path"
	], function(Path) {
		return Path.extend({
			/**
			 * Post render method. Called after the control has been rendered to the target.
			 *
			 * @method postRender
			 * @return {tinymce.ui.ElementPath} Current combobox instance.
			 */
			postRender: function() {
				var self = this, editor = self.settings.editor;
	
				function isHidden(elm) {
					if (elm.nodeType === 1) {
						if (elm.nodeName == "BR" || !!elm.getAttribute('data-mce-bogus')) {
							return true;
						}
	
						if (elm.getAttribute('data-mce-type') === 'bookmark') {
							return true;
						}
					}
	
					return false;
				}
	
				if (editor.settings.elementpath !== false) {
					self.on('select', function(e) {
						editor.focus();
						editor.selection.select(this.row()[e.index].element);
						editor.nodeChanged();
					});
	
					editor.on('nodeChange', function(e) {
						var outParents = [], parents = e.parents, i = parents.length;
	
						while (i--) {
							if (parents[i].nodeType == 1 && !isHidden(parents[i])) {
								var args = editor.fire('ResolveName', {
									name: parents[i].nodeName.toLowerCase(),
									target: parents[i]
								});
	
								if (!args.isDefaultPrevented()) {
									outParents.push({name: args.name, element: parents[i]});
								}
	
								if (args.isPropagationStopped()) {
									break;
								}
							}
						}
	
						self.row(outParents);
					});
				}
	
				return self._super();
			}
		});
	});
	
	// Included from: js/tinymce/classes/ui/FormItem.js
	
	/**
	 * FormItem.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This class is a container created by the form element with
	 * a label and control item.
	 *
	 * @class tinymce.ui.FormItem
	 * @extends tinymce.ui.Container
	 * @setting {String} label Label to display for the form item.
	 */
	define("tinymce/ui/FormItem", [
		"tinymce/ui/Container"
	], function(Container) {
		"use strict";
	
		return Container.extend({
			Defaults: {
				layout: 'flex',
				align: 'center',
				defaults: {
					flex: 1
				}
			},
	
			/**
			 * Renders the control as a HTML string.
			 *
			 * @method renderHtml
			 * @return {String} HTML representing the control.
			 */
			renderHtml: function() {
				var self = this, layout = self._layout, prefix = self.classPrefix;
	
				self.classes.add('formitem');
				layout.preRender(self);
	
				return (
					'<div id="' + self._id + '" class="' + self.classes + '" hidefocus="1" tabindex="-1">' +
						(self.settings.title ? ('<div id="' + self._id + '-title" class="' + prefix + 'title">' +
							self.settings.title + '</div>') : '') +
						'<div id="' + self._id + '-body" class="' + self.bodyClasses + '">' +
							(self.settings.html || '') + layout.renderHtml(self) +
						'</div>' +
					'</div>'
				);
			}
		});
	});
	
	// Included from: js/tinymce/classes/ui/Form.js
	
	/**
	 * Form.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This class creates a form container. A form container has the ability
	 * to automatically wrap items in tinymce.ui.FormItem instances.
	 *
	 * Each FormItem instance is a container for the label and the item.
	 *
	 * @example
	 * tinymce.ui.Factory.create({
	 *     type: 'form',
	 *     items: [
	 *         {type: 'textbox', label: 'My text box'}
	 *     ]
	 * }).renderTo(document.body);
	 *
	 * @class tinymce.ui.Form
	 * @extends tinymce.ui.Container
	 */
	define("tinymce/ui/Form", [
		"tinymce/ui/Container",
		"tinymce/ui/FormItem",
		"tinymce/util/Tools"
	], function(Container, FormItem, Tools) {
		"use strict";
	
		return Container.extend({
			Defaults: {
				containerCls: 'form',
				layout: 'flex',
				direction: 'column',
				align: 'stretch',
				flex: 1,
				padding: 20,
				labelGap: 30,
				spacing: 10,
				callbacks: {
					submit: function() {
						this.submit();
					}
				}
			},
	
			/**
			 * This method gets invoked before the control is rendered.
			 *
			 * @method preRender
			 */
			preRender: function() {
				var self = this, items = self.items();
	
				if (!self.settings.formItemDefaults) {
					self.settings.formItemDefaults = {
						layout: 'flex',
						autoResize: "overflow",
						defaults: {flex: 1}
					};
				}
	
				// Wrap any labeled items in FormItems
				items.each(function(ctrl) {
					var formItem, label = ctrl.settings.label;
	
					if (label) {
						formItem = new FormItem(Tools.extend({
							items: {
								type: 'label',
								id: ctrl._id + '-l',
								text: label,
								flex: 0,
								forId: ctrl._id,
								disabled: ctrl.disabled()
							}
						}, self.settings.formItemDefaults));
	
						formItem.type = 'formitem';
						ctrl.aria('labelledby', ctrl._id + '-l');
	
						if (typeof ctrl.settings.flex == "undefined") {
							ctrl.settings.flex = 1;
						}
	
						self.replace(ctrl, formItem);
						formItem.add(ctrl);
					}
				});
			},
	
			/**
			 * Fires a submit event with the serialized form.
			 *
			 * @method submit
			 * @return {Object} Event arguments object.
			 */
			submit: function() {
				return this.fire('submit', {data: this.toJSON()});
			},
	
			/**
			 * Post render method. Called after the control has been rendered to the target.
			 *
			 * @method postRender
			 * @return {tinymce.ui.ComboBox} Current combobox instance.
			 */
			postRender: function() {
				var self = this;
	
				self._super();
				self.fromJSON(self.settings.data);
			},
	
			bindStates: function() {
				var self = this;
	
				self._super();
	
				function recalcLabels() {
					var maxLabelWidth = 0, labels = [], i, labelGap, items;
	
					if (self.settings.labelGapCalc === false) {
						return;
					}
	
					if (self.settings.labelGapCalc == "children") {
						items = self.find('formitem');
					} else {
						items = self.items();
					}
	
					items.filter('formitem').each(function(item) {
						var labelCtrl = item.items()[0], labelWidth = labelCtrl.getEl().clientWidth;
	
						maxLabelWidth = labelWidth > maxLabelWidth ? labelWidth : maxLabelWidth;
						labels.push(labelCtrl);
					});
	
					labelGap = self.settings.labelGap || 0;
	
					i = labels.length;
					while (i--) {
						labels[i].settings.minWidth = maxLabelWidth + labelGap;
					}
				}
	
				self.on('show', recalcLabels);
				recalcLabels();
			}
		});
	});
	
	// Included from: js/tinymce/classes/ui/FieldSet.js
	
	/**
	 * FieldSet.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This class creates fieldset containers.
	 *
	 * @-x-less FieldSet.less
	 * @class tinymce.ui.FieldSet
	 * @extends tinymce.ui.Form
	 */
	define("tinymce/ui/FieldSet", [
		"tinymce/ui/Form"
	], function(Form) {
		"use strict";
	
		return Form.extend({
			Defaults: {
				containerCls: 'fieldset',
				layout: 'flex',
				direction: 'column',
				align: 'stretch',
				flex: 1,
				padding: "25 15 5 15",
				labelGap: 30,
				spacing: 10,
				border: 1
			},
	
			/**
			 * Renders the control as a HTML string.
			 *
			 * @method renderHtml
			 * @return {String} HTML representing the control.
			 */
			renderHtml: function() {
				var self = this, layout = self._layout, prefix = self.classPrefix;
	
				self.preRender();
				layout.preRender(self);
	
				return (
					'<fieldset id="' + self._id + '" class="' + self.classes + '" hidefocus="1" tabindex="-1">' +
						(self.settings.title ? ('<legend id="' + self._id + '-title" class="' + prefix + 'fieldset-title">' +
							self.settings.title + '</legend>') : '') +
						'<div id="' + self._id + '-body" class="' + self.bodyClasses + '">' +
							(self.settings.html || '') + layout.renderHtml(self) +
						'</div>' +
					'</fieldset>'
				);
			}
		});
	});
	
	// Included from: js/tinymce/classes/content/LinkTargets.js
	
	/**
	 * LinkTargets.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2016 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This module is enables you to get anything that you can link to in a element.
	 *
	 * @private
	 * @class tinymce.content.LinkTargets
	 */
	define('tinymce/content/LinkTargets', [
		'tinymce/dom/DOMUtils',
		'tinymce/util/Fun',
		'tinymce/util/Arr',
		'tinymce/util/Uuid',
		'tinymce/util/Tools',
		'tinymce/dom/NodeType'
	], function(
		DOMUtils,
		Fun,
		Arr,
		Uuid,
		Tools,
		NodeType
	) {
		var trim = Tools.trim;
	
		var create = function (type, title, url, level, attach) {
			return {
				type: type,
				title: title,
				url: url,
				level: level,
				attach: attach
			};
		};
	
		var isChildOfContentEditableTrue = function (node) {
			while ((node = node.parentNode)) {
				var value = node.contentEditable;
				if (value && value !== 'inherit') {
					return NodeType.isContentEditableTrue(node);
				}
			}
	
			return false;
		};
	
		var select = function (selector, root) {
			return DOMUtils.DOM.select(selector, root);
		};
	
		var getElementText = function (elm) {
			return elm.innerText || elm.textContent;
		};
	
		var getOrGenerateId = function (elm) {
			return elm.id ? elm.id : Uuid.uuid('h');
		};
	
		var isAnchor = function (elm) {
			return elm && elm.nodeName === 'A' && (elm.id || elm.name);
		};
	
		var isValidAnchor = function (elm) {
			return isAnchor(elm) && isEditable(elm);
		};
	
		var isHeader = function (elm) {
			return elm && /^(H[1-6])$/.test(elm.nodeName);
		};
	
		var isEditable = function (elm) {
			return isChildOfContentEditableTrue(elm) && !NodeType.isContentEditableFalse(elm);
		};
	
		var isValidHeader = function (elm) {
			return isHeader(elm) && isEditable(elm);
		};
	
		var getLevel = function (elm) {
			return isHeader(elm) ? parseInt(elm.nodeName.substr(1), 10) : 0;
		};
	
		var headerTarget = function (elm) {
			var headerId = getOrGenerateId(elm);
	
			var attach = function () {
				elm.id = headerId;
			};
	
			return create('header', getElementText(elm), '#' + headerId, getLevel(elm), attach);
		};
	
		var anchorTarget = function (elm) {
			var anchorId = elm.id || elm.name;
			var anchorText = getElementText(elm);
	
			return create('anchor', anchorText ? anchorText : '#' + anchorId, '#' + anchorId, 0, Fun.noop);
		};
	
		var getHeaderTargets = function (elms) {
			return Arr.map(Arr.filter(elms, isValidHeader), headerTarget);
		};
	
		var getAnchorTargets = function (elms) {
			return Arr.map(Arr.filter(elms, isValidAnchor), anchorTarget);
		};
	
		var getTargetElements = function (elm) {
			var elms = select('h1,h2,h3,h4,h5,h6,a:not([href])', elm);
			return elms;
		};
	
		var hasTitle = function (target) {
			return trim(target.title).length > 0;
		};
	
		var find = function (elm) {
			var elms = getTargetElements(elm);
			return Arr.filter(getHeaderTargets(elms).concat(getAnchorTargets(elms)), hasTitle);
		};
	
		return {
			find: find
		};
	});
	
	// Included from: js/tinymce/classes/ui/FilePicker.js
	
	/**
	 * FilePicker.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/*global tinymce:true */
	
	/**
	 * This class creates a file picker control.
	 *
	 * @class tinymce.ui.FilePicker
	 * @extends tinymce.ui.ComboBox
	 */
	define("tinymce/ui/FilePicker", [
		"tinymce/ui/ComboBox",
		"tinymce/util/Tools",
		"tinymce/util/Arr",
		"tinymce/util/Fun",
		"tinymce/util/VK",
		"tinymce/content/LinkTargets"
	], function(ComboBox, Tools, Arr, Fun, VK, LinkTargets) {
		"use strict";
	
		var history = {};
		var HISTORY_LENGTH = 5;
	
		var toMenuItem = function (target) {
			return {
				title: target.title,
				value: {
					title: {raw: target.title},
					url: target.url,
					attach: target.attach
				}
			};
		};
	
		var toMenuItems = function (targets) {
			return Tools.map(targets, toMenuItem);
		};
	
		var staticMenuItem = function (title, url) {
			return {
				title: title,
				value: {
					title: title,
					url: url,
					attach: Fun.noop
				}
			};
		};
	
		var isUniqueUrl = function (url, targets) {
			var foundTarget = Arr.find(targets, function (target) {
				return target.url === url;
			});
	
			return !foundTarget;
		};
	
		var getSetting = function (editorSettings, name, defaultValue) {
			var value = name in editorSettings ? editorSettings[name] : defaultValue;
			return value === false ? null : value;
		};
	
		var createMenuItems = function (term, targets, fileType, editorSettings) {
			var separator = {title: '-'};
	
			var fromHistoryMenuItems = function (history) {
				var uniqueHistory = Arr.filter(history[fileType], function (url) {
					return isUniqueUrl(url, targets);
				});
	
				return Tools.map(uniqueHistory, function (url) {
					return {
						title: url,
						value: {
							title: url,
							url: url,
							attach: Fun.noop
						}
					};
				});
			};
	
			var fromMenuItems = function (type) {
				var filteredTargets = Arr.filter(targets, function (target) {
					return target.type == type;
				});
	
				return toMenuItems(filteredTargets);
			};
	
			var anchorMenuItems = function () {
				var anchorMenuItems = fromMenuItems('anchor');
				var topAnchor = getSetting(editorSettings, 'anchor_top', '#top');
				var bottomAchor = getSetting(editorSettings, 'anchor_bottom', '#bottom');
	
				if (topAnchor !== null) {
					anchorMenuItems.unshift(staticMenuItem('<top>', topAnchor));
				}
	
				if (bottomAchor !== null) {
					anchorMenuItems.push(staticMenuItem('<bottom>', bottomAchor));
				}
	
				return anchorMenuItems;
			};
	
			var join = function (items) {
				return Arr.reduce(items, function (a, b) {
					var bothEmpty = a.length === 0 || b.length === 0;
					return bothEmpty ? a.concat(b) : a.concat(separator, b);
				}, []);
			};
	
			if (editorSettings.typeahead_urls === false) {
				return [];
			}
	
			return fileType === 'file' ? join([
				filterByQuery(term, fromHistoryMenuItems(history)),
				filterByQuery(term, fromMenuItems('header')),
				filterByQuery(term, anchorMenuItems())
			]) : filterByQuery(term, fromHistoryMenuItems(history));
		};
	
		var addToHistory = function (url, fileType) {
			var items = history[fileType];
	
			if (!/^https?/.test(url)) {
				return;
			}
	
			if (items) {
				if (Arr.indexOf(items, url) === -1) {
					history[fileType] = items.slice(0, HISTORY_LENGTH).concat(url);
				}
			} else {
				history[fileType] = [url];
			}
		};
	
		var filterByQuery = function (term, menuItems) {
			var lowerCaseTerm = term.toLowerCase();
			var result = Tools.grep(menuItems, function (item) {
				return item.title.toLowerCase().indexOf(lowerCaseTerm) !== -1;
			});
	
			return result.length === 1 && result[0].title === term ? [] : result;
		};
	
		var getTitle = function (linkDetails) {
			var title = linkDetails.title;
			return title.raw ? title.raw : title;
		};
	
		var setupAutoCompleteHandler = function (ctrl, editorSettings, bodyElm, fileType) {
			var autocomplete = function (term) {
				var linkTargets = LinkTargets.find(bodyElm);
				var menuItems = createMenuItems(term, linkTargets, fileType, editorSettings);
				ctrl.showAutoComplete(menuItems, term);
			};
	
			ctrl.on('autocomplete', function () {
				autocomplete(ctrl.value());
			});
	
			ctrl.on('selectitem', function (e) {
				var linkDetails = e.value;
	
				ctrl.value(linkDetails.url);
				var title = getTitle(linkDetails);
	
				if (fileType === 'image') {
					ctrl.fire('change', {meta: {alt: title, attach: linkDetails.attach}});
				} else {
					ctrl.fire('change', {meta: {text: title, attach: linkDetails.attach}});
				}
	
				ctrl.focus();
			});
	
			ctrl.on('click', function () {
				if (ctrl.value().length === 0) {
					autocomplete('');
				}
			});
	
			ctrl.on('PostRender', function () {
				ctrl.getRoot().on('submit', function (e) {
					if (!e.isDefaultPrevented()) {
						addToHistory(ctrl.value(), fileType);
					}
				});
			});
		};
	
		var statusToUiState = function (result) {
			var status = result.status, message = result.message;
	
			if (status === 'valid') {
				return {status: 'ok', message: message};
			} else if (status === 'unknown') {
				return {status: 'warn', message: message};
			} else if (status === 'invalid') {
				return {status: 'warn', message: message};
			} else {
				return {status: 'none', message: ''};
			}
		};
	
		var setupLinkValidatorHandler = function (ctrl, editorSettings, fileType) {
			var validatorHandler = editorSettings.filepicker_validator_handler;
			if (validatorHandler) {
				var validateUrl = function (url) {
					if (url.length === 0) {
						ctrl.statusLevel('none');
						return;
					}
	
					validatorHandler({
						url: url,
						type: fileType
					}, function (result) {
						var uiState = statusToUiState(result);
	
						ctrl.statusMessage(uiState.message);
						ctrl.statusLevel(uiState.status);
					});
				};
	
				ctrl.state.on('change:value', function (e) {
					validateUrl(e.value);
				});
			}
		};
	
		return ComboBox.extend({
			/**
			 * Constructs a new control instance with the specified settings.
			 *
			 * @constructor
			 * @param {Object} settings Name/value object with settings.
			 */
			init: function(settings) {
				var self = this, editor = tinymce.activeEditor, editorSettings = editor.settings;
				var actionCallback, fileBrowserCallback, fileBrowserCallbackTypes;
				var fileType = settings.filetype;
	
				settings.spellcheck = false;
	
				fileBrowserCallbackTypes = editorSettings.file_picker_types || editorSettings.file_browser_callback_types;
				if (fileBrowserCallbackTypes) {
					fileBrowserCallbackTypes = Tools.makeMap(fileBrowserCallbackTypes, /[, ]/);
				}
	
				if (!fileBrowserCallbackTypes || fileBrowserCallbackTypes[fileType]) {
					fileBrowserCallback = editorSettings.file_picker_callback;
					if (fileBrowserCallback && (!fileBrowserCallbackTypes || fileBrowserCallbackTypes[fileType])) {
						actionCallback = function() {
							var meta = self.fire('beforecall').meta;
	
							meta = Tools.extend({filetype: fileType}, meta);
	
							// file_picker_callback(callback, currentValue, metaData)
							fileBrowserCallback.call(
								editor,
								function(value, meta) {
									self.value(value).fire('change', {meta: meta});
								},
								self.value(),
								meta
							);
						};
					} else {
						// Legacy callback: file_picker_callback(id, currentValue, filetype, window)
						fileBrowserCallback = editorSettings.file_browser_callback;
						if (fileBrowserCallback && (!fileBrowserCallbackTypes || fileBrowserCallbackTypes[fileType])) {
							actionCallback = function() {
								fileBrowserCallback(
									self.getEl('inp').id,
									self.value(),
									fileType,
									window
								);
							};
						}
					}
				}
	
				if (actionCallback) {
					settings.icon = 'browse';
					settings.onaction = actionCallback;
				}
	
				self._super(settings);
	
				setupAutoCompleteHandler(self, editorSettings, editor.getBody(), fileType);
				setupLinkValidatorHandler(self, editorSettings, fileType);
			}
		});
	});
	
	// Included from: js/tinymce/classes/ui/FitLayout.js
	
	/**
	 * FitLayout.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This layout manager will resize the control to be the size of it's parent container.
	 * In other words width: 100% and height: 100%.
	 *
	 * @-x-less FitLayout.less
	 * @class tinymce.ui.FitLayout
	 * @extends tinymce.ui.AbsoluteLayout
	 */
	define("tinymce/ui/FitLayout", [
		"tinymce/ui/AbsoluteLayout"
	], function(AbsoluteLayout) {
		"use strict";
	
		return AbsoluteLayout.extend({
			/**
			 * Recalculates the positions of the controls in the specified container.
			 *
			 * @method recalc
			 * @param {tinymce.ui.Container} container Container instance to recalc.
			 */
			recalc: function(container) {
				var contLayoutRect = container.layoutRect(), paddingBox = container.paddingBox;
	
				container.items().filter(':visible').each(function(ctrl) {
					ctrl.layoutRect({
						x: paddingBox.left,
						y: paddingBox.top,
						w: contLayoutRect.innerW - paddingBox.right - paddingBox.left,
						h: contLayoutRect.innerH - paddingBox.top - paddingBox.bottom
					});
	
					if (ctrl.recalc) {
						ctrl.recalc();
					}
				});
			}
		});
	});
	
	// Included from: js/tinymce/classes/ui/FlexLayout.js
	
	/**
	 * FlexLayout.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This layout manager works similar to the CSS flex box.
	 *
	 * @setting {String} direction row|row-reverse|column|column-reverse
	 * @setting {Number} flex A positive-number to flex by.
	 * @setting {String} align start|end|center|stretch
	 * @setting {String} pack start|end|justify
	 *
	 * @class tinymce.ui.FlexLayout
	 * @extends tinymce.ui.AbsoluteLayout
	 */
	define("tinymce/ui/FlexLayout", [
		"tinymce/ui/AbsoluteLayout"
	], function(AbsoluteLayout) {
		"use strict";
	
		return AbsoluteLayout.extend({
			/**
			 * Recalculates the positions of the controls in the specified container.
			 *
			 * @method recalc
			 * @param {tinymce.ui.Container} container Container instance to recalc.
			 */
			recalc: function(container) {
				// A ton of variables, needs to be in the same scope for performance
				var i, l, items, contLayoutRect, contPaddingBox, contSettings, align, pack, spacing, totalFlex, availableSpace, direction;
				var ctrl, ctrlLayoutRect, ctrlSettings, flex, maxSizeItems = [], size, maxSize, ratio, rect, pos, maxAlignEndPos;
				var sizeName, minSizeName, posName, maxSizeName, beforeName, innerSizeName, deltaSizeName, contentSizeName;
				var alignAxisName, alignInnerSizeName, alignSizeName, alignMinSizeName, alignBeforeName, alignAfterName;
				var alignDeltaSizeName, alignContentSizeName;
				var max = Math.max, min = Math.min;
	
				// Get container items, properties and settings
				items = container.items().filter(':visible');
				contLayoutRect = container.layoutRect();
				contPaddingBox = container.paddingBox;
				contSettings = container.settings;
				direction = container.isRtl() ? (contSettings.direction || 'row-reversed') : contSettings.direction;
				align = contSettings.align;
				pack = container.isRtl() ? (contSettings.pack || 'end') : contSettings.pack;
				spacing = contSettings.spacing || 0;
	
				if (direction == "row-reversed" || direction == "column-reverse") {
					items = items.set(items.toArray().reverse());
					direction = direction.split('-')[0];
				}
	
				// Setup axis variable name for row/column direction since the calculations is the same
				if (direction == "column") {
					posName = "y";
					sizeName = "h";
					minSizeName = "minH";
					maxSizeName = "maxH";
					innerSizeName = "innerH";
					beforeName = 'top';
					deltaSizeName = "deltaH";
					contentSizeName = "contentH";
	
					alignBeforeName = "left";
					alignSizeName = "w";
					alignAxisName = "x";
					alignInnerSizeName = "innerW";
					alignMinSizeName = "minW";
					alignAfterName = "right";
					alignDeltaSizeName = "deltaW";
					alignContentSizeName = "contentW";
				} else {
					posName = "x";
					sizeName = "w";
					minSizeName = "minW";
					maxSizeName = "maxW";
					innerSizeName = "innerW";
					beforeName = 'left';
					deltaSizeName = "deltaW";
					contentSizeName = "contentW";
	
					alignBeforeName = "top";
					alignSizeName = "h";
					alignAxisName = "y";
					alignInnerSizeName = "innerH";
					alignMinSizeName = "minH";
					alignAfterName = "bottom";
					alignDeltaSizeName = "deltaH";
					alignContentSizeName = "contentH";
				}
	
				// Figure out total flex, availableSpace and collect any max size elements
				availableSpace = contLayoutRect[innerSizeName] - contPaddingBox[beforeName] - contPaddingBox[beforeName];
				maxAlignEndPos = totalFlex = 0;
				for (i = 0, l = items.length; i < l; i++) {
					ctrl = items[i];
					ctrlLayoutRect = ctrl.layoutRect();
					ctrlSettings = ctrl.settings;
					flex = ctrlSettings.flex;
					availableSpace -= (i < l - 1 ? spacing : 0);
	
					if (flex > 0) {
						totalFlex += flex;
	
						// Flexed item has a max size then we need to check if we will hit that size
						if (ctrlLayoutRect[maxSizeName]) {
							maxSizeItems.push(ctrl);
						}
	
						ctrlLayoutRect.flex = flex;
					}
	
					availableSpace -= ctrlLayoutRect[minSizeName];
	
					// Calculate the align end position to be used to check for overflow/underflow
					size = contPaddingBox[alignBeforeName] + ctrlLayoutRect[alignMinSizeName] + contPaddingBox[alignAfterName];
					if (size > maxAlignEndPos) {
						maxAlignEndPos = size;
					}
				}
	
				// Calculate minW/minH
				rect = {};
				if (availableSpace < 0) {
					rect[minSizeName] = contLayoutRect[minSizeName] - availableSpace + contLayoutRect[deltaSizeName];
				} else {
					rect[minSizeName] = contLayoutRect[innerSizeName] - availableSpace + contLayoutRect[deltaSizeName];
				}
	
				rect[alignMinSizeName] = maxAlignEndPos + contLayoutRect[alignDeltaSizeName];
	
				rect[contentSizeName] = contLayoutRect[innerSizeName] - availableSpace;
				rect[alignContentSizeName] = maxAlignEndPos;
				rect.minW = min(rect.minW, contLayoutRect.maxW);
				rect.minH = min(rect.minH, contLayoutRect.maxH);
				rect.minW = max(rect.minW, contLayoutRect.startMinWidth);
				rect.minH = max(rect.minH, contLayoutRect.startMinHeight);
	
				// Resize container container if minSize was changed
				if (contLayoutRect.autoResize && (rect.minW != contLayoutRect.minW || rect.minH != contLayoutRect.minH)) {
					rect.w = rect.minW;
					rect.h = rect.minH;
	
					container.layoutRect(rect);
					this.recalc(container);
	
					// Forced recalc for example if items are hidden/shown
					if (container._lastRect === null) {
						var parentCtrl = container.parent();
						if (parentCtrl) {
							parentCtrl._lastRect = null;
							parentCtrl.recalc();
						}
					}
	
					return;
				}
	
				// Handle max size elements, check if they will become to wide with current options
				ratio = availableSpace / totalFlex;
				for (i = 0, l = maxSizeItems.length; i < l; i++) {
					ctrl = maxSizeItems[i];
					ctrlLayoutRect = ctrl.layoutRect();
					maxSize = ctrlLayoutRect[maxSizeName];
					size = ctrlLayoutRect[minSizeName] + ctrlLayoutRect.flex * ratio;
	
					if (size > maxSize) {
						availableSpace -= (ctrlLayoutRect[maxSizeName] - ctrlLayoutRect[minSizeName]);
						totalFlex -= ctrlLayoutRect.flex;
						ctrlLayoutRect.flex = 0;
						ctrlLayoutRect.maxFlexSize = maxSize;
					} else {
						ctrlLayoutRect.maxFlexSize = 0;
					}
				}
	
				// Setup new ratio, target layout rect, start position
				ratio = availableSpace / totalFlex;
				pos = contPaddingBox[beforeName];
				rect = {};
	
				// Handle pack setting moves the start position to end, center
				if (totalFlex === 0) {
					if (pack == "end") {
						pos = availableSpace + contPaddingBox[beforeName];
					} else if (pack == "center") {
						pos = Math.round(
							(contLayoutRect[innerSizeName] / 2) - ((contLayoutRect[innerSizeName] - availableSpace) / 2)
						) + contPaddingBox[beforeName];
	
						if (pos < 0) {
							pos = contPaddingBox[beforeName];
						}
					} else if (pack == "justify") {
						pos = contPaddingBox[beforeName];
						spacing = Math.floor(availableSpace / (items.length - 1));
					}
				}
	
				// Default aligning (start) the other ones needs to be calculated while doing the layout
				rect[alignAxisName] = contPaddingBox[alignBeforeName];
	
				// Start laying out controls
				for (i = 0, l = items.length; i < l; i++) {
					ctrl = items[i];
					ctrlLayoutRect = ctrl.layoutRect();
					size = ctrlLayoutRect.maxFlexSize || ctrlLayoutRect[minSizeName];
	
					// Align the control on the other axis
					if (align === "center") {
						rect[alignAxisName] = Math.round((contLayoutRect[alignInnerSizeName] / 2) - (ctrlLayoutRect[alignSizeName] / 2));
					} else if (align === "stretch") {
						rect[alignSizeName] = max(
							ctrlLayoutRect[alignMinSizeName] || 0,
							contLayoutRect[alignInnerSizeName] - contPaddingBox[alignBeforeName] - contPaddingBox[alignAfterName]
						);
						rect[alignAxisName] = contPaddingBox[alignBeforeName];
					} else if (align === "end") {
						rect[alignAxisName] = contLayoutRect[alignInnerSizeName] - ctrlLayoutRect[alignSizeName] - contPaddingBox.top;
					}
	
					// Calculate new size based on flex
					if (ctrlLayoutRect.flex > 0) {
						size += ctrlLayoutRect.flex * ratio;
					}
	
					rect[sizeName] = size;
					rect[posName] = pos;
					ctrl.layoutRect(rect);
	
					// Recalculate containers
					if (ctrl.recalc) {
						ctrl.recalc();
					}
	
					// Move x/y position
					pos += size + spacing;
				}
			}
		});
	});
	
	// Included from: js/tinymce/classes/ui/FlowLayout.js
	
	/**
	 * FlowLayout.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This layout manager will place the controls by using the browsers native layout.
	 *
	 * @-x-less FlowLayout.less
	 * @class tinymce.ui.FlowLayout
	 * @extends tinymce.ui.Layout
	 */
	define("tinymce/ui/FlowLayout", [
		"tinymce/ui/Layout"
	], function(Layout) {
		return Layout.extend({
			Defaults: {
				containerClass: 'flow-layout',
				controlClass: 'flow-layout-item',
				endClass: 'break'
			},
	
			/**
			 * Recalculates the positions of the controls in the specified container.
			 *
			 * @method recalc
			 * @param {tinymce.ui.Container} container Container instance to recalc.
			 */
			recalc: function(container) {
				container.items().filter(':visible').each(function(ctrl) {
					if (ctrl.recalc) {
						ctrl.recalc();
					}
				});
			},
	
			isNative: function() {
				return true;
			}
		});
	});
	
	// Included from: js/tinymce/classes/ui/FormatControls.js
	
	/**
	 * FormatControls.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Internal class containing all TinyMCE specific control types such as
	 * format listboxes, fontlist boxes, toolbar buttons etc.
	 *
	 * @class tinymce.ui.FormatControls
	 */
	define("tinymce/ui/FormatControls", [
		"tinymce/ui/Control",
		"tinymce/ui/Widget",
		"tinymce/ui/FloatPanel",
		"tinymce/util/Tools",
		"tinymce/util/Arr",
		"tinymce/dom/DOMUtils",
		"tinymce/EditorManager",
		"tinymce/Env"
	], function(Control, Widget, FloatPanel, Tools, Arr, DOMUtils, EditorManager, Env) {
		var each = Tools.each;
	
		var flatten = function (ar) {
			return Arr.reduce(ar, function (result, item) {
				return result.concat(item);
			}, []);
		};
	
		EditorManager.on('AddEditor', function(e) {
			var editor = e.editor;
	
			setupRtlMode(editor);
			registerControls(editor);
			setupContainer(editor);
		});
	
		Control.translate = function(text) {
			return EditorManager.translate(text);
		};
	
		Widget.tooltips = !Env.iOS;
	
		function setupContainer(editor) {
			if (editor.settings.ui_container) {
				Env.container = DOMUtils.DOM.select(editor.settings.ui_container)[0];
			}
		}
	
		function setupRtlMode(editor) {
			editor.on('ScriptsLoaded', function () {
				if (editor.rtl) {
					Control.rtl = true;
				}
			});
		}
	
		function registerControls(editor) {
			var formatMenu;
	
			function createListBoxChangeHandler(items, formatName) {
				return function() {
					var self = this;
	
					editor.on('nodeChange', function(e) {
						var formatter = editor.formatter;
						var value = null;
	
						each(e.parents, function(node) {
							each(items, function(item) {
								if (formatName) {
									if (formatter.matchNode(node, formatName, {value: item.value})) {
										value = item.value;
									}
								} else {
									if (formatter.matchNode(node, item.value)) {
										value = item.value;
									}
								}
	
								if (value) {
									return false;
								}
							});
	
							if (value) {
								return false;
							}
						});
	
						self.value(value);
					});
				};
			}
	
			function createFormats(formats) {
				formats = formats.replace(/;$/, '').split(';');
	
				var i = formats.length;
				while (i--) {
					formats[i] = formats[i].split('=');
				}
	
				return formats;
			}
	
			function createFormatMenu() {
				var count = 0, newFormats = [];
	
				var defaultStyleFormats = [
					{title: 'Headings', items: [
						{title: 'Heading 1', format: 'h1'},
						{title: 'Heading 2', format: 'h2'},
						{title: 'Heading 3', format: 'h3'},
						{title: 'Heading 4', format: 'h4'},
						{title: 'Heading 5', format: 'h5'},
						{title: 'Heading 6', format: 'h6'}
					]},
	
					{title: 'Inline', items: [
						{title: 'Bold', icon: 'bold', format: 'bold'},
						{title: 'Italic', icon: 'italic', format: 'italic'},
						{title: 'Underline', icon: 'underline', format: 'underline'},
						{title: 'Strikethrough', icon: 'strikethrough', format: 'strikethrough'},
						{title: 'Superscript', icon: 'superscript', format: 'superscript'},
						{title: 'Subscript', icon: 'subscript', format: 'subscript'},
						{title: 'Code', icon: 'code', format: 'code'}
					]},
	
					{title: 'Blocks', items: [
						{title: 'Paragraph', format: 'p'},
						{title: 'Blockquote', format: 'blockquote'},
						{title: 'Div', format: 'div'},
						{title: 'Pre', format: 'pre'}
					]},
	
					{title: 'Alignment', items: [
						{title: 'Left', icon: 'alignleft', format: 'alignleft'},
						{title: 'Center', icon: 'aligncenter', format: 'aligncenter'},
						{title: 'Right', icon: 'alignright', format: 'alignright'},
						{title: 'Justify', icon: 'alignjustify', format: 'alignjustify'}
					]}
				];
	
				function createMenu(formats) {
					var menu = [];
	
					if (!formats) {
						return;
					}
	
					each(formats, function(format) {
						var menuItem = {
							text: format.title,
							icon: format.icon
						};
	
						if (format.items) {
							menuItem.menu = createMenu(format.items);
						} else {
							var formatName = format.format || "custom" + count++;
	
							if (!format.format) {
								format.name = formatName;
								newFormats.push(format);
							}
	
							menuItem.format = formatName;
							menuItem.cmd = format.cmd;
						}
	
						menu.push(menuItem);
					});
	
					return menu;
				}
	
				function createStylesMenu() {
					var menu;
	
					if (editor.settings.style_formats_merge) {
						if (editor.settings.style_formats) {
							menu = createMenu(defaultStyleFormats.concat(editor.settings.style_formats));
						} else {
							menu = createMenu(defaultStyleFormats);
						}
					} else {
						menu = createMenu(editor.settings.style_formats || defaultStyleFormats);
					}
	
					return menu;
				}
	
				editor.on('init', function() {
					each(newFormats, function(format) {
						editor.formatter.register(format.name, format);
					});
				});
	
				return {
					type: 'menu',
					items: createStylesMenu(),
					onPostRender: function(e) {
						editor.fire('renderFormatsMenu', {control: e.control});
					},
					itemDefaults: {
						preview: true,
	
						textStyle: function() {
							if (this.settings.format) {
								return editor.formatter.getCssText(this.settings.format);
							}
						},
	
						onPostRender: function() {
							var self = this;
	
							self.parent().on('show', function() {
								var formatName, command;
	
								formatName = self.settings.format;
								if (formatName) {
									self.disabled(!editor.formatter.canApply(formatName));
									self.active(editor.formatter.match(formatName));
								}
	
								command = self.settings.cmd;
								if (command) {
									self.active(editor.queryCommandState(command));
								}
							});
						},
	
						onclick: function() {
							if (this.settings.format) {
								toggleFormat(this.settings.format);
							}
	
							if (this.settings.cmd) {
								editor.execCommand(this.settings.cmd);
							}
						}
					}
				};
			}
	
			formatMenu = createFormatMenu();
	
			function initOnPostRender(name) {
				return function() {
					var self = this;
	
					// TODO: Fix this
					if (editor.formatter) {
						editor.formatter.formatChanged(name, function(state) {
							self.active(state);
						});
					} else {
						editor.on('init', function() {
							editor.formatter.formatChanged(name, function(state) {
								self.active(state);
							});
						});
					}
				};
			}
	
			// Simple format controls <control/format>:<UI text>
			each({
				bold: 'Bold',
				italic: 'Italic',
				underline: 'Underline',
				strikethrough: 'Strikethrough',
				subscript: 'Subscript',
				superscript: 'Superscript'
			}, function(text, name) {
				editor.addButton(name, {
					tooltip: text,
					onPostRender: initOnPostRender(name),
					onclick: function() {
						toggleFormat(name);
					}
				});
			});
	
			// Simple command controls <control>:[<UI text>,<Command>]
			each({
				outdent: ['Decrease indent', 'Outdent'],
				indent: ['Increase indent', 'Indent'],
				cut: ['Cut', 'Cut'],
				copy: ['Copy', 'Copy'],
				paste: ['Paste', 'Paste'],
				help: ['Help', 'mceHelp'],
				selectall: ['Select all', 'SelectAll'],
				removeformat: ['Clear formatting', 'RemoveFormat'],
				visualaid: ['Visual aids', 'mceToggleVisualAid'],
				newdocument: ['New document', 'mceNewDocument']
			}, function(item, name) {
				editor.addButton(name, {
					tooltip: item[0],
					cmd: item[1]
				});
			});
	
			// Simple command controls with format state
			each({
				blockquote: ['Blockquote', 'mceBlockQuote'],
				subscript: ['Subscript', 'Subscript'],
				superscript: ['Superscript', 'Superscript'],
				alignleft: ['Align left', 'JustifyLeft'],
				aligncenter: ['Align center', 'JustifyCenter'],
				alignright: ['Align right', 'JustifyRight'],
				alignjustify: ['Justify', 'JustifyFull'],
				alignnone: ['No alignment', 'JustifyNone']
			}, function(item, name) {
				editor.addButton(name, {
					tooltip: item[0],
					cmd: item[1],
					onPostRender: initOnPostRender(name)
				});
			});
	
			function toggleUndoRedoState(type) {
				return function() {
					var self = this;
	
					type = type == 'redo' ? 'hasRedo' : 'hasUndo';
	
					function checkState() {
						return editor.undoManager ? editor.undoManager[type]() : false;
					}
	
					self.disabled(!checkState());
					editor.on('Undo Redo AddUndo TypingUndo ClearUndos SwitchMode', function() {
						self.disabled(editor.readonly || !checkState());
					});
				};
			}
	
			function toggleVisualAidState() {
				var self = this;
	
				editor.on('VisualAid', function(e) {
					self.active(e.hasVisual);
				});
	
				self.active(editor.hasVisual);
			}
	
			var trimMenuItems = function (menuItems) {
				var outputMenuItems = menuItems;
	
				if (outputMenuItems.length > 0 && outputMenuItems[0].text === '-') {
					outputMenuItems = outputMenuItems.slice(1);
				}
	
				if (outputMenuItems.length > 0 && outputMenuItems[outputMenuItems.length - 1].text === '-') {
					outputMenuItems = outputMenuItems.slice(0, outputMenuItems.length - 1);
				}
	
				return outputMenuItems;
			};
	
			var createCustomMenuItems = function (names) {
				var items, nameList;
	
				if (typeof names === 'string') {
					nameList = names.split(' ');
				} else if (Tools.isArray(names)) {
					return flatten(Tools.map(names, createCustomMenuItems));
				}
	
				items = Tools.grep(nameList, function (name) {
					return name === '|' || name in editor.menuItems;
				});
	
				return Tools.map(items, function (name) {
					return name === '|' ? {text: '-'} : editor.menuItems[name];
				});
			};
	
			var createContextMenuItems = function (context) {
				var outputMenuItems = [{text: '-'}];
				var menuItems = Tools.grep(editor.menuItems, function (menuItem) {
					return menuItem.context === context;
				});
	
				Tools.each(menuItems, function (menuItem) {
					if (menuItem.separator == 'before') {
						outputMenuItems.push({text: '|'});
					}
	
					if (menuItem.prependToContext) {
						outputMenuItems.unshift(menuItem);
					} else {
						outputMenuItems.push(menuItem);
					}
	
					if (menuItem.separator == 'after') {
						outputMenuItems.push({text: '|'});
					}
				});
	
				return outputMenuItems;
			};
	
			var createInsertMenu = function (editorSettings) {
				if (editorSettings.insert_button_items) {
					return trimMenuItems(createCustomMenuItems(editorSettings.insert_button_items));
				} else {
					return trimMenuItems(createContextMenuItems('insert'));
				}
			};
	
			editor.addButton('undo', {
				tooltip: 'Undo',
				onPostRender: toggleUndoRedoState('undo'),
				cmd: 'undo'
			});
	
			editor.addButton('redo', {
				tooltip: 'Redo',
				onPostRender: toggleUndoRedoState('redo'),
				cmd: 'redo'
			});
	
			editor.addMenuItem('newdocument', {
				text: 'New document',
				icon: 'newdocument',
				cmd: 'mceNewDocument'
			});
	
			editor.addMenuItem('undo', {
				text: 'Undo',
				icon: 'undo',
				shortcut: 'Meta+Z',
				onPostRender: toggleUndoRedoState('undo'),
				cmd: 'undo'
			});
	
			editor.addMenuItem('redo', {
				text: 'Redo',
				icon: 'redo',
				shortcut: 'Meta+Y',
				onPostRender: toggleUndoRedoState('redo'),
				cmd: 'redo'
			});
	
			editor.addMenuItem('visualaid', {
				text: 'Visual aids',
				selectable: true,
				onPostRender: toggleVisualAidState,
				cmd: 'mceToggleVisualAid'
			});
	
			editor.addButton('remove', {
				tooltip: 'Remove',
				icon: 'remove',
				cmd: 'Delete'
			});
	
			editor.addButton('insert', {
				type: 'menubutton',
				icon: 'insert',
				menu: [],
				oncreatemenu: function () {
					this.menu.add(createInsertMenu(editor.settings));
					this.menu.renderNew();
				}
			});
	
			each({
				cut: ['Cut', 'Cut', 'Meta+X'],
				copy: ['Copy', 'Copy', 'Meta+C'],
				paste: ['Paste', 'Paste', 'Meta+V'],
				selectall: ['Select all', 'SelectAll', 'Meta+A'],
				bold: ['Bold', 'Bold', 'Meta+B'],
				italic: ['Italic', 'Italic', 'Meta+I'],
				underline: ['Underline', 'Underline'],
				strikethrough: ['Strikethrough', 'Strikethrough'],
				subscript: ['Subscript', 'Subscript'],
				superscript: ['Superscript', 'Superscript'],
				removeformat: ['Clear formatting', 'RemoveFormat']
			}, function(item, name) {
				editor.addMenuItem(name, {
					text: item[0],
					icon: name,
					shortcut: item[2],
					cmd: item[1]
				});
			});
	
			editor.on('mousedown', function() {
				FloatPanel.hideAll();
			});
	
			function toggleFormat(fmt) {
				if (fmt.control) {
					fmt = fmt.control.value();
				}
	
				if (fmt) {
					editor.execCommand('mceToggleFormat', false, fmt);
				}
			}
	
			function hideMenuObjects(menu) {
				var count = menu.length;
	
				Tools.each(menu, function (item) {
					if (item.menu) {
						item.hidden = hideMenuObjects(item.menu) === 0;
					}
	
					var formatName = item.format;
					if (formatName) {
						item.hidden = !editor.formatter.canApply(formatName);
					}
	
					if (item.hidden) {
						count--;
					}
				});
	
				return count;
			}
	
			function hideFormatMenuItems(menu) {
				var count = menu.items().length;
	
				menu.items().each(function (item) {
					if (item.menu) {
						item.visible(hideFormatMenuItems(item.menu) > 0);
					}
	
					if (!item.menu && item.settings.menu) {
						item.visible(hideMenuObjects(item.settings.menu) > 0);
					}
	
					var formatName = item.settings.format;
					if (formatName) {
						item.visible(editor.formatter.canApply(formatName));
					}
	
					if (!item.visible()) {
						count--;
					}
				});
	
				return count;
			}
	
			editor.addButton('styleselect', {
				type: 'menubutton',
				text: 'Formats',
				menu: formatMenu,
				onShowMenu: function () {
					if (editor.settings.style_formats_autohide) {
						hideFormatMenuItems(this.menu);
					}
				}
			});
	
			editor.addButton('formatselect', function() {
				var items = [], blocks = createFormats(editor.settings.block_formats ||
					'Paragraph=p;' +
					'Heading 1=h1;' +
					'Heading 2=h2;' +
					'Heading 3=h3;' +
					'Heading 4=h4;' +
					'Heading 5=h5;' +
					'Heading 6=h6;' +
					'Preformatted=pre'
				);
	
				each(blocks, function(block) {
					items.push({
						text: block[0],
						value: block[1],
						textStyle: function() {
							return editor.formatter.getCssText(block[1]);
						}
					});
				});
	
				return {
					type: 'listbox',
					text: blocks[0][0],
					values: items,
					fixedWidth: true,
					onselect: toggleFormat,
					onPostRender: createListBoxChangeHandler(items)
				};
			});
	
			editor.addButton('fontselect', function() {
				var defaultFontsFormats =
					'Andale Mono=andale mono,monospace;' +
					'Arial=arial,helvetica,sans-serif;' +
					'Arial Black=arial black,sans-serif;' +
					'Book Antiqua=book antiqua,palatino,serif;' +
					'Comic Sans MS=comic sans ms,sans-serif;' +
					'Courier New=courier new,courier,monospace;' +
					'Georgia=georgia,palatino,serif;' +
					'Helvetica=helvetica,arial,sans-serif;' +
					'Impact=impact,sans-serif;' +
					'Symbol=symbol;' +
					'Tahoma=tahoma,arial,helvetica,sans-serif;' +
					'Terminal=terminal,monaco,monospace;' +
					'Times New Roman=times new roman,times,serif;' +
					'Trebuchet MS=trebuchet ms,geneva,sans-serif;' +
					'Verdana=verdana,geneva,sans-serif;' +
					'Webdings=webdings;' +
					'Wingdings=wingdings,zapf dingbats';
	
				var items = [], fonts = createFormats(editor.settings.font_formats || defaultFontsFormats);
	
				each(fonts, function(font) {
					items.push({
						text: {raw: font[0]},
						value: font[1],
						textStyle: font[1].indexOf('dings') == -1 ? 'font-family:' + font[1] : ''
					});
				});
	
				return {
					type: 'listbox',
					text: 'Font Family',
					tooltip: 'Font Family',
					values: items,
					fixedWidth: true,
					onPostRender: createListBoxChangeHandler(items, 'fontname'),
					onselect: function(e) {
						if (e.control.settings.value) {
							editor.execCommand('FontName', false, e.control.settings.value);
						}
					}
				};
			});
	
			editor.addButton('fontsizeselect', function() {
				var items = [], defaultFontsizeFormats = '8pt 10pt 12pt 14pt 18pt 24pt 36pt';
				var fontsize_formats = editor.settings.fontsize_formats || defaultFontsizeFormats;
	
				each(fontsize_formats.split(' '), function(item) {
					var text = item, value = item;
					// Allow text=value font sizes.
					var values = item.split('=');
					if (values.length > 1) {
						text = values[0];
						value = values[1];
					}
					items.push({text: text, value: value});
				});
	
				return {
					type: 'listbox',
					text: 'Font Sizes',
					tooltip: 'Font Sizes',
					values: items,
					fixedWidth: true,
					onPostRender: createListBoxChangeHandler(items, 'fontsize'),
					onclick: function(e) {
						if (e.control.settings.value) {
							editor.execCommand('FontSize', false, e.control.settings.value);
						}
					}
				};
			});
	
			editor.addMenuItem('formats', {
				text: 'Formats',
				menu: formatMenu
			});
		}
	});
	
	// Included from: js/tinymce/classes/ui/GridLayout.js
	
	/**
	 * GridLayout.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This layout manager places controls in a grid.
	 *
	 * @setting {Number} spacing Spacing between controls.
	 * @setting {Number} spacingH Horizontal spacing between controls.
	 * @setting {Number} spacingV Vertical spacing between controls.
	 * @setting {Number} columns Number of columns to use.
	 * @setting {String/Array} alignH start|end|center|stretch or array of values for each column.
	 * @setting {String/Array} alignV start|end|center|stretch or array of values for each column.
	 * @setting {String} pack start|end
	 *
	 * @class tinymce.ui.GridLayout
	 * @extends tinymce.ui.AbsoluteLayout
	 */
	define("tinymce/ui/GridLayout", [
		"tinymce/ui/AbsoluteLayout"
	], function(AbsoluteLayout) {
		"use strict";
	
		return AbsoluteLayout.extend({
			/**
			 * Recalculates the positions of the controls in the specified container.
			 *
			 * @method recalc
			 * @param {tinymce.ui.Container} container Container instance to recalc.
			 */
			recalc: function(container) {
				var settings, rows, cols, items, contLayoutRect, width, height, rect,
					ctrlLayoutRect, ctrl, x, y, posX, posY, ctrlSettings, contPaddingBox, align, spacingH, spacingV, alignH, alignV, maxX, maxY,
					colWidths = [], rowHeights = [], ctrlMinWidth, ctrlMinHeight, availableWidth, availableHeight, reverseRows, idx;
	
				// Get layout settings
				settings = container.settings;
				items = container.items().filter(':visible');
				contLayoutRect = container.layoutRect();
				cols = settings.columns || Math.ceil(Math.sqrt(items.length));
				rows = Math.ceil(items.length / cols);
				spacingH = settings.spacingH || settings.spacing || 0;
				spacingV = settings.spacingV || settings.spacing || 0;
				alignH = settings.alignH || settings.align;
				alignV = settings.alignV || settings.align;
				contPaddingBox = container.paddingBox;
				reverseRows = 'reverseRows' in settings ? settings.reverseRows : container.isRtl();
	
				if (alignH && typeof alignH == "string") {
					alignH = [alignH];
				}
	
				if (alignV && typeof alignV == "string") {
					alignV = [alignV];
				}
	
				// Zero padd columnWidths
				for (x = 0; x < cols; x++) {
					colWidths.push(0);
				}
	
				// Zero padd rowHeights
				for (y = 0; y < rows; y++) {
					rowHeights.push(0);
				}
	
				// Calculate columnWidths and rowHeights
				for (y = 0; y < rows; y++) {
					for (x = 0; x < cols; x++) {
						ctrl = items[y * cols + x];
	
						// Out of bounds
						if (!ctrl) {
							break;
						}
	
						ctrlLayoutRect = ctrl.layoutRect();
						ctrlMinWidth = ctrlLayoutRect.minW;
						ctrlMinHeight = ctrlLayoutRect.minH;
	
						colWidths[x] = ctrlMinWidth > colWidths[x] ? ctrlMinWidth : colWidths[x];
						rowHeights[y] = ctrlMinHeight > rowHeights[y] ? ctrlMinHeight : rowHeights[y];
					}
				}
	
				// Calculate maxX
				availableWidth = contLayoutRect.innerW - contPaddingBox.left - contPaddingBox.right;
				for (maxX = 0, x = 0; x < cols; x++) {
					maxX += colWidths[x] + (x > 0 ? spacingH : 0);
					availableWidth -= (x > 0 ? spacingH : 0) + colWidths[x];
				}
	
				// Calculate maxY
				availableHeight = contLayoutRect.innerH - contPaddingBox.top - contPaddingBox.bottom;
				for (maxY = 0, y = 0; y < rows; y++) {
					maxY += rowHeights[y] + (y > 0 ? spacingV : 0);
					availableHeight -= (y > 0 ? spacingV : 0) + rowHeights[y];
				}
	
				maxX += contPaddingBox.left + contPaddingBox.right;
				maxY += contPaddingBox.top + contPaddingBox.bottom;
	
				// Calculate minW/minH
				rect = {};
				rect.minW = maxX + (contLayoutRect.w - contLayoutRect.innerW);
				rect.minH = maxY + (contLayoutRect.h - contLayoutRect.innerH);
	
				rect.contentW = rect.minW - contLayoutRect.deltaW;
				rect.contentH = rect.minH - contLayoutRect.deltaH;
				rect.minW = Math.min(rect.minW, contLayoutRect.maxW);
				rect.minH = Math.min(rect.minH, contLayoutRect.maxH);
				rect.minW = Math.max(rect.minW, contLayoutRect.startMinWidth);
				rect.minH = Math.max(rect.minH, contLayoutRect.startMinHeight);
	
				// Resize container container if minSize was changed
				if (contLayoutRect.autoResize && (rect.minW != contLayoutRect.minW || rect.minH != contLayoutRect.minH)) {
					rect.w = rect.minW;
					rect.h = rect.minH;
	
					container.layoutRect(rect);
					this.recalc(container);
	
					// Forced recalc for example if items are hidden/shown
					if (container._lastRect === null) {
						var parentCtrl = container.parent();
						if (parentCtrl) {
							parentCtrl._lastRect = null;
							parentCtrl.recalc();
						}
					}
	
					return;
				}
	
				// Update contentW/contentH so absEnd moves correctly
				if (contLayoutRect.autoResize) {
					rect = container.layoutRect(rect);
					rect.contentW = rect.minW - contLayoutRect.deltaW;
					rect.contentH = rect.minH - contLayoutRect.deltaH;
				}
	
				var flexV;
	
				if (settings.packV == 'start') {
					flexV = 0;
				} else {
					flexV = availableHeight > 0 ? Math.floor(availableHeight / rows) : 0;
				}
	
				// Calculate totalFlex
				var totalFlex = 0;
				var flexWidths = settings.flexWidths;
				if (flexWidths) {
					for (x = 0; x < flexWidths.length; x++) {
						totalFlex += flexWidths[x];
					}
				} else {
					totalFlex = cols;
				}
	
				// Calculate new column widths based on flex values
				var ratio = availableWidth / totalFlex;
				for (x = 0; x < cols; x++) {
					colWidths[x] += flexWidths ? flexWidths[x] * ratio : ratio;
				}
	
				// Move/resize controls
				posY = contPaddingBox.top;
				for (y = 0; y < rows; y++) {
					posX = contPaddingBox.left;
					height = rowHeights[y] + flexV;
	
					for (x = 0; x < cols; x++) {
						if (reverseRows) {
							idx = y * cols + cols - 1 - x;
						} else {
							idx = y * cols + x;
						}
	
						ctrl = items[idx];
	
						// No more controls to render then break
						if (!ctrl) {
							break;
						}
	
						// Get control settings and calculate x, y
						ctrlSettings = ctrl.settings;
						ctrlLayoutRect = ctrl.layoutRect();
						width = Math.max(colWidths[x], ctrlLayoutRect.startMinWidth);
						ctrlLayoutRect.x = posX;
						ctrlLayoutRect.y = posY;
	
						// Align control horizontal
						align = ctrlSettings.alignH || (alignH ? (alignH[x] || alignH[0]) : null);
						if (align == "center") {
							ctrlLayoutRect.x = posX + (width / 2) - (ctrlLayoutRect.w / 2);
						} else if (align == "right") {
							ctrlLayoutRect.x = posX + width - ctrlLayoutRect.w;
						} else if (align == "stretch") {
							ctrlLayoutRect.w = width;
						}
	
						// Align control vertical
						align = ctrlSettings.alignV || (alignV ? (alignV[x] || alignV[0]) : null);
						if (align == "center") {
							ctrlLayoutRect.y = posY + (height / 2) - (ctrlLayoutRect.h / 2);
						} else if (align == "bottom") {
							ctrlLayoutRect.y = posY + height - ctrlLayoutRect.h;
						} else if (align == "stretch") {
							ctrlLayoutRect.h = height;
						}
	
						ctrl.layoutRect(ctrlLayoutRect);
	
						posX += width + spacingH;
	
						if (ctrl.recalc) {
							ctrl.recalc();
						}
					}
	
					posY += height + spacingV;
				}
			}
		});
	});
	
	// Included from: js/tinymce/classes/ui/Iframe.js
	
	/**
	 * Iframe.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/*jshint scripturl:true */
	
	/**
	 * This class creates an iframe.
	 *
	 * @setting {String} url Url to open in the iframe.
	 *
	 * @-x-less Iframe.less
	 * @class tinymce.ui.Iframe
	 * @extends tinymce.ui.Widget
	 */
	define("tinymce/ui/Iframe", [
		"tinymce/ui/Widget",
		"tinymce/util/Delay"
	], function(Widget, Delay) {
		"use strict";
	
		return Widget.extend({
			/**
			 * Renders the control as a HTML string.
			 *
			 * @method renderHtml
			 * @return {String} HTML representing the control.
			 */
			renderHtml: function() {
				var self = this;
	
				self.classes.add('iframe');
				self.canFocus = false;
	
				/*eslint no-script-url:0 */
				return (
					'<iframe id="' + self._id + '" class="' + self.classes + '" tabindex="-1" src="' +
					(self.settings.url || "javascript:''") + '" frameborder="0"></iframe>'
				);
			},
	
			/**
			 * Setter for the iframe source.
			 *
			 * @method src
			 * @param {String} src Source URL for iframe.
			 */
			src: function(src) {
				this.getEl().src = src;
			},
	
			/**
			 * Inner HTML for the iframe.
			 *
			 * @method html
			 * @param {String} html HTML string to set as HTML inside the iframe.
			 * @param {function} callback Optional callback to execute when the iframe body is filled with contents.
			 * @return {tinymce.ui.Iframe} Current iframe control.
			 */
			html: function(html, callback) {
				var self = this, body = this.getEl().contentWindow.document.body;
	
				// Wait for iframe to initialize IE 10 takes time
				if (!body) {
					Delay.setTimeout(function() {
						self.html(html);
					});
				} else {
					body.innerHTML = html;
	
					if (callback) {
						callback();
					}
				}
	
				return this;
			}
		});
	});
	
	// Included from: js/tinymce/classes/ui/InfoBox.js
	
	/**
	 * InfoBox.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2016 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * ....
	 *
	 * @-x-less InfoBox.less
	 * @class tinymce.ui.InfoBox
	 * @extends tinymce.ui.Widget
	 */
	define("tinymce/ui/InfoBox", [
		"tinymce/ui/Widget"
	], function(Widget) {
		"use strict";
	
		return Widget.extend({
			/**
			 * Constructs a instance with the specified settings.
			 *
			 * @constructor
			 * @param {Object} settings Name/value object with settings.
			 * @setting {Boolean} multiline Multiline label.
			 */
			init: function(settings) {
				var self = this;
	
				self._super(settings);
				self.classes.add('widget').add('infobox');
				self.canFocus = false;
			},
	
			severity: function(level) {
				this.classes.remove('error');
				this.classes.remove('warning');
				this.classes.remove('success');
				this.classes.add(level);
			},
	
			help: function(state) {
				this.state.set('help', state);
			},
	
			/**
			 * Renders the control as a HTML string.
			 *
			 * @method renderHtml
			 * @return {String} HTML representing the control.
			 */
			renderHtml: function() {
				var self = this, prefix = self.classPrefix;
	
				return (
					'<div id="' + self._id + '" class="' + self.classes + '">' +
						'<div id="' + self._id + '-body">' +
							self.encode(self.state.get('text')) +
							'<button role="button" tabindex="-1">' +
								'<i class="' + prefix + 'ico ' + prefix + 'i-help"></i>' +
							'</button>' +
						'</div>' +
					'</div>'
				);
			},
	
			bindStates: function() {
				var self = this;
	
				self.state.on('change:text', function(e) {
					self.getEl('body').firstChild.data = self.encode(e.value);
	
					if (self.state.get('rendered')) {
						self.updateLayoutRect();
					}
				});
	
				self.state.on('change:help', function(e) {
					self.classes.toggle('has-help', e.value);
	
					if (self.state.get('rendered')) {
						self.updateLayoutRect();
					}
				});
	
				return self._super();
			}
		});
	});
	
	// Included from: js/tinymce/classes/ui/Label.js
	
	/**
	 * Label.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This class creates a label element. A label is a simple text control
	 * that can be bound to other controls.
	 *
	 * @-x-less Label.less
	 * @class tinymce.ui.Label
	 * @extends tinymce.ui.Widget
	 */
	define("tinymce/ui/Label", [
		"tinymce/ui/Widget",
		"tinymce/ui/DomUtils"
	], function(Widget, DomUtils) {
		"use strict";
	
		return Widget.extend({
			/**
			 * Constructs a instance with the specified settings.
			 *
			 * @constructor
			 * @param {Object} settings Name/value object with settings.
			 * @setting {Boolean} multiline Multiline label.
			 */
			init: function(settings) {
				var self = this;
	
				self._super(settings);
				self.classes.add('widget').add('label');
				self.canFocus = false;
	
				if (settings.multiline) {
					self.classes.add('autoscroll');
				}
	
				if (settings.strong) {
					self.classes.add('strong');
				}
			},
	
			/**
			 * Initializes the current controls layout rect.
			 * This will be executed by the layout managers to determine the
			 * default minWidth/minHeight etc.
			 *
			 * @method initLayoutRect
			 * @return {Object} Layout rect instance.
			 */
			initLayoutRect: function() {
				var self = this, layoutRect = self._super();
	
				if (self.settings.multiline) {
					var size = DomUtils.getSize(self.getEl());
	
					// Check if the text fits within maxW if not then try word wrapping it
					if (size.width > layoutRect.maxW) {
						layoutRect.minW = layoutRect.maxW;
						self.classes.add('multiline');
					}
	
					self.getEl().style.width = layoutRect.minW + 'px';
					layoutRect.startMinH = layoutRect.h = layoutRect.minH = Math.min(layoutRect.maxH, DomUtils.getSize(self.getEl()).height);
				}
	
				return layoutRect;
			},
	
			/**
			 * Repaints the control after a layout operation.
			 *
			 * @method repaint
			 */
			repaint: function() {
				var self = this;
	
				if (!self.settings.multiline) {
					self.getEl().style.lineHeight = self.layoutRect().h + 'px';
				}
	
				return self._super();
			},
	
			severity: function(level) {
				this.classes.remove('error');
				this.classes.remove('warning');
				this.classes.remove('success');
				this.classes.add(level);
			},
	
			/**
			 * Renders the control as a HTML string.
			 *
			 * @method renderHtml
			 * @return {String} HTML representing the control.
			 */
			renderHtml: function() {
				var self = this, targetCtrl, forName, forId = self.settings.forId;
	
				if (!forId && (forName = self.settings.forName)) {
					targetCtrl = self.getRoot().find('#' + forName)[0];
	
					if (targetCtrl) {
						forId = targetCtrl._id;
					}
				}
	
				if (forId) {
					return (
						'<label id="' + self._id + '" class="' + self.classes + '"' + (forId ? ' for="' + forId + '"' : '') + '>' +
							self.encode(self.state.get('text')) +
						'</label>'
					);
				}
	
				return (
					'<span id="' + self._id + '" class="' + self.classes + '">' +
						self.encode(self.state.get('text')) +
					'</span>'
				);
			},
	
			bindStates: function() {
				var self = this;
	
				self.state.on('change:text', function(e) {
					self.innerHtml(self.encode(e.value));
	
					if (self.state.get('rendered')) {
						self.updateLayoutRect();
					}
				});
	
				return self._super();
			}
		});
	});
	
	// Included from: js/tinymce/classes/ui/Toolbar.js
	
	/**
	 * Toolbar.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Creates a new toolbar.
	 *
	 * @class tinymce.ui.Toolbar
	 * @extends tinymce.ui.Container
	 */
	define("tinymce/ui/Toolbar", [
		"tinymce/ui/Container"
	], function(Container) {
		"use strict";
	
		return Container.extend({
			Defaults: {
				role: 'toolbar',
				layout: 'flow'
			},
	
			/**
			 * Constructs a instance with the specified settings.
			 *
			 * @constructor
			 * @param {Object} settings Name/value object with settings.
			 */
			init: function(settings) {
				var self = this;
	
				self._super(settings);
				self.classes.add('toolbar');
			},
	
			/**
			 * Called after the control has been rendered.
			 *
			 * @method postRender
			 */
			postRender: function() {
				var self = this;
	
				self.items().each(function(ctrl) {
					ctrl.classes.add('toolbar-item');
				});
	
				return self._super();
			}
		});
	});
	
	// Included from: js/tinymce/classes/ui/MenuBar.js
	
	/**
	 * MenuBar.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Creates a new menubar.
	 *
	 * @-x-less MenuBar.less
	 * @class tinymce.ui.MenuBar
	 * @extends tinymce.ui.Container
	 */
	define("tinymce/ui/MenuBar", [
		"tinymce/ui/Toolbar"
	], function(Toolbar) {
		"use strict";
	
		return Toolbar.extend({
			Defaults: {
				role: 'menubar',
				containerCls: 'menubar',
				ariaRoot: true,
				defaults: {
					type: 'menubutton'
				}
			}
		});
	});
	
	// Included from: js/tinymce/classes/ui/MenuButton.js
	
	/**
	 * MenuButton.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Creates a new menu button.
	 *
	 * @-x-less MenuButton.less
	 * @class tinymce.ui.MenuButton
	 * @extends tinymce.ui.Button
	 */
	define("tinymce/ui/MenuButton", [
		"tinymce/ui/Button",
		"tinymce/ui/Factory",
		"tinymce/ui/MenuBar"
	], function(Button, Factory, MenuBar) {
		"use strict";
	
		// TODO: Maybe add as some global function
		function isChildOf(node, parent) {
			while (node) {
				if (parent === node) {
					return true;
				}
	
				node = node.parentNode;
			}
	
			return false;
		}
	
		var MenuButton = Button.extend({
			/**
			 * Constructs a instance with the specified settings.
			 *
			 * @constructor
			 * @param {Object} settings Name/value object with settings.
			 */
			init: function(settings) {
				var self = this;
	
				self._renderOpen = true;
	
				self._super(settings);
				settings = self.settings;
	
				self.classes.add('menubtn');
	
				if (settings.fixedWidth) {
					self.classes.add('fixed-width');
				}
	
				self.aria('haspopup', true);
	
				self.state.set('menu', settings.menu || self.render());
			},
	
			/**
			 * Shows the menu for the button.
			 *
			 * @method showMenu
			 */
			showMenu: function() {
				var self = this, menu;
	
				if (self.menu && self.menu.visible()) {
					return self.hideMenu();
				}
	
				if (!self.menu) {
					menu = self.state.get('menu') || [];
	
					// Is menu array then auto constuct menu control
					if (menu.length) {
						menu = {
							type: 'menu',
							items: menu
						};
					} else {
						menu.type = menu.type || 'menu';
					}
	
					if (!menu.renderTo) {
						self.menu = Factory.create(menu).parent(self).renderTo();
					} else {
						self.menu = menu.parent(self).show().renderTo();
					}
	
					self.fire('createmenu');
					self.menu.reflow();
					self.menu.on('cancel', function(e) {
						if (e.control.parent() === self.menu) {
							e.stopPropagation();
							self.focus();
							self.hideMenu();
						}
					});
	
					// Move focus to button when a menu item is selected/clicked
					self.menu.on('select', function() {
						self.focus();
					});
	
					self.menu.on('show hide', function(e) {
						if (e.control == self.menu) {
							self.activeMenu(e.type == 'show');
						}
	
						self.aria('expanded', e.type == 'show');
					}).fire('show');
				}
	
				self.menu.show();
				self.menu.layoutRect({w: self.layoutRect().w});
				self.menu.moveRel(self.getEl(), self.isRtl() ? ['br-tr', 'tr-br'] : ['bl-tl', 'tl-bl']);
				self.fire('showmenu');
			},
	
			/**
			 * Hides the menu for the button.
			 *
			 * @method hideMenu
			 */
			hideMenu: function() {
				var self = this;
	
				if (self.menu) {
					self.menu.items().each(function(item) {
						if (item.hideMenu) {
							item.hideMenu();
						}
					});
	
					self.menu.hide();
				}
			},
	
			/**
			 * Sets the active menu state.
			 *
			 * @private
			 */
			activeMenu: function(state) {
				this.classes.toggle('active', state);
			},
	
			/**
			 * Renders the control as a HTML string.
			 *
			 * @method renderHtml
			 * @return {String} HTML representing the control.
			 */
			renderHtml: function() {
				var self = this, id = self._id, prefix = self.classPrefix;
				var icon = self.settings.icon, image, text = self.state.get('text'),
					textHtml = '';
	
				image = self.settings.image;
				if (image) {
					icon = 'none';
	
					// Support for [high dpi, low dpi] image sources
					if (typeof image != "string") {
						image = window.getSelection ? image[0] : image[1];
					}
	
					image = ' style="background-image: url(\'' + image + '\')"';
				} else {
					image = '';
				}
	
				if (text) {
					self.classes.add('btn-has-text');
					textHtml = '<span class="' + prefix + 'txt">' + self.encode(text) + '</span>';
				}
	
				icon = self.settings.icon ? prefix + 'ico ' + prefix + 'i-' + icon : '';
	
				self.aria('role', self.parent() instanceof MenuBar ? 'menuitem' : 'button');
	
				return (
					'<div id="' + id + '" class="' + self.classes + '" tabindex="-1" aria-labelledby="' + id + '">' +
						'<button id="' + id + '-open" role="presentation" type="button" tabindex="-1">' +
							(icon ? '<i class="' + icon + '"' + image + '></i>' : '') +
							textHtml +
							' <i class="' + prefix + 'caret"></i>' +
						'</button>' +
					'</div>'
				);
			},
	
			/**
			 * Gets invoked after the control has been rendered.
			 *
			 * @method postRender
			 */
			postRender: function() {
				var self = this;
	
				self.on('click', function(e) {
					if (e.control === self && isChildOf(e.target, self.getEl())) {
						self.showMenu();
	
						if (e.aria) {
							self.menu.items().filter(':visible')[0].focus();
						}
					}
				});
	
				self.on('mouseenter', function(e) {
					var overCtrl = e.control, parent = self.parent(), hasVisibleSiblingMenu;
	
					if (overCtrl && parent && overCtrl instanceof MenuButton && overCtrl.parent() == parent) {
						parent.items().filter('MenuButton').each(function(ctrl) {
							if (ctrl.hideMenu && ctrl != overCtrl) {
								if (ctrl.menu && ctrl.menu.visible()) {
									hasVisibleSiblingMenu = true;
								}
	
								ctrl.hideMenu();
							}
						});
	
						if (hasVisibleSiblingMenu) {
							overCtrl.focus(); // Fix for: #5887
							overCtrl.showMenu();
						}
					}
				});
	
				return self._super();
			},
	
			bindStates: function() {
				var self = this;
	
				self.state.on('change:menu', function() {
					if (self.menu) {
						self.menu.remove();
					}
	
					self.menu = null;
				});
	
				return self._super();
			},
	
			/**
			 * Removes the control and it's menus.
			 *
			 * @method remove
			 */
			remove: function() {
				this._super();
	
				if (this.menu) {
					this.menu.remove();
				}
			}
		});
	
		return MenuButton;
	});
	
	// Included from: js/tinymce/classes/ui/MenuItem.js
	
	/**
	 * MenuItem.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Creates a new menu item.
	 *
	 * @-x-less MenuItem.less
	 * @class tinymce.ui.MenuItem
	 * @extends tinymce.ui.Control
	 */
	define("tinymce/ui/MenuItem", [
		"tinymce/ui/Widget",
		"tinymce/ui/Factory",
		"tinymce/Env",
		"tinymce/util/Delay"
	], function(Widget, Factory, Env, Delay) {
		"use strict";
	
		return Widget.extend({
			Defaults: {
				border: 0,
				role: 'menuitem'
			},
	
			/**
			 * Constructs a instance with the specified settings.
			 *
			 * @constructor
			 * @param {Object} settings Name/value object with settings.
			 * @setting {Boolean} selectable Selectable menu.
			 * @setting {Array} menu Submenu array with items.
			 * @setting {String} shortcut Shortcut to display for menu item. Example: Ctrl+X
			 */
			init: function(settings) {
				var self = this, text;
	
				self._super(settings);
	
				settings = self.settings;
	
				self.classes.add('menu-item');
	
				if (settings.menu) {
					self.classes.add('menu-item-expand');
				}
	
				if (settings.preview) {
					self.classes.add('menu-item-preview');
				}
	
				text = self.state.get('text');
				if (text === '-' || text === '|') {
					self.classes.add('menu-item-sep');
					self.aria('role', 'separator');
					self.state.set('text', '-');
				}
	
				if (settings.selectable) {
					self.aria('role', 'menuitemcheckbox');
					self.classes.add('menu-item-checkbox');
					settings.icon = 'selected';
				}
	
				if (!settings.preview && !settings.selectable) {
					self.classes.add('menu-item-normal');
				}
	
				self.on('mousedown', function(e) {
					e.preventDefault();
				});
	
				if (settings.menu && !settings.ariaHideMenu) {
					self.aria('haspopup', true);
				}
			},
	
			/**
			 * Returns true/false if the menuitem has sub menu.
			 *
			 * @method hasMenus
			 * @return {Boolean} True/false state if it has submenu.
			 */
			hasMenus: function() {
				return !!this.settings.menu;
			},
	
			/**
			 * Shows the menu for the menu item.
			 *
			 * @method showMenu
			 */
			showMenu: function() {
				var self = this, settings = self.settings, menu, parent = self.parent();
	
				parent.items().each(function(ctrl) {
					if (ctrl !== self) {
						ctrl.hideMenu();
					}
				});
	
				if (settings.menu) {
					menu = self.menu;
	
					if (!menu) {
						menu = settings.menu;
	
						// Is menu array then auto constuct menu control
						if (menu.length) {
							menu = {
								type: 'menu',
								items: menu
							};
						} else {
							menu.type = menu.type || 'menu';
						}
	
						if (parent.settings.itemDefaults) {
							menu.itemDefaults = parent.settings.itemDefaults;
						}
	
						menu = self.menu = Factory.create(menu).parent(self).renderTo();
						menu.reflow();
						menu.on('cancel', function(e) {
							e.stopPropagation();
							self.focus();
							menu.hide();
						});
						menu.on('show hide', function(e) {
							if (e.control.items) {
								e.control.items().each(function(ctrl) {
									ctrl.active(ctrl.settings.selected);
								});
							}
						}).fire('show');
	
						menu.on('hide', function(e) {
							if (e.control === menu) {
								self.classes.remove('selected');
							}
						});
	
						menu.submenu = true;
					} else {
						menu.show();
					}
	
					menu._parentMenu = parent;
	
					menu.classes.add('menu-sub');
	
					var rel = menu.testMoveRel(
						self.getEl(),
						self.isRtl() ? ['tl-tr', 'bl-br', 'tr-tl', 'br-bl'] : ['tr-tl', 'br-bl', 'tl-tr', 'bl-br']
					);
	
					menu.moveRel(self.getEl(), rel);
					menu.rel = rel;
	
					rel = 'menu-sub-' + rel;
					menu.classes.remove(menu._lastRel).add(rel);
					menu._lastRel = rel;
	
					self.classes.add('selected');
					self.aria('expanded', true);
				}
			},
	
			/**
			 * Hides the menu for the menu item.
			 *
			 * @method hideMenu
			 */
			hideMenu: function() {
				var self = this;
	
				if (self.menu) {
					self.menu.items().each(function(item) {
						if (item.hideMenu) {
							item.hideMenu();
						}
					});
	
					self.menu.hide();
					self.aria('expanded', false);
				}
	
				return self;
			},
	
			/**
			 * Renders the control as a HTML string.
			 *
			 * @method renderHtml
			 * @return {String} HTML representing the control.
			 */
			renderHtml: function() {
				var self = this, id = self._id, settings = self.settings, prefix = self.classPrefix, text = self.state.get('text');
				var icon = self.settings.icon, image = '', shortcut = settings.shortcut;
				var url = self.encode(settings.url), iconHtml = '';
	
				// Converts shortcut format to Mac/PC variants
				function convertShortcut(shortcut) {
					var i, value, replace = {};
	
					if (Env.mac) {
						replace = {
							alt: '&#x2325;',
							ctrl: '&#x2318;',
							shift: '&#x21E7;',
							meta: '&#x2318;'
						};
					} else {
						replace = {
							meta: 'Ctrl'
						};
					}
	
					shortcut = shortcut.split('+');
	
					for (i = 0; i < shortcut.length; i++) {
						value = replace[shortcut[i].toLowerCase()];
	
						if (value) {
							shortcut[i] = value;
						}
					}
	
					return shortcut.join('+');
				}
	
				function escapeRegExp(str) {
					return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
				}
	
				function markMatches(text) {
					var match = settings.match || '';
	
					return match ? text.replace(new RegExp(escapeRegExp(match), 'gi'), function (match) {
						return '!mce~match[' + match + ']mce~match!';
					}) : text;
				}
	
				function boldMatches(text) {
					return text.
						replace(new RegExp(escapeRegExp('!mce~match['), 'g'), '<b>').
						replace(new RegExp(escapeRegExp(']mce~match!'), 'g'), '</b>');
				}
	
				if (icon) {
					self.parent().classes.add('menu-has-icons');
				}
	
				if (settings.image) {
					image = ' style="background-image: url(\'' + settings.image + '\')"';
				}
	
				if (shortcut) {
					shortcut = convertShortcut(shortcut);
				}
	
				icon = prefix + 'ico ' + prefix + 'i-' + (self.settings.icon || 'none');
				iconHtml = (text !== '-' ? '<i class="' + icon + '"' + image + '></i>\u00a0' : '');
	
				text = boldMatches(self.encode(markMatches(text)));
				url = boldMatches(self.encode(markMatches(url)));
	
				return (
					'<div id="' + id + '" class="' + self.classes + '" tabindex="-1">' +
						iconHtml +
						(text !== '-' ? '<span id="' + id + '-text" class="' + prefix + 'text">' + text + '</span>' : '') +
						(shortcut ? '<div id="' + id + '-shortcut" class="' + prefix + 'menu-shortcut">' + shortcut + '</div>' : '') +
						(settings.menu ? '<div class="' + prefix + 'caret"></div>' : '') +
						(url ? '<div class="' + prefix + 'menu-item-link">' + url + '</div>' : '') +
					'</div>'
				);
			},
	
			/**
			 * Gets invoked after the control has been rendered.
			 *
			 * @method postRender
			 */
			postRender: function() {
				var self = this, settings = self.settings;
	
				var textStyle = settings.textStyle;
				if (typeof textStyle == "function") {
					textStyle = textStyle.call(this);
				}
	
				if (textStyle) {
					var textElm = self.getEl('text');
					if (textElm) {
						textElm.setAttribute('style', textStyle);
					}
				}
	
				self.on('mouseenter click', function(e) {
					if (e.control === self) {
						if (!settings.menu && e.type === 'click') {
							self.fire('select');
	
							// Edge will crash if you stress it see #2660
							Delay.requestAnimationFrame(function() {
								self.parent().hideAll();
							});
						} else {
							self.showMenu();
	
							if (e.aria) {
								self.menu.focus(true);
							}
						}
					}
				});
	
				self._super();
	
				return self;
			},
	
			hover: function() {
				var self = this;
	
				self.parent().items().each(function(ctrl) {
					ctrl.classes.remove('selected');
				});
	
				self.classes.toggle('selected', true);
	
				return self;
			},
	
			active: function(state) {
				if (typeof state != "undefined") {
					this.aria('checked', state);
				}
	
				return this._super(state);
			},
	
			/**
			 * Removes the control and it's menus.
			 *
			 * @method remove
			 */
			remove: function() {
				this._super();
	
				if (this.menu) {
					this.menu.remove();
				}
			}
		});
	});
	
	// Included from: js/tinymce/classes/ui/Throbber.js
	
	/**
	 * Throbber.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This class enables you to display a Throbber for any element.
	 *
	 * @-x-less Throbber.less
	 * @class tinymce.ui.Throbber
	 */
	define("tinymce/ui/Throbber", [
		"tinymce/dom/DomQuery",
		"tinymce/ui/Control",
		"tinymce/util/Delay"
	], function($, Control, Delay) {
		"use strict";
	
		/**
		 * Constructs a new throbber.
		 *
		 * @constructor
		 * @param {Element} elm DOM Html element to display throbber in.
		 * @param {Boolean} inline Optional true/false state if the throbber should be appended to end of element for infinite scroll.
		 */
		return function(elm, inline) {
			var self = this, state, classPrefix = Control.classPrefix, timer;
	
			/**
			 * Shows the throbber.
			 *
			 * @method show
			 * @param {Number} [time] Time to wait before showing.
			 * @param {function} [callback] Optional callback to execute when the throbber is shown.
			 * @return {tinymce.ui.Throbber} Current throbber instance.
			 */
			self.show = function(time, callback) {
				function render() {
						if (state) {
							$(elm).append(
								'<div class="' + classPrefix + 'throbber' + (inline ? ' ' + classPrefix + 'throbber-inline' : '') + '"></div>'
							);
	
							if (callback) {
								callback();
							}
						}
				}
	
				self.hide();
	
				state = true;
	
				if (time) {
					timer = Delay.setTimeout(render, time);
				} else {
					render();
				}
	
				return self;
			};
	
			/**
			 * Hides the throbber.
			 *
			 * @method hide
			 * @return {tinymce.ui.Throbber} Current throbber instance.
			 */
			self.hide = function() {
				var child = elm.lastChild;
	
				Delay.clearTimeout(timer);
	
				if (child && child.className.indexOf('throbber') != -1) {
					child.parentNode.removeChild(child);
				}
	
				state = false;
	
				return self;
			};
		};
	});
	
	// Included from: js/tinymce/classes/ui/Menu.js
	
	/**
	 * Menu.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Creates a new menu.
	 *
	 * @-x-less Menu.less
	 * @class tinymce.ui.Menu
	 * @extends tinymce.ui.FloatPanel
	 */
	define("tinymce/ui/Menu", [
		"tinymce/ui/FloatPanel",
		"tinymce/ui/MenuItem",
		"tinymce/ui/Throbber",
		"tinymce/util/Tools"
	], function(FloatPanel, MenuItem, Throbber, Tools) {
		"use strict";
	
		return FloatPanel.extend({
			Defaults: {
				defaultType: 'menuitem',
				border: 1,
				layout: 'stack',
				role: 'application',
				bodyRole: 'menu',
				ariaRoot: true
			},
	
			/**
			 * Constructs a instance with the specified settings.
			 *
			 * @constructor
			 * @param {Object} settings Name/value object with settings.
			 */
			init: function(settings) {
				var self = this;
	
				settings.autohide = true;
				settings.constrainToViewport = true;
	
				if (typeof settings.items === 'function') {
					settings.itemsFactory = settings.items;
					settings.items = [];
				}
	
				if (settings.itemDefaults) {
					var items = settings.items, i = items.length;
	
					while (i--) {
						items[i] = Tools.extend({}, settings.itemDefaults, items[i]);
					}
				}
	
				self._super(settings);
				self.classes.add('menu');
			},
	
			/**
			 * Repaints the control after a layout operation.
			 *
			 * @method repaint
			 */
			repaint: function() {
				this.classes.toggle('menu-align', true);
	
				this._super();
	
				this.getEl().style.height = '';
				this.getEl('body').style.height = '';
	
				return this;
			},
	
			/**
			 * Hides/closes the menu.
			 *
			 * @method cancel
			 */
			cancel: function() {
				var self = this;
	
				self.hideAll();
				self.fire('select');
			},
	
			/**
			 * Loads new items from the factory items function.
			 *
			 * @method load
			 */
			load: function() {
				var self = this, time, factory;
	
				function hideThrobber() {
					if (self.throbber) {
						self.throbber.hide();
						self.throbber = null;
					}
				}
	
				factory = self.settings.itemsFactory;
				if (!factory) {
					return;
				}
	
				if (!self.throbber) {
					self.throbber = new Throbber(self.getEl('body'), true);
	
					if (self.items().length === 0) {
						self.throbber.show();
						self.fire('loading');
					} else {
						self.throbber.show(100, function() {
							self.items().remove();
							self.fire('loading');
						});
					}
	
					self.on('hide close', hideThrobber);
				}
	
				self.requestTime = time = new Date().getTime();
	
				self.settings.itemsFactory(function(items) {
					if (items.length === 0) {
						self.hide();
						return;
					}
	
					if (self.requestTime !== time) {
						return;
					}
	
					self.getEl().style.width = '';
					self.getEl('body').style.width = '';
	
					hideThrobber();
					self.items().remove();
					self.getEl('body').innerHTML = '';
	
					self.add(items);
					self.renderNew();
					self.fire('loaded');
				});
			},
	
			/**
			 * Hide menu and all sub menus.
			 *
			 * @method hideAll
			 */
			hideAll: function() {
				var self = this;
	
				this.find('menuitem').exec('hideMenu');
	
				return self._super();
			},
	
			/**
			 * Invoked before the menu is rendered.
			 *
			 * @method preRender
			 */
			preRender: function() {
				var self = this;
	
				self.items().each(function(ctrl) {
					var settings = ctrl.settings;
	
					if (settings.icon || settings.image || settings.selectable) {
						self._hasIcons = true;
						return false;
					}
				});
	
				if (self.settings.itemsFactory) {
					self.on('postrender', function() {
						if (self.settings.itemsFactory) {
							self.load();
						}
					});
				}
	
				return self._super();
			}
		});
	});
	
	// Included from: js/tinymce/classes/ui/ListBox.js
	
	/**
	 * ListBox.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Creates a new list box control.
	 *
	 * @-x-less ListBox.less
	 * @class tinymce.ui.ListBox
	 * @extends tinymce.ui.MenuButton
	 */
	define("tinymce/ui/ListBox", [
		"tinymce/ui/MenuButton",
		"tinymce/ui/Menu"
	], function(MenuButton, Menu) {
		"use strict";
	
		return MenuButton.extend({
			/**
			 * Constructs a instance with the specified settings.
			 *
			 * @constructor
			 * @param {Object} settings Name/value object with settings.
			 * @setting {Array} values Array with values to add to list box.
			 */
			init: function(settings) {
				var self = this, values, selected, selectedText, lastItemCtrl;
	
				function setSelected(menuValues) {
					// Try to find a selected value
					for (var i = 0; i < menuValues.length; i++) {
						selected = menuValues[i].selected || settings.value === menuValues[i].value;
	
						if (selected) {
							selectedText = selectedText || menuValues[i].text;
							self.state.set('value', menuValues[i].value);
							return true;
						}
	
						// If the value has a submenu, try to find the selected values in that menu
						if (menuValues[i].menu) {
							if (setSelected(menuValues[i].menu)) {
								return true;
							}
						}
					}
				}
	
				self._super(settings);
				settings = self.settings;
	
				self._values = values = settings.values;
				if (values) {
					if (typeof settings.value != "undefined") {
						setSelected(values);
					}
	
					// Default with first item
					if (!selected && values.length > 0) {
						selectedText = values[0].text;
						self.state.set('value', values[0].value);
					}
	
					self.state.set('menu', values);
				}
	
				self.state.set('text', settings.text || selectedText);
	
				self.classes.add('listbox');
	
				self.on('select', function(e) {
					var ctrl = e.control;
	
					if (lastItemCtrl) {
						e.lastControl = lastItemCtrl;
					}
	
					if (settings.multiple) {
						ctrl.active(!ctrl.active());
					} else {
						self.value(e.control.value());
					}
	
					lastItemCtrl = ctrl;
				});
			},
	
			/**
			 * Getter/setter function for the control value.
			 *
			 * @method value
			 * @param {String} [value] Value to be set.
			 * @return {Boolean/tinymce.ui.ListBox} Value or self if it's a set operation.
			 */
			bindStates: function() {
				var self = this;
	
				function activateMenuItemsByValue(menu, value) {
					if (menu instanceof Menu) {
						menu.items().each(function(ctrl) {
							if (!ctrl.hasMenus()) {
								ctrl.active(ctrl.value() === value);
							}
						});
					}
				}
	
				function getSelectedItem(menuValues, value) {
					var selectedItem;
	
					if (!menuValues) {
						return;
					}
	
					for (var i = 0; i < menuValues.length; i++) {
						if (menuValues[i].value === value) {
							return menuValues[i];
						}
	
						if (menuValues[i].menu) {
							selectedItem = getSelectedItem(menuValues[i].menu, value);
							if (selectedItem) {
								return selectedItem;
							}
						}
					}
				}
	
				self.on('show', function(e) {
					activateMenuItemsByValue(e.control, self.value());
				});
	
				self.state.on('change:value', function(e) {
					var selectedItem = getSelectedItem(self.state.get('menu'), e.value);
	
					if (selectedItem) {
						self.text(selectedItem.text);
					} else {
						self.text(self.settings.text);
					}
				});
	
				return self._super();
			}
		});
	});
	
	// Included from: js/tinymce/classes/ui/Radio.js
	
	/**
	 * Radio.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Creates a new radio button.
	 *
	 * @-x-less Radio.less
	 * @class tinymce.ui.Radio
	 * @extends tinymce.ui.Checkbox
	 */
	define("tinymce/ui/Radio", [
		"tinymce/ui/Checkbox"
	], function(Checkbox) {
		"use strict";
	
		return Checkbox.extend({
			Defaults: {
				classes: "radio",
				role: "radio"
			}
		});
	});
	
	// Included from: js/tinymce/classes/ui/ResizeHandle.js
	
	/**
	 * ResizeHandle.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Renders a resize handle that fires ResizeStart, Resize and ResizeEnd events.
	 *
	 * @-x-less ResizeHandle.less
	 * @class tinymce.ui.ResizeHandle
	 * @extends tinymce.ui.Widget
	 */
	define("tinymce/ui/ResizeHandle", [
		"tinymce/ui/Widget",
		"tinymce/ui/DragHelper"
	], function(Widget, DragHelper) {
		"use strict";
	
		return Widget.extend({
			/**
			 * Renders the control as a HTML string.
			 *
			 * @method renderHtml
			 * @return {String} HTML representing the control.
			 */
			renderHtml: function() {
				var self = this, prefix = self.classPrefix;
	
				self.classes.add('resizehandle');
	
				if (self.settings.direction == "both") {
					self.classes.add('resizehandle-both');
				}
	
				self.canFocus = false;
	
				return (
					'<div id="' + self._id + '" class="' + self.classes + '">' +
						'<i class="' + prefix + 'ico ' + prefix + 'i-resize"></i>' +
					'</div>'
				);
			},
	
			/**
			 * Called after the control has been rendered.
			 *
			 * @method postRender
			 */
			postRender: function() {
				var self = this;
	
				self._super();
	
				self.resizeDragHelper = new DragHelper(this._id, {
					start: function() {
						self.fire('ResizeStart');
					},
	
					drag: function(e) {
						if (self.settings.direction != "both") {
							e.deltaX = 0;
						}
	
						self.fire('Resize', e);
					},
	
					stop: function() {
						self.fire('ResizeEnd');
					}
				});
			},
	
			remove: function() {
				if (this.resizeDragHelper) {
					this.resizeDragHelper.destroy();
				}
	
				return this._super();
			}
		});
	});
	
	// Included from: js/tinymce/classes/ui/SelectBox.js
	
	/**
	 * SelectBox.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Creates a new select box control.
	 *
	 * @-x-less SelectBox.less
	 * @class tinymce.ui.SelectBox
	 * @extends tinymce.ui.Widget
	 */
	define("tinymce/ui/SelectBox", [
		"tinymce/ui/Widget"
	], function(Widget) {
		"use strict";
	
		function createOptions(options) {
			var strOptions = '';
			if (options) {
				for (var i = 0; i < options.length; i++) {
					strOptions += '<option value="' + options[i] + '">' + options[i] + '</option>';
				}
			}
			return strOptions;
		}
	
		return Widget.extend({
			Defaults: {
				classes: "selectbox",
				role: "selectbox",
				options: []
			},
			/**
			 * Constructs a instance with the specified settings.
			 *
			 * @constructor
			 * @param {Object} settings Name/value object with settings.
			 * @setting {Array} options Array with options to add to the select box.
			 */
			init: function(settings) {
				var self = this;
	
				self._super(settings);
	
				if (self.settings.size) {
					self.size = self.settings.size;
				}
	
				if (self.settings.options) {
					self._options = self.settings.options;
				}
	
				self.on('keydown', function(e) {
					var rootControl;
	
					if (e.keyCode == 13) {
						e.preventDefault();
	
						// Find root control that we can do toJSON on
						self.parents().reverse().each(function(ctrl) {
							if (ctrl.toJSON) {
								rootControl = ctrl;
								return false;
							}
						});
	
						// Fire event on current text box with the serialized data of the whole form
						self.fire('submit', {data: rootControl.toJSON()});
					}
				});
			},
	
			/**
			 * Getter/setter function for the options state.
			 *
			 * @method options
			 * @param {Array} [state] State to be set.
			 * @return {Array|tinymce.ui.SelectBox} Array of string options.
			 */
			options: function(state) {
				if (!arguments.length) {
					return this.state.get('options');
				}
	
				this.state.set('options', state);
	
				return this;
			},
	
			renderHtml: function() {
				var self = this, options, size = '';
	
				options = createOptions(self._options);
	
				if (self.size) {
					size = ' size = "' + self.size + '"';
				}
	
				return (
					'<select id="' + self._id + '" class="' + self.classes + '"' + size + '>' +
						options +
					'</select>'
				);
			},
	
			bindStates: function() {
				var self = this;
	
				self.state.on('change:options', function(e) {
					self.getEl().innerHTML = createOptions(e.value);
				});
	
				return self._super();
			}
		});
	});
	
	// Included from: js/tinymce/classes/ui/Slider.js
	
	/**
	 * Slider.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Slider control.
	 *
	 * @-x-less Slider.less
	 * @class tinymce.ui.Slider
	 * @extends tinymce.ui.Widget
	 */
	define("tinymce/ui/Slider", [
		"tinymce/ui/Widget",
		"tinymce/ui/DragHelper",
		"tinymce/ui/DomUtils"
	], function(Widget, DragHelper, DomUtils) {
		"use strict";
	
		function constrain(value, minVal, maxVal) {
			if (value < minVal) {
				value = minVal;
			}
	
			if (value > maxVal) {
				value = maxVal;
			}
	
			return value;
		}
	
		function setAriaProp(el, name, value) {
			el.setAttribute('aria-' + name, value);
		}
	
		function updateSliderHandle(ctrl, value) {
			var maxHandlePos, shortSizeName, sizeName, stylePosName, styleValue, handleEl;
	
			if (ctrl.settings.orientation == "v") {
				stylePosName = "top";
				sizeName = "height";
				shortSizeName = "h";
			} else {
				stylePosName = "left";
				sizeName = "width";
				shortSizeName = "w";
			}
	
			handleEl = ctrl.getEl('handle');
			maxHandlePos = (ctrl.layoutRect()[shortSizeName] || 100) - DomUtils.getSize(handleEl)[sizeName];
	
			styleValue = (maxHandlePos * ((value - ctrl._minValue) / (ctrl._maxValue - ctrl._minValue))) + 'px';
			handleEl.style[stylePosName] = styleValue;
			handleEl.style.height = ctrl.layoutRect().h + 'px';
	
			setAriaProp(handleEl, 'valuenow', value);
			setAriaProp(handleEl, 'valuetext', '' + ctrl.settings.previewFilter(value));
			setAriaProp(handleEl, 'valuemin', ctrl._minValue);
			setAriaProp(handleEl, 'valuemax', ctrl._maxValue);
		}
	
		return Widget.extend({
			init: function(settings) {
				var self = this;
	
				if (!settings.previewFilter) {
					settings.previewFilter = function(value) {
						return Math.round(value * 100) / 100.0;
					};
				}
	
				self._super(settings);
				self.classes.add('slider');
	
				if (settings.orientation == "v") {
					self.classes.add('vertical');
				}
	
				self._minValue = settings.minValue || 0;
				self._maxValue = settings.maxValue || 100;
				self._initValue = self.state.get('value');
			},
	
			renderHtml: function() {
				var self = this, id = self._id, prefix = self.classPrefix;
	
				return (
					'<div id="' + id + '" class="' + self.classes + '">' +
						'<div id="' + id + '-handle" class="' + prefix + 'slider-handle" role="slider" tabindex="-1"></div>' +
					'</div>'
				);
			},
	
			reset: function() {
				this.value(this._initValue).repaint();
			},
	
			postRender: function() {
				var self = this, minValue, maxValue, screenCordName,
						stylePosName, sizeName, shortSizeName;
	
				function toFraction(min, max, val) {
					return (val + min) / (max - min);
				}
	
				function fromFraction(min, max, val) {
					return (val * (max - min)) - min;
				}
	
				function handleKeyboard(minValue, maxValue) {
					function alter(delta) {
						var value;
	
						value = self.value();
						value = fromFraction(minValue, maxValue, toFraction(minValue, maxValue, value) + (delta * 0.05));
						value = constrain(value, minValue, maxValue);
	
						self.value(value);
	
						self.fire('dragstart', {value: value});
						self.fire('drag', {value: value});
						self.fire('dragend', {value: value});
					}
	
					self.on('keydown', function(e) {
						switch (e.keyCode) {
							case 37:
							case 38:
								alter(-1);
								break;
	
							case 39:
							case 40:
								alter(1);
								break;
						}
					});
				}
	
				function handleDrag(minValue, maxValue, handleEl) {
					var startPos, startHandlePos, maxHandlePos, handlePos, value;
	
					self._dragHelper = new DragHelper(self._id, {
						handle: self._id + "-handle",
	
						start: function(e) {
							startPos = e[screenCordName];
							startHandlePos = parseInt(self.getEl('handle').style[stylePosName], 10);
							maxHandlePos = (self.layoutRect()[shortSizeName] || 100) - DomUtils.getSize(handleEl)[sizeName];
							self.fire('dragstart', {value: value});
						},
	
						drag: function(e) {
							var delta = e[screenCordName] - startPos;
	
							handlePos = constrain(startHandlePos + delta, 0, maxHandlePos);
							handleEl.style[stylePosName] = handlePos + 'px';
	
							value = minValue + (handlePos / maxHandlePos) * (maxValue - minValue);
							self.value(value);
	
							self.tooltip().text('' + self.settings.previewFilter(value)).show().moveRel(handleEl, 'bc tc');
	
							self.fire('drag', {value: value});
						},
	
						stop: function() {
							self.tooltip().hide();
							self.fire('dragend', {value: value});
						}
					});
				}
	
				minValue = self._minValue;
				maxValue = self._maxValue;
	
				if (self.settings.orientation == "v") {
					screenCordName = "screenY";
					stylePosName = "top";
					sizeName = "height";
					shortSizeName = "h";
				} else {
					screenCordName = "screenX";
					stylePosName = "left";
					sizeName = "width";
					shortSizeName = "w";
				}
	
				self._super();
	
				handleKeyboard(minValue, maxValue, self.getEl('handle'));
				handleDrag(minValue, maxValue, self.getEl('handle'));
			},
	
			repaint: function() {
				this._super();
				updateSliderHandle(this, this.value());
			},
	
			bindStates: function() {
				var self = this;
	
				self.state.on('change:value', function(e) {
					updateSliderHandle(self, e.value);
				});
	
				return self._super();
			}
		});
	});
	
	// Included from: js/tinymce/classes/ui/Spacer.js
	
	/**
	 * Spacer.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Creates a spacer. This control is used in flex layouts for example.
	 *
	 * @-x-less Spacer.less
	 * @class tinymce.ui.Spacer
	 * @extends tinymce.ui.Widget
	 */
	define("tinymce/ui/Spacer", [
		"tinymce/ui/Widget"
	], function(Widget) {
		"use strict";
	
		return Widget.extend({
			/**
			 * Renders the control as a HTML string.
			 *
			 * @method renderHtml
			 * @return {String} HTML representing the control.
			 */
			renderHtml: function() {
				var self = this;
	
				self.classes.add('spacer');
				self.canFocus = false;
	
				return '<div id="' + self._id + '" class="' + self.classes + '"></div>';
			}
		});
	});
	
	// Included from: js/tinymce/classes/ui/SplitButton.js
	
	/**
	 * SplitButton.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Creates a split button.
	 *
	 * @-x-less SplitButton.less
	 * @class tinymce.ui.SplitButton
	 * @extends tinymce.ui.Button
	 */
	define("tinymce/ui/SplitButton", [
		"tinymce/ui/MenuButton",
		"tinymce/ui/DomUtils",
		"tinymce/dom/DomQuery"
	], function(MenuButton, DomUtils, $) {
		return MenuButton.extend({
			Defaults: {
				classes: "widget btn splitbtn",
				role: "button"
			},
	
			/**
			 * Repaints the control after a layout operation.
			 *
			 * @method repaint
			 */
			repaint: function() {
				var self = this, elm = self.getEl(), rect = self.layoutRect(), mainButtonElm, menuButtonElm;
	
				self._super();
	
				mainButtonElm = elm.firstChild;
				menuButtonElm = elm.lastChild;
	
				$(mainButtonElm).css({
					width: rect.w - DomUtils.getSize(menuButtonElm).width,
					height: rect.h - 2
				});
	
				$(menuButtonElm).css({
					height: rect.h - 2
				});
	
				return self;
			},
	
			/**
			 * Sets the active menu state.
			 *
			 * @private
			 */
			activeMenu: function(state) {
				var self = this;
	
				$(self.getEl().lastChild).toggleClass(self.classPrefix + 'active', state);
			},
	
			/**
			 * Renders the control as a HTML string.
			 *
			 * @method renderHtml
			 * @return {String} HTML representing the control.
			 */
			renderHtml: function() {
				var self = this, id = self._id, prefix = self.classPrefix, image;
				var icon = self.state.get('icon'), text = self.state.get('text'),
					textHtml = '';
	
				image = self.settings.image;
				if (image) {
					icon = 'none';
	
					// Support for [high dpi, low dpi] image sources
					if (typeof image != "string") {
						image = window.getSelection ? image[0] : image[1];
					}
	
					image = ' style="background-image: url(\'' + image + '\')"';
				} else {
					image = '';
				}
	
				icon = self.settings.icon ? prefix + 'ico ' + prefix + 'i-' + icon : '';
	
				if (text) {
					self.classes.add('btn-has-text');
					textHtml = '<span class="' + prefix + 'txt">' + self.encode(text) + '</span>';
				}
	
				return (
					'<div id="' + id + '" class="' + self.classes + '" role="button" tabindex="-1">' +
						'<button type="button" hidefocus="1" tabindex="-1">' +
							(icon ? '<i class="' + icon + '"' + image + '></i>' : '') +
							textHtml +
						'</button>' +
						'<button type="button" class="' + prefix + 'open" hidefocus="1" tabindex="-1">' +
							//(icon ? '<i class="' + icon + '"></i>' : '') +
							(self._menuBtnText ? (icon ? '\u00a0' : '') + self._menuBtnText : '') +
							' <i class="' + prefix + 'caret"></i>' +
						'</button>' +
					'</div>'
				);
			},
	
			/**
			 * Called after the control has been rendered.
			 *
			 * @method postRender
			 */
			postRender: function() {
				var self = this, onClickHandler = self.settings.onclick;
	
				self.on('click', function(e) {
					var node = e.target;
	
					if (e.control == this) {
						// Find clicks that is on the main button
						while (node) {
							if ((e.aria && e.aria.key != 'down') || (node.nodeName == 'BUTTON' && node.className.indexOf('open') == -1)) {
								e.stopImmediatePropagation();
	
								if (onClickHandler) {
									onClickHandler.call(this, e);
								}
	
								return;
							}
	
							node = node.parentNode;
						}
					}
				});
	
				delete self.settings.onclick;
	
				return self._super();
			}
		});
	});
	
	// Included from: js/tinymce/classes/ui/StackLayout.js
	
	/**
	 * StackLayout.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This layout uses the browsers layout when the items are blocks.
	 *
	 * @-x-less StackLayout.less
	 * @class tinymce.ui.StackLayout
	 * @extends tinymce.ui.FlowLayout
	 */
	define("tinymce/ui/StackLayout", [
		"tinymce/ui/FlowLayout"
	], function(FlowLayout) {
		"use strict";
	
		return FlowLayout.extend({
			Defaults: {
				containerClass: 'stack-layout',
				controlClass: 'stack-layout-item',
				endClass: 'break'
			},
	
			isNative: function() {
				return true;
			}
		});
	});
	
	// Included from: js/tinymce/classes/ui/TabPanel.js
	
	/**
	 * TabPanel.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Creates a tab panel control.
	 *
	 * @-x-less TabPanel.less
	 * @class tinymce.ui.TabPanel
	 * @extends tinymce.ui.Panel
	 *
	 * @setting {Number} activeTab Active tab index.
	 */
	define("tinymce/ui/TabPanel", [
		"tinymce/ui/Panel",
		"tinymce/dom/DomQuery",
		"tinymce/ui/DomUtils"
	], function(Panel, $, DomUtils) {
		"use strict";
	
		return Panel.extend({
			Defaults: {
				layout: 'absolute',
				defaults: {
					type: 'panel'
				}
			},
	
			/**
			 * Activates the specified tab by index.
			 *
			 * @method activateTab
			 * @param {Number} idx Index of the tab to activate.
			 */
			activateTab: function(idx) {
				var activeTabElm;
	
				if (this.activeTabId) {
					activeTabElm = this.getEl(this.activeTabId);
					$(activeTabElm).removeClass(this.classPrefix + 'active');
					activeTabElm.setAttribute('aria-selected', "false");
				}
	
				this.activeTabId = 't' + idx;
	
				activeTabElm = this.getEl('t' + idx);
				activeTabElm.setAttribute('aria-selected', "true");
				$(activeTabElm).addClass(this.classPrefix + 'active');
	
				this.items()[idx].show().fire('showtab');
				this.reflow();
	
				this.items().each(function(item, i) {
					if (idx != i) {
						item.hide();
					}
				});
			},
	
			/**
			 * Renders the control as a HTML string.
			 *
			 * @method renderHtml
			 * @return {String} HTML representing the control.
			 */
			renderHtml: function() {
				var self = this, layout = self._layout, tabsHtml = '', prefix = self.classPrefix;
	
				self.preRender();
				layout.preRender(self);
	
				self.items().each(function(ctrl, i) {
					var id = self._id + '-t' + i;
	
					ctrl.aria('role', 'tabpanel');
					ctrl.aria('labelledby', id);
	
					tabsHtml += (
						'<div id="' + id + '" class="' + prefix + 'tab" ' +
							'unselectable="on" role="tab" aria-controls="' + ctrl._id + '" aria-selected="false" tabIndex="-1">' +
							self.encode(ctrl.settings.title) +
						'</div>'
					);
				});
	
				return (
					'<div id="' + self._id + '" class="' + self.classes + '" hidefocus="1" tabindex="-1">' +
						'<div id="' + self._id + '-head" class="' + prefix + 'tabs" role="tablist">' +
							tabsHtml +
						'</div>' +
						'<div id="' + self._id + '-body" class="' + self.bodyClasses + '">' +
							layout.renderHtml(self) +
						'</div>' +
					'</div>'
				);
			},
	
			/**
			 * Called after the control has been rendered.
			 *
			 * @method postRender
			 */
			postRender: function() {
				var self = this;
	
				self._super();
	
				self.settings.activeTab = self.settings.activeTab || 0;
				self.activateTab(self.settings.activeTab);
	
				this.on('click', function(e) {
					var targetParent = e.target.parentNode;
	
					if (targetParent && targetParent.id == self._id + '-head') {
						var i = targetParent.childNodes.length;
	
						while (i--) {
							if (targetParent.childNodes[i] == e.target) {
								self.activateTab(i);
							}
						}
					}
				});
			},
	
			/**
			 * Initializes the current controls layout rect.
			 * This will be executed by the layout managers to determine the
			 * default minWidth/minHeight etc.
			 *
			 * @method initLayoutRect
			 * @return {Object} Layout rect instance.
			 */
			initLayoutRect: function() {
				var self = this, rect, minW, minH;
	
				minW = DomUtils.getSize(self.getEl('head')).width;
				minW = minW < 0 ? 0 : minW;
				minH = 0;
	
				self.items().each(function(item) {
					minW = Math.max(minW, item.layoutRect().minW);
					minH = Math.max(minH, item.layoutRect().minH);
				});
	
				self.items().each(function(ctrl) {
					ctrl.settings.x = 0;
					ctrl.settings.y = 0;
					ctrl.settings.w = minW;
					ctrl.settings.h = minH;
	
					ctrl.layoutRect({
						x: 0,
						y: 0,
						w: minW,
						h: minH
					});
				});
	
				var headH = DomUtils.getSize(self.getEl('head')).height;
	
				self.settings.minWidth = minW;
				self.settings.minHeight = minH + headH;
	
				rect = self._super();
				rect.deltaH += headH;
				rect.innerH = rect.h - rect.deltaH;
	
				return rect;
			}
		});
	});
	
	// Included from: js/tinymce/classes/ui/TextBox.js
	
	/**
	 * TextBox.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Creates a new textbox.
	 *
	 * @-x-less TextBox.less
	 * @class tinymce.ui.TextBox
	 * @extends tinymce.ui.Widget
	 */
	define("tinymce/ui/TextBox", [
		"tinymce/ui/Widget",
		"tinymce/util/Tools",
		"tinymce/ui/DomUtils"
	], function(Widget, Tools, DomUtils) {
		return Widget.extend({
			/**
			 * Constructs a instance with the specified settings.
			 *
			 * @constructor
			 * @param {Object} settings Name/value object with settings.
			 * @setting {Boolean} multiline True if the textbox is a multiline control.
			 * @setting {Number} maxLength Max length for the textbox.
			 * @setting {Number} size Size of the textbox in characters.
			 */
			init: function(settings) {
				var self = this;
	
				self._super(settings);
	
				self.classes.add('textbox');
	
				if (settings.multiline) {
					self.classes.add('multiline');
				} else {
					self.on('keydown', function(e) {
						var rootControl;
	
						if (e.keyCode == 13) {
							e.preventDefault();
	
							// Find root control that we can do toJSON on
							self.parents().reverse().each(function(ctrl) {
								if (ctrl.toJSON) {
									rootControl = ctrl;
									return false;
								}
							});
	
							// Fire event on current text box with the serialized data of the whole form
							self.fire('submit', {data: rootControl.toJSON()});
						}
					});
	
					self.on('keyup', function(e) {
						self.state.set('value', e.target.value);
					});
				}
			},
	
			/**
			 * Repaints the control after a layout operation.
			 *
			 * @method repaint
			 */
			repaint: function() {
				var self = this, style, rect, borderBox, borderW, borderH = 0, lastRepaintRect;
	
				style = self.getEl().style;
				rect = self._layoutRect;
				lastRepaintRect = self._lastRepaintRect || {};
	
				// Detect old IE 7+8 add lineHeight to align caret vertically in the middle
				var doc = document;
				if (!self.settings.multiline && doc.all && (!doc.documentMode || doc.documentMode <= 8)) {
					style.lineHeight = (rect.h - borderH) + 'px';
				}
	
				borderBox = self.borderBox;
				borderW = borderBox.left + borderBox.right + 8;
				borderH = borderBox.top + borderBox.bottom + (self.settings.multiline ? 8 : 0);
	
				if (rect.x !== lastRepaintRect.x) {
					style.left = rect.x + 'px';
					lastRepaintRect.x = rect.x;
				}
	
				if (rect.y !== lastRepaintRect.y) {
					style.top = rect.y + 'px';
					lastRepaintRect.y = rect.y;
				}
	
				if (rect.w !== lastRepaintRect.w) {
					style.width = (rect.w - borderW) + 'px';
					lastRepaintRect.w = rect.w;
				}
	
				if (rect.h !== lastRepaintRect.h) {
					style.height = (rect.h - borderH) + 'px';
					lastRepaintRect.h = rect.h;
				}
	
				self._lastRepaintRect = lastRepaintRect;
				self.fire('repaint', {}, false);
	
				return self;
			},
	
			/**
			 * Renders the control as a HTML string.
			 *
			 * @method renderHtml
			 * @return {String} HTML representing the control.
			 */
			renderHtml: function() {
				var self = this, settings = self.settings, attrs, elm;
	
				attrs = {
					id: self._id,
					hidefocus: '1'
				};
	
				Tools.each([
					'rows',	'spellcheck',	'maxLength', 'size', 'readonly', 'min',
					'max', 'step', 'list', 'pattern', 'placeholder', 'required', 'multiple'
				], function(name) {
					attrs[name] = settings[name];
				});
	
				if (self.disabled()) {
					attrs.disabled = 'disabled';
				}
	
				if (settings.subtype) {
					attrs.type = settings.subtype;
				}
	
				elm = DomUtils.create(settings.multiline ? 'textarea' : 'input', attrs);
				elm.value = self.state.get('value');
				elm.className = self.classes;
	
				return elm.outerHTML;
			},
	
			value: function(value) {
				if (arguments.length) {
					this.state.set('value', value);
					return this;
				}
	
				// Make sure the real state is in sync
				if (this.state.get('rendered')) {
					this.state.set('value', this.getEl().value);
				}
	
				return this.state.get('value');
			},
	
			/**
			 * Called after the control has been rendered.
			 *
			 * @method postRender
			 */
			postRender: function() {
				var self = this;
	
				self.getEl().value = self.state.get('value');
				self._super();
	
				self.$el.on('change', function(e) {
					self.state.set('value', e.target.value);
					self.fire('change', e);
				});
			},
	
			bindStates: function() {
				var self = this;
	
				self.state.on('change:value', function(e) {
					if (self.getEl().value != e.value) {
						self.getEl().value = e.value;
					}
				});
	
				self.state.on('change:disabled', function(e) {
					self.getEl().disabled = e.value;
				});
	
				return self._super();
			},
	
			remove: function() {
				this.$el.off();
				this._super();
			}
		});
	});
	
	// Included from: js/tinymce/classes/Register.js
	
	/**
	 * Register.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This registers tinymce in common module loaders.
	 *
	 * @private
	 * @class tinymce.Register
	 */
	define("tinymce/Register", [
	], function() {
		/*eslint consistent-this: 0 */
		var context = this || window;
	
		var tinymce = function() {
			return context.tinymce;
		};
	
		if (typeof context.define === "function") {
			// Bolt
			if (!context.define.amd) {
				context.define("ephox/tinymce", [], tinymce);
			}
		}
	
		if (true) {
			/* global module */
			module.exports = window.tinymce;
		}
	
		return {};
	});
	
	expose(["tinymce/geom/Rect","tinymce/util/Promise","tinymce/util/Delay","tinymce/Env","tinymce/dom/EventUtils","tinymce/dom/Sizzle","tinymce/util/Tools","tinymce/dom/DomQuery","tinymce/html/Styles","tinymce/dom/TreeWalker","tinymce/html/Entities","tinymce/dom/DOMUtils","tinymce/dom/ScriptLoader","tinymce/AddOnManager","tinymce/dom/RangeUtils","tinymce/html/Node","tinymce/html/Schema","tinymce/html/SaxParser","tinymce/html/DomParser","tinymce/html/Writer","tinymce/html/Serializer","tinymce/dom/Serializer","tinymce/util/VK","tinymce/dom/ControlSelection","tinymce/dom/BookmarkManager","tinymce/dom/Selection","tinymce/Formatter","tinymce/UndoManager","tinymce/EditorCommands","tinymce/util/URI","tinymce/util/Class","tinymce/util/EventDispatcher","tinymce/util/Observable","tinymce/ui/Selector","tinymce/ui/Collection","tinymce/ui/ReflowQueue","tinymce/ui/Control","tinymce/ui/Factory","tinymce/ui/KeyboardNavigation","tinymce/ui/Container","tinymce/ui/DragHelper","tinymce/ui/Scrollable","tinymce/ui/Panel","tinymce/ui/Movable","tinymce/ui/Resizable","tinymce/ui/FloatPanel","tinymce/ui/Window","tinymce/ui/MessageBox","tinymce/WindowManager","tinymce/ui/Tooltip","tinymce/ui/Widget","tinymce/ui/Progress","tinymce/ui/Notification","tinymce/NotificationManager","tinymce/EditorObservable","tinymce/Shortcuts","tinymce/Editor","tinymce/util/I18n","tinymce/FocusManager","tinymce/EditorManager","tinymce/util/XHR","tinymce/util/JSON","tinymce/util/JSONRequest","tinymce/util/JSONP","tinymce/util/LocalStorage","tinymce/Compat","tinymce/ui/Layout","tinymce/ui/AbsoluteLayout","tinymce/ui/Button","tinymce/ui/ButtonGroup","tinymce/ui/Checkbox","tinymce/ui/ComboBox","tinymce/ui/ColorBox","tinymce/ui/PanelButton","tinymce/ui/ColorButton","tinymce/util/Color","tinymce/ui/ColorPicker","tinymce/ui/Path","tinymce/ui/ElementPath","tinymce/ui/FormItem","tinymce/ui/Form","tinymce/ui/FieldSet","tinymce/ui/FilePicker","tinymce/ui/FitLayout","tinymce/ui/FlexLayout","tinymce/ui/FlowLayout","tinymce/ui/FormatControls","tinymce/ui/GridLayout","tinymce/ui/Iframe","tinymce/ui/InfoBox","tinymce/ui/Label","tinymce/ui/Toolbar","tinymce/ui/MenuBar","tinymce/ui/MenuButton","tinymce/ui/MenuItem","tinymce/ui/Throbber","tinymce/ui/Menu","tinymce/ui/ListBox","tinymce/ui/Radio","tinymce/ui/ResizeHandle","tinymce/ui/SelectBox","tinymce/ui/Slider","tinymce/ui/Spacer","tinymce/ui/SplitButton","tinymce/ui/StackLayout","tinymce/ui/TabPanel","tinymce/ui/TextBox"]);
	})(this);
	
	/*** EXPORTS FROM exports-loader ***/
	module.exports = window.tinymce;
	}.call(window));
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(231).setImmediate))

/***/ },
/* 231 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(setImmediate, clearImmediate) {var nextTick = __webpack_require__(208).nextTick;
	var apply = Function.prototype.apply;
	var slice = Array.prototype.slice;
	var immediateIds = {};
	var nextImmediateId = 0;
	
	// DOM APIs, for completeness
	
	exports.setTimeout = function() {
	  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
	};
	exports.setInterval = function() {
	  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
	};
	exports.clearTimeout =
	exports.clearInterval = function(timeout) { timeout.close(); };
	
	function Timeout(id, clearFn) {
	  this._id = id;
	  this._clearFn = clearFn;
	}
	Timeout.prototype.unref = Timeout.prototype.ref = function() {};
	Timeout.prototype.close = function() {
	  this._clearFn.call(window, this._id);
	};
	
	// Does not start the time, just sets up the members needed.
	exports.enroll = function(item, msecs) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = msecs;
	};
	
	exports.unenroll = function(item) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = -1;
	};
	
	exports._unrefActive = exports.active = function(item) {
	  clearTimeout(item._idleTimeoutId);
	
	  var msecs = item._idleTimeout;
	  if (msecs >= 0) {
	    item._idleTimeoutId = setTimeout(function onTimeout() {
	      if (item._onTimeout)
	        item._onTimeout();
	    }, msecs);
	  }
	};
	
	// That's not how node.js implements it but the exposed api is the same.
	exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
	  var id = nextImmediateId++;
	  var args = arguments.length < 2 ? false : slice.call(arguments, 1);
	
	  immediateIds[id] = true;
	
	  nextTick(function onNextTick() {
	    if (immediateIds[id]) {
	      // fn.call() is faster so we optimize for the common use-case
	      // @see http://jsperf.com/call-apply-segu
	      if (args) {
	        fn.apply(null, args);
	      } else {
	        fn.call(null);
	      }
	      // Prevent ids from leaking
	      exports.clearImmediate(id);
	    }
	  });
	
	  return id;
	};
	
	exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
	  delete immediateIds[id];
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(231).setImmediate, __webpack_require__(231).clearImmediate))

/***/ },
/* 232 */
/***/ function(module, exports) {

	(function () {
	
	var defs = {}; // id -> {dependencies, definition, instance (possibly undefined)}
	
	// Used when there is no 'main' module.
	// The name is probably (hopefully) unique so minification removes for releases.
	var register_3795 = function (id) {
	  var module = dem(id);
	  var fragments = id.split('.');
	  var target = Function('return this;')();
	  for (var i = 0; i < fragments.length - 1; ++i) {
	    if (target[fragments[i]] === undefined)
	      target[fragments[i]] = {};
	    target = target[fragments[i]];
	  }
	  target[fragments[fragments.length - 1]] = module;
	};
	
	var instantiate = function (id) {
	  var actual = defs[id];
	  var dependencies = actual.deps;
	  var definition = actual.defn;
	  var len = dependencies.length;
	  var instances = new Array(len);
	  for (var i = 0; i < len; ++i)
	    instances[i] = dem(dependencies[i]);
	  var defResult = definition.apply(null, instances);
	  if (defResult === undefined)
	     throw 'module [' + id + '] returned undefined';
	  actual.instance = defResult;
	};
	
	var def = function (id, dependencies, definition) {
	  if (typeof id !== 'string')
	    throw 'module id must be a string';
	  else if (dependencies === undefined)
	    throw 'no dependencies for ' + id;
	  else if (definition === undefined)
	    throw 'no definition function for ' + id;
	  defs[id] = {
	    deps: dependencies,
	    defn: definition,
	    instance: undefined
	  };
	};
	
	var dem = function (id) {
	  var actual = defs[id];
	  if (actual === undefined)
	    throw 'module [' + id + '] was undefined';
	  else if (actual.instance === undefined)
	    instantiate(id);
	  return actual.instance;
	};
	
	var req = function (ids, callback) {
	  var len = ids.length;
	  var instances = new Array(len);
	  for (var i = 0; i < len; ++i)
	    instances.push(dem(ids[i]));
	  callback.apply(null, callback);
	};
	
	var ephox = {};
	
	ephox.bolt = {
	  module: {
	    api: {
	      define: def,
	      require: req,
	      demand: dem
	    }
	  }
	};
	
	var define = def;
	var require = req;
	var demand = dem;
	// this helps with minificiation when using a lot of global references
	var defineGlobal = function (id, ref) {
	  define(id, [], function () { return ref; });
	};
	/*jsc
	["tinymce.modern.Theme","global!tinymce.Env","global!tinymce.EditorManager","global!tinymce.ThemeManager","tinymce.modern.modes.Iframe","tinymce.modern.modes.Inline","tinymce.modern.ui.Resize","tinymce.modern.ui.ProgressState","global!tinymce.util.Tools","global!tinymce.ui.Factory","global!tinymce.DOM","tinymce.modern.ui.Toolbar","tinymce.modern.ui.Menubar","tinymce.modern.ui.ContextToolbars","tinymce.modern.ui.A11y","tinymce.modern.ui.Sidebar","tinymce.modern.ui.SkinLoaded","global!tinymce.ui.FloatPanel","global!tinymce.ui.Throbber","global!tinymce.util.Delay","global!tinymce.geom.Rect"]
	jsc*/
	defineGlobal("global!tinymce.Env", tinymce.Env);
	defineGlobal("global!tinymce.EditorManager", tinymce.EditorManager);
	defineGlobal("global!tinymce.ThemeManager", tinymce.ThemeManager);
	defineGlobal("global!tinymce.util.Tools", tinymce.util.Tools);
	defineGlobal("global!tinymce.ui.Factory", tinymce.ui.Factory);
	defineGlobal("global!tinymce.DOM", tinymce.DOM);
	/**
	 * Toolbar.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2016 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	define('tinymce.modern.ui.Toolbar', [
		'global!tinymce.util.Tools',
		'global!tinymce.ui.Factory'
	], function (Tools, Factory) {
		var defaultToolbar = "undo redo | styleselect | bold italic | alignleft aligncenter alignright alignjustify | " +
			"bullist numlist outdent indent | link image";
	
		var createToolbar = function (editor, items, size) {
			var toolbarItems = [], buttonGroup;
	
			if (!items) {
				return;
			}
	
			Tools.each(items.split(/[ ,]/), function(item) {
				var itemName;
	
				var bindSelectorChanged = function () {
					var selection = editor.selection;
	
					if (item.settings.stateSelector) {
						selection.selectorChanged(item.settings.stateSelector, function(state) {
							item.active(state);
						}, true);
					}
	
					if (item.settings.disabledStateSelector) {
						selection.selectorChanged(item.settings.disabledStateSelector, function(state) {
							item.disabled(state);
						});
					}
				};
	
				if (item == "|") {
					buttonGroup = null;
				} else {
					if (Factory.has(item)) {
						item = {type: item, size: size};
						toolbarItems.push(item);
						buttonGroup = null;
					} else {
						if (!buttonGroup) {
							buttonGroup = {type: 'buttongroup', items: []};
							toolbarItems.push(buttonGroup);
						}
	
						if (editor.buttons[item]) {
							// TODO: Move control creation to some UI class
							itemName = item;
							item = editor.buttons[itemName];
	
							if (typeof item == "function") {
								item = item();
							}
	
							item.type = item.type || 'button';
							item.size = size;
	
							item = Factory.create(item);
							buttonGroup.items.push(item);
	
							if (editor.initialized) {
								bindSelectorChanged();
							} else {
								editor.on('init', bindSelectorChanged);
							}
						}
					}
				}
			});
	
			return {
				type: 'toolbar',
				layout: 'flow',
				items: toolbarItems
			};
		};
	
		/**
		 * Creates the toolbars from config and returns a toolbar array.
		 *
		 * @param {String} size Optional toolbar item size.
		 * @return {Array} Array with toolbars.
		 */
		var createToolbars = function (editor, size) {
			var toolbars = [], settings = editor.settings;
	
			var addToolbar = function (items) {
				if (items) {
					toolbars.push(createToolbar(editor, items, size));
					return true;
				}
			};
	
			// Convert toolbar array to multiple options
			if (Tools.isArray(settings.toolbar)) {
				// Empty toolbar array is the same as a disabled toolbar
				if (settings.toolbar.length === 0) {
					return;
				}
	
				Tools.each(settings.toolbar, function(toolbar, i) {
					settings["toolbar" + (i + 1)] = toolbar;
				});
	
				delete settings.toolbar;
			}
	
			// Generate toolbar<n>
			for (var i = 1; i < 10; i++) {
				if (!addToolbar(settings["toolbar" + i])) {
					break;
				}
			}
	
			// Generate toolbar or default toolbar unless it's disabled
			if (!toolbars.length && settings.toolbar !== false) {
				addToolbar(settings.toolbar || defaultToolbar);
			}
	
			if (toolbars.length) {
				return {
					type: 'panel',
					layout: 'stack',
					classes: "toolbar-grp",
					ariaRoot: true,
					ariaRemember: true,
					items: toolbars
				};
			}
		};
	
		return {
			createToolbar: createToolbar,
			createToolbars: createToolbars
		};
	});
	
	/**
	 * Menubar.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2016 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	define('tinymce.modern.ui.Menubar', [
		'global!tinymce.util.Tools'
	], function (Tools) {
		var defaultMenus = {
			file: {title: 'File', items: 'newdocument'},
			edit: {title: 'Edit', items: 'undo redo | cut copy paste pastetext | selectall'},
			insert: {title: 'Insert', items: '|'},
			view: {title: 'View', items: 'visualaid |'},
			format: {title: 'Format', items: 'bold italic underline strikethrough superscript subscript | formats | removeformat'},
			table: {title: 'Table'},
			tools: {title: 'Tools'}
		};
	
		var createMenuItem = function (menuItems, name) {
			var menuItem;
	
			if (name == '|') {
				return {text: '|'};
			}
	
			menuItem = menuItems[name];
	
			return menuItem;
		};
	
		var createMenu = function (editorMenuItems, settings, context) {
			var menuButton, menu, menuItems, isUserDefined, removedMenuItems;
	
			removedMenuItems = Tools.makeMap((settings.removed_menuitems || '').split(/[ ,]/));
	
			// User defined menu
			if (settings.menu) {
				menu = settings.menu[context];
				isUserDefined = true;
			} else {
				menu = defaultMenus[context];
			}
	
			if (menu) {
				menuButton = {text: menu.title};
				menuItems = [];
	
				// Default/user defined items
				Tools.each((menu.items || '').split(/[ ,]/), function(item) {
					var menuItem = createMenuItem(editorMenuItems, item);
	
					if (menuItem && !removedMenuItems[item]) {
						menuItems.push(createMenuItem(editorMenuItems, item));
					}
				});
	
				// Added though context
				if (!isUserDefined) {
					Tools.each(editorMenuItems, function(menuItem) {
						if (menuItem.context == context) {
							if (menuItem.separator == 'before') {
								menuItems.push({text: '|'});
							}
	
							if (menuItem.prependToContext) {
								menuItems.unshift(menuItem);
							} else {
								menuItems.push(menuItem);
							}
	
							if (menuItem.separator == 'after') {
								menuItems.push({text: '|'});
							}
						}
					});
				}
	
				for (var i = 0; i < menuItems.length; i++) {
					if (menuItems[i].text == '|') {
						if (i === 0 || i == menuItems.length - 1) {
							menuItems.splice(i, 1);
						}
					}
				}
	
				menuButton.menu = menuItems;
	
				if (!menuButton.menu.length) {
					return null;
				}
			}
	
			return menuButton;
		};
	
		var createMenuButtons = function (editor) {
			var name, menuButtons = [], settings = editor.settings;
	
			var defaultMenuBar = [];
			if (settings.menu) {
				for (name in settings.menu) {
					defaultMenuBar.push(name);
				}
			} else {
				for (name in defaultMenus) {
					defaultMenuBar.push(name);
				}
			}
	
			var enabledMenuNames = typeof settings.menubar == "string" ? settings.menubar.split(/[ ,]/) : defaultMenuBar;
			for (var i = 0; i < enabledMenuNames.length; i++) {
				var menu = enabledMenuNames[i];
				menu = createMenu(editor.menuItems, editor.settings, menu);
	
				if (menu) {
					menuButtons.push(menu);
				}
			}
	
			return menuButtons;
		};
	
		return {
			createMenuButtons: createMenuButtons
		};
	});
	
	defineGlobal("global!tinymce.util.Delay", tinymce.util.Delay);
	defineGlobal("global!tinymce.geom.Rect", tinymce.geom.Rect);
	/**
	 * ContextToolbars.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2016 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	define('tinymce.modern.ui.ContextToolbars', [
		'global!tinymce.DOM',
		'global!tinymce.util.Tools',
		'global!tinymce.util.Delay',
		'tinymce.modern.ui.Toolbar',
		'global!tinymce.ui.Factory',
		'global!tinymce.geom.Rect'
	], function (DOM, Tools, Delay, Toolbar, Factory, Rect) {
		var toClientRect = function (geomRect) {
			return {
				left: geomRect.x,
				top: geomRect.y,
				width: geomRect.w,
				height: geomRect.h,
				right: geomRect.x + geomRect.w,
				bottom: geomRect.y + geomRect.h
			};
		};
	
		var hideAllFloatingPanels = function (editor) {
			Tools.each(editor.contextToolbars, function(toolbar) {
				if (toolbar.panel) {
					toolbar.panel.hide();
				}
			});
		};
	
		var movePanelTo = function (panel, pos) {
			panel.moveTo(pos.left, pos.top);
		};
	
		var togglePositionClass = function (panel, relPos, predicate) {
			relPos = relPos ? relPos.substr(0, 2) : '';
	
			Tools.each({
				t: 'down',
				b: 'up'
			}, function(cls, pos) {
				panel.classes.toggle('arrow-' + cls, predicate(pos, relPos.substr(0, 1)));
			});
	
			Tools.each({
				l: 'left',
				r: 'right'
			}, function(cls, pos) {
				panel.classes.toggle('arrow-' + cls, predicate(pos, relPos.substr(1, 1)));
			});
		};
	
		var userConstrain = function (handler, x, y, elementRect, contentAreaRect, panelRect) {
			panelRect = toClientRect({x: x, y: y, w: panelRect.w, h: panelRect.h});
	
			if (handler) {
				panelRect = handler({
					elementRect: toClientRect(elementRect),
					contentAreaRect: toClientRect(contentAreaRect),
					panelRect: panelRect
				});
			}
	
			return panelRect;
		};
	
		var addContextualToolbars = function (editor) {
			var scrollContainer, settings = editor.settings;
	
			var getContextToolbars = function () {
				return editor.contextToolbars || [];
			};
	
			var getElementRect = function (elm) {
				var pos, targetRect, root;
	
				pos = DOM.getPos(editor.getContentAreaContainer());
				targetRect = editor.dom.getRect(elm);
				root = editor.dom.getRoot();
	
				// Adjust targetPos for scrolling in the editor
				if (root.nodeName === 'BODY') {
					targetRect.x -= root.ownerDocument.documentElement.scrollLeft || root.scrollLeft;
					targetRect.y -= root.ownerDocument.documentElement.scrollTop || root.scrollTop;
				}
	
				targetRect.x += pos.x;
				targetRect.y += pos.y;
	
				return targetRect;
			};
	
			var reposition = function (match, shouldShow) {
				var relPos, panelRect, elementRect, contentAreaRect, panel, relRect, testPositions, smallElementWidthThreshold;
				var handler = settings.inline_toolbar_position_handler;
	
				if (editor.removed) {
					return;
				}
	
				if (!match || !match.toolbar.panel) {
					hideAllFloatingPanels(editor);
					return;
				}
	
				testPositions = [
					'bc-tc', 'tc-bc',
					'tl-bl', 'bl-tl',
					'tr-br', 'br-tr'
				];
	
				panel = match.toolbar.panel;
	
				// Only show the panel on some events not for example nodeChange since that fires when context menu is opened
				if (shouldShow) {
					panel.show();
				}
	
				elementRect = getElementRect(match.element);
				panelRect = DOM.getRect(panel.getEl());
				contentAreaRect = DOM.getRect(editor.getContentAreaContainer() || editor.getBody());
				smallElementWidthThreshold = 25;
	
				if (DOM.getStyle(match.element, 'display', true) !== 'inline') {
					// We need to use these instead of the rect values since the style
					// size properites might not be the same as the real size for a table
					elementRect.w = match.element.clientWidth;
					elementRect.h = match.element.clientHeight;
				}
	
				if (!editor.inline) {
					contentAreaRect.w = editor.getDoc().documentElement.offsetWidth;
				}
	
				// Inflate the elementRect so it doesn't get placed above resize handles
				if (editor.selection.controlSelection.isResizable(match.element) && elementRect.w < smallElementWidthThreshold) {
					elementRect = Rect.inflate(elementRect, 0, 8);
				}
	
				relPos = Rect.findBestRelativePosition(panelRect, elementRect, contentAreaRect, testPositions);
				elementRect = Rect.clamp(elementRect, contentAreaRect);
	
				if (relPos) {
					relRect = Rect.relativePosition(panelRect, elementRect, relPos);
					movePanelTo(panel, userConstrain(handler, relRect.x, relRect.y, elementRect, contentAreaRect, panelRect));
				} else {
					// Allow overflow below the editor to avoid placing toolbars ontop of tables
					contentAreaRect.h += panelRect.h;
	
					elementRect = Rect.intersect(contentAreaRect, elementRect);
					if (elementRect) {
						relPos = Rect.findBestRelativePosition(panelRect, elementRect, contentAreaRect, [
							'bc-tc', 'bl-tl', 'br-tr'
						]);
	
						if (relPos) {
							relRect = Rect.relativePosition(panelRect, elementRect, relPos);
							movePanelTo(panel, userConstrain(handler, relRect.x, relRect.y, elementRect, contentAreaRect, panelRect));
						} else {
							movePanelTo(panel, userConstrain(handler, elementRect.x, elementRect.y, elementRect, contentAreaRect, panelRect));
						}
					} else {
						panel.hide();
					}
				}
	
				togglePositionClass(panel, relPos, function(pos1, pos2) {
					return pos1 === pos2;
				});
	
				//drawRect(contentAreaRect, 'blue');
				//drawRect(elementRect, 'red');
				//drawRect(panelRect, 'green');
			};
	
			var repositionHandler = function (show) {
				return function () {
					var execute = function () {
						if (editor.selection) {
							reposition(findFrontMostMatch(editor.selection.getNode()), show);
						}
					};
	
					Delay.requestAnimationFrame(execute);
				};
			};
	
			var bindScrollEvent = function () {
				if (!scrollContainer) {
					scrollContainer = editor.selection.getScrollContainer() || editor.getWin();
					DOM.bind(scrollContainer, 'scroll', repositionHandler(true));
	
					editor.on('remove', function() {
						DOM.unbind(scrollContainer, 'scroll');
					});
				}
			};
	
			var showContextToolbar = function (match) {
				var panel;
	
				if (match.toolbar.panel) {
					match.toolbar.panel.show();
					reposition(match);
					return;
				}
	
				bindScrollEvent();
	
				panel = Factory.create({
					type: 'floatpanel',
					role: 'dialog',
					classes: 'tinymce tinymce-inline arrow',
					ariaLabel: 'Inline toolbar',
					layout: 'flex',
					direction: 'column',
					align: 'stretch',
					autohide: false,
					autofix: true,
					fixed: true,
					border: 1,
					items: Toolbar.createToolbar(editor, match.toolbar.items),
					oncancel: function() {
						editor.focus();
					}
				});
	
				match.toolbar.panel = panel;
				panel.renderTo(document.body).reflow();
				reposition(match);
			};
	
			var hideAllContextToolbars = function () {
				Tools.each(getContextToolbars(), function(toolbar) {
					if (toolbar.panel) {
						toolbar.panel.hide();
					}
				});
			};
	
			var findFrontMostMatch = function (targetElm) {
				var i, y, parentsAndSelf, toolbars = getContextToolbars();
	
				parentsAndSelf = editor.$(targetElm).parents().add(targetElm);
				for (i = parentsAndSelf.length - 1; i >= 0; i--) {
					for (y = toolbars.length - 1; y >= 0; y--) {
						if (toolbars[y].predicate(parentsAndSelf[i])) {
							return {
								toolbar: toolbars[y],
								element: parentsAndSelf[i]
							};
						}
					}
				}
	
				return null;
			};
	
			editor.on('click keyup setContent ObjectResized', function(e) {
				// Only act on partial inserts
				if (e.type === 'setcontent' && !e.selection) {
					return;
				}
	
				// Needs to be delayed to avoid Chrome img focus out bug
				Delay.setEditorTimeout(editor, function() {
					var match;
	
					match = findFrontMostMatch(editor.selection.getNode());
					if (match) {
						hideAllContextToolbars();
						showContextToolbar(match);
					} else {
						hideAllContextToolbars();
					}
				});
			});
	
			editor.on('blur hide contextmenu', hideAllContextToolbars);
	
			editor.on('ObjectResizeStart', function() {
				var match = findFrontMostMatch(editor.selection.getNode());
	
				if (match && match.toolbar.panel) {
					match.toolbar.panel.hide();
				}
			});
	
			editor.on('ResizeEditor ResizeWindow', repositionHandler(true));
			editor.on('nodeChange', repositionHandler(false));
	
			editor.on('remove', function() {
				Tools.each(getContextToolbars(), function(toolbar) {
					if (toolbar.panel) {
						toolbar.panel.remove();
					}
				});
	
				editor.contextToolbars = {};
			});
	
			editor.shortcuts.add('ctrl+shift+e > ctrl+shift+p', '', function() {
				var match = findFrontMostMatch(editor.selection.getNode());
				if (match && match.toolbar.panel) {
					match.toolbar.panel.items()[0].focus();
				}
			});
		};
	
		return {
			addContextualToolbars: addContextualToolbars
		};
	});
	
	/**
	 * A11y.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2016 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	define('tinymce.modern.ui.A11y', [
	], function () {
		var focus = function (panel, type) {
			return function () {
				var item = panel.find(type)[0];
	
				if (item) {
					item.focus(true);
				}
			};
		};
	
		var addKeys = function (editor, panel) {
			editor.shortcuts.add('Alt+F9', '', focus(panel, 'menubar'));
			editor.shortcuts.add('Alt+F10,F10', '', focus(panel, 'toolbar'));
			editor.shortcuts.add('Alt+F11', '', focus(panel, 'elementpath'));
			panel.on('cancel', function() {
				editor.focus();
			});
		};
	
		return {
			addKeys: addKeys
		};
	});
	
	/**
	 * Sidebar.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2016 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	define('tinymce.modern.ui.Sidebar', [
		'global!tinymce.util.Tools',
		'global!tinymce.ui.Factory',
		'global!tinymce.Env'
	], function (Tools, Factory, Env) {
		var api = function (elm) {
			return {
				element: function () {
					return elm;
				}
			};
		};
	
		var trigger = function (sidebar, panel, callbackName) {
			var callback = sidebar.settings[callbackName];
			if (callback) {
				callback(api(panel.getEl('body')));
			}
		};
	
		var hidePanels = function (name, container, sidebars) {
			Tools.each(sidebars, function (sidebar) {
				var panel = container.items().filter('#' + sidebar.name)[0];
	
				if (panel && panel.visible() && sidebar.name !== name) {
					trigger(sidebar, panel, 'onhide');
					panel.visible(false);
				}
			});
		};
	
		var deactivateButtons = function (toolbar) {
			toolbar.items().each(function (ctrl) {
				ctrl.active(false);
			});
		};
	
		var findSidebar = function (sidebars, name) {
			return Tools.grep(sidebars, function (sidebar) {
				return sidebar.name === name;
			})[0];
		};
	
		var showPanel = function (editor, name, sidebars) {
			return function (e) {
				var btnCtrl = e.control;
				var container = btnCtrl.parents().filter('panel')[0];
				var panel = container.find('#' + name)[0];
				var sidebar = findSidebar(sidebars, name);
	
				hidePanels(name, container, sidebars);
				deactivateButtons(btnCtrl.parent());
	
				if (panel && panel.visible()) {
					trigger(sidebar, panel, 'onhide');
					panel.hide();
					btnCtrl.active(false);
				} else {
					if (panel) {
						panel.show();
						trigger(sidebar, panel, 'onshow');
					} else {
						panel = Factory.create({
							type: 'container',
							name: name,
							layout: 'stack',
							classes: 'sidebar-panel',
							html: ''
						});
	
						container.prepend(panel);
						trigger(sidebar, panel, 'onrender');
						trigger(sidebar, panel, 'onshow');
					}
	
					btnCtrl.active(true);
				}
	
				editor.fire('ResizeEditor');
			};
		};
	
		var isModernBrowser = function () {
			return !Env.ie || Env.ie >= 11;
		};
	
		var hasSidebar = function (editor) {
			return isModernBrowser() && editor.sidebars ? editor.sidebars.length > 0 : false;
		};
	
		var createSidebar = function (editor) {
			var buttons = Tools.map(editor.sidebars, function (sidebar) {
				var settings = sidebar.settings;
	
				return {
					type: 'button',
					icon: settings.icon,
					image: settings.image,
					tooltip: settings.tooltip,
					onclick: showPanel(editor, sidebar.name, editor.sidebars)
				};
			});
	
			return {
				type: 'panel',
				name: 'sidebar',
				layout: 'stack',
				classes: 'sidebar',
				items: [
					{
						type: 'toolbar',
						layout: 'stack',
						classes: 'sidebar-toolbar',
						items: buttons
					}
				]
			};
		};
	
		return {
			hasSidebar: hasSidebar,
			createSidebar: createSidebar
		};
	});
	/**
	 * SkinLoaded.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2016 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	define('tinymce.modern.ui.SkinLoaded', [
	], function () {
		var fireSkinLoaded = function (editor) {
			return function() {
				if (editor.initialized) {
					editor.fire('SkinLoaded');
				} else {
					editor.on('init', function() {
						editor.fire('SkinLoaded');
					});
				}
			};
		};
	
		return {
			fireSkinLoaded: fireSkinLoaded
		};
	});
	
	/**
	 * Resize.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2016 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	define('tinymce.modern.ui.Resize', [
		'global!tinymce.DOM'
	], function (DOM) {
		var getSize = function (elm) {
			return {
				width: elm.clientWidth,
				height: elm.clientHeight
			};
		};
	
		var resizeTo = function (editor, width, height) {
			var containerElm, iframeElm, containerSize, iframeSize, settings = editor.settings;
	
			containerElm = editor.getContainer();
			iframeElm = editor.getContentAreaContainer().firstChild;
			containerSize = getSize(containerElm);
			iframeSize = getSize(iframeElm);
	
			if (width !== null) {
				width = Math.max(settings.min_width || 100, width);
				width = Math.min(settings.max_width || 0xFFFF, width);
	
				DOM.setStyle(containerElm, 'width', width + (containerSize.width - iframeSize.width));
				DOM.setStyle(iframeElm, 'width', width);
			}
	
			height = Math.max(settings.min_height || 100, height);
			height = Math.min(settings.max_height || 0xFFFF, height);
			DOM.setStyle(iframeElm, 'height', height);
	
			editor.fire('ResizeEditor');
		};
	
		var resizeBy = function (editor, dw, dh) {
			var elm = editor.getContentAreaContainer();
			resizeTo(editor, elm.clientWidth + dw, elm.clientHeight + dh);
		};
	
		return {
			resizeTo: resizeTo,
			resizeBy: resizeBy
		};
	});
	
	/**
	 * Iframe.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2016 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	define('tinymce.modern.modes.Iframe', [
		'global!tinymce.util.Tools',
		'global!tinymce.ui.Factory',
		'global!tinymce.DOM',
		'tinymce.modern.ui.Toolbar',
		'tinymce.modern.ui.Menubar',
		'tinymce.modern.ui.ContextToolbars',
		'tinymce.modern.ui.A11y',
		'tinymce.modern.ui.Sidebar',
		'tinymce.modern.ui.SkinLoaded',
		'tinymce.modern.ui.Resize'
	], function (Tools, Factory, DOM, Toolbar, Menubar, ContextToolbars, A11y, Sidebar, SkinLoaded, Resize) {
		var switchMode = function (panel) {
			return function(e) {
				panel.find('*').disabled(e.mode === 'readonly');
			};
		};
	
		var editArea = function (border) {
			return {
				type: 'panel',
				name: 'iframe',
				layout: 'stack',
				classes: 'edit-area',
				border: border,
				html: ''
			};
		};
	
		var editAreaContainer = function (editor) {
			return {
				type: 'panel',
				layout: 'stack',
				classes: 'edit-aria-container',
				border: '1 0 0 0',
				items: [
					editArea('0'),
					Sidebar.createSidebar(editor)
				]
			};
		};
	
		var render = function (editor, theme, args) {
			var panel, resizeHandleCtrl, startSize, settings = editor.settings;
	
			if (args.skinUiCss) {
				DOM.styleSheetLoader.load(args.skinUiCss, SkinLoaded.fireSkinLoaded(editor));
			}
	
			panel = theme.panel = Factory.create({
				type: 'panel',
				role: 'application',
				classes: 'tinymce',
				style: 'visibility: hidden',
				layout: 'stack',
				border: 1,
				items: [
					settings.menubar === false ? null : {type: 'menubar', border: '0 0 1 0', items: Menubar.createMenuButtons(editor)},
					Toolbar.createToolbars(editor, settings.toolbar_items_size),
					Sidebar.hasSidebar(editor) ? editAreaContainer(editor) : editArea('1 0 0 0')
				]
			});
	
			if (settings.resize !== false) {
				resizeHandleCtrl = {
					type: 'resizehandle',
					direction: settings.resize,
	
					onResizeStart: function() {
						var elm = editor.getContentAreaContainer().firstChild;
	
						startSize = {
							width: elm.clientWidth,
							height: elm.clientHeight
						};
					},
	
					onResize: function(e) {
						if (settings.resize === 'both') {
							Resize.resizeTo(editor, startSize.width + e.deltaX, startSize.height + e.deltaY);
						} else {
							Resize.resizeTo(editor, null, startSize.height + e.deltaY);
						}
					}
				};
			}
	
			// Add statusbar if needed
			if (settings.statusbar !== false) {
				panel.add({type: 'panel', name: 'statusbar', classes: 'statusbar', layout: 'flow', border: '1 0 0 0', ariaRoot: true, items: [
					{type: 'elementpath', editor: editor},
					resizeHandleCtrl
				]});
			}
	
			editor.fire('BeforeRenderUI');
			editor.on('SwitchMode', switchMode(panel));
			panel.renderBefore(args.targetNode).reflow();
	
			if (settings.readonly) {
				editor.setMode('readonly');
			}
	
			if (settings.width) {
				DOM.setStyle(panel.getEl(), 'width', settings.width);
			}
	
			// Remove the panel when the editor is removed
			editor.on('remove', function() {
				panel.remove();
				panel = null;
			});
	
			// Add accesibility shortcuts
			A11y.addKeys(editor, panel);
			ContextToolbars.addContextualToolbars(editor);
	
			return {
				iframeContainer: panel.find('#iframe')[0].getEl(),
				editorContainer: panel.getEl()
			};
		};
	
		return {
			render: render
		};
	});
	
	defineGlobal("global!tinymce.ui.FloatPanel", tinymce.ui.FloatPanel);
	/**
	 * Inline.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2016 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	define('tinymce.modern.modes.Inline', [
		'global!tinymce.util.Tools',
		'global!tinymce.ui.Factory',
		'global!tinymce.DOM',
		'global!tinymce.ui.FloatPanel',
		'tinymce.modern.ui.Toolbar',
		'tinymce.modern.ui.Menubar',
		'tinymce.modern.ui.ContextToolbars',
		'tinymce.modern.ui.A11y',
		'tinymce.modern.ui.SkinLoaded'
	], function (Tools, Factory, DOM, FloatPanel, Toolbar, Menubar, ContextToolbars, A11y, SkinLoaded) {
		var render = function (editor, theme, args) {
			var panel, inlineToolbarContainer, settings = editor.settings;
	
			if (settings.fixed_toolbar_container) {
				inlineToolbarContainer = DOM.select(settings.fixed_toolbar_container)[0];
			}
	
			var reposition = function () {
				if (panel && panel.moveRel && panel.visible() && !panel._fixed) {
					// TODO: This is kind of ugly and doesn't handle multiple scrollable elements
					var scrollContainer = editor.selection.getScrollContainer(), body = editor.getBody();
					var deltaX = 0, deltaY = 0;
	
					if (scrollContainer) {
						var bodyPos = DOM.getPos(body), scrollContainerPos = DOM.getPos(scrollContainer);
	
						deltaX = Math.max(0, scrollContainerPos.x - bodyPos.x);
						deltaY = Math.max(0, scrollContainerPos.y - bodyPos.y);
					}
	
					panel.fixed(false).moveRel(body, editor.rtl ? ['tr-br', 'br-tr'] : ['tl-bl', 'bl-tl', 'tr-br']).moveBy(deltaX, deltaY);
				}
			};
	
			var show = function () {
				if (panel) {
					panel.show();
					reposition();
					DOM.addClass(editor.getBody(), 'mce-edit-focus');
				}
			};
	
			var hide = function () {
				if (panel) {
					// We require two events as the inline float panel based toolbar does not have autohide=true
					panel.hide();
	
					// All other autohidden float panels will be closed below.
					FloatPanel.hideAll();
	
					DOM.removeClass(editor.getBody(), 'mce-edit-focus');
				}
			};
	
			var render = function () {
				if (panel) {
					if (!panel.visible()) {
						show();
					}
	
					return;
				}
	
				// Render a plain panel inside the inlineToolbarContainer if it's defined
				panel = theme.panel = Factory.create({
					type: inlineToolbarContainer ? 'panel' : 'floatpanel',
					role: 'application',
					classes: 'tinymce tinymce-inline',
					layout: 'flex',
					direction: 'column',
					align: 'stretch',
					autohide: false,
					autofix: true,
					fixed: !!inlineToolbarContainer,
					border: 1,
					items: [
						settings.menubar === false ? null : {type: 'menubar', border: '0 0 1 0', items: Menubar.createMenuButtons(editor)},
						Toolbar.createToolbars(editor, settings.toolbar_items_size)
					]
				});
	
				// Add statusbar
				/*if (settings.statusbar !== false) {
					panel.add({type: 'panel', classes: 'statusbar', layout: 'flow', border: '1 0 0 0', items: [
						{type: 'elementpath'}
					]});
				}*/
	
				editor.fire('BeforeRenderUI');
				panel.renderTo(inlineToolbarContainer || document.body).reflow();
	
				A11y.addKeys(editor, panel);
				show();
				ContextToolbars.addContextualToolbars(editor);
	
				editor.on('nodeChange', reposition);
				editor.on('activate', show);
				editor.on('deactivate', hide);
	
				editor.nodeChanged();
			};
	
			settings.content_editable = true;
	
			editor.on('focus', function() {
				// Render only when the CSS file has been loaded
				if (args.skinUiCss) {
					DOM.styleSheetLoader.load(args.skinUiCss, render, render);
				} else {
					render();
				}
			});
	
			editor.on('blur hide', hide);
	
			// Remove the panel when the editor is removed
			editor.on('remove', function() {
				if (panel) {
					panel.remove();
					panel = null;
				}
			});
	
			// Preload skin css
			if (args.skinUiCss) {
				DOM.styleSheetLoader.load(args.skinUiCss, SkinLoaded.fireSkinLoaded(editor));
			}
	
			return {};
		};
	
		return {
			render: render
		};
	});
	
	defineGlobal("global!tinymce.ui.Throbber", tinymce.ui.Throbber);
	/**
	 * ProgressState.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2016 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	define('tinymce.modern.ui.ProgressState', [
		'global!tinymce.ui.Throbber'
	], function (Throbber) {
		var setup = function (editor, theme) {
			var throbber;
	
			editor.on('ProgressState', function(e) {
				throbber = throbber || new Throbber(theme.panel.getEl('body'));
	
				if (e.state) {
					throbber.show(e.time);
				} else {
					throbber.hide();
				}
			});
		};
	
		return {
			setup: setup
		};
	});
	
	/**
	 * Theme.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2016 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	define('tinymce.modern.Theme', [
		'global!tinymce.Env',
		'global!tinymce.EditorManager',
		'global!tinymce.ThemeManager',
		'tinymce.modern.modes.Iframe',
		'tinymce.modern.modes.Inline',
		'tinymce.modern.ui.Resize',
		'tinymce.modern.ui.ProgressState'
	], function (Env, EditorManager, ThemeManager, Iframe, Inline, Resize, ProgressState) {
		var renderUI = function(editor, theme, args) {
			var settings = editor.settings;
			var skin = settings.skin !== false ? settings.skin || 'lightgray' : false;
	
			if (skin) {
				var skinUrl = settings.skin_url;
	
				if (skinUrl) {
					skinUrl = editor.documentBaseURI.toAbsolute(skinUrl);
				} else {
					skinUrl = EditorManager.baseURL + '/skins/' + skin;
				}
	
				// Load special skin for IE7
				// TODO: Remove this when we drop IE7 support
				if (Env.documentMode <= 7) {
					args.skinUiCss = skinUrl + '/skin.ie7.min.css';
				} else {
					args.skinUiCss = skinUrl + '/skin.min.css';
				}
	
				// Load content.min.css or content.inline.min.css
				editor.contentCSS.push(skinUrl + '/content' + (editor.inline ? '.inline' : '') + '.min.css');
			}
	
			ProgressState.setup(editor, theme);
	
			if (settings.inline) {
				return Inline.render(editor, theme, args);
			}
	
			return Iframe.render(editor, theme, args);
		};
	
		ThemeManager.add('modern', function (editor) {
			return {
				renderUI: function (args) {
					return renderUI(editor, this, args);
				},
				resizeTo: function (w, h) {
					return Resize.resizeTo(editor, w, h);
				},
				resizeBy: function (dw, dh) {
					return Resize.resizeBy(editor, dw, dh);
				}
			};
		});
	
		return function () {
		};
	});
	
	dem('tinymce.modern.Theme')();
	})();


/***/ },
/* 233 */
/***/ function(module, exports, __webpack_require__) {

	// Exports the "lists" plugin for usage with module loaders
	// Usage:
	//   CommonJS:
	//     require('tinymce/plugins/lists')
	//   ES2015:
	//     import 'tinymce/plugins/lists'
	__webpack_require__(234);

/***/ },
/* 234 */
/***/ function(module, exports) {

	/**
	 * plugin.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/*global tinymce:true */
	/*eslint consistent-this:0 */
	
	tinymce.PluginManager.add('lists', function(editor) {
		var self = this;
	
		function isChildOfBody(elm) {
			return editor.$.contains(editor.getBody(), elm);
		}
	
		function isBr(node) {
			return node && node.nodeName == 'BR';
		}
	
		function isListNode(node) {
			return node && (/^(OL|UL|DL)$/).test(node.nodeName) && isChildOfBody(node);
		}
	
		function isListItemNode(node) {
			return node && /^(LI|DT|DD)$/.test(node.nodeName);
		}
	
		function isFirstChild(node) {
			return node.parentNode.firstChild == node;
		}
	
		function isLastChild(node) {
			return node.parentNode.lastChild == node;
		}
	
		function isTextBlock(node) {
			return node && !!editor.schema.getTextBlockElements()[node.nodeName];
		}
	
		function isEditorBody(elm) {
			return elm === editor.getBody();
		}
	
		function isTextNode(node) {
			return node && node.nodeType === 3;
		}
	
		function getNormalizedEndPoint(container, offset) {
			var node = tinymce.dom.RangeUtils.getNode(container, offset);
	
			if (isListItemNode(container) && isTextNode(node)) {
				var textNodeOffset = offset >= container.childNodes.length ? node.data.length : 0;
				return {container: node, offset: textNodeOffset};
			}
	
			return {container: container, offset: offset};
		}
	
		function normalizeRange(rng) {
			var outRng = rng.cloneRange();
	
			var rangeStart = getNormalizedEndPoint(rng.startContainer, rng.startOffset);
			outRng.setStart(rangeStart.container, rangeStart.offset);
	
			var rangeEnd = getNormalizedEndPoint(rng.endContainer, rng.endOffset);
			outRng.setEnd(rangeEnd.container, rangeEnd.offset);
	
			return outRng;
		}
	
		editor.on('init', function() {
			var dom = editor.dom, selection = editor.selection;
	
			function isEmpty(elm, keepBookmarks) {
				var empty = dom.isEmpty(elm);
	
				if (keepBookmarks && dom.select('span[data-mce-type=bookmark]').length > 0) {
					return false;
				}
	
				return empty;
			}
	
			/**
			 * Returns a range bookmark. This will convert indexed bookmarks into temporary span elements with
			 * index 0 so that they can be restored properly after the DOM has been modified. Text bookmarks will not have spans
			 * added to them since they can be restored after a dom operation.
			 *
			 * So this: <p><b>|</b><b>|</b></p>
			 * becomes: <p><b><span data-mce-type="bookmark">|</span></b><b data-mce-type="bookmark">|</span></b></p>
			 *
			 * @param  {DOMRange} rng DOM Range to get bookmark on.
			 * @return {Object} Bookmark object.
			 */
			function createBookmark(rng) {
				var bookmark = {};
	
				function setupEndPoint(start) {
					var offsetNode, container, offset;
	
					container = rng[start ? 'startContainer' : 'endContainer'];
					offset = rng[start ? 'startOffset' : 'endOffset'];
	
					if (container.nodeType == 1) {
						offsetNode = dom.create('span', {'data-mce-type': 'bookmark'});
	
						if (container.hasChildNodes()) {
							offset = Math.min(offset, container.childNodes.length - 1);
	
							if (start) {
								container.insertBefore(offsetNode, container.childNodes[offset]);
							} else {
								dom.insertAfter(offsetNode, container.childNodes[offset]);
							}
						} else {
							container.appendChild(offsetNode);
						}
	
						container = offsetNode;
						offset = 0;
					}
	
					bookmark[start ? 'startContainer' : 'endContainer'] = container;
					bookmark[start ? 'startOffset' : 'endOffset'] = offset;
				}
	
				setupEndPoint(true);
	
				if (!rng.collapsed) {
					setupEndPoint();
				}
	
				return bookmark;
			}
	
			/**
			 * Moves the selection to the current bookmark and removes any selection container wrappers.
			 *
			 * @param {Object} bookmark Bookmark object to move selection to.
			 */
			function moveToBookmark(bookmark) {
				function restoreEndPoint(start) {
					var container, offset, node;
	
					function nodeIndex(container) {
						var node = container.parentNode.firstChild, idx = 0;
	
						while (node) {
							if (node == container) {
								return idx;
							}
	
							// Skip data-mce-type=bookmark nodes
							if (node.nodeType != 1 || node.getAttribute('data-mce-type') != 'bookmark') {
								idx++;
							}
	
							node = node.nextSibling;
						}
	
						return -1;
					}
	
					container = node = bookmark[start ? 'startContainer' : 'endContainer'];
					offset = bookmark[start ? 'startOffset' : 'endOffset'];
	
					if (!container) {
						return;
					}
	
					if (container.nodeType == 1) {
						offset = nodeIndex(container);
						container = container.parentNode;
						dom.remove(node);
					}
	
					bookmark[start ? 'startContainer' : 'endContainer'] = container;
					bookmark[start ? 'startOffset' : 'endOffset'] = offset;
				}
	
				restoreEndPoint(true);
				restoreEndPoint();
	
				var rng = dom.createRng();
	
				rng.setStart(bookmark.startContainer, bookmark.startOffset);
	
				if (bookmark.endContainer) {
					rng.setEnd(bookmark.endContainer, bookmark.endOffset);
				}
	
				selection.setRng(normalizeRange(rng));
			}
	
			function createNewTextBlock(contentNode, blockName) {
				var node, textBlock, fragment = dom.createFragment(), hasContentNode;
				var blockElements = editor.schema.getBlockElements();
	
				if (editor.settings.forced_root_block) {
					blockName = blockName || editor.settings.forced_root_block;
				}
	
				if (blockName) {
					textBlock = dom.create(blockName);
	
					if (textBlock.tagName === editor.settings.forced_root_block) {
						dom.setAttribs(textBlock, editor.settings.forced_root_block_attrs);
					}
	
					fragment.appendChild(textBlock);
				}
	
				if (contentNode) {
					while ((node = contentNode.firstChild)) {
						var nodeName = node.nodeName;
	
						if (!hasContentNode && (nodeName != 'SPAN' || node.getAttribute('data-mce-type') != 'bookmark')) {
							hasContentNode = true;
						}
	
						if (blockElements[nodeName]) {
							fragment.appendChild(node);
							textBlock = null;
						} else {
							if (blockName) {
								if (!textBlock) {
									textBlock = dom.create(blockName);
									fragment.appendChild(textBlock);
								}
	
								textBlock.appendChild(node);
							} else {
								fragment.appendChild(node);
							}
						}
					}
				}
	
				if (!editor.settings.forced_root_block) {
					fragment.appendChild(dom.create('br'));
				} else {
					// BR is needed in empty blocks on non IE browsers
					if (!hasContentNode && (!tinymce.Env.ie || tinymce.Env.ie > 10)) {
						textBlock.appendChild(dom.create('br', {'data-mce-bogus': '1'}));
					}
				}
	
				return fragment;
			}
	
			function getSelectedListItems() {
				return tinymce.grep(selection.getSelectedBlocks(), function(block) {
					return isListItemNode(block);
				});
			}
	
			function splitList(ul, li, newBlock) {
				var tmpRng, fragment, bookmarks, node;
	
				function removeAndKeepBookmarks(targetNode) {
					tinymce.each(bookmarks, function(node) {
						targetNode.parentNode.insertBefore(node, li.parentNode);
					});
	
					dom.remove(targetNode);
				}
	
				bookmarks = dom.select('span[data-mce-type="bookmark"]', ul);
				newBlock = newBlock || createNewTextBlock(li);
				tmpRng = dom.createRng();
				tmpRng.setStartAfter(li);
				tmpRng.setEndAfter(ul);
				fragment = tmpRng.extractContents();
	
				for (node = fragment.firstChild; node; node = node.firstChild) {
					if (node.nodeName == 'LI' && dom.isEmpty(node)) {
						dom.remove(node);
						break;
					}
				}
	
				if (!dom.isEmpty(fragment)) {
					dom.insertAfter(fragment, ul);
				}
	
				dom.insertAfter(newBlock, ul);
	
				if (isEmpty(li.parentNode)) {
					removeAndKeepBookmarks(li.parentNode);
				}
	
				dom.remove(li);
	
				if (isEmpty(ul)) {
					dom.remove(ul);
				}
			}
	
			var shouldMerge = function (listBlock, sibling) {
				var targetStyle = editor.dom.getStyle(listBlock, 'list-style-type', true);
				var style = editor.dom.getStyle(sibling, 'list-style-type', true);
				return targetStyle === style;
			};
	
			function mergeWithAdjacentLists(listBlock) {
				var sibling, node;
	
				sibling = listBlock.nextSibling;
				if (sibling && isListNode(sibling) && sibling.nodeName == listBlock.nodeName && shouldMerge(listBlock, sibling)) {
					while ((node = sibling.firstChild)) {
						listBlock.appendChild(node);
					}
	
					dom.remove(sibling);
				}
	
				sibling = listBlock.previousSibling;
				if (sibling && isListNode(sibling) && sibling.nodeName == listBlock.nodeName && shouldMerge(listBlock, sibling)) {
					while ((node = sibling.lastChild)) {
						listBlock.insertBefore(node, listBlock.firstChild);
					}
	
					dom.remove(sibling);
				}
			}
	
			function normalizeLists(element) {
				tinymce.each(tinymce.grep(dom.select('ol,ul', element)), normalizeList);
			}
	
			function normalizeList(ul) {
				var sibling, parentNode = ul.parentNode;
	
				// Move UL/OL to previous LI if it's the only child of a LI
				if (parentNode.nodeName == 'LI' && parentNode.firstChild == ul) {
					sibling = parentNode.previousSibling;
					if (sibling && sibling.nodeName == 'LI') {
						sibling.appendChild(ul);
	
						if (isEmpty(parentNode)) {
							dom.remove(parentNode);
						}
					} else {
						dom.setStyle(parentNode, 'listStyleType', 'none');
					}
				}
	
				// Append OL/UL to previous LI if it's in a parent OL/UL i.e. old HTML4
				if (isListNode(parentNode)) {
					sibling = parentNode.previousSibling;
					if (sibling && sibling.nodeName == 'LI') {
						sibling.appendChild(ul);
					}
				}
			}
	
			function outdent(li) {
				var ul = li.parentNode, ulParent = ul.parentNode, newBlock;
	
				function removeEmptyLi(li) {
					if (isEmpty(li)) {
						dom.remove(li);
					}
				}
	
				if (isEditorBody(ul)) {
					return true;
				}
	
				if (li.nodeName == 'DD') {
					dom.rename(li, 'DT');
					return true;
				}
	
				if (isFirstChild(li) && isLastChild(li)) {
					if (ulParent.nodeName == "LI") {
						dom.insertAfter(li, ulParent);
						removeEmptyLi(ulParent);
						dom.remove(ul);
					} else if (isListNode(ulParent)) {
						dom.remove(ul, true);
					} else {
						ulParent.insertBefore(createNewTextBlock(li), ul);
						dom.remove(ul);
					}
	
					return true;
				} else if (isFirstChild(li)) {
					if (ulParent.nodeName == "LI") {
						dom.insertAfter(li, ulParent);
						li.appendChild(ul);
						removeEmptyLi(ulParent);
					} else if (isListNode(ulParent)) {
						ulParent.insertBefore(li, ul);
					} else {
						ulParent.insertBefore(createNewTextBlock(li), ul);
						dom.remove(li);
					}
	
					return true;
				} else if (isLastChild(li)) {
					if (ulParent.nodeName == "LI") {
						dom.insertAfter(li, ulParent);
					} else if (isListNode(ulParent)) {
						dom.insertAfter(li, ul);
					} else {
						dom.insertAfter(createNewTextBlock(li), ul);
						dom.remove(li);
					}
	
					return true;
				}
	
				if (ulParent.nodeName == 'LI') {
					ul = ulParent;
					newBlock = createNewTextBlock(li, 'LI');
				} else if (isListNode(ulParent)) {
					newBlock = createNewTextBlock(li, 'LI');
				} else {
					newBlock = createNewTextBlock(li);
				}
	
				splitList(ul, li, newBlock);
				normalizeLists(ul.parentNode);
	
				return true;
			}
	
			function indent(li) {
				var sibling, newList, listStyle;
	
				function mergeLists(from, to) {
					var node;
	
					if (isListNode(from)) {
						while ((node = li.lastChild.firstChild)) {
							to.appendChild(node);
						}
	
						dom.remove(from);
					}
				}
	
				if (li.nodeName == 'DT') {
					dom.rename(li, 'DD');
					return true;
				}
	
				sibling = li.previousSibling;
	
				if (sibling && isListNode(sibling)) {
					sibling.appendChild(li);
					return true;
				}
	
				if (sibling && sibling.nodeName == 'LI' && isListNode(sibling.lastChild)) {
					sibling.lastChild.appendChild(li);
					mergeLists(li.lastChild, sibling.lastChild);
					return true;
				}
	
				sibling = li.nextSibling;
	
				if (sibling && isListNode(sibling)) {
					sibling.insertBefore(li, sibling.firstChild);
					return true;
				}
	
				/*if (sibling && sibling.nodeName == 'LI' && isListNode(li.lastChild)) {
					return false;
				}*/
	
				sibling = li.previousSibling;
				if (sibling && sibling.nodeName == 'LI') {
					newList = dom.create(li.parentNode.nodeName);
					listStyle = dom.getStyle(li.parentNode, 'listStyleType');
					if (listStyle) {
						dom.setStyle(newList, 'listStyleType', listStyle);
					}
					sibling.appendChild(newList);
					newList.appendChild(li);
					mergeLists(li.lastChild, newList);
					return true;
				}
	
				return false;
			}
	
			function indentSelection() {
				var listElements = getSelectedListItems();
	
				if (listElements.length) {
					var bookmark = createBookmark(selection.getRng(true));
	
					for (var i = 0; i < listElements.length; i++) {
						if (!indent(listElements[i]) && i === 0) {
							break;
						}
					}
	
					moveToBookmark(bookmark);
					editor.nodeChanged();
	
					return true;
				}
			}
	
			function outdentSelection() {
				var listElements = getSelectedListItems();
	
				if (listElements.length) {
					var bookmark = createBookmark(selection.getRng(true));
					var i, y, root = editor.getBody();
	
					i = listElements.length;
					while (i--) {
						var node = listElements[i].parentNode;
	
						while (node && node != root) {
							y = listElements.length;
							while (y--) {
								if (listElements[y] === node) {
									listElements.splice(i, 1);
									break;
								}
							}
	
							node = node.parentNode;
						}
					}
	
					for (i = 0; i < listElements.length; i++) {
						if (!outdent(listElements[i]) && i === 0) {
							break;
						}
					}
	
					moveToBookmark(bookmark);
					editor.nodeChanged();
	
					return true;
				}
			}
	
			function applyList(listName, detail) {
				var rng = selection.getRng(true), bookmark, listItemName = 'LI';
	
				if (dom.getContentEditable(selection.getNode()) === "false") {
					return;
				}
	
				listName = listName.toUpperCase();
	
				if (listName == 'DL') {
					listItemName = 'DT';
				}
	
				function getSelectedTextBlocks() {
					var textBlocks = [], root = editor.getBody();
	
					function getEndPointNode(start) {
						var container, offset;
	
						container = rng[start ? 'startContainer' : 'endContainer'];
						offset = rng[start ? 'startOffset' : 'endOffset'];
	
						// Resolve node index
						if (container.nodeType == 1) {
							container = container.childNodes[Math.min(offset, container.childNodes.length - 1)] || container;
						}
	
						while (container.parentNode != root) {
							if (isTextBlock(container)) {
								return container;
							}
	
							if (/^(TD|TH)$/.test(container.parentNode.nodeName)) {
								return container;
							}
	
							container = container.parentNode;
						}
	
						return container;
					}
	
					var startNode = getEndPointNode(true);
					var endNode = getEndPointNode();
					var block, siblings = [];
	
					for (var node = startNode; node; node = node.nextSibling) {
						siblings.push(node);
	
						if (node == endNode) {
							break;
						}
					}
	
					tinymce.each(siblings, function(node) {
						if (isTextBlock(node)) {
							textBlocks.push(node);
							block = null;
							return;
						}
	
						if (dom.isBlock(node) || isBr(node)) {
							if (isBr(node)) {
								dom.remove(node);
							}
	
							block = null;
							return;
						}
	
						var nextSibling = node.nextSibling;
						if (tinymce.dom.BookmarkManager.isBookmarkNode(node)) {
							if (isTextBlock(nextSibling) || (!nextSibling && node.parentNode == root)) {
								block = null;
								return;
							}
						}
	
						if (!block) {
							block = dom.create('p');
							node.parentNode.insertBefore(block, node);
							textBlocks.push(block);
						}
	
						block.appendChild(node);
					});
	
					return textBlocks;
				}
	
				bookmark = createBookmark(rng);
	
				tinymce.each(getSelectedTextBlocks(), function(block) {
					var listBlock, sibling;
	
					var hasCompatibleStyle = function (sib) {
						var sibStyle = dom.getStyle(sib, 'list-style-type');
						var detailStyle = detail ? detail['list-style-type'] : '';
	
						detailStyle = detailStyle === null ? '' : detailStyle;
	
						return sibStyle === detailStyle;
					};
	
					sibling = block.previousSibling;
					if (sibling && isListNode(sibling) && sibling.nodeName == listName && hasCompatibleStyle(sibling)) {
						listBlock = sibling;
						block = dom.rename(block, listItemName);
						sibling.appendChild(block);
					} else {
						listBlock = dom.create(listName);
						block.parentNode.insertBefore(listBlock, block);
						listBlock.appendChild(block);
						block = dom.rename(block, listItemName);
					}
	
					updateListStyle(listBlock, detail);
					mergeWithAdjacentLists(listBlock);
				});
	
				moveToBookmark(bookmark);
			}
	
			var updateListStyle = function (el, detail) {
				dom.setStyle(el, 'list-style-type', detail ? detail['list-style-type'] : null);
			};
	
			function removeList() {
				var bookmark = createBookmark(selection.getRng(true)), root = editor.getBody();
	
				tinymce.each(getSelectedListItems(), function(li) {
					var node, rootList;
	
					if (isEditorBody(li.parentNode)) {
						return;
					}
	
					if (isEmpty(li)) {
						outdent(li);
						return;
					}
	
					for (node = li; node && node != root; node = node.parentNode) {
						if (isListNode(node)) {
							rootList = node;
						}
					}
	
					splitList(rootList, li);
					normalizeLists(rootList.parentNode);
				});
	
				moveToBookmark(bookmark);
			}
	
			function toggleList(listName, detail) {
				var parentList = dom.getParent(selection.getStart(), 'OL,UL,DL');
	
				if (isEditorBody(parentList)) {
					return;
				}
	
				if (parentList) {
					if (parentList.nodeName == listName) {
						removeList(listName);
					} else {
						var bookmark = createBookmark(selection.getRng(true));
						updateListStyle(parentList, detail);
						mergeWithAdjacentLists(dom.rename(parentList, listName));
	
						moveToBookmark(bookmark);
					}
				} else {
					applyList(listName, detail);
				}
			}
	
			function queryListCommandState(listName) {
				return function() {
					var parentList = dom.getParent(editor.selection.getStart(), 'UL,OL,DL');
	
					return parentList && parentList.nodeName == listName;
				};
			}
	
			function isBogusBr(node) {
				if (!isBr(node)) {
					return false;
				}
	
				if (dom.isBlock(node.nextSibling) && !isBr(node.previousSibling)) {
					return true;
				}
	
				return false;
			}
	
			function findNextCaretContainer(rng, isForward) {
				var node = rng.startContainer, offset = rng.startOffset;
				var nonEmptyBlocks, walker;
	
				if (node.nodeType == 3 && (isForward ? offset < node.data.length : offset > 0)) {
					return node;
				}
	
				nonEmptyBlocks = editor.schema.getNonEmptyElements();
				if (node.nodeType == 1) {
					node = tinymce.dom.RangeUtils.getNode(node, offset);
				}
	
				walker = new tinymce.dom.TreeWalker(node, editor.getBody());
	
				// Delete at <li>|<br></li> then jump over the bogus br
				if (isForward) {
					if (isBogusBr(node)) {
						walker.next();
					}
				}
	
				while ((node = walker[isForward ? 'next' : 'prev2']())) {
					if (node.nodeName == 'LI' && !node.hasChildNodes()) {
						return node;
					}
	
					if (nonEmptyBlocks[node.nodeName]) {
						return node;
					}
	
					if (node.nodeType == 3 && node.data.length > 0) {
						return node;
					}
				}
			}
	
			function mergeLiElements(fromElm, toElm) {
				var node, listNode, ul = fromElm.parentNode;
	
				if (!isChildOfBody(fromElm) || !isChildOfBody(toElm)) {
					return;
				}
	
				if (isListNode(toElm.lastChild)) {
					listNode = toElm.lastChild;
				}
	
				if (ul == toElm.lastChild) {
					if (isBr(ul.previousSibling)) {
						dom.remove(ul.previousSibling);
					}
				}
	
				node = toElm.lastChild;
				if (node && isBr(node) && fromElm.hasChildNodes()) {
					dom.remove(node);
				}
	
				if (isEmpty(toElm, true)) {
					dom.$(toElm).empty();
				}
	
				if (!isEmpty(fromElm, true)) {
					while ((node = fromElm.firstChild)) {
						toElm.appendChild(node);
					}
				}
	
				if (listNode) {
					toElm.appendChild(listNode);
				}
	
				dom.remove(fromElm);
	
				if (isEmpty(ul) && !isEditorBody(ul)) {
					dom.remove(ul);
				}
			}
	
			function backspaceDeleteCaret(isForward) {
				var li = dom.getParent(selection.getStart(), 'LI'), ul, rng, otherLi;
	
				if (li) {
					ul = li.parentNode;
					if (isEditorBody(ul) && dom.isEmpty(ul)) {
						return true;
					}
	
					rng = normalizeRange(selection.getRng(true));
					otherLi = dom.getParent(findNextCaretContainer(rng, isForward), 'LI');
	
					if (otherLi && otherLi != li) {
						var bookmark = createBookmark(rng);
	
						if (isForward) {
							mergeLiElements(otherLi, li);
						} else {
							mergeLiElements(li, otherLi);
						}
	
						moveToBookmark(bookmark);
	
						return true;
					} else if (!otherLi) {
						if (!isForward && removeList(ul.nodeName)) {
							return true;
						}
					}
				}
			}
	
			function backspaceDeleteRange() {
				var startListParent = editor.dom.getParent(editor.selection.getStart(), 'LI,DT,DD');
	
				if (startListParent || getSelectedListItems().length > 0) {
					editor.undoManager.transact(function() {
						editor.execCommand('Delete');
						normalizeLists(editor.getBody());
					});
	
					return true;
				}
	
				return false;
			}
	
			self.backspaceDelete = function(isForward) {
				return selection.isCollapsed() ? backspaceDeleteCaret(isForward) : backspaceDeleteRange();
			};
	
			editor.on('BeforeExecCommand', function(e) {
				var cmd = e.command.toLowerCase(), isHandled;
	
				if (cmd == "indent") {
					if (indentSelection()) {
						isHandled = true;
					}
				} else if (cmd == "outdent") {
					if (outdentSelection()) {
						isHandled = true;
					}
				}
	
				if (isHandled) {
					editor.fire('ExecCommand', {command: e.command});
					e.preventDefault();
					return true;
				}
			});
	
			editor.addCommand('InsertUnorderedList', function(ui, detail) {
				toggleList('UL', detail);
			});
	
			editor.addCommand('InsertOrderedList', function(ui, detail) {
				toggleList('OL', detail);
			});
	
			editor.addCommand('InsertDefinitionList', function(ui, detail) {
				toggleList('DL', detail);
			});
	
			editor.addQueryStateHandler('InsertUnorderedList', queryListCommandState('UL'));
			editor.addQueryStateHandler('InsertOrderedList', queryListCommandState('OL'));
			editor.addQueryStateHandler('InsertDefinitionList', queryListCommandState('DL'));
	
			editor.on('keydown', function(e) {
				// Check for tab but not ctrl/cmd+tab since it switches browser tabs
				if (e.keyCode != 9 || tinymce.util.VK.metaKeyPressed(e)) {
					return;
				}
	
				if (editor.dom.getParent(editor.selection.getStart(), 'LI,DT,DD')) {
					e.preventDefault();
	
					if (e.shiftKey) {
						outdentSelection();
					} else {
						indentSelection();
					}
				}
			});
		});
	
		var listState = function (listName) {
			return function () {
				var self = this;
	
				editor.on('NodeChange', function (e) {
					var lists = tinymce.util.Tools.grep(e.parents, isListNode);
					self.active(lists.length > 0 && lists[0].nodeName === listName);
				});
			};
		};
	
		if (!tinymce.PluginManager.get("advlist")) {
			editor.addButton('numlist', {
				title: 'Numbered list',
				cmd: 'InsertOrderedList',
				onPostRender: listState('OL')
			});
	
			editor.addButton('bullist', {
				title: 'Bullet list',
				cmd: 'InsertUnorderedList',
				onPostRender: listState('UL')
			});
		}
	
		editor.addButton('indent', {
			icon: 'indent',
			title: 'Increase indent',
			cmd: 'Indent',
			onPostRender: function() {
				var ctrl = this;
	
				editor.on('nodechange', function() {
					var blocks = editor.selection.getSelectedBlocks();
					var disable = false;
	
					for (var i = 0, l = blocks.length; !disable && i < l; i++) {
						var tag = blocks[i].nodeName;
	
						disable = (tag == 'LI' && isFirstChild(blocks[i]) || tag == 'UL' || tag == 'OL' || tag == 'DD');
					}
	
					ctrl.disabled(disable);
				});
			}
		});
	
		editor.on('keydown', function(e) {
			if (e.keyCode == tinymce.util.VK.BACKSPACE) {
				if (self.backspaceDelete()) {
					e.preventDefault();
				}
			} else if (e.keyCode == tinymce.util.VK.DELETE) {
				if (self.backspaceDelete(true)) {
					e.preventDefault();
				}
			}
		});
	});


/***/ },
/* 235 */
/***/ function(module, exports, __webpack_require__) {

	// Exports the "link" plugin for usage with module loaders
	// Usage:
	//   CommonJS:
	//     require('tinymce/plugins/link')
	//   ES2015:
	//     import 'tinymce/plugins/link'
	__webpack_require__(236);

/***/ },
/* 236 */
/***/ function(module, exports) {

	/**
	 * plugin.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/*global tinymce:true */
	
	tinymce.PluginManager.add('link', function(editor) {
		var attachState = {};
	
		function isLink(elm) {
			return elm && elm.nodeName === 'A' && elm.href;
		}
	
		function hasLinks(elements) {
			return tinymce.util.Tools.grep(elements, isLink).length > 0;
		}
	
		function getLink(elm) {
			return editor.dom.getParent(elm, 'a[href]');
		}
	
		function getSelectedLink() {
			return getLink(editor.selection.getStart());
		}
	
		function getHref(elm) {
			// Returns the real href value not the resolved a.href value
			var href = elm.getAttribute('data-mce-href');
			return href ? href : elm.getAttribute('href');
		}
	
		function isContextMenuVisible() {
			var contextmenu = editor.plugins.contextmenu;
			return contextmenu ? contextmenu.isContextMenuVisible() : false;
		}
	
		var hasOnlyAltModifier = function (e) {
			return e.altKey === true && e.shiftKey === false && e.ctrlKey === false && e.metaKey === false;
		};
	
		function leftClickedOnAHref(elm) {
			var sel, rng, node;
			if (editor.settings.link_context_toolbar && !isContextMenuVisible() && isLink(elm)) {
				sel = editor.selection;
				rng = sel.getRng();
				node = rng.startContainer;
				// ignore cursor positions at the beginning/end (to make context toolbar less noisy)
				if (node.nodeType == 3 && sel.isCollapsed() && rng.startOffset > 0 && rng.startOffset < node.data.length) {
					return true;
				}
			}
			return false;
		}
	
		function openDetachedWindow(url) {
			// Chrome and Webkit has implemented noopener and works correctly with/without popup blocker
			// Firefox has it implemented noopener but when the popup blocker is activated it doesn't work
			// Edge has only implemented noreferrer and it seems to remove opener as well
			// Older IE versions pre IE 11 falls back to a window.open approach
			if (!tinymce.Env.ie || tinymce.Env.ie > 10) {
				var link = document.createElement('a');
				link.target = '_blank';
				link.href = url;
				link.rel = 'noreferrer noopener';
	
				var evt = document.createEvent('MouseEvents');
				evt.initMouseEvent('click', true, true, window, true, 0, 0, 0, 0, false, false, false, false, 0, null);
				link.dispatchEvent(evt);
			} else {
				var win = window.open('', '_blank');
				if (win) {
					win.opener = null;
					var doc = win.document;
					doc.open();
					doc.write('<meta http-equiv="refresh" content="0; url=' + tinymce.DOM.encode(url) + '">');
					doc.close();
				}
			}
		}
	
		function gotoLink(a) {
			if (a) {
				var href = getHref(a);
				if (/^#/.test(href)) {
					var targetEl = editor.$(href);
					if (targetEl.length) {
						editor.selection.scrollIntoView(targetEl[0], true);
					}
				} else {
					openDetachedWindow(a.href);
				}
			}
		}
	
		function gotoSelectedLink() {
			gotoLink(getSelectedLink());
		}
	
		function toggleViewLinkState() {
	        var self = this;
	
			var toggleVisibility = function (e) {
				if (hasLinks(e.parents)) {
					self.show();
				} else {
					self.hide();
				}
			};
	
			if (!hasLinks(editor.dom.getParents(editor.selection.getStart()))) {
				self.hide();
			}
	
	        editor.on('nodechange', toggleVisibility);
	
			self.on('remove', function () {
				editor.off('nodechange', toggleVisibility);
			});
		}
	
		function createLinkList(callback) {
			return function() {
				var linkList = editor.settings.link_list;
	
				if (typeof linkList == "string") {
					tinymce.util.XHR.send({
						url: linkList,
						success: function(text) {
							callback(tinymce.util.JSON.parse(text));
						}
					});
				} else if (typeof linkList == "function") {
					linkList(callback);
				} else {
					callback(linkList);
				}
			};
		}
	
		function buildListItems(inputList, itemCallback, startItems) {
			function appendItems(values, output) {
				output = output || [];
	
				tinymce.each(values, function(item) {
					var menuItem = {text: item.text || item.title};
	
					if (item.menu) {
						menuItem.menu = appendItems(item.menu);
					} else {
						menuItem.value = item.value;
	
						if (itemCallback) {
							itemCallback(menuItem);
						}
					}
	
					output.push(menuItem);
				});
	
				return output;
			}
	
			return appendItems(inputList, startItems || []);
		}
	
		function showDialog(linkList) {
			var data = {}, selection = editor.selection, dom = editor.dom, selectedElm, anchorElm, initialText;
			var win, onlyText, textListCtrl, linkListCtrl, relListCtrl, targetListCtrl, classListCtrl, linkTitleCtrl, value;
	
			function linkListChangeHandler(e) {
				var textCtrl = win.find('#text');
	
				if (!textCtrl.value() || (e.lastControl && textCtrl.value() == e.lastControl.text())) {
					textCtrl.value(e.control.text());
				}
	
				win.find('#href').value(e.control.value());
			}
	
			function buildAnchorListControl(url) {
				var anchorList = [];
	
				tinymce.each(editor.dom.select('a:not([href])'), function(anchor) {
					var id = anchor.name || anchor.id;
	
					if (id) {
						anchorList.push({
							text: id,
							value: '#' + id,
							selected: url.indexOf('#' + id) != -1
						});
					}
				});
	
				if (anchorList.length) {
					anchorList.unshift({text: 'None', value: ''});
	
					return {
						name: 'anchor',
						type: 'listbox',
						label: 'Anchors',
						values: anchorList,
						onselect: linkListChangeHandler
					};
				}
			}
	
			function updateText() {
				if (!initialText && data.text.length === 0 && onlyText) {
					this.parent().parent().find('#text')[0].value(this.value());
				}
			}
	
			function urlChange(e) {
				var meta = e.meta || {};
	
				if (linkListCtrl) {
					linkListCtrl.value(editor.convertURL(this.value(), 'href'));
				}
	
				tinymce.each(e.meta, function(value, key) {
					var inp = win.find('#' + key);
	
					if (key === 'text') {
						if (initialText.length === 0) {
							inp.value(value);
							data.text = value;
						}
					} else {
						inp.value(value);
					}
				});
	
				if (meta.attach) {
					attachState = {
						href: this.value(),
						attach: meta.attach
					};
				}
	
				if (!meta.text) {
					updateText.call(this);
				}
			}
	
			function isOnlyTextSelected(anchorElm) {
				var html = selection.getContent();
	
				// Partial html and not a fully selected anchor element
				if (/</.test(html) && (!/^<a [^>]+>[^<]+<\/a>$/.test(html) || html.indexOf('href=') == -1)) {
					return false;
				}
	
				if (anchorElm) {
					var nodes = anchorElm.childNodes, i;
	
					if (nodes.length === 0) {
						return false;
					}
	
					for (i = nodes.length - 1; i >= 0; i--) {
						if (nodes[i].nodeType != 3) {
							return false;
						}
					}
				}
	
				return true;
			}
	
			function onBeforeCall(e) {
				e.meta = win.toJSON();
			}
	
			selectedElm = selection.getNode();
			anchorElm = dom.getParent(selectedElm, 'a[href]');
			onlyText = isOnlyTextSelected();
	
			data.text = initialText = anchorElm ? (anchorElm.innerText || anchorElm.textContent) : selection.getContent({format: 'text'});
			data.href = anchorElm ? dom.getAttrib(anchorElm, 'href') : '';
	
			if (anchorElm) {
				data.target = dom.getAttrib(anchorElm, 'target');
			} else if (editor.settings.default_link_target) {
				data.target = editor.settings.default_link_target;
			}
	
			if ((value = dom.getAttrib(anchorElm, 'rel'))) {
				data.rel = value;
			}
	
			if ((value = dom.getAttrib(anchorElm, 'class'))) {
				data['class'] = value;
			}
	
			if ((value = dom.getAttrib(anchorElm, 'title'))) {
				data.title = value;
			}
	
			if (onlyText) {
				textListCtrl = {
					name: 'text',
					type: 'textbox',
					size: 40,
					label: 'Text to display',
					onchange: function() {
						data.text = this.value();
					}
				};
			}
	
			if (linkList) {
				linkListCtrl = {
					type: 'listbox',
					label: 'Link list',
					values: buildListItems(
						linkList,
						function(item) {
							item.value = editor.convertURL(item.value || item.url, 'href');
						},
						[{text: 'None', value: ''}]
					),
					onselect: linkListChangeHandler,
					value: editor.convertURL(data.href, 'href'),
					onPostRender: function() {
						/*eslint consistent-this:0*/
						linkListCtrl = this;
					}
				};
			}
	
			if (editor.settings.target_list !== false) {
				if (!editor.settings.target_list) {
					editor.settings.target_list = [
						{text: 'None', value: ''},
						{text: 'New window', value: '_blank'}
					];
				}
	
				targetListCtrl = {
					name: 'target',
					type: 'listbox',
					label: 'Target',
					values: buildListItems(editor.settings.target_list)
				};
			}
	
			if (editor.settings.rel_list) {
				relListCtrl = {
					name: 'rel',
					type: 'listbox',
					label: 'Rel',
					values: buildListItems(editor.settings.rel_list)
				};
			}
	
			if (editor.settings.link_class_list) {
				classListCtrl = {
					name: 'class',
					type: 'listbox',
					label: 'Class',
					values: buildListItems(
						editor.settings.link_class_list,
						function(item) {
							if (item.value) {
								item.textStyle = function() {
									return editor.formatter.getCssText({inline: 'a', classes: [item.value]});
								};
							}
						}
					)
				};
			}
	
			if (editor.settings.link_title !== false) {
				linkTitleCtrl = {
					name: 'title',
					type: 'textbox',
					label: 'Title',
					value: data.title
				};
			}
	
			win = editor.windowManager.open({
				title: 'Insert link',
				data: data,
				body: [
					{
						name: 'href',
						type: 'filepicker',
						filetype: 'file',
						size: 40,
						autofocus: true,
						label: 'Url',
						onchange: urlChange,
						onkeyup: updateText,
						onbeforecall: onBeforeCall
					},
					textListCtrl,
					linkTitleCtrl,
					buildAnchorListControl(data.href),
					linkListCtrl,
					relListCtrl,
					targetListCtrl,
					classListCtrl
				],
				onSubmit: function(e) {
					/*eslint dot-notation: 0*/
					var href;
	
					data = tinymce.extend(data, e.data);
					href = data.href;
	
					// Delay confirm since onSubmit will move focus
					function delayedConfirm(message, callback) {
						var rng = editor.selection.getRng();
	
						tinymce.util.Delay.setEditorTimeout(editor, function() {
							editor.windowManager.confirm(message, function(state) {
								editor.selection.setRng(rng);
								callback(state);
							});
						});
					}
	
					function toggleTargetRules(rel, isUnsafe) {
						var rules = 'noopener noreferrer';
	
						function addTargetRules(rel) {
							rel = removeTargetRules(rel);
							return rel ? [rel, rules].join(' ') : rules;
						}
	
						function removeTargetRules(rel) {
							var regExp = new RegExp('(' + rules.replace(' ', '|') + ')', 'g');
							if (rel) {
								rel = tinymce.trim(rel.replace(regExp, ''));
							}
							return rel ? rel : null;
						}
	
						return isUnsafe ? addTargetRules(rel) : removeTargetRules(rel);
					}
	
					function createLink() {
						var linkAttrs = {
							href: href,
							target: data.target ? data.target : null,
							rel: data.rel ? data.rel : null,
							"class": data["class"] ? data["class"] : null,
							title: data.title ? data.title : null
						};
	
						if (!editor.settings.allow_unsafe_link_target) {
							linkAttrs.rel = toggleTargetRules(linkAttrs.rel, linkAttrs.target == '_blank');
						}
	
						if (href === attachState.href) {
							attachState.attach();
							attachState = {};
						}
	
						if (anchorElm) {
							editor.focus();
	
							if (onlyText && data.text != initialText) {
								if ("innerText" in anchorElm) {
									anchorElm.innerText = data.text;
								} else {
									anchorElm.textContent = data.text;
								}
							}
	
							dom.setAttribs(anchorElm, linkAttrs);
	
							selection.select(anchorElm);
							editor.undoManager.add();
						} else {
							if (onlyText) {
								editor.insertContent(dom.createHTML('a', linkAttrs, dom.encode(data.text)));
							} else {
								editor.execCommand('mceInsertLink', false, linkAttrs);
							}
						}
					}
	
					function insertLink() {
						editor.undoManager.transact(createLink);
					}
	
					if (!href) {
						editor.execCommand('unlink');
						return;
					}
	
					// Is email and not //user@domain.com
					if (href.indexOf('@') > 0 && href.indexOf('//') == -1 && href.indexOf('mailto:') == -1) {
						delayedConfirm(
							'The URL you entered seems to be an email address. Do you want to add the required mailto: prefix?',
							function(state) {
								if (state) {
									href = 'mailto:' + href;
								}
	
								insertLink();
							}
						);
	
						return;
					}
	
					// Is not protocol prefixed
					if ((editor.settings.link_assume_external_targets && !/^\w+:/i.test(href)) ||
						(!editor.settings.link_assume_external_targets && /^\s*www[\.|\d\.]/i.test(href))) {
						delayedConfirm(
							'The URL you entered seems to be an external link. Do you want to add the required http:// prefix?',
							function(state) {
								if (state) {
									href = 'http://' + href;
								}
	
								insertLink();
							}
						);
	
						return;
					}
	
					insertLink();
				}
			});
		}
	
		editor.addButton('link', {
			icon: 'link',
			tooltip: 'Insert/edit link',
			shortcut: 'Meta+K',
			onclick: createLinkList(showDialog),
			stateSelector: 'a[href]'
		});
	
		editor.addButton('unlink', {
			icon: 'unlink',
			tooltip: 'Remove link',
			cmd: 'unlink',
			stateSelector: 'a[href]'
		});
	
	
		if (editor.addContextToolbar) {
			editor.addButton('openlink', {
				icon: 'newtab',
				tooltip: 'Open link',
				onclick: gotoSelectedLink
			});
	
			editor.addContextToolbar(
				leftClickedOnAHref,
				'openlink | link unlink'
			);
		}
	
	
		editor.addShortcut('Meta+K', '', createLinkList(showDialog));
		editor.addCommand('mceLink', createLinkList(showDialog));
	
		editor.on('click', function (e) {
			var link = getLink(e.target);
			if (link && tinymce.util.VK.metaKeyPressed(e)) {
				e.preventDefault();
				gotoLink(link);
			}
		});
	
		editor.on('keydown', function (e) {
			var link = getSelectedLink();
			if (link && e.keyCode === 13 && hasOnlyAltModifier(e)) {
				e.preventDefault();
				gotoLink(link);
			}
		});
	
		this.showDialog = showDialog;
	
		editor.addMenuItem('openlink', {
			text: 'Open link',
			icon: 'newtab',
			onclick: gotoSelectedLink,
			onPostRender: toggleViewLinkState,
			prependToContext: true
		});
	
		editor.addMenuItem('link', {
			icon: 'link',
			text: 'Link',
			shortcut: 'Meta+K',
			onclick: createLinkList(showDialog),
			stateSelector: 'a[href]',
			context: 'insert',
			prependToContext: true
		});
	});


/***/ },
/* 237 */
/***/ function(module, exports, __webpack_require__) {

	// Exports the "code" plugin for usage with module loaders
	// Usage:
	//   CommonJS:
	//     require('tinymce/plugins/code')
	//   ES2015:
	//     import 'tinymce/plugins/code'
	__webpack_require__(238);

/***/ },
/* 238 */
/***/ function(module, exports) {

	/**
	 * plugin.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/*global tinymce:true */
	
	tinymce.PluginManager.add('code', function(editor) {
		function showDialog() {
			var win = editor.windowManager.open({
				title: "Source code",
				body: {
					type: 'textbox',
					name: 'code',
					multiline: true,
					minWidth: editor.getParam("code_dialog_width", 600),
					minHeight: editor.getParam("code_dialog_height", Math.min(tinymce.DOM.getViewPort().h - 200, 500)),
					spellcheck: false,
					style: 'direction: ltr; text-align: left'
				},
				onSubmit: function(e) {
					// We get a lovely "Wrong document" error in IE 11 if we
					// don't move the focus to the editor before creating an undo
					// transation since it tries to make a bookmark for the current selection
					editor.focus();
	
					editor.undoManager.transact(function() {
						editor.setContent(e.data.code);
					});
	
					editor.selection.setCursorLocation();
					editor.nodeChanged();
				}
			});
	
			// Gecko has a major performance issue with textarea
			// contents so we need to set it when all reflows are done
			win.find('#code').value(editor.getContent({source_view: true}));
		}
	
		editor.addCommand("mceCodeEditor", showDialog);
	
		editor.addButton('code', {
			icon: 'code',
			tooltip: 'Source code',
			onclick: showDialog
		});
	
		editor.addMenuItem('code', {
			icon: 'code',
			text: 'Source code',
			context: 'tools',
			onclick: showDialog
		});
	});

/***/ },
/* 239 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _classCallCheck2 = __webpack_require__(2);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(20);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(89);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _BaseField2 = __webpack_require__(197);
	
	var _BaseField3 = _interopRequireDefault(_BaseField2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var SelectField = function (_BaseField) {
	    (0, _inherits3.default)(SelectField, _BaseField);
	
	    function SelectField(opts) {
	        (0, _classCallCheck3.default)(this, SelectField);
	        return (0, _possibleConstructorReturn3.default)(this, _BaseField.call(this, opts));
	    }
	
	    SelectField.prototype.createLocalizedField = function createLocalizedField(lang) {
	
	        var uid = this.id() + "-" + lang;
	
	        var elHtml = '<select id="select-' + uid + '" class="composer-field select" data-lang="' + lang + '">';
	        var opts = this.settings.values;
	        if (opts) {
	            var first = true;
	            for (var optValue in opts) {
	                var selected = first ? ' selected="selected" ' : '';
	                elHtml += '<option ' + selected + ' value="' + optValue + '">' + opts[optValue] + '</option>';
	                first = false;
	            }
	        }
	
	        elHtml += '</select>';
	        var parsedEl = new DOMParser().parseFromString(elHtml, "text/html");
	        return _BaseField.prototype.find.call(this, parsedEl, "#select-" + uid);
	    };
	
	    SelectField.prototype.init = function init() {};
	
	    return SelectField;
	}(_BaseField3.default);
	
	exports.default = SelectField;

/***/ },
/* 240 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _classCallCheck2 = __webpack_require__(2);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(20);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(89);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _BaseRender2 = __webpack_require__(196);
	
	var _BaseRender3 = _interopRequireDefault(_BaseRender2);
	
	var _Utils = __webpack_require__(103);
	
	var _Utils2 = _interopRequireDefault(_Utils);
	
	var _fields = __webpack_require__(199);
	
	var Fields = _interopRequireWildcard(_fields);
	
	var _classie = __webpack_require__(99);
	
	var _classie2 = _interopRequireDefault(_classie);
	
	var _lodash = __webpack_require__(198);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	// ImageTextBlockItem
	var ImageTextRender = function (_BaseRender) {
	    (0, _inherits3.default)(ImageTextRender, _BaseRender);
	
	    function ImageTextRender(opts) {
	        (0, _classCallCheck3.default)(this, ImageTextRender);
	        return (0, _possibleConstructorReturn3.default)(this, _BaseRender.call(this, opts));
	    }
	
	    ImageTextRender.prototype.createFields = function createFields() {
	
	        var columnContainerEl = document.createElement("div");
	        _classie2.default.add(columnContainerEl, "grid-container");
	        _classie2.default.add(columnContainerEl, "grid-parent");
	        _classie2.default.add(columnContainerEl, "columns-container");
	
	        var leftContainerEl = document.createElement("div");
	        _classie2.default.add(leftContainerEl, "grid-45");
	        _classie2.default.add(leftContainerEl, "suffix-5");
	        _classie2.default.add(leftContainerEl, "left-column");
	
	        var rightContainerEl = document.createElement("div");
	        _classie2.default.add(rightContainerEl, "grid-45");
	        _classie2.default.add(rightContainerEl, "prefix-5");
	        _classie2.default.add(rightContainerEl, "right-column");
	
	        /* Image field */
	        var imageField = new Fields.ImageField(_BaseRender.prototype.getSettingsForChild.call(this, false));
	
	        /* Caption field */
	        var captionField = new Fields.RichTextField(_BaseRender.prototype.getSettingsForChild.call(this, true, {
	            "showCode": true
	        }));
	
	        /* Subtitle field */
	        var subtitleField = new Fields.RichTextField(_BaseRender.prototype.getSettingsForChild.call(this, true, {
	            "showCode": true,
	            "toolbar": 'undo redo | bold | alignleft aligncenter alignright | removeformat'
	        }));
	
	        /* Subtitle style field */
	        var subtitleStyleField = new Fields.SelectField(_BaseRender.prototype.getSettingsForChild.call(this, false, {
	            "values": {
	                "normal": "Normale",
	                "gradient": "Gradiente arancione"
	            }
	        }));
	
	        /* Text field */
	        var textField = new Fields.RichTextField(_BaseRender.prototype.getSettingsForChild.call(this, true, {
	            "showCode": true
	        }));
	
	        /* Image position field */
	        var imagePositionField = new Fields.SelectField(_BaseRender.prototype.getSettingsForChild.call(this, false, {
	            "values": {
	                "dx": "Destra",
	                "sx": "Sinistra"
	            }
	        }));
	
	        /* Caption position field */
	        var captionPositionField = new Fields.SelectField(_BaseRender.prototype.getSettingsForChild.call(this, false, {
	            "values": {
	                "top": "Sopra",
	                "bottom": "Sotto"
	            }
	        }));
	
	        _BaseRender.prototype.appendField.call(this, "imagePosition", imagePositionField, "Posizione immagine");
	
	        if (_BaseRender.prototype.addField.call(this, "subtitle", subtitleField)) {
	            leftContainerEl.appendChild(_BaseRender.prototype.wrapField.call(this, subtitleField.build(), "Sottotitolo (opzionale)"));
	        }
	
	        if (_BaseRender.prototype.addField.call(this, "subtitleStyle", subtitleStyleField)) {
	            leftContainerEl.appendChild(_BaseRender.prototype.wrapField.call(this, subtitleStyleField.build(), "Stile sottotitolo"));
	        }
	
	        if (_BaseRender.prototype.addField.call(this, "text", textField)) {
	            leftContainerEl.appendChild(_BaseRender.prototype.wrapField.call(this, textField.build(), "Testo"));
	        }
	
	        if (_BaseRender.prototype.addField.call(this, "image", imageField)) {
	            rightContainerEl.appendChild(_BaseRender.prototype.wrapField.call(this, imageField.build(), "Immagine"));
	        }
	
	        if (_BaseRender.prototype.addField.call(this, "imageCaption", captionField)) {
	            rightContainerEl.appendChild(_BaseRender.prototype.wrapField.call(this, captionField.build(), "Didascalia (opzionale)"));
	        }
	
	        if (_BaseRender.prototype.addField.call(this, "imageCaptionPosition", captionPositionField)) {
	            rightContainerEl.appendChild(_BaseRender.prototype.wrapField.call(this, captionPositionField.build(), "Posizione didascalia"));
	        }
	
	        columnContainerEl.appendChild(leftContainerEl);
	        columnContainerEl.appendChild(rightContainerEl);
	
	        _BaseRender.prototype.addToLayout.call(this, columnContainerEl);
	    };
	
	    ImageTextRender.prototype.init = function init(el) {
	        var _this2 = this;
	
	        _BaseRender.prototype.init.call(this, el);
	
	        // TODO: encapsulate event binding in SelectField and propagate event from field
	        for (var _iterator = _BaseRender.prototype.getField.call(this, "imagePosition").getComponents(), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
	            var _ref;
	
	            if (_isArray) {
	                if (_i >= _iterator.length) break;
	                _ref = _iterator[_i++];
	            } else {
	                _i = _iterator.next();
	                if (_i.done) break;
	                _ref = _i.value;
	            }
	
	            var _ref2 = _ref,
	                lang = _ref2[0],
	                el = _ref2[1];
	
	
	            el.addEventListener("change", function (e) {
	                _this2.swapColumns(e.currentTarget);
	            });
	
	            if (el.value == "sx") {
	                this.swapColumns(el);
	            }
	        }
	    };
	
	    ImageTextRender.prototype.swapColumns = function swapColumns(imagePositionEl) {
	        var blockEl = _Utils2.default.FindAncestorByClass(imagePositionEl, "block-item");
	        var container = _BaseRender.prototype.find.call(this, blockEl, ".columns-container");
	        var leftContainerEl = _BaseRender.prototype.find.call(this, container, ".left-column");
	        var rightContainerEl = _BaseRender.prototype.find.call(this, container, ".right-column");
	        _Utils2.default.FadeSwapElements(leftContainerEl, rightContainerEl);
	    };
	
	    ImageTextRender.prototype.delete = function _delete() {
	        return _BaseRender.prototype.getField.call(this, "image").delete();
	    };
	
	    return ImageTextRender;
	}(_BaseRender3.default);
	
	exports.default = ImageTextRender;

/***/ },
/* 241 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _classCallCheck2 = __webpack_require__(2);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(20);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(89);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _BaseRender2 = __webpack_require__(196);
	
	var _BaseRender3 = _interopRequireDefault(_BaseRender2);
	
	var _Utils = __webpack_require__(103);
	
	var _Utils2 = _interopRequireDefault(_Utils);
	
	var _fields = __webpack_require__(199);
	
	var Fields = _interopRequireWildcard(_fields);
	
	var _classie = __webpack_require__(99);
	
	var _classie2 = _interopRequireDefault(_classie);
	
	var _lodash = __webpack_require__(198);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	// ImageBlockItem
	var ImageRender = function (_BaseRender) {
	    (0, _inherits3.default)(ImageRender, _BaseRender);
	
	    function ImageRender(opts) {
	        (0, _classCallCheck3.default)(this, ImageRender);
	        return (0, _possibleConstructorReturn3.default)(this, _BaseRender.call(this, opts));
	    }
	
	    ImageRender.prototype.createFields = function createFields() {
	
	        /* Image field */
	        var imageField = new Fields.ImageField(_BaseRender.prototype.getSettingsForChild.call(this, false));
	
	        /* Image position field */
	        var imagePositionField = new Fields.SelectField(_BaseRender.prototype.getSettingsForChild.call(this, false, {
	            "values": {
	                "center": "Centrale"
	            }
	        }));
	
	        /* Type field */
	        var imageTypeField = new Fields.SelectField(_BaseRender.prototype.getSettingsForChild.call(this, false, {
	            "values": {
	                "full": "Full",
	                "small": "Small"
	            }
	        }));
	
	        /* Caption field */
	        var captionField = new Fields.RichTextField(_BaseRender.prototype.getSettingsForChild.call(this, true, {
	            "showCode": true
	        }));
	
	        /* Caption position field */
	        var captionPositionField = new Fields.SelectField(_BaseRender.prototype.getSettingsForChild.call(this, false, {
	            "values": {
	                "top": "Sopra",
	                "bottom": "Sotto"
	            }
	        }));
	
	        /* Abstract field */
	        var abstractField = new Fields.RichTextField(_BaseRender.prototype.getSettingsForChild.call(this, true, {
	            "showCode": true,
	            "toolbar": 'undo redo | bold | alignleft aligncenter alignright | removeformat'
	        }));
	
	        /* Abstract style field */
	        var abstractStyleField = new Fields.SelectField(_BaseRender.prototype.getSettingsForChild.call(this, false, {
	            "values": {
	                "normal": "Normale",
	                "gradient": "Gradiente arancione"
	            }
	        }));
	
	        /* Text field */
	        var textField = new Fields.RichTextField(_BaseRender.prototype.getSettingsForChild.call(this, true, {
	            "showCode": true
	        }));
	
	        _BaseRender.prototype.appendField.call(this, "image", imageField, "Immagine");
	        _BaseRender.prototype.appendField.call(this, "imagePosition", imagePositionField, "Posizione immagine");
	        _BaseRender.prototype.appendField.call(this, "imageType", imageTypeField, "Tipo immagine");
	        _BaseRender.prototype.appendField.call(this, "imageCaption", captionField, "Didascalia (opzionale)");
	        _BaseRender.prototype.appendField.call(this, "imageCaptionPosition", captionPositionField, "Posizione didascalia");
	        _BaseRender.prototype.appendField.call(this, "abstract", abstractField, "Sottotitolo");
	        _BaseRender.prototype.appendField.call(this, "abstractStyle", abstractStyleField, "Stile sottotitolo");
	        _BaseRender.prototype.appendField.call(this, "text", textField, "Testo (opzionale)");
	    };
	
	    ImageRender.prototype.init = function init(el) {
	        _BaseRender.prototype.init.call(this, el);
	    };
	
	    ImageRender.prototype.delete = function _delete() {
	        return _BaseRender.prototype.getField.call(this, "image").delete();
	    };
	
	    return ImageRender;
	}(_BaseRender3.default);
	
	exports.default = ImageRender;

/***/ },
/* 242 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	var emitter = __webpack_require__(243);
	var crossvent = __webpack_require__(247);
	var classes = __webpack_require__(250);
	var doc = document;
	var documentElement = doc.documentElement;
	
	function dragula (initialContainers, options) {
	  var len = arguments.length;
	  if (len === 1 && Array.isArray(initialContainers) === false) {
	    options = initialContainers;
	    initialContainers = [];
	  }
	  var _mirror; // mirror image
	  var _source; // source container
	  var _item; // item being dragged
	  var _offsetX; // reference x
	  var _offsetY; // reference y
	  var _moveX; // reference move x
	  var _moveY; // reference move y
	  var _initialSibling; // reference sibling when grabbed
	  var _currentSibling; // reference sibling now
	  var _copy; // item used for copying
	  var _renderTimer; // timer for setTimeout renderMirrorImage
	  var _lastDropTarget = null; // last container item was over
	  var _grabbed; // holds mousedown context until first mousemove
	
	  var o = options || {};
	  if (o.moves === void 0) { o.moves = always; }
	  if (o.accepts === void 0) { o.accepts = always; }
	  if (o.invalid === void 0) { o.invalid = invalidTarget; }
	  if (o.containers === void 0) { o.containers = initialContainers || []; }
	  if (o.isContainer === void 0) { o.isContainer = never; }
	  if (o.copy === void 0) { o.copy = false; }
	  if (o.copySortSource === void 0) { o.copySortSource = false; }
	  if (o.revertOnSpill === void 0) { o.revertOnSpill = false; }
	  if (o.removeOnSpill === void 0) { o.removeOnSpill = false; }
	  if (o.direction === void 0) { o.direction = 'vertical'; }
	  if (o.ignoreInputTextSelection === void 0) { o.ignoreInputTextSelection = true; }
	  if (o.mirrorContainer === void 0) { o.mirrorContainer = doc.body; }
	
	  var drake = emitter({
	    containers: o.containers,
	    start: manualStart,
	    end: end,
	    cancel: cancel,
	    remove: remove,
	    destroy: destroy,
	    canMove: canMove,
	    dragging: false
	  });
	
	  if (o.removeOnSpill === true) {
	    drake.on('over', spillOver).on('out', spillOut);
	  }
	
	  events();
	
	  return drake;
	
	  function isContainer (el) {
	    return drake.containers.indexOf(el) !== -1 || o.isContainer(el);
	  }
	
	  function events (remove) {
	    var op = remove ? 'remove' : 'add';
	    touchy(documentElement, op, 'mousedown', grab);
	    touchy(documentElement, op, 'mouseup', release);
	  }
	
	  function eventualMovements (remove) {
	    var op = remove ? 'remove' : 'add';
	    touchy(documentElement, op, 'mousemove', startBecauseMouseMoved);
	  }
	
	  function movements (remove) {
	    var op = remove ? 'remove' : 'add';
	    crossvent[op](documentElement, 'selectstart', preventGrabbed); // IE8
	    crossvent[op](documentElement, 'click', preventGrabbed);
	  }
	
	  function destroy () {
	    events(true);
	    release({});
	  }
	
	  function preventGrabbed (e) {
	    if (_grabbed) {
	      e.preventDefault();
	    }
	  }
	
	  function grab (e) {
	    _moveX = e.clientX;
	    _moveY = e.clientY;
	
	    var ignore = whichMouseButton(e) !== 1 || e.metaKey || e.ctrlKey;
	    if (ignore) {
	      return; // we only care about honest-to-god left clicks and touch events
	    }
	    var item = e.target;
	    var context = canStart(item);
	    if (!context) {
	      return;
	    }
	    _grabbed = context;
	    eventualMovements();
	    if (e.type === 'mousedown') {
	      if (isInput(item)) { // see also: https://github.com/bevacqua/dragula/issues/208
	        item.focus(); // fixes https://github.com/bevacqua/dragula/issues/176
	      } else {
	        e.preventDefault(); // fixes https://github.com/bevacqua/dragula/issues/155
	      }
	    }
	  }
	
	  function startBecauseMouseMoved (e) {
	    if (!_grabbed) {
	      return;
	    }
	    if (whichMouseButton(e) === 0) {
	      release({});
	      return; // when text is selected on an input and then dragged, mouseup doesn't fire. this is our only hope
	    }
	    // truthy check fixes #239, equality fixes #207
	    if (e.clientX !== void 0 && e.clientX === _moveX && e.clientY !== void 0 && e.clientY === _moveY) {
	      return;
	    }
	    if (o.ignoreInputTextSelection) {
	      var clientX = getCoord('clientX', e);
	      var clientY = getCoord('clientY', e);
	      var elementBehindCursor = doc.elementFromPoint(clientX, clientY);
	      if (isInput(elementBehindCursor)) {
	        return;
	      }
	    }
	
	    var grabbed = _grabbed; // call to end() unsets _grabbed
	    eventualMovements(true);
	    movements();
	    end();
	    start(grabbed);
	
	    var offset = getOffset(_item);
	    _offsetX = getCoord('pageX', e) - offset.left;
	    _offsetY = getCoord('pageY', e) - offset.top;
	
	    classes.add(_copy || _item, 'gu-transit');
	    renderMirrorImage();
	    drag(e);
	  }
	
	  function canStart (item) {
	    if (drake.dragging && _mirror) {
	      return;
	    }
	    if (isContainer(item)) {
	      return; // don't drag container itself
	    }
	    var handle = item;
	    while (getParent(item) && isContainer(getParent(item)) === false) {
	      if (o.invalid(item, handle)) {
	        return;
	      }
	      item = getParent(item); // drag target should be a top element
	      if (!item) {
	        return;
	      }
	    }
	    var source = getParent(item);
	    if (!source) {
	      return;
	    }
	    if (o.invalid(item, handle)) {
	      return;
	    }
	
	    var movable = o.moves(item, source, handle, nextEl(item));
	    if (!movable) {
	      return;
	    }
	
	    return {
	      item: item,
	      source: source
	    };
	  }
	
	  function canMove (item) {
	    return !!canStart(item);
	  }
	
	  function manualStart (item) {
	    var context = canStart(item);
	    if (context) {
	      start(context);
	    }
	  }
	
	  function start (context) {
	    if (isCopy(context.item, context.source)) {
	      _copy = context.item.cloneNode(true);
	      drake.emit('cloned', _copy, context.item, 'copy');
	    }
	
	    _source = context.source;
	    _item = context.item;
	    _initialSibling = _currentSibling = nextEl(context.item);
	
	    drake.dragging = true;
	    drake.emit('drag', _item, _source);
	  }
	
	  function invalidTarget () {
	    return false;
	  }
	
	  function end () {
	    if (!drake.dragging) {
	      return;
	    }
	    var item = _copy || _item;
	    drop(item, getParent(item));
	  }
	
	  function ungrab () {
	    _grabbed = false;
	    eventualMovements(true);
	    movements(true);
	  }
	
	  function release (e) {
	    ungrab();
	
	    if (!drake.dragging) {
	      return;
	    }
	    var item = _copy || _item;
	    var clientX = getCoord('clientX', e);
	    var clientY = getCoord('clientY', e);
	    var elementBehindCursor = getElementBehindPoint(_mirror, clientX, clientY);
	    var dropTarget = findDropTarget(elementBehindCursor, clientX, clientY);
	    if (dropTarget && ((_copy && o.copySortSource) || (!_copy || dropTarget !== _source))) {
	      drop(item, dropTarget);
	    } else if (o.removeOnSpill) {
	      remove();
	    } else {
	      cancel();
	    }
	  }
	
	  function drop (item, target) {
	    var parent = getParent(item);
	    if (_copy && o.copySortSource && target === _source) {
	      parent.removeChild(_item);
	    }
	    if (isInitialPlacement(target)) {
	      drake.emit('cancel', item, _source, _source);
	    } else {
	      drake.emit('drop', item, target, _source, _currentSibling);
	    }
	    cleanup();
	  }
	
	  function remove () {
	    if (!drake.dragging) {
	      return;
	    }
	    var item = _copy || _item;
	    var parent = getParent(item);
	    if (parent) {
	      parent.removeChild(item);
	    }
	    drake.emit(_copy ? 'cancel' : 'remove', item, parent, _source);
	    cleanup();
	  }
	
	  function cancel (revert) {
	    if (!drake.dragging) {
	      return;
	    }
	    var reverts = arguments.length > 0 ? revert : o.revertOnSpill;
	    var item = _copy || _item;
	    var parent = getParent(item);
	    var initial = isInitialPlacement(parent);
	    if (initial === false && reverts) {
	      if (_copy) {
	        if (parent) {
	          parent.removeChild(_copy);
	        }
	      } else {
	        _source.insertBefore(item, _initialSibling);
	      }
	    }
	    if (initial || reverts) {
	      drake.emit('cancel', item, _source, _source);
	    } else {
	      drake.emit('drop', item, parent, _source, _currentSibling);
	    }
	    cleanup();
	  }
	
	  function cleanup () {
	    var item = _copy || _item;
	    ungrab();
	    removeMirrorImage();
	    if (item) {
	      classes.rm(item, 'gu-transit');
	    }
	    if (_renderTimer) {
	      clearTimeout(_renderTimer);
	    }
	    drake.dragging = false;
	    if (_lastDropTarget) {
	      drake.emit('out', item, _lastDropTarget, _source);
	    }
	    drake.emit('dragend', item);
	    _source = _item = _copy = _initialSibling = _currentSibling = _renderTimer = _lastDropTarget = null;
	  }
	
	  function isInitialPlacement (target, s) {
	    var sibling;
	    if (s !== void 0) {
	      sibling = s;
	    } else if (_mirror) {
	      sibling = _currentSibling;
	    } else {
	      sibling = nextEl(_copy || _item);
	    }
	    return target === _source && sibling === _initialSibling;
	  }
	
	  function findDropTarget (elementBehindCursor, clientX, clientY) {
	    var target = elementBehindCursor;
	    while (target && !accepted()) {
	      target = getParent(target);
	    }
	    return target;
	
	    function accepted () {
	      var droppable = isContainer(target);
	      if (droppable === false) {
	        return false;
	      }
	
	      var immediate = getImmediateChild(target, elementBehindCursor);
	      var reference = getReference(target, immediate, clientX, clientY);
	      var initial = isInitialPlacement(target, reference);
	      if (initial) {
	        return true; // should always be able to drop it right back where it was
	      }
	      return o.accepts(_item, target, _source, reference);
	    }
	  }
	
	  function drag (e) {
	    if (!_mirror) {
	      return;
	    }
	    e.preventDefault();
	
	    var clientX = getCoord('clientX', e);
	    var clientY = getCoord('clientY', e);
	    var x = clientX - _offsetX;
	    var y = clientY - _offsetY;
	
	    _mirror.style.left = x + 'px';
	    _mirror.style.top = y + 'px';
	
	    var item = _copy || _item;
	    var elementBehindCursor = getElementBehindPoint(_mirror, clientX, clientY);
	    var dropTarget = findDropTarget(elementBehindCursor, clientX, clientY);
	    var changed = dropTarget !== null && dropTarget !== _lastDropTarget;
	    if (changed || dropTarget === null) {
	      out();
	      _lastDropTarget = dropTarget;
	      over();
	    }
	    var parent = getParent(item);
	    if (dropTarget === _source && _copy && !o.copySortSource) {
	      if (parent) {
	        parent.removeChild(item);
	      }
	      return;
	    }
	    var reference;
	    var immediate = getImmediateChild(dropTarget, elementBehindCursor);
	    if (immediate !== null) {
	      reference = getReference(dropTarget, immediate, clientX, clientY);
	    } else if (o.revertOnSpill === true && !_copy) {
	      reference = _initialSibling;
	      dropTarget = _source;
	    } else {
	      if (_copy && parent) {
	        parent.removeChild(item);
	      }
	      return;
	    }
	    if (
	      (reference === null && changed) ||
	      reference !== item &&
	      reference !== nextEl(item)
	    ) {
	      _currentSibling = reference;
	      dropTarget.insertBefore(item, reference);
	      drake.emit('shadow', item, dropTarget, _source);
	    }
	    function moved (type) { drake.emit(type, item, _lastDropTarget, _source); }
	    function over () { if (changed) { moved('over'); } }
	    function out () { if (_lastDropTarget) { moved('out'); } }
	  }
	
	  function spillOver (el) {
	    classes.rm(el, 'gu-hide');
	  }
	
	  function spillOut (el) {
	    if (drake.dragging) { classes.add(el, 'gu-hide'); }
	  }
	
	  function renderMirrorImage () {
	    if (_mirror) {
	      return;
	    }
	    var rect = _item.getBoundingClientRect();
	    _mirror = _item.cloneNode(true);
	    _mirror.style.width = getRectWidth(rect) + 'px';
	    _mirror.style.height = getRectHeight(rect) + 'px';
	    classes.rm(_mirror, 'gu-transit');
	    classes.add(_mirror, 'gu-mirror');
	    o.mirrorContainer.appendChild(_mirror);
	    touchy(documentElement, 'add', 'mousemove', drag);
	    classes.add(o.mirrorContainer, 'gu-unselectable');
	    drake.emit('cloned', _mirror, _item, 'mirror');
	  }
	
	  function removeMirrorImage () {
	    if (_mirror) {
	      classes.rm(o.mirrorContainer, 'gu-unselectable');
	      touchy(documentElement, 'remove', 'mousemove', drag);
	      getParent(_mirror).removeChild(_mirror);
	      _mirror = null;
	    }
	  }
	
	  function getImmediateChild (dropTarget, target) {
	    var immediate = target;
	    while (immediate !== dropTarget && getParent(immediate) !== dropTarget) {
	      immediate = getParent(immediate);
	    }
	    if (immediate === documentElement) {
	      return null;
	    }
	    return immediate;
	  }
	
	  function getReference (dropTarget, target, x, y) {
	    var horizontal = o.direction === 'horizontal';
	    var reference = target !== dropTarget ? inside() : outside();
	    return reference;
	
	    function outside () { // slower, but able to figure out any position
	      var len = dropTarget.children.length;
	      var i;
	      var el;
	      var rect;
	      for (i = 0; i < len; i++) {
	        el = dropTarget.children[i];
	        rect = el.getBoundingClientRect();
	        if (horizontal && (rect.left + rect.width / 2) > x) { return el; }
	        if (!horizontal && (rect.top + rect.height / 2) > y) { return el; }
	      }
	      return null;
	    }
	
	    function inside () { // faster, but only available if dropped inside a child element
	      var rect = target.getBoundingClientRect();
	      if (horizontal) {
	        return resolve(x > rect.left + getRectWidth(rect) / 2);
	      }
	      return resolve(y > rect.top + getRectHeight(rect) / 2);
	    }
	
	    function resolve (after) {
	      return after ? nextEl(target) : target;
	    }
	  }
	
	  function isCopy (item, container) {
	    return typeof o.copy === 'boolean' ? o.copy : o.copy(item, container);
	  }
	}
	
	function touchy (el, op, type, fn) {
	  var touch = {
	    mouseup: 'touchend',
	    mousedown: 'touchstart',
	    mousemove: 'touchmove'
	  };
	  var pointers = {
	    mouseup: 'pointerup',
	    mousedown: 'pointerdown',
	    mousemove: 'pointermove'
	  };
	  var microsoft = {
	    mouseup: 'MSPointerUp',
	    mousedown: 'MSPointerDown',
	    mousemove: 'MSPointerMove'
	  };
	  if (global.navigator.pointerEnabled) {
	    crossvent[op](el, pointers[type], fn);
	  } else if (global.navigator.msPointerEnabled) {
	    crossvent[op](el, microsoft[type], fn);
	  } else {
	    crossvent[op](el, touch[type], fn);
	    crossvent[op](el, type, fn);
	  }
	}
	
	function whichMouseButton (e) {
	  if (e.touches !== void 0) { return e.touches.length; }
	  if (e.which !== void 0 && e.which !== 0) { return e.which; } // see https://github.com/bevacqua/dragula/issues/261
	  if (e.buttons !== void 0) { return e.buttons; }
	  var button = e.button;
	  if (button !== void 0) { // see https://github.com/jquery/jquery/blob/99e8ff1baa7ae341e94bb89c3e84570c7c3ad9ea/src/event.js#L573-L575
	    return button & 1 ? 1 : button & 2 ? 3 : (button & 4 ? 2 : 0);
	  }
	}
	
	function getOffset (el) {
	  var rect = el.getBoundingClientRect();
	  return {
	    left: rect.left + getScroll('scrollLeft', 'pageXOffset'),
	    top: rect.top + getScroll('scrollTop', 'pageYOffset')
	  };
	}
	
	function getScroll (scrollProp, offsetProp) {
	  if (typeof global[offsetProp] !== 'undefined') {
	    return global[offsetProp];
	  }
	  if (documentElement.clientHeight) {
	    return documentElement[scrollProp];
	  }
	  return doc.body[scrollProp];
	}
	
	function getElementBehindPoint (point, x, y) {
	  var p = point || {};
	  var state = p.className;
	  var el;
	  p.className += ' gu-hide';
	  el = doc.elementFromPoint(x, y);
	  p.className = state;
	  return el;
	}
	
	function never () { return false; }
	function always () { return true; }
	function getRectWidth (rect) { return rect.width || (rect.right - rect.left); }
	function getRectHeight (rect) { return rect.height || (rect.bottom - rect.top); }
	function getParent (el) { return el.parentNode === doc ? null : el.parentNode; }
	function isInput (el) { return el.tagName === 'INPUT' || el.tagName === 'TEXTAREA' || el.tagName === 'SELECT' || isEditable(el); }
	function isEditable (el) {
	  if (!el) { return false; } // no parents were editable
	  if (el.contentEditable === 'false') { return false; } // stop the lookup
	  if (el.contentEditable === 'true') { return true; } // found a contentEditable element in the chain
	  return isEditable(getParent(el)); // contentEditable is set to 'inherit'
	}
	
	function nextEl (el) {
	  return el.nextElementSibling || manually();
	  function manually () {
	    var sibling = el;
	    do {
	      sibling = sibling.nextSibling;
	    } while (sibling && sibling.nodeType !== 1);
	    return sibling;
	  }
	}
	
	function getEventHost (e) {
	  // on touchend event, we have to use `e.changedTouches`
	  // see http://stackoverflow.com/questions/7192563/touchend-event-properties
	  // see https://github.com/bevacqua/dragula/issues/34
	  if (e.targetTouches && e.targetTouches.length) {
	    return e.targetTouches[0];
	  }
	  if (e.changedTouches && e.changedTouches.length) {
	    return e.changedTouches[0];
	  }
	  return e;
	}
	
	function getCoord (coord, e) {
	  var host = getEventHost(e);
	  var missMap = {
	    pageX: 'clientX', // IE8
	    pageY: 'clientY' // IE8
	  };
	  if (coord in missMap && !(coord in host) && missMap[coord] in host) {
	    coord = missMap[coord];
	  }
	  return host[coord];
	}
	
	module.exports = dragula;
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 243 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var atoa = __webpack_require__(244);
	var debounce = __webpack_require__(245);
	
	module.exports = function emitter (thing, options) {
	  var opts = options || {};
	  var evt = {};
	  if (thing === undefined) { thing = {}; }
	  thing.on = function (type, fn) {
	    if (!evt[type]) {
	      evt[type] = [fn];
	    } else {
	      evt[type].push(fn);
	    }
	    return thing;
	  };
	  thing.once = function (type, fn) {
	    fn._once = true; // thing.off(fn) still works!
	    thing.on(type, fn);
	    return thing;
	  };
	  thing.off = function (type, fn) {
	    var c = arguments.length;
	    if (c === 1) {
	      delete evt[type];
	    } else if (c === 0) {
	      evt = {};
	    } else {
	      var et = evt[type];
	      if (!et) { return thing; }
	      et.splice(et.indexOf(fn), 1);
	    }
	    return thing;
	  };
	  thing.emit = function () {
	    var args = atoa(arguments);
	    return thing.emitterSnapshot(args.shift()).apply(this, args);
	  };
	  thing.emitterSnapshot = function (type) {
	    var et = (evt[type] || []).slice(0);
	    return function () {
	      var args = atoa(arguments);
	      var ctx = this || thing;
	      if (type === 'error' && opts.throws !== false && !et.length) { throw args.length === 1 ? args[0] : args; }
	      et.forEach(function emitter (listen) {
	        if (opts.async) { debounce(listen, args, ctx); } else { listen.apply(ctx, args); }
	        if (listen._once) { thing.off(type, listen); }
	      });
	      return thing;
	    };
	  };
	  return thing;
	};


/***/ },
/* 244 */
/***/ function(module, exports) {

	module.exports = function atoa (a, n) { return Array.prototype.slice.call(a, n); }


/***/ },
/* 245 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var ticky = __webpack_require__(246);
	
	module.exports = function debounce (fn, args, ctx) {
	  if (!fn) { return; }
	  ticky(function run () {
	    fn.apply(ctx || null, args || []);
	  });
	};


/***/ },
/* 246 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(setImmediate) {var si = typeof setImmediate === 'function', tick;
	if (si) {
	  tick = function (fn) { setImmediate(fn); };
	} else {
	  tick = function (fn) { setTimeout(fn, 0); };
	}
	
	module.exports = tick;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(231).setImmediate))

/***/ },
/* 247 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	var customEvent = __webpack_require__(248);
	var eventmap = __webpack_require__(249);
	var doc = global.document;
	var addEvent = addEventEasy;
	var removeEvent = removeEventEasy;
	var hardCache = [];
	
	if (!global.addEventListener) {
	  addEvent = addEventHard;
	  removeEvent = removeEventHard;
	}
	
	module.exports = {
	  add: addEvent,
	  remove: removeEvent,
	  fabricate: fabricateEvent
	};
	
	function addEventEasy (el, type, fn, capturing) {
	  return el.addEventListener(type, fn, capturing);
	}
	
	function addEventHard (el, type, fn) {
	  return el.attachEvent('on' + type, wrap(el, type, fn));
	}
	
	function removeEventEasy (el, type, fn, capturing) {
	  return el.removeEventListener(type, fn, capturing);
	}
	
	function removeEventHard (el, type, fn) {
	  var listener = unwrap(el, type, fn);
	  if (listener) {
	    return el.detachEvent('on' + type, listener);
	  }
	}
	
	function fabricateEvent (el, type, model) {
	  var e = eventmap.indexOf(type) === -1 ? makeCustomEvent() : makeClassicEvent();
	  if (el.dispatchEvent) {
	    el.dispatchEvent(e);
	  } else {
	    el.fireEvent('on' + type, e);
	  }
	  function makeClassicEvent () {
	    var e;
	    if (doc.createEvent) {
	      e = doc.createEvent('Event');
	      e.initEvent(type, true, true);
	    } else if (doc.createEventObject) {
	      e = doc.createEventObject();
	    }
	    return e;
	  }
	  function makeCustomEvent () {
	    return new customEvent(type, { detail: model });
	  }
	}
	
	function wrapperFactory (el, type, fn) {
	  return function wrapper (originalEvent) {
	    var e = originalEvent || global.event;
	    e.target = e.target || e.srcElement;
	    e.preventDefault = e.preventDefault || function preventDefault () { e.returnValue = false; };
	    e.stopPropagation = e.stopPropagation || function stopPropagation () { e.cancelBubble = true; };
	    e.which = e.which || e.keyCode;
	    fn.call(el, e);
	  };
	}
	
	function wrap (el, type, fn) {
	  var wrapper = unwrap(el, type, fn) || wrapperFactory(el, type, fn);
	  hardCache.push({
	    wrapper: wrapper,
	    element: el,
	    type: type,
	    fn: fn
	  });
	  return wrapper;
	}
	
	function unwrap (el, type, fn) {
	  var i = find(el, type, fn);
	  if (i) {
	    var wrapper = hardCache[i].wrapper;
	    hardCache.splice(i, 1); // free up a tad of memory
	    return wrapper;
	  }
	}
	
	function find (el, type, fn) {
	  var i, item;
	  for (i = 0; i < hardCache.length; i++) {
	    item = hardCache[i];
	    if (item.element === el && item.type === type && item.fn === fn) {
	      return i;
	    }
	  }
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 248 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {
	var NativeCustomEvent = global.CustomEvent;
	
	function useNative () {
	  try {
	    var p = new NativeCustomEvent('cat', { detail: { foo: 'bar' } });
	    return  'cat' === p.type && 'bar' === p.detail.foo;
	  } catch (e) {
	  }
	  return false;
	}
	
	/**
	 * Cross-browser `CustomEvent` constructor.
	 *
	 * https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent.CustomEvent
	 *
	 * @public
	 */
	
	module.exports = useNative() ? NativeCustomEvent :
	
	// IE >= 9
	'function' === typeof document.createEvent ? function CustomEvent (type, params) {
	  var e = document.createEvent('CustomEvent');
	  if (params) {
	    e.initCustomEvent(type, params.bubbles, params.cancelable, params.detail);
	  } else {
	    e.initCustomEvent(type, false, false, void 0);
	  }
	  return e;
	} :
	
	// IE <= 8
	function CustomEvent (type, params) {
	  var e = document.createEventObject();
	  e.type = type;
	  if (params) {
	    e.bubbles = Boolean(params.bubbles);
	    e.cancelable = Boolean(params.cancelable);
	    e.detail = params.detail;
	  } else {
	    e.bubbles = false;
	    e.cancelable = false;
	    e.detail = void 0;
	  }
	  return e;
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 249 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	var eventmap = [];
	var eventname = '';
	var ron = /^on/;
	
	for (eventname in global) {
	  if (ron.test(eventname)) {
	    eventmap.push(eventname.slice(2));
	  }
	}
	
	module.exports = eventmap;
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 250 */
/***/ function(module, exports) {

	'use strict';
	
	var cache = {};
	var start = '(?:^|\\s)';
	var end = '(?:\\s|$)';
	
	function lookupClass (className) {
	  var cached = cache[className];
	  if (cached) {
	    cached.lastIndex = 0;
	  } else {
	    cache[className] = cached = new RegExp(start + className + end, 'g');
	  }
	  return cached;
	}
	
	function addClass (el, className) {
	  var current = el.className;
	  if (!current.length) {
	    el.className = className;
	  } else if (!lookupClass(className).test(current)) {
	    el.className += ' ' + className;
	  }
	}
	
	function rmClass (el, className) {
	  el.className = el.className.replace(lookupClass(className), ' ').trim();
	}
	
	module.exports = {
	  add: addClass,
	  rm: rmClass
	};


/***/ },
/* 251 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Cookies.js - 1.2.3
	 * https://github.com/ScottHamper/Cookies
	 *
	 * This is free and unencumbered software released into the public domain.
	 */
	(function (global, undefined) {
	    'use strict';
	
	    var factory = function (window) {
	        if (typeof window.document !== 'object') {
	            throw new Error('Cookies.js requires a `window` with a `document` object');
	        }
	
	        var Cookies = function (key, value, options) {
	            return arguments.length === 1 ?
	                Cookies.get(key) : Cookies.set(key, value, options);
	        };
	
	        // Allows for setter injection in unit tests
	        Cookies._document = window.document;
	
	        // Used to ensure cookie keys do not collide with
	        // built-in `Object` properties
	        Cookies._cacheKeyPrefix = 'cookey.'; // Hurr hurr, :)
	        
	        Cookies._maxExpireDate = new Date('Fri, 31 Dec 9999 23:59:59 UTC');
	
	        Cookies.defaults = {
	            path: '/',
	            secure: false
	        };
	
	        Cookies.get = function (key) {
	            if (Cookies._cachedDocumentCookie !== Cookies._document.cookie) {
	                Cookies._renewCache();
	            }
	            
	            var value = Cookies._cache[Cookies._cacheKeyPrefix + key];
	
	            return value === undefined ? undefined : decodeURIComponent(value);
	        };
	
	        Cookies.set = function (key, value, options) {
	            options = Cookies._getExtendedOptions(options);
	            options.expires = Cookies._getExpiresDate(value === undefined ? -1 : options.expires);
	
	            Cookies._document.cookie = Cookies._generateCookieString(key, value, options);
	
	            return Cookies;
	        };
	
	        Cookies.expire = function (key, options) {
	            return Cookies.set(key, undefined, options);
	        };
	
	        Cookies._getExtendedOptions = function (options) {
	            return {
	                path: options && options.path || Cookies.defaults.path,
	                domain: options && options.domain || Cookies.defaults.domain,
	                expires: options && options.expires || Cookies.defaults.expires,
	                secure: options && options.secure !== undefined ?  options.secure : Cookies.defaults.secure
	            };
	        };
	
	        Cookies._isValidDate = function (date) {
	            return Object.prototype.toString.call(date) === '[object Date]' && !isNaN(date.getTime());
	        };
	
	        Cookies._getExpiresDate = function (expires, now) {
	            now = now || new Date();
	
	            if (typeof expires === 'number') {
	                expires = expires === Infinity ?
	                    Cookies._maxExpireDate : new Date(now.getTime() + expires * 1000);
	            } else if (typeof expires === 'string') {
	                expires = new Date(expires);
	            }
	
	            if (expires && !Cookies._isValidDate(expires)) {
	                throw new Error('`expires` parameter cannot be converted to a valid Date instance');
	            }
	
	            return expires;
	        };
	
	        Cookies._generateCookieString = function (key, value, options) {
	            key = key.replace(/[^#$&+\^`|]/g, encodeURIComponent);
	            key = key.replace(/\(/g, '%28').replace(/\)/g, '%29');
	            value = (value + '').replace(/[^!#$&-+\--:<-\[\]-~]/g, encodeURIComponent);
	            options = options || {};
	
	            var cookieString = key + '=' + value;
	            cookieString += options.path ? ';path=' + options.path : '';
	            cookieString += options.domain ? ';domain=' + options.domain : '';
	            cookieString += options.expires ? ';expires=' + options.expires.toUTCString() : '';
	            cookieString += options.secure ? ';secure' : '';
	
	            return cookieString;
	        };
	
	        Cookies._getCacheFromString = function (documentCookie) {
	            var cookieCache = {};
	            var cookiesArray = documentCookie ? documentCookie.split('; ') : [];
	
	            for (var i = 0; i < cookiesArray.length; i++) {
	                var cookieKvp = Cookies._getKeyValuePairFromCookieString(cookiesArray[i]);
	
	                if (cookieCache[Cookies._cacheKeyPrefix + cookieKvp.key] === undefined) {
	                    cookieCache[Cookies._cacheKeyPrefix + cookieKvp.key] = cookieKvp.value;
	                }
	            }
	
	            return cookieCache;
	        };
	
	        Cookies._getKeyValuePairFromCookieString = function (cookieString) {
	            // "=" is a valid character in a cookie value according to RFC6265, so cannot `split('=')`
	            var separatorIndex = cookieString.indexOf('=');
	
	            // IE omits the "=" when the cookie value is an empty string
	            separatorIndex = separatorIndex < 0 ? cookieString.length : separatorIndex;
	
	            var key = cookieString.substr(0, separatorIndex);
	            var decodedKey;
	            try {
	                decodedKey = decodeURIComponent(key);
	            } catch (e) {
	                if (console && typeof console.error === 'function') {
	                    console.error('Could not decode cookie with key "' + key + '"', e);
	                }
	            }
	            
	            return {
	                key: decodedKey,
	                value: cookieString.substr(separatorIndex + 1) // Defer decoding value until accessed
	            };
	        };
	
	        Cookies._renewCache = function () {
	            Cookies._cache = Cookies._getCacheFromString(Cookies._document.cookie);
	            Cookies._cachedDocumentCookie = Cookies._document.cookie;
	        };
	
	        Cookies._areEnabled = function () {
	            var testKey = 'cookies.js';
	            var areEnabled = Cookies.set(testKey, 1).get(testKey) === '1';
	            Cookies.expire(testKey);
	            return areEnabled;
	        };
	
	        Cookies.enabled = Cookies._areEnabled();
	
	        return Cookies;
	    };
	    var cookiesExport = (global && typeof global.document === 'object') ? factory(global) : factory;
	
	    // AMD support
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_RESULT__ = function () { return cookiesExport; }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    // CommonJS/Node.js support
	    } else if (typeof exports === 'object') {
	        // Support Node.js specific `module.exports` (which can be a function)
	        if (typeof module === 'object' && typeof module.exports === 'object') {
	            exports = module.exports = cookiesExport;
	        }
	        // But always support CommonJS module 1.1.1 spec (`exports` cannot be a function)
	        exports.Cookies = cookiesExport;
	    } else {
	        global.Cookies = cookiesExport;
	    }
	})(typeof window === 'undefined' ? this : window);

/***/ }
/******/ ]);
//# sourceMappingURL=app.js.map